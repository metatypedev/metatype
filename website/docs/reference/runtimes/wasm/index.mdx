# Wasm

## Wasm runtime

Wasm runtime allows running functions written in any language that can be compiled into WebAssembly and that follows the [component model](https://component-model.bytecodealliance.org/design/why-component-model.html).

## Example
Here is a simple wit component description using [wit IDL](https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md) that exports the `add` function.

```rust
package example:host;
world host {
  export add: func(a: u32, b: u32) -> u32;
}
```

An implementation in Rust might look like this:
```rust
wit_bindgen::generate!({ world: "host" });
struct MyLib;
impl Guest for MyLib {
    fn add(a: u32, b: u32) -> u32 {
        a + b
    }
}
export!(MyLib);
```

You can interface it similarly to how Deno and Python runtime work.
```python
from typegraph.runtimes.wasm import WasmRuntime

@typegraph
def example(g: Graph):
    pub = Policy.public()
    wasmedge = WasmEdgeRuntime()
    wasm = WasmRuntime()

    g.expose(
        add=wasm.from_wasm(
            t.struct({"a": t.integer(), "b": t.integer()}),
            t.integer(),
            wasm="path/to/your-compiled-component.wasm",
        )
    )

```

## Wit to Typegraph types
Compared to Deno or Python Runtime, wit ensures that you have strongly typed input and output values.\
For this reason, you may want to refer to the correspondance table bellow when writing your typegraph.

|                             wit                              |                                  typegraph                                   |                Example values                 |
| ------------------------------------------------------------ | :--------------------------------------------------------------------------: | --------------------------------------------- |
| `string`                                                     |                           `t.string()`, `t.uuid()`                           | "Hello world", "H", ..                        |
| `u8`, `u16`, `u32`, `u64`, `s8`, `s16`, `s32`, `s64`         |                          `t.integer()`, `t.float()`                          | 1, 2, 0, ..                                   |
| `f32`, `f64`                                                 |                                 `t.float()`                                  | 3.14, 100, 2, ..                              |
| `char`                                                       | `t.string()` (truncated), `t.integer()` (truncated as `u8`), `t.float()` (truncated as `u8`) | "A", 65, 65.0, ..                                   |
| `option<T>`                                                  |                               `<T>.optional()`                               | `null`, "hello world", ..                     |
| `list<T>`                                                    |                                `t.list(<T>)`                                 | ["one", "two" ], [1, 2], ..                   |
| `tuple<T1, T2, ..>`                                          |                        `t.list(t.enum([t1, t2, ..]))`                        | [1, "one"], [2, "two"], ..                    |
| `enum example { one, two }`                                  |                           `t.enum(["one", "two"])`                           | "one", "two"                                  |
| `variant example { one(string), two }`                       | `t.struct({ "tag": t.enum(["one", "two"]), "value": t.string().optional() )` | `{ "tag": "two", "value": null }`             |
| `record example { id: string, description: option<string> }` |    `t.struct({ "id": t.integer(), "description": t.string().optional() )`    | `{ "id": 123, "description": "some text"}`    |
| `flags example { read, write, delete }`                      |                `t.list(t.enum_(["read", "write", "delete"]))`                | `["read"]`, `["read", "write", "delete"]`, .. |
