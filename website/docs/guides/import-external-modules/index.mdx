import SDKTabs from "@site/src/components/SDKTabs";
import TabItem from "@theme/TabItem";
import TGExample from "@site/src/components/TGExample";
import CodeBlock from "@theme-original/CodeBlock";


# Importing External Modules

So far, the materializers we've looked at have been generated by helpers like the CRUD helpers from the Prisma runtime or the the Random runtime's `generate` helper.
The `deno.policy` function we used for authoring policies was also based on function objects. 
All these helpers are shorthands for creating function objects and now we'll look at how to roll a custom function ourselves.
We'll be using the Deno runtime to run our code.

Instead of including the code inline through a string, the Deno runtime allows us to import modules from disk.
Our modules are allowed to use ESM imports to access libraries on different registries like `npm` and `deno.land`.
We'll use these features to write a simple materializer that converts markdown to html.

```typescript
import * as marked from "https://deno.land/x/marked/mod.ts";

export function parse({ raw }: { raw: string }): string {
  return marked.parse(raw);
}
```

We'll expose our module using the deno runtime.

    <SDKTabs>
              <TabItem value="typescript">


```typescript
typegraph("roadmap", (g) => {
  // ...
  g.expose(
    {
      // ..
      "parse_markdown": deno.import(
          t.struct({"raw": t.string()}),
          t.string(),
          {
            name: "parse",
            // the path is parsed relative to the typegraph file
            module: "md2html.ts",
          }
        ),
      // ..
    }, pub
  );
});
```

      </TabItem>
  <TabItem value="python">


```python
@typegraph()
def roadmap(g: Graph):
    g.expose(
        pub,
        # ..
        parse_markdown=deno.import_(
            t.struct({"raw": t.string()}),
            t.string(),
            # the path is parsed relative to the typegraph file
            module="md2html.ts",
            name="parse",
        ),
    )

```
      </TabItem>
                </SDKTabs>

We can now access our func through the GraphQl api.
    <TGExample
      typegraph="roadmap-func"
      python={require("../../../../examples/typegraphs/func.py")}
      typescript={require("!!code-loader!../../../../examples/typegraphs/func.ts")}
      query={require("./func.graphql")}
    />
