import TabItem from "@theme/TabItem";
import SDKTabs from "@site/src/components/SDKTabs";

import PyPmTabs from "@site/src/components/PythonPackageManagerTabs";
import TsPmTabs from "@site/src/components/TsPackageManagerTabs";

# Test typegraphs

[Typegraph](/docs/reference/typegraph) is the frontend of the _Metatype_ ecosystem where the app is authored and defined. Typegraph is basically a function that includes the definition of the exposed APIs, the embedded runtimes, database table definitions, functions and other building blocks of the application.

Typegraphs can be tested easily with the common test suites in the language of your choosing.

The following next lines describes how you can test your typegraph.
For _Typescript_ SDK, we will be using [vitest](https://vitest.dev/) and [pytest](https://docs.pytest.org/en/stable/) for the _Python_ SDK in this example.

<SDKTabs>

    <TabItem value="typescript">
    example typegraph
    </TabItem>

    <TabItem value="python">
    
First, you need to add _pytest_ as a dev dependency in your project/application. 
:::info
You can follow [this](/docs/tutorials/quick-start) link on how to bootstrap a metatype application.
:::
<PyPmTabs>
    <TabItem value="pip">
    ```bash
    pip3 install pytest
    ```
    </TabItem>
    <TabItem value="poetry">
    ```bash
    poetry add --dev pytest
    ```
    </TabItem>
</PyPmTabs>

After successful installation, you need to activate a python venv. In poetry, you can easily activate the virtual environment using the command below.

```bash
poetry shell
```

Now, You can start writing tests for your typegraph. For convention, write the tests inside the `tests` directory under the project's root dir. 

Assuming we have this simple typegraph definition, which is a template typegraph you can generate by using the `meta new` commmand from the _Meta CLI_.

```python
from typegraph import typegraph, Policy, t, Graph
from typegraph.runtimes import PythonRuntime


@typegraph()
def example(g: Graph):
    public = Policy.public()
    python = PythonRuntime()

    hello = python.from_lambda(
        t.struct({"world": t.string()}),
        t.string(),
        lambda x: f"Hello {x['world']}!",
    )

    g.expose(public, hello=hello)

```

You can write the following test to check if your typegraph is correctly authored. Under `/tests` dir, create an empty test and add the test code below. Make sure you name your test file appending `_test` or prepending `test_` so pytest can discover them. 

```python
from example.api.example import example as tg
import subprocess

# running the typegraph gives a TypegraphOutput object 
tg_output = tg()

# test if the tg output is correct,
def test_tg_name():
    assert tg_output.name == "example"
    
def test_serialize_tg():
    assert callable(tg_output.serialize)

# check if the typegraph gets serialized
def test_serialize():
    command_args = [
        "meta",
        "serialize",
        "-f",
        "example/api/example.py" # tg path from the project root dir
    ]
    result = subprocess.run(command_args, capture_output=True, text=True)
    assert result.returncode == 0
```

Running the typegraph function, results in a [TypegraphOutput](https://github.com/metatypedev/metatype/blob/8cc1c129b0f858047eda8557c1bc120873d37aca/typegraph/python/typegraph/graph/shared_types.py#L18) object which you can play around to add more checks to your tests.

After you have written your tests, you can run them all by executing the `pytest` command from your terminal.

```bash
pytest
```

Using the above steps, you can always test your typegraph whenever you need to. 

While `pytest` is used in this example, typegraphs can be easily tested with most of other test suite solutions by following the above approach.
    
    </TabItem>

</SDKTabs>
