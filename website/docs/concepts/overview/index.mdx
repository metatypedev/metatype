---
sidebar_position: 1
---

import Metatype from "../../../shared/metatype-intro.mdx";

# Overview

This page gives a high-level views of Metatype's principles.

:::tip Looking to build?
For a hands-on introduction, head over to the [quickstart](/docs/tutorials/getting-started) and start build your first typegraph.
:::

## Why does Metatype exists?

> "Product" refers here indistinctly to a project, a product, a start-up idea or a company.

As products evolve and grow, the technological stack becomes a challenging place where initiatives collides and efficiency become a struggle. Especially, a lot of time is spent on organizing, prioritizing, kick-starting, integrating, and deploying new features. This usually affect the speed of delivery and the innovation drive of teams.

Metatype's vision is to enable everyone to compose their data, anywhere. By increasing the re-use of data and logic, it enables teams to focus on what matters: their added value and expert knowledge. Metatype handle the complex layers for them and orchestrate systems into modular API blocks, making it easy to understand and innovative ready for your next iteration.

It aims at providing a new paradigm and tackle with agility the following challenges:

- onboard quickly new team members independently of their experience level
- make system interfaces accessible and easy to understand for everyone
- embrace iterative approaches and cut time to deployment in half
- build strong foundations for APIs with type safety and expressiveness
- transform - some of - technical debts into an asset thanks to interoperability
- empower teams to innovate with new technology and architectures

## How does Metatype work?

Metatype work changing your design and development approach. Take the example of a new feature to add in your product - defined by "the change" in the next lines. The classical approach is to define what data will be at play, how to transform them, where the execution shall take place and who should be authorized. Instead, Metatype define an abstraction for each of those steps and put the emphasis on composing already defined API blocks, or define re-usable modular ones when there is no existing solution.

|                       | Classical approach                       | Metatype's approach                                                                       |
| --------------------- | ---------------------------------------- | ----------------------------------------------------------------------------------------- |
| What (data flows)     | fixed response defined by the controller | API clients selects what they need from [types](/docs/concepts/typegraph#types)           |
| How (transformations) | static code logic                        | compose data with interchangeable [materializers](/docs/concepts/typegraph#materializers) |
| Where (execution)     | 1 code base + 1 database                 | orchestrate the request among multiple [runtimes](/docs/concepts/typegraph#runtimes)      |
| Who (authentication)  | hard-coded rules or system               | request context based and controlled by [policies](/docs/concepts/typegraph#policies)     |
| When (event)          | request arrival                          | based on [triggers](/docs/concepts/typegraph#triggers)                                    |

## What's exactly Metatype?

<Metatype />

### Architectural zoom

Metatype is designed for cloud environments and comes with minimal components. The only requirement to scale horizontally is to share some memory between replicas of the typegate via Redis. You can use Metatype [helm chart](https://github.com/metatypedev/charts) to deploy typegates on your Kubernetes cluster.

<div className="text-center">

![Metatype's architecture](image.drawio.svg)

</div>
