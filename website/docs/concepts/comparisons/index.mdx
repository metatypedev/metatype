---
sidebar_position: 7
title: Comparing Metatype
---

# Comparing Metatype

Metatype foundations takes inspiration from many innovative tools that arose in the last years. We took the best of each of them and combined them into a single engine backed by a convenient [computing model](/docs/reference/typegraph).

While this provides a unique and powerful platform, it can be difficult to understand how exactly Metatype compares to other tools. This page provides a high-level overview of these differences.

## Development platforms

- Firebase
- Supabase
- Hasura
- PostGraphile

These are great platforms to quickly start a new project. However, they hardly scale in terms of architecture evolution, technology freedom, number of developers on the project, and you will eventually have to move out due to increasing costs or iterations slowness.

**When to choose Metatype**

1. You want to build modular APIs by composing pre-defined blocks and import the ones you need from existing systems.
2. You want to take advantage of developers tooling you are familiar with like version controls or multiple environments.
3. You favor interoperability and extensibility over vendor lock-in and follow your future needs with ease.
4. You want to decouple your database from your API and change where the data is stored as the project evolves.

## Headless CMS

- Strapi
- Directus

Headless Content Management Systems (CMS) are great tools to manage content and providing great editing experience. However, they are not designed to build complex APIs like a cart checkout or integrate with other systems.

**When to choose Metatype**

1. You want an all-in-one APIs development platforms and offer the same editing experience through a user-friendly interface
2. You care about end-user performance and want to use the best underlying technology for each use cases
3. You are more than one on the project and want to manage your data models using preferred programming language


## GraphQL-based backends

- WunderGraph
- Grafbase

These great tools leverage GraphQL to build internal APIs using pre-determined queries. They are less API consumer oriented and that disables powerful capabilities like querying between multiple instances owned by different users.

**When to choose Metatype**

1. You want to build internal and external APIs, and go beyond what can be described in a GraphQL schema
2. You want to optimize your API queries on the fly and let the engine resolve your data in the most efficient way
3. You expect a fine-grained permission model and control the data you expose at the level of each model field

## Low Code Platforms

- Retool
- Airtable
- Windmill

Low Code platforms are a game changer when it comes to faster development cycle, great collaboration options and the gentle learning curve. However, this comes at the cost of losing degree of flexibility and cusomizability. They are also hard to apply different scalability and come with limited performance optimization. 

**When to choose Metatype**

1. When you want more control over your application instances running on the cloud.
2. When you want to build more complex APIs.
3. When you want to have the freedom to make detailed changes to your application to gain that extra peformance.


Feature/Capability Key:
- :white_check_mark: 1st class, with no extra dependencies. 
- :white_circle: supported, but with extra 3rd party dependencies
- :large_orange_diamond: supported, but with extra 3rd party dependencies and user code.
- :red_circle: not officially supported or documented. 

|  | Metatype | Development Platforms | Headless CMS | Low code platform |
|------------------------------------|------------------------|-------------|------------------|------------------------------------|
| Licensing | [MPL-2.0](https://github.com/metatypedev/metatype/blob/main/dev/LICENSE-MPL-2.0.md) |  |  |  |
| Platform's Requirements |  |  |  |  |
| Architecture Model |  |  |  |  |
| REST/HTTP |  |  |  |  |
| GraphQL |  |  |  |  |
| GRPC |  |  |  |  |
| GUI for non programmers |  |  |  |  |
| Development SDKs |  |  |  |  |
| Development Approach |  |  |  |  |
| CLI |  |  |  |  |
| Dev Tools |  |  |  |  |
| LSP and Extensions |  |  |  |  |
| Authentication |  |  |  |  |
| Authorization |  |  |  |  |
| Access Control |  |  |  |  |
| Type System |  |  |  |  |
| Database Toolkit/ORM |  |  |  |  |
| Query Planning Model |  |  |  |  |
| Query Computing Model |  |  |  |  |
| Custom Code Support |  |  |  |  |
| Version Control |  |  |  |  |
| GitOPs Friendly |  |  |  |  |
| Vertical Scalability |  |  |  |  |
| Service Decomposition |  |  |  |  |
| Deployment Options |  |  |  |  |
| Monitoring and Tracking |  |  |  |  |
| Logging |  |  |  |  |
| Query Plan Time |  |  |  |  |
| Query Compute Time |  |  |  |  |


### Table Parameters Legend

#### Solution's Meta
**Licensing**
**Platform's Requirements**
**Architecture Model**

#### Network comms

**REST/HTTP**
**GraphQL**
**GRPC**

#### Ecosystem
**GUI for non programmers**
**Development SDKs**
**Development Approach**
**CLI**
**Dev Tools**
**LSP and Extensions**

#### Security
**Authentication**
**Authorization**
**Access Control**

#### Database Interaction
**Type System**
**Database Toolkit/ORM**

#### Query Processing
**Query Planning Model**
**Query Computing Model**

#### System Flexibility
**Custom Code support**

#### Versioning and CI/CD
**Version Control**
**GitOPs Friendly**

#### Scalability
{/* how to express scalability using facts */}
**vertical scalability**
**service decomposition** {/* from micro service aspect */}

#### Deployment
**Deployment Options**

#### Monitoring, Logging and maintenance
**Monitoring and Tracking**
**Logging**

#### Safety and Fault tolerance

#### Basic Benchmarks
**Query Plan Time**
**Query Compute Time**
