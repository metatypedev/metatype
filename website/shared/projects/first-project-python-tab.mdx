import TabItem from "@theme/TabItem";
import CodeBlock from "@theme-original/CodeBlock";


To bootstrap a python `Metatype` project, run the following commands on your terminal.
```bash
# create startup files
meta new --template python

# install dependencies
poetry install

# create and activate virtual environment
poetry shell
```

This will create the necessary files for development, some of which are:
- `.graphqlrc.yaml`: configuration file to define settings and options related to. 
-  `compose.yml`: is where the typegate node and similar services are setup.
- `metatype.yaml`: is where we configure different variables such as authentication, secrets... used by the backend.

The command also creates a directory called `api` where we will be building much of our applications's business logic. Inside the `api` directory, you will find a single file called `example.py` which defines a simple [Typegraph](/docs/reference/typegraph).
<CodeBlock language="python">{require("../../../examples/templates/python/api/example.py").content}</CodeBlock>

Let's break down the above code snippet.
The `example` function is where most of the our logic inside lives. We need to decorate the function with `@typegraph()` from the typegraph SDK. Inside the our function, we have different components of our application.

Metatype uses Policy Based [Access Control](/docs/concepts/access-control) for accessing resources in your backend and here we have defined a public access.
```python3
public = Policy.public()
```

There is a runtime defined namely [PythonRuntime](/docs/reference/runtimes/python). We will be using the runtime to perform different data operations along with the other [runtimes](/docs/referenece/runtimes) Metatype provides. 
```python3
python = PythonRuntime()
```

Now that we have runtimes to process data and we have specified our access control, we need to define endpoints to communicate with our backend. This is where we use the `g.expose` method to enumerate the endpoints we want in our application. From our starter file, we can see that we have defined an endpoint `hello`. 
```python3
# custom functions
hello = python.from_lambda(
        t.struct({"world": t.string()}),
        t.string(),
        lambda x: f"Hello {x['world']}!",
    )

g.expose(public, hello=hello)
```
The `hello` endpoint is mapped with a `custom function` which accepts a `string` and returns **hello** concatinated with the `string`. The processing of data is done using the `PythonRuntime`. When we are defining the custom function, we pass the input type, output type and then a [materializer](/docs/concepts/mental-model#materializers). 

That's it! We have created your first `Metatype` project. It's as easy as this. Before we go ahead and test our app, let's add two more endpoints which peform basic `Create` and `Read` database operation.

In order to exercise database capabilities, we need to build a table schema or a model. The typegraph SDK provides rich [Types](/docs/reference/types) which we can use to create any database table that fits to our usecase. Let's create a simple Message table which has fields `id`, `title` and `body`. This is what it will look like in code.
```python3
message = t.struct(
        {
            "id": t.integer(as_id=True, config=["auto"]),
            "title": t.string(),
            "body": t.string(),
        },
        name="message",
    )
```
Great! Now we need a runtime which processes database requests. We will be using another runtime that comes out of the box with `Metatype`. i.e the [PrismaRuntime](/docs/reference/runtimes/prisma). Let's go ahead and introduce the `PrismaRuntime` to our app. We can add the following code below the `PythonRuntime` that was predefined.
```python3
...
python = PythonRuntime()
db = PrismaRuntime("database", "POSTGRES_CONN")
```

Last, we need to expose a `Create` and `Read` endpoints to our database table. Let's add these two lines to `g.expose`.
```python3
...
g.expose(
        public,
        hello=hello,
        create_message=db.create(message),
        list_messages=db.find_many(message),
    )
```
With these simple steps, we were able to build a basic backend with database capabilities. Finally, this is what our typegraph looks like in `example.py`. 
<CodeBlock language="python">{require("../../../examples/typegraphs/quick-start-project.py").content}</CodeBlock>

We are almost there to test your first `Metatype` application. We now need to spin a [Tyepgate](/docs/reference/typegate) and deploy our typegraph to the instance. 
To start the typegate instance, run the following command.
```bash
docker compose up --detach
```
    TODO: Add result image/log

To deploy our typegraph to our typegate engine, there are two approaces we can follow. We can either use `self-deploy` which comes with the typegraph SDK or the [Meta CLI](/docs/reference/meta-cli). For now, we will be deploying our typegraph using `Meta CLI`. Execute the command below on your terminal to deploy the typegraph. 
```bash
meta -- -C api/example.ts deploy --allow-dirty --create-migration --target dev --gate http://localhost:7890
```
    TODO: Add result image

You have deployed your first typegraph. It's time to run and test our backend which is running on our typegate instance. Click [here](http://localhost:7890/example) to open a `graphql` interface to interact with your backend on your browser. 
    TODO: Add result image
    TODO: Add example graphql queries

You can also try out what we have built so far here on this playground. 
    TODO: Add playground
