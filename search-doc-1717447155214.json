{"searchDocs":[{"title":"Programmable glue for developers","type":0,"sectionRef":"#","url":"/blog/2023/06/18/programmable-glue","content":"","keywords":"","version":null},{"title":"What is Metatype?‚Äã","type":1,"pageTitle":"Programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#what-is-metatype","content":" Metatype is an open source platform to author and deploy APIs for the cloud and components eras. It provides a declarative programming model that helps you to efficiently design APIs and focus on the functional requirements.  The runtime embraces WebAssembly (WASM) as a first-class citizen to allow you to write your business logic in the language of your choice and run it on-demand. Those &quot;backend components&quot; are reusable across your stacks and deployable without pipelines or containers.  The platform provides a set of capabilities out of the box:  create/read/update/delete data in your databasestoring files in your cloud storageauthenticate users with different providers or using JWTsconnecting to third-party/internal APIs  And offers an opportunity to climb the one step higher in the abstraction ladder and drastically simplify the building of great APIs and systems!      Metatype is designed to be as simple as possible and horizontally scalable in existing container orchestration solution like Kubernetes. It consists of multiple parts, including:  Typegraph: a cross-language SDK to manage typegraphs - virtual graphs of types - and compose themTypegate: a serverless GraphQL/REST gateway to execute queries over typegraphsMeta CLI: a command-line tool to efficiently deploy the typegraphs on the gateway    ","version":null,"tagName":"h2"},{"title":"What are virtual graphs?‚Äã","type":1,"pageTitle":"Programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#what-are-virtual-graphs","content":" Typegraphs are a declarative way to expose all APIs, storage and business logic of your stack as a single graph. They take inspiration from domain-driven design principles and in the idea that the relation between of the data is as important as data itself, even though they might be in different locations or shapes.  Loading...  These elements can then be combined and composed together similarly on how you would compose web components to create an interface in modern frontend practices. This allows developers to build modular and strongly typed APIs using typegraph as a programmable glue.  ","version":null,"tagName":"h2"},{"title":"Where does this belong in the tech landscape?‚Äã","type":1,"pageTitle":"Programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#where-does-this-belong-in-the-tech-landscape","content":" Before Metatype, there was a gap in the technological landscape for a solution that specifically addressed the transactional, short-lived use cases. While there were existing tools for analytical or long-running use cases, such as Trino and Temporal, there was no generic engine for handling transactional, short-lived tasks.  \t‚Üê individual entities transactional\tlarge data ‚Üí analytical instantaneous ‚Üë short-lived\tMetatype composition engine for entities in evolving systems\tTrino query engine for large data from multiples sources long-running asynchronous ‚Üì\tTemporal workflow orchestration for long-running operations\tSpark batch/streaming engine for large data processing  ","version":null,"tagName":"h2"},{"title":"Give it a try!‚Äã","type":1,"pageTitle":"Programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#give-it-a-try","content":" Let us know what you think! Metatype is open source and we welcome any feedback or contributions. The community primarily lives on GitHub.  Next steps Build your first typegraph or read more about the concepts behind Metatype. ","version":null,"tagName":"h2"},{"title":"The Node/Deno SDK is now available","type":0,"sectionRef":"#","url":"/blog/2023/11/27/node-compatibility","content":"","keywords":"","version":null},{"title":"Meet wit‚Äã","type":1,"pageTitle":"The Node/Deno SDK is now available","url":"/blog/2023/11/27/node-compatibility#meet-wit","content":" In the realm of WebAssembly, the wit-bindgen project emerges as the most mature tool to create and maintain the language bindings for WebAssembly modules. This tool introduces WIT (WebAssembly Interface Types) as an Interface Definition Language (IDL) to describe the imports, exports, and capabilities of WebAssembly components seamlessly.  For example, Metatype implements the reactor pattern to handle requests as they come and delegate part of their execution in correct WASM runtime. The wit-bindgen helps there to define the interfaces between the guest (the Metatype runtime) and the host (the typegate) to ensure the correct serialization of the payloads. The wit definition could look like this:  package metatype:wit-wire; interface typegate-wire { hostcall: func(op-name: string, json: string) -&gt; result&lt;string, string&gt;; } interface mat-wire { record handle-req { op-name: string, in-json: string, } handle: func(req: handle-req) -&gt; result&lt;string, string&gt;; } world wit-wire { import typegate-wire; export mat-wire; }   The wit file is then used to generate the bindings for the host and the guest in Rust, TypeScript, Python, and other languages. The host bindings are used in the typegate to call the WASM runtime, and the guest bindings are used in the WASM runtime to call the typegate.  ","version":null,"tagName":"h2"},{"title":"Install the v0.2.x series‚Äã","type":1,"pageTitle":"The Node/Deno SDK is now available","url":"/blog/2023/11/27/node-compatibility#install-the-v02x-series","content":" The documentation contains now examples for Node and Deno.  ","version":null,"tagName":"h2"},{"title":"Upgrade with Node‚Äã","type":1,"pageTitle":"The Node/Deno SDK is now available","url":"/blog/2023/11/27/node-compatibility#upgrade-with-node","content":" npm install @typegraph/sdk meta new --template node .   ","version":null,"tagName":"h3"},{"title":"Upgrade with Deno‚Äã","type":1,"pageTitle":"The Node/Deno SDK is now available","url":"/blog/2023/11/27/node-compatibility#upgrade-with-deno","content":" meta new --template deno .   import { typegraph } from &quot;npm:@typegraph/sdk/index.js&quot;;   ","version":null,"tagName":"h3"},{"title":"Upgrade with Python‚Äã","type":1,"pageTitle":"The Node/Deno SDK is now available","url":"/blog/2023/11/27/node-compatibility#upgrade-with-python","content":" pip3 install --upgrade typegraph poetry add typegraph@latest   ","version":null,"tagName":"h3"},{"title":"Give us feedback!‚Äã","type":1,"pageTitle":"The Node/Deno SDK is now available","url":"/blog/2023/11/27/node-compatibility#give-us-feedback","content":" This new release enables us to provide a consistent experience across all languages and reduce the work to maintain the existing Python SDK.  As always, report issues and let us know what you think on GitHub. ","version":null,"tagName":"h2"},{"title":"Welcome to Metatype!","type":0,"sectionRef":"#","url":"/docs","content":"","keywords":"","version":"Next"},{"title":"Start building with the tutorials‚Äã","type":1,"pageTitle":"Welcome to Metatype!","url":"/docs#start-building-with-the-tutorials","content":" üìÑÔ∏è Quick-start Install the requirements and start building. üìÑÔ∏è Metatype basics Learn the basics by building a real world API.  ","version":"Next","tagName":"h2"},{"title":"Explore and learn more functionalities‚Äã","type":1,"pageTitle":"Welcome to Metatype!","url":"/docs#explore-and-learn-more-functionalities","content":" The platform provides out of the box support for many use cases:  create/read/update/delete data in your databasestoring files in your cloud storageauthenticate users with different providers or using JWTsconnecting to third-party/internal APIsrunning custom business logic in your preferred languageproviding fine-grained access control to your dataand more...  üìÑÔ∏è All about types üìÑÔ∏è List of support runtimes üìÑÔ∏è Deploy with Meta CLI üìÑÔ∏è Deep into the typegate  ","version":"Next","tagName":"h2"},{"title":"Understand Metatype in depth‚Äã","type":1,"pageTitle":"Welcome to Metatype!","url":"/docs#understand-metatype-in-depth","content":" Once you are familiar with the basics, you can learn more about the motivation behind Metatype and the underlying implementation.  üìÑÔ∏è Mental model üìÑÔ∏è Comparing Metatype ","version":"Next","tagName":"h2"},{"title":"Architecture","type":0,"sectionRef":"#","url":"/docs/concepts/architecture","content":"","keywords":"","version":"Next"},{"title":"Artifacts‚Äã","type":1,"pageTitle":"Architecture","url":"/docs/concepts/architecture#artifacts","content":" While developing and building an application using Metatype, different types of artifacts can be used in different parts of the application. An artifact is an external file that your application uses as a dependency to execute tasks.  For instance, while working with PythonRuntime, we import an external Python script artifacts/hasher.py which has some hashing functionality. The script which we imported will be marked as an artifact and run inside the PythonRuntime. There can be numerous artifacts which can be used by different Runtimes inside Metatype.  The way Metatype tracks depends on the mode in which the typegate is running.  In the single-replica mode (default), the artifacts are stored in only in the filesystem of the Typegate node.In the Synchronized mode, they are stored in a shared S3-compatible object store.    ","version":"Next","tagName":"h2"},{"title":"Reference counting‚Äã","type":1,"pageTitle":"Architecture","url":"/docs/concepts/architecture#reference-counting","content":" Artifacts are tracked using reference counts. After a successful upload, each artifact is assigned a zero reference count.  When a typegraph is deployed for the first time, the reference counts associated to each of its artifacts are incremented.  When a typegraph is updated, reference counts are updated according to the diff of the artifact list between new and old versions of the typegraph (list of artifact hashes): removal ‚Üí decrementation, addition ‚Üí incrementation, no change ‚Üí no change.  When a typegraph is undeployed, the reference count of each artifact associated to the typegraph is decremented.  Rationale‚Äã  Why do we use reference counts instead of removing unused artifacts after each typegraph update/undeployment?  Artifacts are shared between typegraphs: multiple typegraphs from a single projects might share the same artifacts.We might have orphaned artifacts due to uncompleted typegraph process.  ","version":"Next","tagName":"h3"},{"title":"Artifact removal‚Äã","type":1,"pageTitle":"Architecture","url":"/docs/concepts/architecture#artifact-removal","content":" GC: Garbage collection‚Äã  Artifacts that have a zero reference count are removed.  Triggers: The GC is triggerred at the end of each typegraph deployment/undeployment process.  Full GC‚Äã  Not implemented  A full GC can be triggered manually with the Meta CLI or on the console.  Remove orphaned artifacts from uncompleted typegraph deployment process or uncompleted GC.Recompute all the reference counts, then run the GC. It might be necessary as the reference count might get wrong due to lack of a proper transaction support for the typegraph deployment/undeployment process. ","version":"Next","tagName":"h3"},{"title":"RFCs","type":0,"sectionRef":"#","url":"/docs/concepts/RFCs","content":"RFCs N¬∞\tName\tDateM0\tTemplate\t2024-05-01","keywords":"","version":"Next"},{"title":"Mental model","type":0,"sectionRef":"#","url":"/docs/concepts/mental-model","content":"","keywords":"","version":"Next"},{"title":"Why does Metatype exist?‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#why-does-metatype-exist","content":" Building great APIs is a thought challenge. Developers usually spend a non-negligible amount of time on low-value added tasks (CRUD generation, data validation, authorization, etc.) and managing deployments. This gives them little time to design great interfaces and experiment with the best technical approaches, eventually increasing the time to delivery and weakening innovation.  Metatype's vision is to enable everyone to build modular API with as little effort as possible. By helping developers to re-use existing systems and APIs, it enables teams to focus on what matters: their expert knowledge in business domain, modelling and technologies. Metatype manage the complex aspects for them, making them productive and innovation-friendly for the next iterations.  ","version":"Next","tagName":"h2"},{"title":"How does Metatype work?‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#how-does-metatype-work","content":" When developing a feature, the classical approach is to define what data will be at play, how to transform them, where the execution shall take place and who should be authorized. Instead, Metatype define an abstraction for each of those steps and put the emphasis on composing pre-defined APIs or defining re-usable ones when there is no existing solution.  \tClassical model\tMetatype's modelWhat (data)\tfixed response defined by the logic\tAPI clients selects what they need from types How (transformations)\tad-hoc code logic\tcomposed data with interchangeable functions Where (execution)\t1 code base + 1 database\torchestrate the request across multiple runtimes Who (authentication)\thard-coded rules or system\trequest context based and controlled by policies When (event)\trequest arrival\tbased on triggers  This computing model brings numerous advantages:  it offers multiple runtimes with pre-defined operations and can replace the needs for an ad-hoc backendwhen the project grows, you easily introduce new APIs or break existing ones in smaller partsyou write complex business logic directly in Typescript, Python or WebAssembly and run them on-demandthird-parties APIs can be easily integrated, providing you visibility and control over themit is interoperable with existing (legacy) systems, and can be introduced step by stepit can be easily self-hosted in your own infrastructure or customized according to your needs  ","version":"Next","tagName":"h2"},{"title":"What's exactly Metatype?‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#whats-exactly-metatype","content":" Metatype is an open source platform to author and deploy APIs for the cloud and components eras. It provides a declarative programming model that helps you to efficiently design APIs and focus on the functional requirements.  The runtime embraces WebAssembly (WASM) as a first-class citizen to allow you to write your business logic in the language of your choice and run it on-demand. Those &quot;backend components&quot; are reusable across your stacks and deployable without pipelines or containers.  The platform provides a set of capabilities out of the box:  create/read/update/delete data in your databasestoring files in your cloud storageauthenticate users with different providers or using JWTsconnecting to third-party/internal APIs  And offers an opportunity to climb the one step higher in the abstraction ladder and drastically simplify the building of great APIs and systems!      Metatype is designed to be as simple as possible and horizontally scalable in existing container orchestration solution like Kubernetes. It consists of multiple parts, including:  Typegraph: a cross-language SDK to manage typegraphs - virtual graphs of types - and compose themTypegate: a serverless GraphQL/REST gateway to execute queries over typegraphsMeta CLI: a command-line tool to efficiently deploy the typegraphs on the gateway    ","version":"Next","tagName":"h2"},{"title":"Core abstractions‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#core-abstractions","content":" ","version":"Next","tagName":"h2"},{"title":"Types‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#types","content":" Types are the building block of typegraphs. They define a type system describing all data objects processed in Metatype. They can be easily extended to support new data types according to the needs of the application.     Analogy in SQL: types are similar to the Data Definition Language (DDL) with the extended capacity of describing any type of data.  ","version":"Next","tagName":"h3"},{"title":"Functions‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#functions","content":" Types can also describe functions and functions define how the input type gets transformed into the output type. The input and output types are similar to a function signature, the runtime + configuration associated to it, to its implementation.  deno = DenoRuntime() deno.func( t.struct({&quot;input&quot;: t.string()}), t.string(), code=&quot;({ input }) =&gt; `hello ${input}`&quot;, # with logic ) http = HttpRuntime(&quot;https://random.org/api&quot;) http.get( &quot;/flip_coin&quot;, t.struct({}), t.enum([&quot;head&quot;, &quot;tail&quot;]), )   ","version":"Next","tagName":"h3"},{"title":"Runtimes‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#runtimes","content":" Every type and function have a runtime associated to it. This runtime describes where the types are physically located. It can be another API, a database, or any other services the typegate can connect to. The typegates uses that information to optimize the execution of the queries and minimize the amount of data moved.  In practice, function types are often not explicitly used and the usage of runtime sugar syntax is preferred.  http = HttpRuntime(&quot;https://random.org/api&quot;) # same func as above http.get( &quot;/flip_coin&quot;, t.struct({}), t.enum([&quot;head&quot;, &quot;tail&quot;]) ) # implicitly attaches runtime to all types   Analogy in SQL: a runtime is similar to a database instance running some requests.  ","version":"Next","tagName":"h3"},{"title":"Policies‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#policies","content":" Policies are a special type of function t.func(t.struct({...}), t.boolean().optional()) attachable to any other type. They are evaluated once per request and determine whether one of the polices authorizes the access or not. They receive the request context (see typegate) as argument allowing you to implement authorization, access control, or any other business logic.  The policy decision can be:  true: the access is authorizedfalse: the access is deniednull: the access in inherited from the parent types  deno = DenoRuntime() public = deno.policy(&quot;public&quot;, &quot;() =&gt; true&quot;) # noqa team_only = deno.policy( &quot;team&quot;, &quot;(ctx) =&gt; ctx.user.role === 'admin'&quot; ) # noqa   Analogy in SQL: policies are similar to Row Security Policies (RSP) or Row Level Security (RLS) concepts.  ","version":"Next","tagName":"h3"},{"title":"Triggers‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#triggers","content":" Triggers are events launching the execution of one or multiple functions. They fire when a GraphQL request is received for the specific typegraph.  @typegraph( ) def triggers(g: Graph): # ... g.expose( public, flip=http.get( &quot;/flip_coin&quot;, t.struct({}), t.enum([&quot;head&quot;, &quot;tail&quot;]) ), )   Analogy in SQL: a trigger is similar to receiving a new query. ","version":"Next","tagName":"h3"},{"title":"M0 - Template","type":0,"sectionRef":"#","url":"/docs/concepts/RFCs/M0-template","content":"","keywords":"","version":"Next"},{"title":"Summary‚Äã","type":1,"pageTitle":"M0 - Template","url":"/docs/concepts/RFCs/M0-template#summary","content":" One paragraph explanation of the feature.  ","version":"Next","tagName":"h2"},{"title":"Motivation‚Äã","type":1,"pageTitle":"M0 - Template","url":"/docs/concepts/RFCs/M0-template#motivation","content":" Why are we doing this? What use cases does it support? What is the expected outcome?  ","version":"Next","tagName":"h2"},{"title":"Guide-level explanation‚Äã","type":1,"pageTitle":"M0 - Template","url":"/docs/concepts/RFCs/M0-template#guide-level-explanation","content":" Explain the proposal as if it were already included in the language, and you were teaching it to another peer programmer. That generally means:  Introducing new named concepts.Explaining the feature largely in terms of examples.Explaining how Metatype programmers should think about the feature, and how it should impact the way they use the platform. It should explain the impact as concretely as possible.If applicable, provide sample error messages, deprecation warnings, or migration guidance.If applicable, describe the differences between teaching this to existing Metatype programmers and to new Metatype programmers.Discuss how this impacts the ability to read, understand, and maintain Metatype code. Code is read and modified far more often than written; will the proposed feature make code easier to maintain?  For implementation-oriented RFCs (e.g. for compiler internals), this section should focus on how compiler contributors should think about the change, and give examples of its concrete impact. For policy RFCs, this section should provide an example-driven introduction to the policy, and explain its impact in concrete terms.  ","version":"Next","tagName":"h2"},{"title":"Reference-level explanation‚Äã","type":1,"pageTitle":"M0 - Template","url":"/docs/concepts/RFCs/M0-template#reference-level-explanation","content":" This is the technical portion of the RFC. Explain the design in sufficient detail that:  Its interaction with other features is clear.It is reasonably clear how the feature would be implemented.Corner cases are dissected by example.  The section should return to the examples given in the previous section, and explain more fully how the detailed proposal makes those examples work.  ","version":"Next","tagName":"h2"},{"title":"Drawbacks‚Äã","type":1,"pageTitle":"M0 - Template","url":"/docs/concepts/RFCs/M0-template#drawbacks","content":" Why should we not do this?  ","version":"Next","tagName":"h2"},{"title":"Rationale and alternatives‚Äã","type":1,"pageTitle":"M0 - Template","url":"/docs/concepts/RFCs/M0-template#rationale-and-alternatives","content":" Why is this design the best in the space of possible designs?  Why is this design the best among possible designs?  What other designs have been considered, and what is the rationale for not choosing them?What is the impact of not doing this?  ","version":"Next","tagName":"h2"},{"title":"Prior art‚Äã","type":1,"pageTitle":"M0 - Template","url":"/docs/concepts/RFCs/M0-template#prior-art","content":" Discuss prior art, both the good and the bad, in relation to this proposal. A few examples of what this can include are:  Does this feature exist in other framework, and what experience have their community had?For community proposals: Is this done by some other community, and what were their experiences with it?For other teams: What lessons can we learn from what other communities have done here?Papers: Are there any published papers or great posts that discuss this? If you have some relevant papers to refer to, this can serve as a more detailed theoretical background.  This section is intended to encourage you as an author to think about the lessons from other framework, provide readers of your RFC with a fuller picture. If there is no prior art, that is fine - your ideas are interesting to us whether they are brand new or if it is an adaptation from other framework.  ","version":"Next","tagName":"h2"},{"title":"Unresolved questions‚Äã","type":1,"pageTitle":"M0 - Template","url":"/docs/concepts/RFCs/M0-template#unresolved-questions","content":" What parts of the design do you expect to resolve through the RFC process before this gets merged?What parts of the design do you expect to resolve through the implementation of this feature before stabilization?What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC?  ","version":"Next","tagName":"h2"},{"title":"Future possibilities‚Äã","type":1,"pageTitle":"M0 - Template","url":"/docs/concepts/RFCs/M0-template#future-possibilities","content":" Think about what the natural extension and evolution of your proposal would be and how it would affect the project as a whole in a holistic way. Try to use this section as a tool to more fully consider all possible interactions with the project in your proposal.  This is also a good place to &quot;dump ideas&quot;, if they are out of scope for the RFC you are writing but otherwise related. ","version":"Next","tagName":"h2"},{"title":"Features overview","type":0,"sectionRef":"#","url":"/docs/concepts/features-overview","content":"","keywords":"","version":"Next"},{"title":"Typegate‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#typegate","content":" GraphQL API COMPLETE Expose select functions in your graph through a GraphQL API. These root-functions will serve as the entry point to your graph for any incoming request. The typegraph model is a great fit for GraphQL semantics and this is the best supported way to consume typegraphs. GraphQL Subscriptions FUTURE Get real-time data to clients. REST API COMPLETE You can expose select root functions through a simple REST API. This is handy to serve endpoints for clients that are not GraphQl capable, even though it hampers access to some typegraph features. Inputs will be sourced from either HTTP bodies or search parameters according to HTTP verb. gRPC API FUTURE Support to expose the typegraph through a gRPC API. Cron triggers FUTURE Execute functions at certain time intervals. Useful for cleanup jobs. Rate-limiting COMPLETE Rate-limit parts of your graph to minimize abuse. The limits can be configured granularly for each function and for custom time windows. Use custom request identifiers, in addition to ip addresses, to track limits counters. CORS COMPLETE Specify cross-origin request rules to control which domains can access your API from within a browser. Prevents abuse from websites trying to use your API without permission. Single-node COMPLETE The typegate can be run as a single node mode for simple deployments and using the filesystem as its artifact store. Useful for local development and testing. Multi-node COMPLETE Deploy multiple instances of the typegate to distribute loads across machines and scale horizontally. You'll only need a Redis compatible key-value cache, an S3 compatible object store, and your favorite load-balancer in front of the instances to get it going. This mode is recommended for production deployments even if only a single node is used.    ","version":"Next","tagName":"h2"},{"title":"Typegraph‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#typegraph","content":" Loading... Scalar types COMPLETE The primitive types integer, float, boolean, string and file. All data that flows through a typegraph reduces down to these types. Type constraints COMPLETE Declare types in your graph that are subset of primitives like string and integers by using regular expressions or min/max limits. Useful to validate incoming data even more and distribute invariants through your app. Composite types COMPLETE Support for struct, list, union, either and optional types. These allow you to represent types equivalent to most modern type systems. Injections COMPLETE Injections resolve part of your graph inline instead of from functions or provide defaults for incoming request data. This can be used to set static values or source them from the context, other parts of the graph...etc. Functions COMPLETE Nodes in your typegraph that represent data to be resolved after running some logic on a Runtime. Function chaining FUTURE Compose functions together by feeding the output of one as the input of another. Encourages code reuse by allowing one to extract common middleware logic from each function, all within the typegraph layer. reduce COMPLETE reduce is useful to transform function input types so that only certain struct fields are used, discarding the others. Required fields can be hidden from the user and can instead be injected from the request's context or a static default. This is useful for remixing generated or core domain types to more targeted forms appropriate for a function. apply COMPLETE apply allows the flattening of deeply nested function input types to something friendlier. Injection can also be used to substitute required fields in the original type from another source. Imports FUTURE Imports will allow graphs to include nodes from other API descriptions like GraphQL, OpenAPI, gRPC and database schemas. These APIs can then be consumed in a typesafe manner through the GraphQL and Http runtimes. Secrets COMPLETE First-class support for secrets to ease runtime substitution of sensetive values. API keys or dynamic values only discovrable after deployment, this is how you get them into your app.    ","version":"Next","tagName":"h2"},{"title":"Runtimes‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#runtimes","content":" Deno runtime COMPLETE Write functions that execute pieces of TypeScript code on a Deno worker. Includes easy access to ESM and libraries through standard Deno features. Loading... Python runtime BETA Implement functions that execute python functions in code snippets or on disk modules. from typegraph import typegraph, Policy, t, Graph from typegraph.runtimes.deno import PythonRuntime @typegraph() def example_python(g: Graph): public = Policy.public() python = PythonRuntime() g.expose( public, add=t.func( t.struct({&quot;a&quot;: t.integer(), &quot;b&quot;: t.integer()}), t.integer(), # we can provide the code inline using lambdas python.from_lambda(lambda x: x[&quot;a&quot;] + x[&quot;b&quot;]), ), sayHello=python.import_( t.struct({&quot;name&quot;: t.string()}), t.string(), # point to pythoin a file on disc module=&quot;hello.py&quot;, name=&quot;say_hello&quot; ), ) } S3 runtime COMPLETE Store large blobs in S3 compatible object stores. This includes support for GraphQL file uploads and presigned URLs making working with images and large uploads a breeze. Temporal runtime COMPLETE Kick off and query Temporal workflows from a typegraph. Temporal is a durable execution engine that can be used to implement long-running, failure-resistant business processes. Wasm runtime BETA Make functions that use WASM components to implement their logic. Write core-wasm or wasi 0.2 based wasm components in languages like Rust, Python and Javascript to power all your custom functions. GraphQL runtime COMPLETE Include external GraphQL APIs as part of your typegraph. This runtime provides functions that resolve the data by querying an external GraphQL API. Http runtime COMPLETE Include external Http APIs as part of your typegraph. Source the data for your graph using external HTTP requests. Random runtime COMPLETE Functions to generate random data based on your types. Useful for quickly throwing together an API and testing. gRPC runtime FUTURE Include external gRPC APIs as part of your typegraph.  ","version":"Next","tagName":"h2"},{"title":"Prisma‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#prisma","content":" Access a myriad of databases directly from your typegraph. Run queries, mange it's schema, the full orm featureset.  Loading... Relational schemas COMPLETE Use the types in your graph to declare and manage relational schemas to be used on your databse. This means support for primary keys, unique constraints, one-to-one, one-to-many, many-to-many relationships...etc. CRUD queries COMPLETE Easily generate functions for common create, update, read and delete queries. Includes nested filtering and aggregration paramters for efficent and targeted requests. Raw queries COMPLETE Drop down to raw SQL queries for cases not covered by the CRUD generators. Useful to access unique features native to your database or craft extra efficient queries. PostgreSQL support COMPLETE Support for PostgreSQL, a modern and established DBMS. Beta databases BETA MySQL, MariaDB, AWS Aurora, AWS Aurora Serverless, Microsoft SQL Server, Azure SQL, MongoDB, CockroachDB.    ","version":"Next","tagName":"h3"},{"title":"Authentication‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#authentication","content":" Policy-based access control COMPLETE Policies are simple functions that take the request as input and return values to signal whether it's allowed/denied access. They can be attached to any function in the graph and are evaluated right before the request triggers one. They compose well and are the primary authorization primitive available to typegraphs. Loading... Basic authentication COMPLETE Requests can authenticate themselves using Basic HTTP headers. Simple but useful for getting started or protecting admin only requests. Loading... JWT authentication COMPLETE Json Web Tokens can be used to attach more authentication and context information to requests. The data in the tokens can then be used by policies to make authorization decisions. Loading... OAuth2 authorization COMPLETE Use the Oauth2 scheme to implement social-sign in from common identity providers like Github, Meta and Google. Loading...    ","version":"Next","tagName":"h2"},{"title":"Tooling‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#tooling","content":" Meta CLI COMPLETE Full-featured CLI to aid development and manage typegraph deployments on the typegate. Supports watch mode to aid rapid-iteration, including support for interactive database migration management. Bundles the typegate within it making the CLI all one needs to get started. (And a text editor, of course.) ‚ùØ meta --help at 02:03:36 Declarative API development platform. Build backend components with WASM/Typescript/Python, no matter where and how your (legacy) systems are. Usage: meta [OPTIONS] [COMMAND] Commands: serialize Serialize the typegraphs defined in the specified python file(s) into JSON dev Push typegraph(s) with development mode features enabled deploy Push typegraph(s) to typegate undeploy Undeploy typegraph(s) from typegate gen Access metagen generators upgrade Upgrade completion Generate shell completion doctor Troubleshoot the installation new Create a new Metatype project typegate Access a minimal deno CLI help Print this message or the help of the given subcommand(s) Options: --version -v, --verbose... Increase logging verbosity -q, --quiet... Decrease logging verbosity -C, --dir &lt;DIR&gt; [default: .] --config &lt;CONFIG&gt; path to the config file -h, --help Print help Metagen BETA Code generation suite that supports Rust, Python and Typescript. Generate types from your graph and other helper functions for authoring custom functions for the Wasm, Python and Deno runtimes respectively. Can be accessed through the CLI under the gen subcommand or through the different SDKs. Meta LSP BETA Extension for your IDE to help authoring of typegraphs. Supports VSCode as of now. Docker images COMPLETE The typegate is primarily distributed as a docker image for deployment as a container. All the available configuration environment variables can be found here. Helm charts COMPLETE Helm charts are published to ease installation of a typegate deployment in your Kubernetes cluster. docker run --rm --pull always \\ -p 7890:7890 \\ -e TG_SECRET=$(openssl rand -base64 64 | tr -d '\\n') \\ -e TG_ADMIN_PASSWORD=&quot;password&quot; \\ ghcr.io/metatypedev/typegate:latest     ","version":"Next","tagName":"h2"},{"title":"SDKs‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#sdks","content":" Typescript SDK COMPLETE Use typescript to author typegraphs and access other SDK tooling. Supports Node and compatible runtimes like Deno and Bun. Python SDK COMPLETE Use Python to author typegraphs and access other SDK tooling. Dart SDK FUTURE Use Dart to author typegraphs and access other SDK tooling. Deployments COMPLETE Programmatically upload your typegraphs to the typegate from within the SDK. Useful for writing tests or building on top of the Metatype platform. Migrations BETA Programmaticaly manage necessary migrations returned by the Prisma runtime. Useful for writing tests or building on top of the Metatype platform. Codegen BETA Access metagen through the SDK directly to generate type declarations and other helpful code. Useful for testing and to build custom workflows/tooling. ","version":"Next","tagName":"h2"},{"title":"Comparing Metatype","type":0,"sectionRef":"#","url":"/docs/concepts/comparisons","content":"","keywords":"","version":"Next"},{"title":"Development platforms‚Äã","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#development-platforms","content":" FirebaseSupabaseHasuraPostGraphile  These are great platforms to quickly start a new project. However, they hardly scale in terms of architecture evolution, technology freedom, number of developers on the project, and you will eventually have to move out due to increasing costs or iterations slowness.  When to choose Metatype  You want to build modular APIs by composing pre-defined blocks and import the ones you need from existing systems.You want to take advantage of developers tooling you are familiar with, like version controls or multiple environments.You favor interoperability and extensibility over vendor lock-in, and follow your future needs with ease.You want to decouple your database from your API and change where the data is stored as the project evolves.  ","version":"Next","tagName":"h2"},{"title":"Headless CMS‚Äã","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#headless-cms","content":" StrapiDirectus  Headless Content Management Systems (CMS) are great tools to manage content and providing great editing experience. However, they are not designed to build complex APIs like a cart checkout or integrate with other systems.  When to choose Metatype  You want an all-in-one APIs development platforms and offer the same editing experience through a user-friendly interfaceYou care about end-user performance and want to use the best underlying technology for each use casesYou are more than one on the project and want to manage your data models using preferred programming language  ","version":"Next","tagName":"h2"},{"title":"Low Code Platforms‚Äã","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#low-code-platforms","content":" RetoolAirtableWindmill  Low Code platforms are a game changer when it comes to faster development cycle, great collaboration options and the gentle learning curve. However, this comes at the cost of losing degree of flexibility and cusomizability. They are also hard to apply different scalability and come with limited performance optimization.  When to choose Metatype  When you want more control over your application instances running on the cloud.When you want to build more complex APIs.When you want to have the freedom to make detailed changes to your application to gain that extra peformance.    Feature/Capability Key:  ‚úÖ 1st class, with no extra dependencies.‚ö™ supported, but with extra 3rd party dependenciesüî∂ supported, but with extra 3rd party dependencies and user code.üî¥ not officially supported or documented.  \tMetatype\tDevelopment Platforms\tHeadless CMS\tLow code platformLicensing\tOpen Source\tOpen Source Proprietary\tOpen Source\tProprietary Platform's Requirements\t- Cloud-based: None - Locally: Deno/Node.js/Python Runtime, Redis, Docker\t- Cloud-based: None - Running Locally: Docker, DBMS\t- NodeJS runtime - DBMS\tCloud-based: None Architecture Model\t- Declarative - Less Code - Serverless\t- API over Database - Serverless\t- Headless Architecture - Serverless\t- Visual drag and drop - Serverless REST/HTTP\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ GraphQL\t‚úÖ\t‚ö™\t‚úÖ\tüî∂ gRPC\tüî∂*\tüî∂\tüî∂\tüî∂ GUI for non programmers\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ Development SDKs\t‚úÖ\t‚úÖ\tüî¥\tüî¥ (Most) ‚úÖ (few) CLI\t‚úÖ\t‚úÖ (some) üî¥ (some)\t‚úÖ\tüî¥ Dev Tools\t‚úÖ\t‚úÖ\t‚úÖ\tüî¥ LSP and Extensions\t‚úÖ*\t‚ö™\t‚ö™\tüî¥ Authentication\t- Basic Auth - JWT - OAuth\t- Basic Auth - JWT - OAuth - JWT\t- email/phone/password - JWT - OAuth\t- email/phone/password - JWT - OAuth - JWT Authorization\t- policy-based access control (PBAC)\t- policy-based access control (PBAC) - role-based access control (RBAC)\t- role-based access control (RBAC)\t- Custom Authorization logic from the User Type System\tCustom Types\t- JS objects - GraphQL Schemas - Database Types\tJS objects\tCustom Types Custom Code Support\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ Version Control Friendly\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ GitOPs Friendly\t‚úÖ\t‚úÖ\t‚ö™\t‚ö™ Vertical Scalability\tFlexibile\tLimited\tFlexibile\tLimited Service Decomposition\t‚úÖ\t‚úÖ\t‚úÖ\tüî¥ Deployment Options\t- On premise - Cloud-based platforms\t- On premise - Cloud-based platforms\t- On premise - Cloud-based platforms\t- On premise - Cloud-based platforms Monitoring and Tracking\t‚úÖ*\t‚úÖ\t‚úÖ\tüî∂ Logging\t‚úÖ*\t‚úÖ\t‚úÖ\tüî∂    ","version":"Next","tagName":"h2"},{"title":"Table Parameters Legend‚Äã","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#table-parameters-legend","content":" Solution's Meta‚Äã  Licensing: The type of licensing model the software solution adopts, such as open-source, proprietary, freemium, etc.  Platform's Requirements: The prerequisites and dependencies required for the software to run efficiently, including hardware, operating system, runtime environment, etc.  Architecture Model: The underlying design principles and patterns governing the behavior/structure of the software solution.  Network comms‚Äã  REST/HTTP: Support for Representational State Transfer (REST) or Hypertext Transfer Protocol (HTTP) communication protocol used for network communication.  GraphQL: Support for GraphQL.  gRPC: Support for gRPC.  Ecosystem‚Äã  GUI for non programmers: Graphical User Interface (GUI) tools designed to facilitate interaction with the software by individuals with limited programming knowledge or expertise.  Development SDKs: Software Development Kits (SDKs) provided by the solution to aid developers in building applications using the platform.  CLI: Command-Line Interface tools provided for developers or administrators to interact with the software from the terminal or command prompt.  Dev Tools: Tools and utilities provided to aid developers in coding, debugging, testing, and profiling applications.  LSP and Extensions: Language Server Protocol (LSP) and Extensions support for enhanced development experience, including features like syntax highlighting, auto-completion, and error checking.  Security‚Äã  Authentication: Mechanisms for verifying the identity of users or entities accessing the software solution.  Authorization: The process of determining whether an authenticated user or system entity is allowed to perform a specific action or access a particular resource.  Database Interaction‚Äã  Type System: The system governing the data types and structures used by which the application entities and models are constructed.      System Flexibility‚Äã  Custom Code support: The ability of the software solution to accommodate custom code or extensions developed by users or third-party developers.    Versioning and CI/CD‚Äã  Version Control: The support for versioning and revision control of software artifacts, typically using systems like Git, SVN, etc.  GitOPs Friendly: Compatibility or support for the GitOps methodology, where infrastructure and application deployments are managed through Git workflows.  Scalability‚Äã    Vertical Scalability: The ability of the software solution to handle increased workload or demand by adding more resources to a single node or instance.  Service Decomposition: The architectural principle of breaking down the software into smaller, independent services (microservices) to improve scalability, maintainability, and flexibility.  Deployment‚Äã  Deployment Options: The available methods and strategies for deploying the software solution, including on-premises, cloud-based, containerized, etc.  Monitoring, Logging and maintenance‚Äã  Monitoring and Tracking: Tools and mechanisms provided for monitoring the health, performance, and usage of the software solution, as well as tracking user activities and behaviors.  Logging: Facilities for recording and storing system events, errors, and other relevant information for troubleshooting, analysis, and auditing purposes.    ","version":"Next","tagName":"h3"},{"title":"","type":0,"sectionRef":"#","url":"/docs/guides/contributing","content":"","keywords":"","version":"Next"},{"title":"Table of Contents‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#table-of-contents","content":" Code of ConductI Have a QuestionI Want To ContributeReporting BugsSuggesting EnhancementsYour First Code Contribution  ","version":"Next","tagName":"h2"},{"title":"Code of Conduct‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#code-of-conduct","content":" This project and everyone participating in it is governed by ourCode of Conduct. By participating, you are expected to uphold this code.  ","version":"Next","tagName":"h2"},{"title":"I Have a Question‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#i-have-a-question","content":" If you want to ask a question, we assume that you have read the availabledocumentation.  Before you ask a question, it is best to search for existingIssues that might help you. In case you have found a suitable issue and still need clarification, you can write your question in this issue. It is also advisable to search the internet for answers first.  If you then still feel the need to ask a question and need clarification, we recommend the following:  Open an Issue.Provide as much context as you can about what you're running into.Provide project and platform versions depending on what seems relevant.  ","version":"Next","tagName":"h2"},{"title":"I Want To Contribute‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#i-want-to-contribute","content":" Legal Notice‚Äã When contributing to this project, you must agree that you have authored 100% of the content, that you have the necessary rights to the content and that the content you contribute may be provided under the project license.  ","version":"Next","tagName":"h2"},{"title":"Reporting Bugs‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#reporting-bugs","content":" Before Submitting a Bug Report‚Äã  A good bug report shouldn't leave others needing to chase you up for more information. Therefore, we ask you to investigate carefully, collect information and describe the issue in detail in your report. Please complete the following steps in advance to help us fix any potential bug as fast as possible.  Make sure that you are using the latest version.Determine if your bug is really a bug and not an error on your side e.g. using incompatible environment components/versions (Make sure that you have read thedocumentation. If you are looking for support, you might want to check this section).To see if other users have experienced (and potentially already solved) the same issue you are having, check if there is not already a bug report existing for your bug or error in thebug tracker.Also make sure to search the internet (including Stack Overflow) to see if users outside the GitHub community have discussed the issue.Collect information about the bug:Stack traceOS, Platform and Version (Windows, Linux, macOS, x86, ARM)Version of the interpreter, compiler, SDK, runtime environment, package manager, depending on what seems relevant.Possibly your input and the outputCan you reliably reproduce the issue? And can you also reproduce it with older versions?  How Do I Submit a Good Bug Report?‚Äã  You must never report security related issues, vulnerabilities or bugs including sensitive information to the issue tracker, or elsewhere in public. Instead sensitive bugs must be reported according to theSecurity Policy.  We use GitHub issues to track bugs and errors. If you run into an issue with the project:  Open an Issue. (Since we can't be sure at this point whether it is a bug or not, we ask you not to talk about a bug yet and not to label the issue.)Explain the behavior you would expect and the actual behavior.Please provide as much context as possible and describe the reproduction steps that someone else can follow to recreate the issue on their own. This usually includes your code. For good bug reports you should isolate the problem and create a reduced test case.Provide the information you collected in the previous section.  ","version":"Next","tagName":"h3"},{"title":"Suggesting Enhancements‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#suggesting-enhancements","content":" This section guides you through submitting an enhancement suggestion for Metatype, including completely new features and minor improvements to existing functionality. Following these guidelines will help us and the community to understand your suggestion and find related suggestions.  Before Submitting an Enhancement‚Äã  Make sure that you are using the latest version.Read the documentation carefully and find out if the functionality is already covered, maybe by an individual configuration.Perform a search to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one.Find out whether your idea fits with the scope and aims of the project. It's up to you to make a strong case to convince the project's developers of the merits of this feature. Keep in mind that we want features that will be useful to the majority of our users and not just a small subset. If you're just targeting a minority of users, consider writing an add-on/plugin library.  How Do I Submit a Good Enhancement Suggestion?‚Äã  Enhancement suggestions are tracked asGitHub issues.  Use a clear and descriptive title for the issue to identify the suggestion.Provide a step-by-step description of the suggested enhancement in as many details as possible.Describe the current behavior and explain which behavior you expected to see instead and why. At this point you can also tell which alternatives do not work for you.Explain why this enhancement would be useful to most Metatype users. You may also want to point out the other projects that solved it better and which could serve as inspiration.  ","version":"Next","tagName":"h3"},{"title":"Your First Code Contribution‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#your-first-code-contribution","content":" Metatype is using a mono-repository approach. This means that all code is centralized and requires many different tools to work with. The following sections will guide you through the setup process.  Dependencies‚Äã  Install the following global dependencies:  RustPythonPipxPNPMDenoNode  And then more specific ones for the workspace:  # manage rust dependencies cargo install cargo-edit # task runner cargo install whiz # enforce style and good practice pipx install pre-commit # manange python dependencies pipx install poetry # grpc prerequisits brew install protobuf sudo apt-get install protobuf-compiler libprotobuf-dev   Running The Project‚Äã  # install git commit hooks pre-commit install # prepare python virtual environment python3 -m venv .venv source .venv/bin/activate # depends on your shell # run the task runner and it will install the remaining dependencies (see whiz.yaml and install step) whiz   Environments And Tests‚Äã  deno run -A dev/env.ts all # or only the envs required (e.g. base prisma s3) cargo test --tests # there is a bug with wasm and doc testings deno run -A dev/test.ts # all tests deno run -A dev/test.ts runtimes/prisma/full_prisma_mapping_test.ts # isolated test deno run -A dev/env.ts # shutdown all envs   There are many more developer scripts in the dev folder, however most of them should only be needed for advanced tasks.  Commit Messages‚Äã  Pre-commit hooks enforce some basic checks, namely that all commit messages follow the conventional commitformat. This is a simple set of rules that makes review easier and help us to generate a changelog.  Faster linking‚Äã  We recommend using mold for Linux targets and macOS new parallel linker for faster linking. You can use them as aliases or configure them in your ~/.cargo/config.toml file.  [target.aarch64-apple-darwin] rustflags = [ &quot;-C&quot;, &quot;link-arg=-fuse-ld=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld&quot;, &quot;-C&quot;, &quot;link-arg=-ld_new&quot; # makes sure the new parallel linker is used ] [target.x86_64-unknown-linux-gnu] rustflags = [ &quot;-C&quot;, &quot;link-arg=-fuse-ld=mold&quot; ]   Local typegraph with Nodejs‚Äã  Currently, the typegraph/sdk/node/dist project is generated dynamically. Depending on your package manager, the protocol used may differ.  # uses the `file:..` protocol npm install path/to/typegraph/sdk/node/dist # uses the `link:..` protocol (equivalent to `file:..` but for directories only) pnpm install path/to/typegraph/sdk/node/dist  ","version":"Next","tagName":"h3"},{"title":"Custom functions","type":0,"sectionRef":"#","url":"/docs/guides/external-functions","content":"","keywords":"","version":"Next"},{"title":"Accessing function context‚Äã","type":1,"pageTitle":"Custom functions","url":"/docs/guides/external-functions#accessing-function-context","content":" Beta The following feature is currently only implemented for the DenoRuntime.  On some runtimes, custom functions are passed to the context object along with the function inputs. This object provides access to all kinds of information about the context in which the function is running. The following example illustrates availaible fields:  Loading...  Note, the typescript version of the sample uses a closure instead of a string snippet to define the function. This is a simple syntax sugar availaible when using DenoRuntime through the typescript sdk or the PythonRuntime the python one. Consult the reference for each runtime to look at what's availaible.  ","version":"Next","tagName":"h2"},{"title":"Write REST endpoints","type":0,"sectionRef":"#","url":"/docs/guides/rest","content":"Write REST endpoints The root functions, the ones we expose from our typegraphs, are served through a GraphQl API over HTTP. In addition, we can also expose REST APIs using the rest method. The method takes GraphQl queries and provides RESTly endpoints for them. Loading... The effect of the root function accessed in the query determines the HTTP verb used, and the mapping can be found here. There's also an OpenAPI schema generated from the rest endpoints served under {typegate_url}/{typegraph}/rest/_schema. A browser-based explorer for the OpenAPI schema is served under {typegate_url}/{typegraph}/rest as well. You can refer to the REST reference section for more information.","keywords":"","version":"Next"},{"title":"Accessing the typegraph‚Äã","type":1,"pageTitle":"Custom functions","url":"/docs/guides/external-functions#accessing-the-typegraph","content":" Beta The following feature is currently only implemented for the DenoRuntime.  To do anything meaningful with custom functions, you'll want to access the rest of functionality implemented on your typegraph. The primary way of doing this is by sending GraphqQl queries from within your function. On the DenoRuntime, to make this easier, there's a gql object passed to all functions. The following exapmle illustrates how it functions:  Loading...  And scripts/createVote.ts looks like:  export async function handle( inp: { ideaId: string; authorEmail: string }, _ctx: any, // the third paramter contains the gql client object { gql }: any, ) { // find the referenced idea from the typegraph const { data: { idea } } = await gql` query getIdeaAuthorEmail($ideaId: String!) { idea: i_get_idea(where: { id: $ideaId }) { authorEmail } } `.run({ ideaId: inp.ideaId }); // we check if the idea exists if (!idea) { throw new Error(`no idea found under id ${inp.ideaId}`); } // and that the author and voter aren't the same if (inp.authorEmail == idea.authorEmail) { throw new Error(`author of idea can't vote for idea`); } // we persist the vote with another gql call const { data: { vote } } = await gql` mutation insertVote($ideaId: String!, $authorEmail: String!) { vote: i_create_vote(data: { authorEmail: $authorEmail, idea: { connect: { id: $ideaId } } }) { id } } `.run(inp); return { voteId: vote.id }; }  ","version":"Next","tagName":"h2"},{"title":"Upload files to cloud storage","type":0,"sectionRef":"#","url":"/docs/guides/files-upload","content":"","keywords":"","version":"Next"},{"title":"Uploading file using GraphQL multipart request‚Äã","type":1,"pageTitle":"Upload files to cloud storage","url":"/docs/guides/files-upload#uploading-file-using-graphql-multipart-request","content":" Metatype supportsGraphQL multipart requestfor uploading files. You may use one of the clients in thislistthat support GraphQL multipart request.  const image = await Deno.readFile(&quot;website/static/images/logo.png&quot;); const formData = new FormData(); formData.append( &quot;operations&quot;, JSON.stringify({ query: ` mutation UploadImage($file: Upload!) { upload(file: $file) { id path size contentType } } `, variables: { file: null, }, }) ); formData.append(&quot;map&quot;, JSON.stringify({ 0: [&quot;variables.file&quot;] })); formData.append(&quot;0&quot;, image, &quot;logo.png&quot;); const upload = await fetch(&quot;http://localhost:7891/files-upload&quot;, { method: &quot;POST&quot;, body: formData, }); console.log(await upload.json());  ","version":"Next","tagName":"h3"},{"title":"Importing External Modules","type":0,"sectionRef":"#","url":"/docs/guides/import-external-modules","content":"Importing External Modules So far, the functinos we've looked at have been generated by helpers like the CRUD helpers from the Prisma runtime or the the Random runtime's generate helper. The deno.policy function we used for authoring policies was also based on function objects. All these helpers are shorthands for creating function objects and now we'll look at how to roll a custom function ourselves. We'll be using the Deno runtime to run our code. Instead of including the code inline through a string, the Deno runtime allows us to import modules from disk. Our modules are allowed to use ESM imports to access libraries on different registries like npm and deno.land. We'll use these features to write a simple function that converts markdown to html. import * as marked from &quot;https://deno.land/x/marked/mod.ts&quot;; export function parse({ raw }: { raw: string }): string { return marked.parse(raw); } We'll expose our module using the deno runtime. Typescript SDK Python SDK typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... g.expose( { // .. &quot;parse_markdown&quot;: deno.import( t.struct({&quot;raw&quot;: t.string()}), t.string(), { name: &quot;parse&quot;, // the path is parsed relative to the typegraph file module: &quot;md2html.ts&quot;, } ), // .. }, pub ); }); We can now access our func through the GraphQl api. Loading...","keywords":"","version":"Next"},{"title":"Secure your requests","type":0,"sectionRef":"#","url":"/docs/guides/securing-requests","content":"","keywords":"","version":"Next"},{"title":"Authentication‚Äã","type":1,"pageTitle":"Secure your requests","url":"/docs/guides/securing-requests#authentication","content":" Typegraphs supports multiple auth schemes for incoming requests including:  Basic accessJSON Web Tokens (JWT)OAuth2  Each scheme relies on tokens that will be expected on the Authorization header of any incoming request. Information extracted from any found tokens will then be added to the context of every request. Each scheme allows for different secrets to be encoded in the tokens, secrets like user identification and access tokens. You can then use policies to examine the context and determine if a request is allowed access to parts of your typegraph. You can also inject data from the context, to set materalizer inputs for example, using from_context.  The following example uses basic authentication in order to only allow access for admin users. Basic authentication relies on a username and password pair. We specify the password through typegraph secrets with the format BASIC_{username}. In this case, the secret BASIC_andim=password is set.  Loading...  Note, the token is encoded in base64. Decoded, it'd read andim:password.  If you were to try to send a request without the header, you'd notice that get_full_context still returns a result. An empty object. Authentication is only responsible for populating the context object and without a policy to shoot down the request, it'll access the materalizers.  On the other hand, get_context returns an empty object when no header is found. from_context acts as guard preventing the materalizer from being accessed unless the named data is found in the context.  More details about authentication can be found here.    ","version":"Next","tagName":"h2"},{"title":"Policies‚Äã","type":1,"pageTitle":"Secure your requests","url":"/docs/guides/securing-requests#policies","content":" The primary authorization paradigm used in typegraphs is policy based access control. Policies are small pieces of logic that evaluate a request and determine weather access is allowed or not. They're attached to materalizers and are evaluated whenever a request tries to access the materalizer.  Concretely, policies are implemented using custom function. These functions take the request's context object as input and return an optional bool. Typescript functions running on DenoRuntime is the recommended way for writing policies today and the following example demonstrates how.  Before anything, the following secrets are required to enable the basic authentication scheme.  typegates: dev: # .. secrets: policies: BASIC_admin: &quot;admin_pass&quot; BASIC_user: &quot;user_pass&quot;   Loading...  More than one policy can be attached to a single materalizer and combining policies allows for compositionaly defining our access control rules. If a materalizer has more than one policy, they are evaluated in turn and:  If any one of attached policy returns true, the request immediately gains access.If a policy returns false, the request is immediately denied access.If the policy means to defer decision to other attached policies, it can return null instead.If all attached policies return null, the request is denied access.  There are helper functions on the Policy object that allow easy construction of common policy patterns.  Policy.public: allow any request.Policy.internal: allow requests originating from within typegraph like custom functions.Policy.on: use different policies depending on request effect. Useful for policy shared across many materalizers.Policy.context: generate a policy using a simple pattern matching on context object fields. ","version":"Next","tagName":"h2"},{"title":"Self-host the Typegate","type":0,"sectionRef":"#","url":"/docs/guides/self-hosting","content":"","keywords":"","version":"Next"},{"title":"Helm‚Äã","type":1,"pageTitle":"Self-host the Typegate","url":"/docs/guides/self-hosting#helm","content":" Helm must be installed to use the charts. Please refer to Helm's documentation to get started. The chart can be accessed on the dedicatedrepository.  Once Helm has been set up correctly, add the repo as follows:  helm repo add metatype https://charts.metatype.dev helm show values metatype/typegate &gt; values.yml # customize values.yaml helm install my-gate --values values.yml metatype/typegate  ","version":"Next","tagName":"h2"},{"title":"Ecosystem","type":0,"sectionRef":"#","url":"/docs/reference/ecosystem","content":"","keywords":"","version":"Next"},{"title":"Metatype‚Äã","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#metatype","content":" Metatype is a declarative API development platform. The main repository contains the Meta CLI, the typegate and the typegraph components.  ","version":"Next","tagName":"h2"},{"title":"ghjk‚Äã","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#ghjk","content":" ghjk (pronounced /gk/) is a programmable runtime manager for developer environments. It powers the development of Metatype on its authors' machines, on the CI and containers.  ","version":"Next","tagName":"h2"},{"title":"Lade‚Äã","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#lade","content":" Lade automatically load secrets from your preferred vault as environment variables, and clear them once your shell command is over. The Meta CLI bundles Lade and use it to load secret seamlessly into your typegates.    ","version":"Next","tagName":"h2"},{"title":"Whiz‚Äã","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#whiz","content":" Whiz is a modern DAG/tasks runner for multi-platform monorepos. It enables to develop the core components of the ecosystem together and reloading only the necessary tasks on file change.   ","version":"Next","tagName":"h2"},{"title":"Meta CLI","type":0,"sectionRef":"#","url":"/docs/reference/meta-cli","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Meta CLI","url":"/docs/reference/meta-cli#installation","content":" info Metatype is only supported on macOS and Linux. Windows users should use Linux on Windows with WSL.  You can download the binary from thereleases page, make it executable and add it to your PATH or use the automated method below.  An installer script is also provided for the CLI in our repository. Curl and install in it with the following one-liner. The installer may ask for your password. curl -fsSL https://raw.githubusercontent.com/metatypedev/metatype/main/installer.sh | bash For later use, you can run the following command to upgrade Meta CLI to a newer version. If your Meta CLI is up to date, you will get an Already up to date! response. meta upgrade   That's it! You are done installing Meta CLI.  For development purposes, the cli bundles the typegate itself and this can be accessed through the meta typegate subcommand.    üìÑÔ∏è Available commands üìÑÔ∏è Configuration file ","version":"Next","tagName":"h2"},{"title":"Configuration file","type":0,"sectionRef":"#","url":"/docs/reference/meta-cli/configuration-file","content":"","keywords":"","version":"Next"},{"title":"Embedded Typegate","type":0,"sectionRef":"#","url":"/docs/reference/meta-cli/embedded-typegate","content":"Embedded Typegate The Meta_CLI comes with an embedded typegate packaged inside it. A typegate instance is where you deploy your typegraphs where any logic written in them is exposed via an HTTP or GraphQL endpoints. You can run an embedded typegate node from the terminal, but you first need to set a couple of environment variables which are needed to instantiate the typegate node. Set the tg_admin_password and tg_secret environment variables. You can use the following command to configure a sample value for the variables and test the embedded typegate. // set up tg_secret and tg_admin_password export tg_secret=a4lNi0PbEItlFZbus1oeH/+wyIxi9uH6TpL8AIqIaMBNvp7SESmuUBbfUwC0prxhGhZqHw8vMDYZAGMhSZ4fLw== tg_admin_password=password If you have not installed Meta_CLI or you have downloaded the thin version, you can check this installation guide of the CLI. Everything is setup to run the embedded typegate. Just run the following command below. meta typegate The typegate instance runs on port 7890 by default. You can check if the typegate node is running by accessing http://localhost:7890 in your browser.","keywords":"","version":"Next"},{"title":"metatype.yml Example file‚Äã","type":1,"pageTitle":"Configuration file","url":"/docs/reference/meta-cli/configuration-file#metatypeyml-example-file","content":" The metatype.yml is a configuration file where we store environment variables, secrets and configs in which our app will use during deployment and runtime.  typegates: dev: url: http://localhost:7890 username: admin password: password secrets: my-app: POSTGRES_URL: postgres://user:password@localhost:5432/db?schema=public typegraphs: python: include: &quot;**/*.py&quot; materializers: prisma: migrations_path: &quot;migrations&quot;   ","version":"Next","tagName":"h2"},{"title":"Typegate configuration‚Äã","type":1,"pageTitle":"Configuration file","url":"/docs/reference/meta-cli/configuration-file#typegate-configuration","content":" Each typegate node is configured under typegates.&lt;name&gt;. The typegate node selection is done by the --target option in the CLI.  ","version":"Next","tagName":"h2"},{"title":"Named secrets‚Äã","type":1,"pageTitle":"Configuration file","url":"/docs/reference/meta-cli/configuration-file#named-secrets","content":" Named secrets are used to configure runtimes. Their values are provided in the secrets section of the configuration file directly or indirectly using lade. Each entry in the secrets section is the set of secrets for a specific typegraph. The typegraph name is the key of the entry and the value is an object mapping each secret name to its value or vault source (see next section).  To sum up, each secret is defined in secrets.&lt;typegraph-name&gt;.&lt;secret-name&gt;.&lt;secret-value-or-source&gt;.  ","version":"Next","tagName":"h3"},{"title":"Automatic secret loading support‚Äã","type":1,"pageTitle":"Configuration file","url":"/docs/reference/meta-cli/configuration-file#automatic-secret-loading-support","content":" Lade is a secret loading tool that transparently inject environment variables from a variety of sources. It works with Fish, Bash or Zsh and currently supports Doppler, Infisical and 1Password as vault source.  To use Lade with Metatype, you can use the op://, infisical:// or doppler:// prefixes in your configuration file. It will then use the CLI of the vault to securely load the required secrets. For example:  typegates: dev: url: http://localhost:7890 username: op://VAULT_NAME/SECRET_NAME/FIELD_NAME password: infisical://app.infisical.com/PROJECT_NAME/ENV_NAME/SECRET_NAME  ","version":"Next","tagName":"h2"},{"title":"Available commands","type":0,"sectionRef":"#","url":"/docs/reference/meta-cli/available-commands","content":"","keywords":"","version":"Next"},{"title":"Managing typegraphs‚Äã","type":1,"pageTitle":"Available commands","url":"/docs/reference/meta-cli/available-commands#managing-typegraphs","content":" Command\tExample of use\tDescriptiondeploy meta deploy --target dev --file path/to/typegraph.py meta --dir folder/to/typegraphs dev --run-destructive-migrations Deploy typegraph to a typegate instance undeploy meta undeploy --target dev --typegraph logs accounting services Undeploy typegraphs by name gen meta gen mod --file path/to/typegraph.py meta gen mdk Generate script or files that are used in your typegraph typegate meta typegate --quiet Access a minimal deno CLI  info The typegate sub-command is not available on the thin version of the meta binary.  ","version":"Next","tagName":"h2"},{"title":"Troubleshooting and others‚Äã","type":1,"pageTitle":"Available commands","url":"/docs/reference/meta-cli/available-commands#troubleshooting-and-others","content":" Command\tExample of use\tDescriptiondoctor meta doctor Help troubleshoot all your installations completion meta completion meta completion --shell bash Generate shell completion (supports bash, elvish, fish, powershell, zsh) serialize meta serialize --file path/to/typegraph.py Inspect serialized version of your typegraph upgrade meta upgrade meta upgrade --version 0.3.4 Upgrade current cli  Feel free to use the --help flag if you want more information on each command and sub-command.  meta -h meta deploy -h meta gen mod -h   ","version":"Next","tagName":"h2"},{"title":"Environment variables‚Äã","type":1,"pageTitle":"Available commands","url":"/docs/reference/meta-cli/available-commands#environment-variables","content":" Name\tDescription\tDefault valueLOADER_TIMEOUT\tSet deploy timeout in seconds\t120 ","version":"Next","tagName":"h2"},{"title":"Policies","type":0,"sectionRef":"#","url":"/docs/reference/policies","content":"","keywords":"","version":"Next"},{"title":"Policy based access control (PBAC)‚Äã","type":1,"pageTitle":"Policies","url":"/docs/reference/policies#policy-based-access-control-pbac","content":" The Deno runtime enable to understand the last abstraction. Policies are a way to verify for each type whether the user is authorized or not to access it. It's a very powerful concept that can be for instance used to guarantee a given type is never accidentally exposed to the outside world.  Metatype comes with some built-in policies, but you can use the Deno runtime to define your own:  policies.public() is an alias for Policy(PureFunMat(&quot;() =&gt; true&quot;)) providing everyone open access.policies.ctx(&quot;role_value&quot;, &quot;role_field&quot;) is a companion policy for the authentication strategy you learned in the previous section. It will verify the context and give adequate access to the user.  Policies are hierarchical in the sense that the request starts with a denial, and the root functions must explicitly provide an access or not. Once access granted, any further types can either inherit or override the access. Policies evaluate in order in case multiple ones are defined.  Loading... ","version":"Next","tagName":"h2"},{"title":"Runtimes","type":0,"sectionRef":"#","url":"/docs/reference/runtimes","content":"","keywords":"","version":"Next"},{"title":"Specialized runtimes‚Äã","type":1,"pageTitle":"Runtimes","url":"/docs/reference/runtimes#specialized-runtimes","content":" This refers to any runtime embedded within typegate that performs specialized tasks.  This includes:  PrismaHTTPGraphQLRandomTemporalS3  Missing your favorite runtime? Submit your request and vote for your preferred ones here.  ","version":"Next","tagName":"h2"},{"title":"Embedded language runtimes‚Äã","type":1,"pageTitle":"Runtimes","url":"/docs/reference/runtimes#embedded-language-runtimes","content":" This type of runtime covers any runtime that uses a sandboxed programming language runtime that you can define custom logic on.  This includes:  DenoPythonWasm  ","version":"Next","tagName":"h2"},{"title":"Custom embedded runtimes‚Äã","type":1,"pageTitle":"Runtimes","url":"/docs/reference/runtimes#custom-embedded-runtimes","content":" This describes any user defined runtimes, you can write your own runtime logic and package it along with your typegraph. This type of runtime refers to any runtime that uses the materializer development kit, which can be generated from the meta gen mdk command. ","version":"Next","tagName":"h2"},{"title":"REST","type":0,"sectionRef":"#","url":"/docs/reference/rest","content":"","keywords":"","version":"Next"},{"title":"General rule‚Äã","type":1,"pageTitle":"REST","url":"/docs/reference/rest#general-rule","content":" query_type endpoint_name($param1: T1, $param2: T2, ..) { exposed(..) { f1 f2 .. } }   There is no rule in what type of query you should do most of the time as everything is up to you, however the type of query you set will define how your endpoint should be used.  In other words, depending on what query_type (query or mutation), $param1, $param2, .. will be defined from the request parameters (GET) or the request body (POST).  query: Perform a GET at TYPEGATE_URL/TG_NAME/rest/endpoint_name?param1=..&amp;param2=..mutation: Perform a POST at TYPEGATE_URL/TG_NAME/rest/endpoint_name with Content-Type set as application/json  { &quot;param1&quot;: .., &quot;param2&quot;: .., .. }   In the example above, for a local instance, the endpoint might look like:http://localhost:7890/example/rest/users?name=Bob&amp;rows=10  ","version":"Next","tagName":"h2"},{"title":"Dynamic queries‚Äã","type":1,"pageTitle":"REST","url":"/docs/reference/rest#dynamic-queries","content":" This enables/disables all non-static queries, i.e. queries whose output or side effects depend on certain parameters.  By default, dynamic is always on.  Typescript SDK Python SDK typegraph({ name: &quot;my-typegraph&quot;, dynamic: false }, (g) =&gt; { // .. });   ","version":"Next","tagName":"h2"},{"title":"Auto-generated docs‚Äã","type":1,"pageTitle":"REST","url":"/docs/reference/rest#auto-generated-docs","content":" In any case, you can always check the auto-generated documentation of the available endpoints, parameters, output shapes.  You can browse it at TYPEGATE_URL/TG_NAME/rest.  Or download the OpenAPI spec at TYPEGATE_URL/TG_NAME/rest/__schema. ","version":"Next","tagName":"h2"},{"title":"Deno/typescript","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/deno","content":"","keywords":"","version":"Next"},{"title":"Deno runtime‚Äã","type":1,"pageTitle":"Deno/typescript","url":"/docs/reference/runtimes/deno#deno-runtime","content":" The DenoRuntime allows you to run lightweight and short-lived typescript function in a sandboxed environment. Permissions can be customized per typegraph and by default only include some HTTPs domains. It's a great way to implement custom logic and functions. All typegraphs can lazily spawn a web worker and get an incredible cold-start and continuous performance thanks to the V8 engine powering Deno.  Loading...  Instead of providing the typescript code inline, we can also point to a file on disk:  # my_typegraph.py from typegraph import typegraph, Policy, t, Graph from typegraph.runtimes.deno import DenoRuntime @typegraph() def deno(g: Graph): public = Policy.public() deno = DenoRuntime() g.expose( public, add=deno.import_( t.struct({&quot;a&quot;: t.number(), &quot;b&quot;: t.number()}), t.number(), module=&quot;main.ts&quot;, # path to ts file name=&quot;doAddition&quot;, # function export from ts file to use ), )   Where main.ts looks like:  // main.ts interface AddInput { a: number; b: number; } export function doAddition({ a, b }: AddInput) { return a + b; }  ","version":"Next","tagName":"h2"},{"title":"Programmatic deployment","type":0,"sectionRef":"#","url":"/docs/reference/programmatic-deployment","content":"","keywords":"","version":"Next"},{"title":"Deploy typegraphs‚Äã","type":1,"pageTitle":"Programmatic deployment","url":"/docs/reference/programmatic-deployment#deploy-typegraphs","content":" This can be done using the tgRemove/tg_remove function. You are required to provide the configurations and also handle migrations by yourself (if any).  Typescript SDK Python SDK import { Policy, t, typegraph } from &quot;@typegraph/sdk/index.js&quot;; import { DenoRuntime } from &quot;@typegraph/sdk/runtimes/deno.js&quot;; import * as path from &quot;path&quot;; import { wit_utils } from &quot;@typegraph/sdk/wit.js&quot;; import { BasicAuth, tgDeploy } from &quot;@typegraph/sdk/tg_deploy.js&quot;; // Your typegraph const tg = await typegraph(&quot;example&quot;, (g) =&gt; { const deno = new DenoRuntime(); const pub = Policy.public(); g.expose({ sayHello: deno.import( t.struct({ name: t.string() }), t.string(), { module: &quot;path/to/say_hello.ts&quot;, name: &quot;sayHello&quot; }, ), }, pub); }); // Configure your deployment const artifactsConfig = { prismaMigration: { globalAction: { create: true, reset: true, // allow destructive migrations }, migrationDir: path.join(&quot;prisma-migrations&quot;, tg.name), }, // dir: &quot;.&quot; // artifacts are resolved relative to this path }; const config = { baseUrl: &quot;&lt;TYPEGATE_URL&gt;&quot;, auth: new BasicAuth(&quot;&lt;USERNAME&gt;&quot;, &quot;&lt;PASSWORD&gt;&quot;);, secrets: { POSTGRES: &quot;&lt;DB_URL&gt;&quot; }, artifactsConfig, }; // Deploy to typegate tgDeploy(tg, config).then(({ typegate }) =&gt; { const selection = typegate?.data?.addTypegraph; if (selection) { const { migrations, messages } = selection; migrations.map(({ runtime, migrations }) =&gt; { // Convention, however if migrationDir is absolute then you might want to use that instead // cwd + tg_name const baseDir = artifactsConfig.prismaMigration.migrationDir; // cwd + tg_name + runtime_name const fullPath = path.join(baseDir, runtime); wit_utils.unpackTarb64(migrations, fullPath); console.log(`Unpacked migrations at ${fullPath}`); }); } else { throw new Error(JSON.stringify(typegate)); } }) .catch(console.error);   ","version":"Next","tagName":"h2"},{"title":"Undeploy typegraphs‚Äã","type":1,"pageTitle":"Programmatic deployment","url":"/docs/reference/programmatic-deployment#undeploy-typegraphs","content":" Similarly to the above, you can undeploy typegraphs using the tgRemove/tg_remove function.  Typescript SDK Python SDK // .. import { BasicAuth, tgDeploy } from &quot;@typegraph/sdk/tg_deploy.js&quot;; // Your typegraph const tg = await typegraph(&quot;example&quot;, (g) =&gt; { // .. }); const { typegate } = await tgRemove(tg, { baseUrl: &quot;&lt;TYPEGATE_URL&gt;&quot;, auth: new BasicAuth(&quot;&lt;USERNAME&gt;&quot;, &quot;&lt;PASSWORD&gt;&quot;), }); // Response from typegate console.log(typegate);  ","version":"Next","tagName":"h2"},{"title":"GraphQL","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/graphql","content":"","keywords":"","version":"Next"},{"title":"GraphQL runtime‚Äã","type":1,"pageTitle":"GraphQL","url":"/docs/reference/runtimes/graphql#graphql-runtime","content":" While you can store users in the same database, it's wiser to avoid data duplication and re-use your service for user management available at GraphQLZero endpoint. Let's introduce the GraphQL runtime that allows remote GraphQL queries.  Update typegraph.py with the highlighted lines below:  Loading...  Again, a few interesting things happened here:  No migration has been run. The field user comes from another runtime and doesn't exist in the database. The typegate will orchestrate the query execution in all runtimes and minimize the work done.The from_parent rule automatically fills the input type with the parent field named uid. The g(¬∑) rule allows making named references to another type and avoids circular references.  Other type enforcement rules also exist:  from_secret(key) to fill the input type with the secret in the TG_[typegraph name]_[key] formatfrom_context(¬∑) to fill the input type with content from the request context, such as JSON Web Token (JWT), etc.set(x) to fill the input type with content x  You should now start to see the power provided by Metatype and might wonder how to integrate it step by step with your existing systems. Writing all those types by hand is tedious and error-prone. The next section will show you how to generate types from existing sources. ","version":"Next","tagName":"h2"},{"title":"HTTP/REST","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/http","content":"","keywords":"","version":"Next"},{"title":"HTTP Runtime‚Äã","type":1,"pageTitle":"HTTP/REST","url":"/docs/reference/runtimes/http#http-runtime","content":" The HTTPRuntime allows your typegraphs to access external REST APIs.  Common use cases (but not limited to):  Enable consuming one or more REST APIs through the same interfaceProgrammatically generate typegraphs from an existing openapi specs or similar  Example:  Loading...  ","version":"Next","tagName":"h2"},{"title":"Verbs‚Äã","type":1,"pageTitle":"HTTP/REST","url":"/docs/reference/runtimes/http#verbs","content":" This runtime supports GET, POST, PUT, DELETE http verbs.  In most cases, queries are not limited to a simple query parameter or use the default application/json content type. You can assign what parts of your request description each field in the input struct belongs to.  In the example bellow, this endpoint corresponds to POST &lt;API_URL&gt;/submit_user?form_type=.. with a body requiring the fields:pseudo, age and with header accept set as application/json.  Typescript SDK Python SDK // .. const remote = new HttpRuntime(&quot;&lt;API_URL&gt;&quot;); g.expose({ add_user: remote.post( // define your input/output t.struct( { id: t.uuid(), username: t.float(), years_lived: t.integer(), form_type: t.integer() }, ), t.struct({ message: t.string() }), { path: &quot;/submit_user&quot;, // specify where each field in your input should be associated with bodyFields: [&quot;username&quot;, &quot;years_lived&quot;], queryFields: [&quot;form_type&quot;], // you may want to rename a few fields // if you are using your own naming conventions or reusing types renameFields: [ [&quot;username&quot;, &quot;pseudo&quot;], [&quot;years_lived&quot;, &quot;age&quot;], ], contentType: &quot;multipart/form-data&quot;, } )}, pub); // ..  ","version":"Next","tagName":"h2"},{"title":"Random","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/random","content":"","keywords":"","version":"Next"},{"title":"Random runtime‚Äã","type":1,"pageTitle":"Random","url":"/docs/reference/runtimes/random#random-runtime","content":" The Random runtime allows you to produce structured datas randomly.  One use case is to use this runtime as way of testing, for example you can rapidly draft a small backend that produces structured data for your frontend application.  The seed parameter ensures repeatability if set.  Loading...  Another use case is to inject random values to a function input  Loading...  ","version":"Next","tagName":"h2"},{"title":"Generators‚Äã","type":1,"pageTitle":"Random","url":"/docs/reference/runtimes/random#generators","content":" Here is a list of some standard generators that you can attach to your type, if unspecifed, it will default on generating any values that the associated type can hold.  Type\tGenerator configt.string()\tname, address, postcode, country, email, uuid, uri, hostname, date, time, phone, ean t.integer(), t.float()\tage  Typescript SDK Python SDK const user = t.struct( { id: t.uuid(), // random uuid name: t.string({}, { config: { gen: &quot;name&quot; } }), // random name age: t.integer({}, { config: { gen: &quot;age&quot;, type: &quot;adult&quot; } }), // type: &quot;child&quot;, &quot;adult&quot; email: t.email(), address: t.struct( { street: t.string({}, { config: { gen: &quot;address&quot; } }), city: t.string({}, { config: { gen: &quot;city&quot; } }), postcode: t.string({}, { config: { gen: &quot;postcode&quot;} }), country: t.string({}, { config: { gen: &quot;country&quot;, full: true } }), } ), } )  ","version":"Next","tagName":"h2"},{"title":"Python","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/python","content":"","keywords":"","version":"Next"},{"title":"Python Runtime‚Äã","type":1,"pageTitle":"Python","url":"/docs/reference/runtimes/python#python-runtime","content":" The PythonRuntime allows you to run short-lived code on a Python virtual machine.  # my_typegraph.py from typegraph import typegraph, Policy, t, Graph from typegraph.runtimes.deno import PythonRuntime @typegraph() def example_python(g: Graph): public = Policy.public() python = PythonRuntime() g.expose( public, add=t.func( t.struct({&quot;a&quot;: t.integer(), &quot;b&quot;: t.integer()}), t.integer(), # we can provide the code inline using lambdas python.from_lambda(lambda x: x[&quot;a&quot;] + x[&quot;b&quot;]), ), sayHello=python.import_( t.struct({&quot;name&quot;: t.string()}), t.string(), # point to pythoin a file on disc module=&quot;hello.py&quot;, name=&quot;say_hello&quot; ), )   # hello.py def say_hello(x: any): return f&quot;Hello {x[&quot;name&quot;]}&quot;  ","version":"Next","tagName":"h2"},{"title":"S3","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/s3","content":"","keywords":"","version":"Next"},{"title":"Temporal","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/temporal","content":"","keywords":"","version":"Next"},{"title":"Temporal runtime‚Äã","type":1,"pageTitle":"Temporal","url":"/docs/reference/runtimes/temporal#temporal-runtime","content":" Temporal is an open-source durable execution engine that can be used to develop workflows that are long lived and failure resistant. Common use cases include:  Implementing multi-step, complicated transactionaly business logic.Guaranteed event processing.Control planes for driving processes.  The TemporalRuntime in Metatype can be used to directly start, query, signal and describe workflows on your temporal cluster. Refer to the temporal docs for more on what you can accomplish with this tech.  An interesting use case is to dynamically describe the operations you want to expose, this enables reusing typegraphs accross different projects or even building a small framework around it.  Here is a simple example of a typegraph that takes some value from an environment variable.  Loading... ","version":"Next","tagName":"h2"},{"title":"S3 runtime‚Äã","type":1,"pageTitle":"S3","url":"/docs/reference/runtimes/s3#s3-runtime","content":" The S3Runtime can be used to interact with object storage APIs that are S3 compatible. Object storages like S3 are commonly used to cover app needs around large blob data like uploading and serving images. Most object storage services provide S3 compatible APIs including the open-source MinIO engine which you can run locally for development.  For the following example, you'll need to setup your S3 compatible store first. The following snippet can get you started using minio on docker compose:  services: minio: image: bitnami/minio:2022 platform: linux/amd64 restart: always ports: - &quot;9000:9000&quot; - &quot;9001:9001&quot; environment: MINIO_REGION_NAME: local MINIO_ROOT_USER: minio MINIO_ROOT_PASSWORD: password MINIO_DEFAULT_BUCKETS: &quot;bucket:none&quot;   We then provide the following secrets to our typegraph through metatype.yml.  typegates: dev: secrets: # .. # replace &quot;files-upload&quot; by the name of your typegraph files-upload: S3_HOST: http://localhost:9000 S3_REGION: local S3_ACCESS_KEY: minio S3_SECRET_KEY: password S3_PATH_STYLE: true   Our typegraph will then look something like:  Loading...  Peruse the reference on the S3Runtime for more information. ","version":"Next","tagName":"h2"},{"title":"Wasm","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/wasm","content":"","keywords":"","version":"Next"},{"title":"Prisma","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/prisma","content":"","keywords":"","version":"Next"},{"title":"Prisma runtime‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#prisma-runtime","content":" Prisma is a &quot;Next-generation Node.js and Typescript ORM&quot; supporting PostgreSQL, MySQL/MariaDB, SQLite, MongoDB, CockroachDB and Microsoft SQL Server. It is one of the main runtimes provided by Metatype and doesn't require any additional installation.  Go ahead and update typegraph.py with the highlighted lines below:  Loading...  A few things to note on the changes:  You can import runtimes from typegraph.runtime.Y or typegraph.providers.X.runtimes.Y for non-core providers.The config method allows specifying runtime specific attributes. In this case, id shall be automatically set and incremented by the database.Types get generated names unless you manually specify them. You can find the exact names in the playground documentation. Here you want to have a human friendly name as it will also be the name of the table in your database.Runtimes often come with some sugar syntax to generate types and avoid manipulating functions directly. A corresponding declaration would have looked like this:    In order to use the Prisma runtime, you need to add a new environment variable. Runtimes don't take raw secrets, but instead a secret key used to look up environment variables named under the format TG_[typegraph name]_[key]. You can either add it in your metatype.yml (recommended) or in your compose.yml.  $ cat metatype.yml typegates: dev: # .. secrets: database POSTGRES_CONN: postgresql://postgres:password@postgres:5432/db $ meta dev   And now, you can iteratively continue to improve your interface, running migrations and having data stored inside your database.  ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#usage","content":" with TypeGraph(&quot;prisma-runtime-example&quot;) as g: db = PrismaRuntime(&quot;main_db&quot;, &quot;DB_CONNECTION&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email(), } ) g.expose( createUser=db.create(user).add_policy(public) )   ","version":"Next","tagName":"h2"},{"title":"Raw query‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#raw-query","content":" Generate a raw SQL query operation on the runtime  db = PrismaRuntime(&quot;my-app&quot;, &quot;POSTGRES&quot;) g.expose( countUsers=db.raw_query( &quot;SELECT COUNT(*) as total FROM User&quot;, t.struct({}), t.list(t.struct({&quot;total&quot;: t.integer()})) ) )   Generate a raw SQL query operation without return  db = PrismaRuntime(&quot;my-app&quot;, &quot;POSTGRES&quot;) g.expose( setActive=db.raw_execute( &quot;UPDATE User SET active = TRUE WHERE id=${id}&quot;, t.struct({&quot;id&quot;: t.uuid()}), effect=effects.update() ), )   ","version":"Next","tagName":"h3"},{"title":"Models‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#models","content":" Any t.struct that is passed to a generator of a PrismaRuntimedefines a model. Models must have an ID field specified by the &quot;id&quot; config.  Here is the list of all the available configs for model fields:  Config\tEffectid\tdefines the field ID for the model (a.k.a. primary key) auto\tthe value of this field can be auto generated; supported for t.integer() (auto-increment) and t.uuid() unique\tmake this field unique among all instances of the model  ","version":"Next","tagName":"h2"},{"title":"Relationships‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#relationships","content":" Relationship fields must be defined on both sides of the relationship. A relationship is always defined for t.struct types and t.optional ort.list of t.struct.  Relationships can also be defined implicitly using the link instance method of PrismaRuntime.  runtime = PrismaRuntime(&quot;example&quot;, &quot;POSTGRES&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email().config(&quot;unique&quot;), &quot;posts&quot;: t.list(g(&quot;Post&quot;)), } ).named(&quot;User&quot;) post = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;title&quot;: t.string(), &quot;author&quot;: g(&quot;User&quot;), } ).named(&quot;Post&quot;)   The PrismaRuntime supports two kinds of relationship between models.  ","version":"Next","tagName":"h2"},{"title":"One-to-one relationships‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#one-to-one-relationships","content":" A one-to-one relationship must be in one of these two variants.  Cardinality\tField type in Model1\tField type in Model21..1 ‚Üî 0..1\tg(&quot;Model2&quot;)\tg(&quot;Model1&quot;).optional() 0..1 ‚Üî 0..1\tg(&quot;Model2&quot;).optional()\tg(&quot;Model1&quot;).optional()  For the optional (0..1 ‚Üî 0..1) one-to-one relationship, you need to indicate on which field/model the foreign key will be by:  wrapping the type in a runtime.link(.) with fkey=True:runtime.link(g(&quot;Model2&quot;).optional(), fkey=True); or adding .config(&quot;unique&quot;): g(&quot;Model2&quot;).optional().config(&quot;unique&quot;).  ","version":"Next","tagName":"h3"},{"title":"One-to-many relationships‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#one-to-many-relationships","content":" A one-to-many relationship must be in one of these two variants.  Cardinality\tField type in Model1\tField type in Model21..1 ‚Üî 0..n\tg(&quot;Model2&quot;)\tt.list(g(&quot;Model1&quot;)) 0..1 ‚Üî 0..n\tg(&quot;Model2&quot;).optional()\tt.list(g(&quot;Model1&quot;))  ","version":"Next","tagName":"h3"},{"title":"Many-to-many relationships‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#many-to-many-relationships","content":" Many-to-many relationships must be modelled explicitly using a join model.  ","version":"Next","tagName":"h3"},{"title":"Link‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#link","content":" Explicitly declare a relationship between models. The return value of this function shall be the type of a property of a t.struct that defines a model. If the other end of the relationship is also defined using link, both links must have the same name.  runtime = PrismaRuntime(&quot;example&quot;, &quot;POSTGRES&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email().config(&quot;unique&quot;), &quot;posts&quot;: runtime.link(t.list(g(&quot;Post&quot;)), &quot;postAuthor&quot;), } ).named(&quot;User&quot;) post = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;title&quot;: t.string(), &quot;author&quot;: runtime.link(g(&quot;User&quot;), &quot;postAuthor&quot;), } ).named(&quot;Post&quot;)   ","version":"Next","tagName":"h3"},{"title":"Generators‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#generators","content":" Generators are instance methods of PrismaRuntime that can be used to generate a t.func that represents a specific operation on a specific model of the runtime. They match to the model queries defined for theprisma client API. for the type of the input t.struct and the return type.  Example:  with TypeGraph(&quot;prisma-runtime-example&quot;) as g: db = PrismaRuntime(&quot;main_db&quot;, &quot;DB_CONNECTION&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email(), } ) g.expose( createUser=db.create(user).add_policy(public), findUser=db.find(user).add_policy(public), findManyUsers=db.find_many(user).add_policy(public), )   Here is a list of all available generators:  find_uniquefind_firstfind_manycreateupdateupsertdeletedelete_many  ","version":"Next","tagName":"h2"},{"title":"Dealing with migrations‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#dealing-with-migrations","content":" Migrations are basically blueprints that ensure that your local database and remote database both have the same schema. Migration files are generated as modifications are made in your typegraph as you deploy.  meta cli offers various ways to deal with failing migrations. In general, you will be required manually edit the SQL changes that made your migration fails, most of the time failing migrations are related to columns/tables that were removed, renamed or added.  However, if you wish to ignore failing migrations (eg. in a testing environment), you can use the --run-destructive-migrations flag, it will reset your database schema. ","version":"Next","tagName":"h2"},{"title":"Typegate","type":0,"sectionRef":"#","url":"/docs/reference/typegate","content":"","keywords":"","version":"Next"},{"title":"Using Embedded Typegate (Recommended)‚Äã","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#using-embedded-typegate-recommended","content":" The Meta_CLI comes with an embedded typegate packaged inside it. A typegate instance is where you deploy your typegraphs where any logic written in them is exposed via an HTTP or GraphQL endpoints. You can run an embedded typegate node from the terminal, but you first need to set a couple of environment variables which are needed to instantiate the typegate node.  Set the tg_admin_password and tg_secret environment variables. You can use the following command to configure a sample value for the variables and test the embedded typegate.  // set up tg_secret and tg_admin_password export tg_secret=a4lNi0PbEItlFZbus1oeH/+wyIxi9uH6TpL8AIqIaMBNvp7SESmuUBbfUwC0prxhGhZqHw8vMDYZAGMhSZ4fLw== tg_admin_password=password   If you have not installed Meta_CLI or you have downloaded the thin version, you can check this installation guide of the CLI.  Everything is setup to run the embedded typegate. Just run the following command below.  meta typegate   The typegate instance runs on port 7890 by default. You can check if the typegate node is running by accessing http://localhost:7890 in your browser.  ","version":"Next","tagName":"h3"},{"title":"Using Docker‚Äã","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#using-docker","content":" Install Docker and use the following compose.yml to launch a typegate node. For multi-instance production workloads, Redis and an S3 object store provider are required but the typegate will run using in-memory stores if no SYNC_* environment variable is detected. More details can be found here. In practice you might also want to add a database or other systems that the typegate can connect to.  services: typegate: image: ghcr.io/metatypedev/typegate:latest ports: - &quot;7890:7890&quot; extra_hosts: - &quot;host.docker.internal:host-gateway&quot; environment: # only for dev, generate secure values for production TG_SECRET: &quot;a4lNi0PbEItlFZbus1oeH/+wyIxi9uH6TpL8AIqIaMBNvp7SESmuUBbfUwC0prxhGhZqHw8vMDYZAGMhSZ4fLw==&quot; TG_ADMIN_PASSWORD: password DEBUG: &quot;true&quot;   # launch the containers docker compose up --detach # watch the typegate logs docker compose logs typegate --follow   ","version":"Next","tagName":"h3"},{"title":"Internal APIs‚Äã","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#internal-apis","content":" Most of the internal APIs are still unstable, and may change without notice. If you still want to experiment with them, you can use the GraphQL introspection to discover them.  /typegate/prisma-migration  The typegate nodes - or typegates - are the central components of the ecosystems. They build and type check typegraphs, and expose them through a HTTP/GraphQL interface. They enforce the type safety of the data flows, connect to all the runtimes and orchestrate the execution of incoming requests.  ","version":"Next","tagName":"h2"},{"title":"Request lifecycle‚Äã","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#request-lifecycle","content":" When a new request fires a trigger, the typegate orchestrates the following stages:  extract the secure request context from custom authentication or JSON Web Token (JWT)retrieve cached execution plan or compute a new one traverse the typegraph to create a DAG of the required typesoptimize the DAG to reduce the number of calls to the runtimespre-compute all structural elements and data resolutions execute the plan type check the argumentsverify lazily policies on the needrun the DAG executionenforce the rate-limitingtype check the response manage metadata of the request  ","version":"Next","tagName":"h2"},{"title":"HTTP/GraphQL interface‚Äã","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#httpgraphql-interface","content":" For now, the typegate nodes are only accessible through HTTP/1.1 and HTTP/2. More protocols could be supported in the future. Typegates expose a GraphQL interface which is the result of a typegraph projected onto corresponding GraphQL types. While this reduces the type safety of the data flowing, it makes more interoperable thanks to the many high-quality and well-known GraphQL tooling already available. The underlying types are also exposed in order for API clients to verify the underlying types.  GraphQL, being a query language, offers a great asset for Metatype's philosophy:  Efficient querying: the client can specify exactly what data it needs, reducing the amount of over- or under-fetchingFlexibility: allows for retrieving multiple resources in a single request, unlike REST, which often requires multiple onesTyping: GraphQL has a built-in type system that allows for better documentation and stronger validation of the requestsImproved tooling: tools and libraries around GraphQL are rapidly growing and great a development experience  ","version":"Next","tagName":"h2"},{"title":"Configuration‚Äã","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#configuration","content":" ","version":"Next","tagName":"h2"},{"title":"Environment variables.‚Äã","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#environment-variables","content":" The following environment variables can be used to configure the typegate. SYNC_* variables have special semantics which you can read about here.  Environment variables\tDesc\tDefaultHOSTNAME\tHostname that typegate is deployed on.\tgetHostname() result. TG_PORT\tTcp port to serve typegate APIs at.\t7890 TG_ADMIN_PASSWORD\tPassword use by the CLI/SDK to configure the typegate.\tRequired TG_SECRET\tSymmetric key used to encrypt cookies and other things.\tRequired. TMP_DIR\tTop-level temporary directory.\t$PWD/tmp DEBUG\tEnable debug output and other development paths.\tfalse TIMER_MAX_TIMEOUT_MS\tTimeout for custom runtime functions and other proccesses.\t3000 TIMER_POLICY_EVAL_RETRIES\tNumber of retries when evaluating policies that have timed out\t1 TIMER_DESTROY_RESOURCES\tForce abort and attempt to restart operations that did not respond after multiple retries\ttrue JWT_MAX_DURATION_SEC\tThe lifetime of generated JWT access tokens.\t30 * 24 * 3600 JWT_REFRESH_DURATION_SEC\tThe lifetime of generated JWT refresh tokens.\t5 * 60 SENTRY_DSN SENTRY_SAMPLE_RATE 1 SENTRY_TRACES_SAMPLE_RATE 1 TRUST_PROXY\tWhether to accept proxy headers when resolving request contexts.\tfalse TRUST_HEADER_IP\tThe header key on which to resolve request origin addresses.\tX-Forwarded-For DENO_V8_FLAGS\tFlags for tuning the v8 javascript engine. Use the --help flag here to see what options are available. SYNC_REDIS_URL\tURL to the Redis database. Must include the database number. SYNC_REDIS_PASSWORD\tRedis database password, can be included in SYNC_REDIS_URL. SYNC_S3_HOST\tHostname of the S3 store. SYNC_S3_REGION\tS3 region. SYNC_S3_ACCESS_KEY\tAccess key for the S3 store credentials. SYNC_S3_SECRET_KEY\tAccess key secret for the S3 store credentials. SYNC_S3_PATH_STYLE\ttrue or false, force path style if true. SYNC_S3_BUCKET\tThe bucket to be used for the system (dedicated).\t ","version":"Next","tagName":"h3"},{"title":"Wasm runtime‚Äã","type":1,"pageTitle":"Wasm","url":"/docs/reference/runtimes/wasm#wasm-runtime","content":" The Wasm runtime enables the execution of functions authored in any language that can be compiled into WebAssembly and that follows the component model.  Common use cases:  Integrating an existing WebAssembly componentBuilding language-agnostic services  ","version":"Next","tagName":"h2"},{"title":"Example‚Äã","type":1,"pageTitle":"Wasm","url":"/docs/reference/runtimes/wasm#example","content":" Here is a simple wit component description using wit IDL that exports the add function.  package example:host; world host { export add: func(a: u32, b: u32) -&gt; u32; }   In your typegraph:  Typescript SDK Python SDK import { Policy, t, typegraph } from &quot;@typegraph/sdk&quot;; import { WasmRuntime } from &quot;@typegraph/sdk/runtimes/wasm.js&quot;; typegraph(&quot;example&quot;, (g) =&gt; { const pub = Policy.public(); const wasm = WasmRuntime.reflected(&quot;path/to/your-compiled-component.wasm&quot;); g.expose({ add: wasm.fromExport( t.struct({ a: t.integer(), b: t.integer() }), t.integer(), { func: &quot;add&quot;, // exported function }, ).withPolicy(pub), }); });   ","version":"Next","tagName":"h2"},{"title":"Wit to Typegraph types‚Äã","type":1,"pageTitle":"Wasm","url":"/docs/reference/runtimes/wasm#wit-to-typegraph-types","content":" Wit ensures that you have statically typed values backed directly in your component. You can refer to the correspondence table bellow in how the input/output values are shaped in your typegraph.  wit\ttypegraph\tExample valuesstring\tt.string(), t.uuid()\t&quot;Hello world&quot;, &quot;H&quot;, .. u8, u16, u32, u64, s8, s16, s32, s64\tt.integer(), t.float()\t1, 2, 0, .. f32, f64\tt.float()\t3.14, 100, 2, .. char\tt.string() (truncated), t.integer() (truncated as u8), t.float() (truncated as u8)\t&quot;A&quot;, 65, 65.0, .. option&lt;T&gt;\t&lt;T&gt;.optional()\tnull, &quot;hello world&quot;, .. list&lt;T&gt;\tt.list(&lt;T&gt;)\t[&quot;one&quot;, &quot;two&quot; ], [1, 2], .. tuple&lt;T1, T2, ..&gt;\tt.list(t.enum([t1, t2, ..]))\t[1, &quot;one&quot;], [2, &quot;two&quot;], .. enum example { one, two }\tt.enum([&quot;one&quot;, &quot;two&quot;])\t&quot;one&quot;, &quot;two&quot; variant example { one(string), two }\tt.struct({ &quot;tag&quot;: t.enum([&quot;one&quot;, &quot;two&quot;]), &quot;value&quot;: t.string().optional() )\t{ &quot;tag&quot;: &quot;two&quot;, &quot;value&quot;: null } record example { id: string, description: option&lt;string&gt; }\tt.struct({ &quot;id&quot;: t.integer(), &quot;description&quot;: t.string().optional() )\t{ &quot;id&quot;: 123, &quot;description&quot;: &quot;some text&quot;} flags example { read, write, delete }\tt.list(t.enum([&quot;read&quot;, &quot;write&quot;, &quot;delete&quot;]))\t[&quot;read&quot;], [&quot;read&quot;, &quot;write&quot;, &quot;delete&quot;], .. ","version":"Next","tagName":"h2"},{"title":"Authentication","type":0,"sectionRef":"#","url":"/docs/reference/typegate/authentication","content":"","keywords":"","version":"Next"},{"title":"Basic authentication‚Äã","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#basic-authentication","content":" Basic authentication is the simplest way to authenticate requests. It is done by sending a base64 encoded string of your username and password in the authorization header. Recall that base64 encoding is not encryption and can be easily reversed, thus the traffic must be encrypted with SSL/TLS when using basic authentication as your password will otherwise be visible.  Components\tValuesSecrets\tBASIC_[username]=password Header\tAuthorization: Basic base64(username:password) Context\t{ username }  Loading...  ","version":"Next","tagName":"h2"},{"title":"JWT authentication‚Äã","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#jwt-authentication","content":" A more secure way to authenticate requests is to use JSON Web Tokens. The context of a user is signed with a secret key and the typegate will verify the signature to ensure the context has not been tampered with. The JWT is then sent in the authorization header.  The JWT is usually generated by an external identity provider (IdP) such as Keycloak or Auth0 and limited in time. The typegate will check that the exp (expiration time) and nbf (not before) are valid if they exist in the context. The logic of refreshing expired tokens is left to the user or the IdP client library being used.  The typegate supports the most frequently used algorithms for signing the JWT and can be imported as using &quot;jwk&quot;, &quot;raw&quot;, &quot;pkcs8&quot; or &quot;spki&quot; formats (see SubtleCrypto documentation). For instance, an asymmetric key pair can be generated with the following command:  const keys = await crypto.subtle.generateKey( { name: &quot;ECDSA&quot;, namedCurve: &quot;P-384&quot; }, true, [&quot;sign&quot;, &quot;verify&quot;] ); const publicKey = await crypto.subtle.exportKey(&quot;jwk&quot;, keys.publicKey); // save keys.privateKey for later use console.log(JSON.stringify(publicKey)); // in typegraph: Auth.jwt(&quot;keycloak&quot;, &quot;jwk&quot;, {&quot;name&quot;: &quot;ECDSA&quot;, &quot;namedCurve&quot;: &quot;P-384&quot;})   Even though, asymmetric encryption is recommended, HMAC-SHA256 is so commonly used that an alias is provided for it.  Components\tValuesSecrets\t[authentication]_JWT=secret Header\tAuthorization: Bearer token Context\t{ your_own_content }  Loading...  Note that for the sake of the demo, the token has no expiration time. Tokens should always be shorted lived and refreshed frequently to reduce the risk of unexpected access.  ","version":"Next","tagName":"h2"},{"title":"OAuth2 authorization‚Äã","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#oauth2-authorization","content":" OAuth2 allows a user to grant limited access to their resources on one site, to another site, without having to expose their credentials. It is commonly used when the typegate needed to access restricted information in third-parties such as Google or GitHub.  Most of the time, the OAuth2 is managed by your identity provider and relies on the JWT authentication as explained above. However the typegate provides a simple way to handle the OAuth2 flow without IdP or when the system should be lightweight.  Components\tValuesSecrets\t[authentication]_CLIENT_ID=client_id, [authentication]_CLIENT_SECRET=client_secret Header\tAuthorization: Bearer token Context\t{ content_from_your_idp }  ","version":"Next","tagName":"h2"},{"title":"Take flow‚Äã","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#take-flow","content":" Redirect the user to https://[typegate].metatype.cloud/[typegraph]/auth/[authentication]?redirect_uri=https://your-website.com/login and the OAuth2 starts for the user When the user has completed the flow, the typegate will redirect the user to https://your-website.com/login and you can &quot;take&quot; the token from the typegate as follows. This can be only done once and is limited in time:  const take = await fetch( &quot;https://[typegate].metatype.cloud/[typegraph]/auth/take&quot;, { credentials: &quot;include&quot;, } ); const { token } = await take.json();   The token can then be used as JWT in the Authorization header of your requests, and the response of the typegate will contain a header Next-Authorization. When this header is present, the value should be used in follow-up calls (value will be empty if the authentication has expired).    Loading...  ","version":"Next","tagName":"h3"},{"title":"OpenID Connect‚Äã","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#openid-connect","content":" OpenID Connect is an authentication layer on top of OAuth2. It is used to verify the identity of the user and retrieve basic information about them. You can add openid to the OAuth2 scope and you will receive an id_token in the response. The id_token is a JWT that contains the user's information and is signed by the IdP.  ","version":"Next","tagName":"h3"},{"title":"Embedded providers‚Äã","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#embedded-providers","content":" Frequent OAuth2 providers are embedded and can be directly used in the typegraph.  from typegraph.graph.auth import oauth2 oauth2.github(&quot;openid profile email&quot;)   The whole list is available here. ","version":"Next","tagName":"h3"},{"title":"CORS","type":0,"sectionRef":"#","url":"/docs/reference/typegate/cors","content":"CORS Cross-Origin Resource Sharing (CORS) is a mechanism that allows or denies cross-origin requests in the browser. It prevents websites that you've not explicitly allowed from using your API. Note that it doesn't protect non-browser clients like server side code or a mobile app from using your typegraphs, only browsers implements the CORS mechanism. More details can be found here. Typescript SDK Python SDK Loading... If your browser support well CORS, you should the following error if you try to run the interactive demo. { &quot;errors&quot;: [ { &quot;message&quot;: &quot;NetworkError when attempting to fetch resource.&quot;, &quot;stack&quot;: &quot;&quot; } ] } Look in the network tab of your browser inspect tools to see the error proper. By the way, there is a hidden cors header in all interactive demos you have met so far: # .. Cors(allow_origin=[&quot;https://metatype.dev&quot;, &quot;http://localhost:3000&quot;]) # .. ","keywords":"","version":"Next"},{"title":"Rate limiting","type":0,"sectionRef":"#","url":"/docs/reference/typegate/rate-limiting","content":"Rate limiting The rate limiting algorithm works as follows: each function type can either count the # of calls it gets or the # of results returned rate_calls=Falseeach function type can have a weight rate_weight=1each request is identified by its IP or by one value of its context if set context_identifiera single query can score a maximum of query_limitmultiple queries can sum up to window_limit in a window_sec windowwhen there is multiple typegates (N), you can improve performance by avoiding score synchronizing while the typegate has not reached local_excess: the real maximum score is thus window_limit + min(local_excess, query_limit) * N Loading... Playing with the above should allow you to quickly hit the limits.","keywords":"","version":"Next"},{"title":"Synchronization","type":0,"sectionRef":"#","url":"/docs/reference/typegate/synchronization","content":"","keywords":"","version":"Next"},{"title":"System setup‚Äã","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#system-setup","content":" To enable multiple typegate instance support, the system need the following services:  Service\tRoleLoad balancer\tShare the loads accross the different typegate instances Redis database\tUsed for synchronization between typegate instances S3 storage\tStore all the shared files/artifacts for the typegate instances Typegate instances\tObvious    ","version":"Next","tagName":"h2"},{"title":"Load balancer‚Äã","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#load-balancer","content":" The setup does not require a specific load balancer software/hardware. Any load balancer can do the job.  ","version":"Next","tagName":"h3"},{"title":"Redis database‚Äã","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#redis-database","content":" A single redis instance can be shared by multiple systems, configured with different database numbers.  ","version":"Next","tagName":"h3"},{"title":"S3 storage‚Äã","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#s3-storage","content":" Any S3-compatible object store is supported for the file/artifact storage.  One S3 storage might be shared by multiple systems. However, each system must be configured to use its own dedicated bucket.  ","version":"Next","tagName":"h3"},{"title":"Typegate instances‚Äã","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#typegate-instances","content":" The typegate instances are configured with environment variables. All the instances of the system must share the same value for the synchronization variables.  See configuration for details.  ","version":"Next","tagName":"h3"},{"title":"Typegate configuration‚Äã","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#typegate-configuration","content":" The typegate instances that at the core of the system must share the configuration variables.  Synchronization variable names start with SYNC_.  warning If no SYNC_* variable is present, the typegate will run in the default single instance mode.The typegate will fail to start if any of the SYNC_* variables is present and some required SYNC_* variable is missing.  Variable\tDescriptionSYNC_REDIS_URL (Required)\tURL to the Redis database. Must include the database number. SYNC_REDIS_PASSWORD (Optional)\tRedis database password, can be included in SYNC_REDIS_URL; SYNC_S3_HOST (Required)\tHostname of the S3 store; SYNC_S3_REGION (Required)\tS3 region; SYNC_S3_ACCESS_KEY (Required)\tAccess key for the S3 store credentials; SYNC_S3_SECRET_KEY (Required)\tAccess key secret for the S3 store credentials; SYNC_S3_PATH_STYLE (Optional)\ttrue or false, force path style if true. SYNC_S3_BUCKET (Required)\tThe bucket to be used for the system (dedicated).  ","version":"Next","tagName":"h2"},{"title":"Synchronized mode features‚Äã","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#synchronized-mode-features","content":" Sharing typegraphs accross multiple typegate instancesHistory (WIP) ","version":"Next","tagName":"h2"},{"title":"Functions","type":0,"sectionRef":"#","url":"/docs/reference/types/functions","content":"","keywords":"","version":"Next"},{"title":"Effects‚Äã","type":1,"pageTitle":"Functions","url":"/docs/reference/types/functions#effects","content":" Effects are a property of functions and help categorization what happens to data when it gets transformed. Although they are similar to REST verbs and SQL statements, there is no direct one-to-one mapping.  Effects\tREST verbs\tSQL statementsnone\tGET\tSELECT create\tPOST\tINSERT update\tPUT/PATCH\tUPDATE upsert\tPUT\tINSERT ON CONFLICT delete\tDELETE\tDELETE  They provide hints to the typegates for the query orchestration by splitting the queries and mutations. For example, the create effect is exposed as a mutation. They also allow setting different policies based on them, that's for the next page. ","version":"Next","tagName":"h2"},{"title":"Typegraph","type":0,"sectionRef":"#","url":"/docs/reference/typegraph","content":"","keywords":"","version":"Next"},{"title":"SDKs‚Äã","type":1,"pageTitle":"Typegraph","url":"/docs/reference/typegraph#sdks","content":" You can author typegraphs using one of the SDKs available.  Typescript SDK Python SDK Install the @typegraph/sdk package from npm using your preferred package manager and runtime. The SDK requires Node 16+ with Typescript 4.7+, Deno 1.28+ or Bun 1+. # using pnpm pnpm add @typegraph/sdk # using npm npm install @typegraph/sdk # using yarn yarn add @typegraph/sdk # using Deno import { ... } from &quot;npm:@typegraph/sdk/mod.ts&quot;; # using Bun bun add @typegraph/sdk When using Node, make sure to add this to your Typescript configuration: &quot;moduleResolution&quot;: &quot;node16&quot;, // Or &quot;nodenext&quot;  ","version":"Next","tagName":"h2"},{"title":"Parameter Transformations","type":0,"sectionRef":"#","url":"/docs/reference/types/parameter-transformations","content":"","keywords":"","version":"Next"},{"title":"func::reduce(tree)‚Äã","type":1,"pageTitle":"Parameter Transformations","url":"/docs/reference/types/parameter-transformations#funcreducetree","content":" The reduce method allows you to only enable some paths in the graph of the input type of the function.  The only required parameter to func::reduce is the reduce tree.  ","version":"Next","tagName":"h2"},{"title":"Reduce tree‚Äã","type":1,"pageTitle":"Parameter Transformations","url":"/docs/reference/types/parameter-transformations#reduce-tree","content":" A reduce tree (reduce sub-tree) is plain object whose property values are either a reduce sub-tree or a g.inherit() expression.  Each plain object represents a t.struct() in the input type subgraph.  All the nodes that are missing from the reduce tree will set the argument to its default value. Therefore they must be optional.  Consider the following typegraph:  Typescript SDK Python SDK const post = t.struct({ id: t.uuid(), title: t.string(), content: t.string(), }); const user = t.struct({ id: t.uuid(), email: t.email(), posts: t.list(post), }); const filter = t.struct({ id: t.uuid().optional(), email: t.email().optional(), posts: t.struct({ count: t.struct({ gt: t.integer({ min: 1 }).optional(), lt: t.integer({ min: 1 }).optional(), }), tag: t.list(t.string()), }), }); const deno = DenoRuntime(); const findUsers = deno.func(filter, t.list(user), { code: &quot;...&quot; }); g.expose({ findUserById: findUsers.reduce({ id: g.inherit(), }), findUsersByPostCount: findUsers.reduce({ posts: { count: g.inherit(), } }), currentUser: findUsers.reduce({ id: g.inherit().fromContext(&quot;profile.userId&quot;), }), });   The following queries are valid:  query FindUsersById($id: String!) { findUserById(id: $id) { id email } } query FindUsersByPostCount($min: Int!) { findUsersByPostCount(posts: { count: { gt: $min } }) { id email } }   However the following query is invalid:  query Q { findUserById(email: &quot;user@example.com&quot;) { id email } }   The currentUser function will not accept any parameter.  Notes:  The only fully supported non-leaf node is t.struct().Support for t.either() and t.union() is experimental.t.list() is not supported.Each non-leaf node may be optional or not.  ","version":"Next","tagName":"h3"},{"title":"func::apply(tree)‚Äã","type":1,"pageTitle":"Parameter Transformations","url":"/docs/reference/types/parameter-transformations#funcapplytree","content":" The apply method allows you to rewrite the input type of the function, enabling flat input type whatever is the level of nesting in the original input type.  The only required parameter to func::apply is the apply tree.  ","version":"Next","tagName":"h2"},{"title":"Apply tree‚Äã","type":1,"pageTitle":"Parameter Transformations","url":"/docs/reference/types/parameter-transformations#apply-tree","content":" Lexicon\tDefinitionApply node\tObject node, list node or leaf-node Apply tree\tObject node Object node\tA plain object whose property values are nodes. It represents a t.struct(). List node\tAn array or list whose items are nodes. It represents a t.list(). Leaf node\tAn apply expression. See below.  From the code blocks in previouse section, let's make the following changes.  Typescript SDK Python SDK g.expose( findUsersByPostCount: findUsers.apply({ posts: { count: { lt: g.as_arg(), gt: g.as_arg(), } } }), findTechWriters: findUsers.apply({ posts: { tags: [g.set(&quot;tech&quot;)] } }), )   In this case, the matching queries are the following:  query FindUsersByPostCount($lt: Int, $gt: Int) { findUsersByPostCount(lt: $lt, gt: $gt) { id email } } query FindTechWriters { findTechWriters { id email } }   Those queries will be translated to the following:  query FindUsersByPostCount($lt: Int, $gt: Int) { findUsers({ posts: { count: { lt: $lt, gt: $gt } } }) { id email } } query FindTechWriters { findUsers({ posts: { tags: [&quot;tech&quot;] } }) { id email } }   ","version":"Next","tagName":"h3"},{"title":"Injections","type":0,"sectionRef":"#","url":"/docs/reference/types/injections","content":"","keywords":"","version":"Next"},{"title":"Static‚Äã","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#static","content":" Description:Static injection sets a static value to the parameter.  Method: .set(value)  Parameter: The value to be set, it must be compatible with the target type.  ","version":"Next","tagName":"h2"},{"title":"Parent‚Äã","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#parent","content":" Description:Parent injection gets the value output of a sibling field in the parent struct. It adds a dependency to the sibling field, so make sure to prevent circular dependencies.  Method: .from_parent(type_name)  Parameter: The type name of the sibling field in the parent struct.  ","version":"Next","tagName":"h2"},{"title":"Context‚Äã","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#context","content":" Description:Context injection gets the value from the request context that contains authentication data.  Method: .from_context(prop_name)  Parameter: The name or jsonpath of the property in the context.  ","version":"Next","tagName":"h2"},{"title":"Secret‚Äã","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#secret","content":" Description:Secret injection gets the value from the secretsdefined when deploying the typegraph.  Method: .from_secret(secret_name)  Parameter: The name of the secret.  ","version":"Next","tagName":"h2"},{"title":"Dynamic‚Äã","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#dynamic","content":" Description:Dynamic injection gets the value from a predefined generator evaluated at runtime.  Method: .inject(generator_name)  Parameter: The name of the generator.  Available generators:  now: produces the current datetime as a valid ISOstring format. This value depends on the configuration of the typegate host machine.  ","version":"Next","tagName":"h2"},{"title":"Example‚Äã","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#example","content":" Loading... ","version":"Next","tagName":"h2"},{"title":"Apply expressions‚Äã","type":1,"pageTitle":"Parameter Transformations","url":"/docs/reference/types/parameter-transformations#apply-expressions","content":" An apply expression indicates the source of the value for a specific leaf node in the apply tree.  Apply expression\tSourceg.as_arg([name])\tThe value will be provided as a parameter, under the name name. It is optional for object properties where the default is the property key. g.from_parent(type_name)\tThe node will have the same value as the field of the parent t.struct (of the t.func) that has the type name type_name. g.from_context(path)\tThe node will have the value of the context field accessible by the path path. g.from_secret(key)\tThe node will have the value of the secret named key on the current typegraph. g.set(literal_value)\tThe passed literal_value will be used. ","version":"Next","tagName":"h3"},{"title":"","type":0,"sectionRef":"#","url":"/docs/reference/changelog","content":"","keywords":"","version":"Next"},{"title":"[unreleased]‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#unreleased","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes","content":" (ci) Poetry lockfile (#732) Fixes poetry lockfile and adds pre-commit hook to prevent issue from happening  Only build xtask once for the tests (#720) Use the xtask binary to run the tests. The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit‚Äã New Features Updated platform compatibility to x86_64-linux. Added new configuration entry for enhanced versioning and platform support. Improvements Modified test script to use a custom build script for better test management. These changes improve platform compatibility and streamline the testing process.  ","version":"Next","tagName":"h3"},{"title":"Documentation‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#documentation","content":" /docs/concepts/features-overview/ (#725) Re-does the feature overview page of the documentation. Summary by CodeRabbit‚Äã New Features Added a &quot;Features Roadmap&quot; component to the website, displaying a list of features with details and links. Documentation Updated various guides and reference documents to improve clarity and presentation of code examples. Added new sections for various features such as Typegate, Typegraph, Runtimes, Prisma, Auth, Tooling, and SDK. Bug Fixes Corrected a typo in the GraphQL runtimes reference documentation. Refactor Replaced SDKTabs and TabItem components with TGExample for better code example presentation. Adjusted the MiniQL component to handle optional properties and default settings.  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features","content":" (mdk) Mdk python (#707) Mdk for python runtime Migration notes‚Äã None Summary by CodeRabbit‚Äã New Features Introduced new functionalities for generating Python code based on configurations, including handling of templates and required objects. Added Python script templates for defining typed functions and structured objects with comprehensive data type handling. Enhanced type management and priority handling in utility functions. Documentation Provided detailed summaries and documentation for new functionalities and templates. Refactor Implemented new structures and methods for efficient code generation and type handling. Tests Added tests for defining typegraph structures and policies in Python. Chores Updated URLs in the .ghjk/deno.lock file to reflect new changes in the codebase.  (mdk,gate) Hostcall (#706) Introduces a mechanism for wasm materializers to access hostgate functions. This implements a pretty basic JSON wire interface, a singularhostcall function that's exposed to materializers. The only implemented function on this interface are gql queries. This is a stacked PR on top of #687. MET-473. The change come with new or modified tests Summary by CodeRabbit‚Äã New Features Added an import statement for std_url and a new task for installing WASI adapter related files. Introduced new functionalities in the application's runtime to support additional parameters and error handling. Enhancements Improved the application's handling of GraphQL queries with new error types and display methods. Enhanced the WASM runtime build process to target a more appropriate architecture. Bug Fixes Fixed issues in Python and WASM runtime tests to ensure reliability and performance. Documentation Updated internal documentation to reflect new command interfaces and environmental interactions in the application's CLI tools. Refactor Refactored various internal APIs to improve code maintainability and efficiency.  (meta-test) Update t.engine() impl (#716) Update the implementation of t.engine() The change comes with removing the different spin-offs of t.enginewhich arose from the previous impl of t.engine incompatibility with artifact upload protocol. The change will make t.engine deploy the artifacts in Artifact Resolution mode by running a shell command to deploy the typegraph. ... MET-500 remove different versions of t.engine add tg_deploy caller script which imports typegraphs dynamically and deploys them. make changes to make t.engine run in artifact resolution mode update existing tests to adhere to the current change pass unique different tempDirs to all the typegate instances created during test. add support for authoring multiple typegraphs in a single file inmeta-test and add multi typegraph tests. Migration notes‚Äã python SDK test typegraphs' function names should be the same with the filename of the typegraph file, for dynamic import compatibility reasons. Summary by CodeRabbit‚Äã New Features Introduced a new function wasm_duplicate to handle WebAssembly runtimes with specific policies. Refactor Renamed and refactored functions and test setups to align with updated test frameworks and improve code clarity. Bug Fixes Added error handling in the getLocalPath function to log warnings if linking errors occur. Tests Updated test scripts to reflect changes in function calls, imports, and engine instantiation for better test accuracy and reliability.  ","version":"Next","tagName":"h3"},{"title":"v0.4.2 - 2024-05-22‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v042---2024-05-22","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-1","content":" (release) Fix fat CLI compilation (#730) Fix fat CLI compilation Bump to 0.4.2 Bump wasmtime to 21 Bump rust to 1.78.0 The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"v0.4.1 - 2024-05-20‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v041---2024-05-20","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-2","content":" (SDK) Artifact upload fails when same file referred multiple times (#715) fix the bug where duplicate artifact references causing failure during artifact resolution(typegate) during runtime. add sync mode tests for Python and Deno runtime. add other edge test cases to artifact upload. test for no artifact in typegraph test for duplicate artifact reference in the same typegraph  (gate) Improve logging and responses, prepare 0.4.1 (#714) Logging before and after each faillible operation Runtimes: foreign resolvers Always log before reporting error: HTTP responseFix error code in artifact_serviceAdd BaseError class for structured messages in responses Summary by CodeRabbit‚Äã New Features Updated Docker image versions and dependency versions to ensure compatibility and stability. Added a search functionality to the app. Bug Fixes Enhanced error handling with specific error classes for more detailed error messages. Refactor Replaced generic Error instances with specific error classes for better error categorization. Refactored error handling in HTTP response functions to use aBaseError class. Chores Updated version numbers across multiple configuration files to0.4.1-0.  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-1","content":" Polish documentation and project (#696) update the headline, the overviews and many other documentation areasupgrades the dependencies. The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit‚Äã Bug Fixes Updated Docker image version for the typegate service to ensure stability and compatibility. Documentation Revised TAGLINE for better clarity on supported languages: WASM, Typescript, and Python. Updated version declarations for improved consistency and functionality across multiple files.  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks","content":" (docs) Final polish to comparison table. (#709) some changes to comparison table(docs) Migration notes‚Äã No Migrations Needed Summary by CodeRabbit‚Äã DocumentationIntroduced a new section on Artifact Tracking Protocol in the architecture documentation, explaining artifact classification and tracking modes in Metatype.Updated comparisons documentation with additional platforms, criteria for choosing Metatype, and detailed feature comparison tables.Renamed project directory for clarity and consistency in project setup documentation.Bug Fixes Removed outdated TODO comment in installation documentation.  Bump to version 0.4.1-0 (#713) Bumps version to 0.4.1-0.Fixes broken release CI.#719Adds 20 minutes to test-full timeout. Summary by CodeRabbit‚Äã Summary by CodeRabbit‚Äã New Features Updated platform support for better compatibility with &quot;x86_64-linux&quot;. Bug Fixes Minor version updates across multiple configurations to enhance stability. Chores Updated version numbers from &quot;0.4.0&quot; to &quot;0.4.1-0&quot; across various files and configurations. Refactor Adjusted build and test scripts for improved efficiency and compatibility. Documentation Enhanced internal documentation to reflect version and platform changes.  ","version":"Next","tagName":"h3"},{"title":"v0.4.0 - 2024-05-09‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v040---2024-05-09","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-3","content":" (ci) Fix broken nighly jobs (#659) Fixes the broken nightly builds. Look at solved resultshere. Motivation and context‚Äã Nightly builds were broken due to oversight during the #571 fixes. Migration notes‚Äã No changes required Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (gh-tests) Fix local npm registry config (#692) Fix the NPM registry config in the Github tests. Migration notes‚Äã N/A  Set max log level based on verbose flag (#664) Set max log level based on verbose flag Motivation and context‚Äã MET-445 Migration notes‚Äã n/a Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Fix secret passing (#675) Fix secret passing in examples and documentation. Motivation and context‚Äã Followup to #666. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Website and headline (#691) Motivation and context‚Äã Fix the CSS issue introduced by docusaurus 3.2.0 (https://github.com/facebook/docusaurus/issues/10005). 3.2.1 should fix it but the affected version maybe loaded by dependencies, so we will have to wait a bit more. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Do not override log level when no verbosity flag is present (#694) Remove log level override by the verbosity flag when no flag is present. It will default to the configured env_logger default level (or env variable). ... The default log level became &quot;error&quot; after #664, and RUST_LOGenvironment variable where ignored. Migration notes‚Äã N/A  ","version":"Next","tagName":"h3"},{"title":"Documentation‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#documentation-1","content":" Start rebranding (#641) Motivation and context‚Äã Changing the intro. Migration notes‚Äã None. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Add reference/programmatic-deployment/ (#686) Motivation and context‚Äã Add missing docs for tgDeploy, tgRemove Migration notes‚Äã None Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Add examples for each command (#684) Motivation and context‚Äã Getting started with meta cli should be easy Migration notes‚Äã None Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Improve /tutorials/quick-start section. (#681) Improve Layout Include a simple project. Add the result/outputs to running CLI commands. Remove Metatype cloud registration form. Separate the CLI commands to separate code blocks Add links to references and concepts. Add playground. Motivation and context‚Äã Docs Meta-task Migration notes‚Äã No Migration Needed Checklist‚Äã Test the commands and the examples. The change come with new or modified tests  Improve /docs/tutorials/metatype-basics (#688) Improve /docs/tutorials/metatype-basics Motivation and context‚Äã Docs Meta-task Migration notes‚Äã No Migrations Needed Checklist‚Äã The change come with new or modified tests  Improve /reference/runtimes/ (#676) Motivation and context‚Äã Better documentation Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Improve /guides/external-functions (#677) Improvements to the /guides/external-functions page.Adds a configuration file for git-town Motivation and context‚Äã N/A Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Improve docs/reference/types (#685) Improves docs/reference/types Motivation and context‚Äã N/A Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Add a comparison b/n metatype and other similar solutions/products. (#697) Adds a comparison table between metatype and other similar services.Add artifact upload protocol to Architecture section in docs. MET-443 Migration notes‚Äã No Migration Needed  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-2","content":" (cli) Long running discovery (#599) Delegate serialize, deploy, undeploy, unpack work to SDK. Motivation and context‚Äã Remove duplicate logic, thinking of cli as a convenience on top of the SDK. Migration notes‚Äã When meta cli is used, Migration files are unpacked/resolved relative to the typegraph's path, not the process's workdir. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (cli) meta gen (#636) Adds a command to meta-cli to invoke metagen. Motivation and context‚Äã MET-424 Migration notes‚Äã No changes required Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (cli) Timeout loader process (#693)  (cli,sdk) Codegen command (#661) Motivation and context‚Äã Enable back codegen on current cli implementation. Migration notes‚Äã None Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (cli,sdk) Better error messages (#689) Motivation and context‚Äã Make it more clear where failures happen Migration notes‚Äã None Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (gate) Wasmtime support (#669) BREAKING: wasmtime support (#669) Motivation and context‚Äã Enable support forwitand facilitate readiness for the upcoming specs. Migration notes‚Äã #[wasmedge_bindgen] are replaced by wit bindings. In the old version we were restricted to#[wasmedge_bindgen], which was only available in Rust and unique to WasmEdge. #[wasmedge_bindgen] fn add(a: u32, b: u32) -&gt; u32 { a + b } In the new implementation, wasm modules written in any language that uses the wit interface are now natively supported within typegate. // wit/example.wit package example:host; world host { export add: func(a: u32, b: u32) -&gt; u32; } An implementation (eg. in Rust) may look like this.. // src/lib.rs wit_bindgen::generate!({ world: &quot;host&quot; }); struct MyLib; impl Guest for MyLib { fn add(a: u32, b: u32) -&gt; u32 { a + b } } export!(MyLib); Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (gate,cli) $DENO_V8_FLAGS (#647) Enables the DENO_V8_FLAGS env var for tuning v8. Motivation and context‚Äã MET-435 or #621 Migration notes‚Äã This just exposes the deno paramter directly. Refer to deno or v8 docs for more details. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (metagen) Metagen mdk rust (#624) Implements the general framework for metagen including a generator for rust based wasm mat functions modules. Motivation and context‚Äã MET-420 Migration notes‚Äã No breaking changes Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (sdk) .tgignore file support (#633) Motivation and context‚Äã Set what files/folders should be ignored when using the customexpand_path function in an external .tgignore file..tgignore will behave similarly to most .ignore files with basic glob syntax support. Migration notes‚Äã expand_glob has been renamed to expand_path Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (sdk) Introduce flag for disabling hashing artifacts + move hash to rust (#645) Motivation and context‚Äã The mdk codegen and typegraph mutually depends on each other (typegraph needs a concrete mdk.wasm for hashing, and for the mdk.wasm to be built, it needs type generation based on the typegraph) Add a flag to enable processing a partial typegraph when using meta gen (partial == no artifact resolution). Migration notes‚Äã get_file_hash has been moved to core sdk (under the name hash_file) Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (sdk, gate, cli) Upload protocol poc uploading wasm file for WasmEdge Runtime for single replica mode (#631) Upload protocol for wasm files and atrifacts for WasmEdge Runtime for single replica mode Motivation and context‚Äã Upload WasmEdge Runtime artifacts during typegraph deployAccess and load WasmEdge Runtime artifacts from the local file system from typegate Migration notes‚Äã No Migrations Needed Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Raw prisma query through the typegate runtime (#634) Enable prisma query execution through the typegate runtime Motivation and context‚Äã Console. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Store the typegraph on s3 (#620) BREAKING: Store the typegraph on s3 (#620) Store the typegraph on s3 for multiple instance support mode. Motivation and context‚Äã Reduce Redis data. Migration notes‚Äã Environment variables: REDIS_URL has been removedFor multiple instance support, the following variables are required:SYNC_REDIS_URL, SYNC_S3_HOST, SYNC_S3_REGION, SYNC_S3_BUCKET,SYNC_S3_ACCESS_KEY, SYNC_S3_SECRET_KEY; and the following variables are optional: SYNC_REDIS_PASSWORD, SYNC_S3_PATH_STYLE. Otherwise, none of them can be set. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Remove secret definitions through env vars (#666) BREAKING: Remove secret definitions through env vars (#666) Remove the ability to define secrets in the env vars of the typegate. Secrets can now only be defined in the metatype config file and the--secret CLI option. Motivation and context‚Äã MET-370 SecurityBetter DX Migration notes‚Äã Metatype config file: On the node configuration, secrets are defined at secrets.&lt;tg_name&gt;.key: # before typegates: dev: env: TG_CONSOLE_POSTGRES_CONN: postgresql://postgres:password@localhost:5432/db?schema=console TG_CONSOLE_BASIC_ADMIN: password #after typegates: dev: secrets: console: POSTGRES_CONN: postgresql://postgres:password@localhost:5432/db?schema=console BASIC_ADMIN: password Secret override option on meta/cli # before meta deploy -f my-tg.py --secret TG_CONSOLE_POSTGRES_CONN=postgresql://postgres:password@localhost:5432/db?schema=console # after meta deploy -f my-tg.py --secret POSTGRES_CONN=postgresql://postgres:password@localhost:5432/db?schema=console # or - with the typegraph name meta deploy -f my-tg.py --secret console:POSTGRES_CONN=postgresql://postgres:password@localhost:5432/db?schema=console Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Add queryPrismaModel in the typegate runtime (#635) The queryPrismaModel function on the typegate typegraph queries rows from a prisma model. Motivation and context‚Äã Console. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Upload artifacts to s3 (#638) Upload artifacts to S3 when sync-mode is enabled Motivation and context‚Äã Sharing artifacts between replicas without including it in the typegraph (and sync through redis) Migration notes‚Äã No changes needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Upload PythonRuntime artifacts and deps (#672) Motivation and context‚Äã Track artifact/module dependencis for PythonRuntime Migration notes‚Äã python.import(...) and python.import_(...) accept an optional parameter deps that accepts list of dependencies for the python module. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Upload DenoRuntime artifacts and deps (#674) Track deno runtime artifacts(also dependencies) Upload artifacts during deploy to either local(single replica) or shared(s3) resolve artifacts(module and deps) upon typegate runtime. Motivation and context‚Äã Persisting deno runtime artifacts to a local/shared storage. Migration notes‚Äã deno.import(...) and deno.import_(...) accept an optional parameter that accepts list of dependencies for the deno/ts module. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Enable batch prisma queries in the typegate runtime (#682) Enable batch prisma queries (and transaction) in the typegate runtime Motivation and context‚Äã Console MET-381 Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Artifact removal (#668) Add GC: remove artifacts when unreferenced by any deployed typegraphImprove resource management: use AsyncDisposable andAsyncDisposableStackImprove testability (for parallel testing): always read the tmpDir config from the Typegate object Motivation and context‚Äã MET-433 Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit‚Äã New Features Enhanced search functionality with the addition of a new search bar.Introduced new test configurations to improve script execution. Updated artifact storage documentation to clarify management processes. Added new extensions to support improved code commenting. Bug Fixes Removed outdated Deno import mapping settings to streamline development environment setup. Documentation Expanded documentation on artifact tracking and management, including reference counting and garbage collection mechanisms. Refactor Implemented interface changes in QueryEngine for better async disposal management. Code restructuring in artifact management for enhanced performance and maintainability. Chores Adjusted settings and configurations in the development environment to align with current best practices. Tests Introduced new test cases for artifact upload and management functionalities.  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-1","content":" (release) Prepare 0.4.0 (#710) Bumps version to release 0.4.0. Summary by CodeRabbit‚Äã New FeaturesUpdated the software across various components to version 0.4.0, enhancing functionality and potentially introducing new features or fixes.DocumentationUpdated version documentation in multiple configuration files to reflect new version 0.4.0.Bug FixesAdjusted version constants and dependencies to ensure compatibility and stability with the new software version 0.4.0.  (sdk,gate) Bump wasmtime to 20.0.0 and wit-bindgen to 0.24.0 (#695)  ","version":"Next","tagName":"h3"},{"title":"Refactor‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#refactor","content":" (gate) Wasi 0.2 pyrt (#687) Rewrites the PythonRuntime host using a componentize-py based component.Leaf through thismemo for a mental model.  (libs/xtask,gate) Remove xtask/codegen (#700) Faster build time Migration notes‚Äã Make sure to sync typegate/src/types.ts when an update is made on the typegraph schema.  (sdk,gate) Improve temporal rt (#642) BREAKING: improve temporal rt (#642) Improve the temporal runtime exposing more parameters and adding more tests. Motivation and context‚Äã MET-397. The old implementation was bug-ridden and did not expose necessary params. Migration notes‚Äã API changes to TemporalRuntime ctor, methods and generated materializers. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Pass test options in the first parameter (#667) Pass the test options in the first parameter along with the test name/description. Motivation and context‚Äã Avoid scrolling to the end of the test function to see/update the test options. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Testing‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#testing","content":" Use local npm registry for tests (#646) Use verdaccio local npm registry for tests: The @typegraph/sdk package is published to the local npm registry, and can now be consumed like any npm package from Nodejs or Deno. Motivation and context‚Äã ... Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"v0.3.6 - 2024-03-14‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v036---2024-03-14","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-4","content":" (gate) RandomRuntime does not consider enum, either, union variants (#619) add either, enum, struct and union type support in Random Runtime. Motivation and context‚Äã generating random values for enums, either and union types was failing. Migration notes‚Äã _No Migrations Needed Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (python-wasi) Fix for vm not initialized after consecutive deploy (#617) Bug fix for typegate throwing vm not initialized after reload Motivation and context‚Äã Bug fix Migration notes‚Äã No Migrations Needed Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Apply from context (#616) Fix type validators for apply from context. Motivation and context‚Äã Bug. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Optimize typegraph size (#618) Hash all type data to compare them on the conversion phase in typegraph/core: remove duplicate types from type final typegraph (duplicate: same value for all the fields except for the &quot;random&quot; name/title).Skip unreferenced types in .apply Motivation and context‚Äã Typegraph is too big sometimes. Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-2","content":" Prepare release v0.3.6 (#626) Prepare release v0.3.6 Motivation and context‚Äã N/A Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"v0.3.5 - 2024-03-05‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v035---2024-03-05","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-5","content":" (cli) Fix for meta-cli deploy exit with code 0 on failure (#600) fix the issue where meta-cli deploy command exits with code 0 on failure. Motivation and context‚Äã bug fix Migration notes‚Äã No changes needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (typegate,typegraph) Minor bugs (#596) Just a few very minor bugs I'd encountered this week. Tests pending. Motivation and context‚Äã Bugs. Migration notes‚Äã No changes required Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Show error message for unregistered type name (#594) Check and throw the error for the expose function when called from the Python SDK. Motivation and context‚Äã We got a finalization failure when there are some unregistered type referenced with g.ref. Migration notes‚Äã No changes needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Remove injections from prisma output types (#597) Remove injections from generated output types for prisma operations. Motivation and context‚Äã Generated types fail validations (injection not allowed in output types). Migration notes‚Äã No changes needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Esm customizer for typegate deno ext (#606) Enables v8 snapshots integration for meta typegate subcommand and the standalone typegate. Also bumps deno to 1.41.0. Motivation and context‚Äã  Re-enable macos-latest cli-compat test job (#608) Fixes and enables the broken job. Motivation and context‚Äã Job was disabled earlier to mysterious breakages. Migration notes‚Äã No changes required Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-3","content":" (deno/sdk) Native function embedding in typescript (#598) Add support for function or lambda definition typescript sdk fordeno.func similarly to how python.from_def in python sdk works. Motivation and context‚Äã Providing a string is a bit impractical and counter-intuitive espcially when the sdk language matches with runtime's language. Migration notes‚Äã No changes needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (sdk) Testing framework integration 2 (#579) Motivation and context‚Äã Continuation of #566 , focused on prisma runtime. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (sdk) From_random injection (#593) This change includes changes in StringFormats(added some string formats), logic to provide random values for type nodes and tests to validate the changes. The changes are mostly in the typegraph sdk. Motivation and context‚Äã This feature enables the user to inject random values for a field(Type Node) when defining a Typegraph. Migration notes‚Äã No changes needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Remove obsolete restrictions on prisma (#592) Motivation and context‚Äã Since v5, where on unique queries exposes all the fields, not just unique fields.  Parameter transformation (#587) Enable parameter transformation with the .apply() method. It has more or less the same logic as .reduce() with the ability to flatten the input type. Motivation and context‚Äã This feature enables simpler APIs (input types) on top of runtimes (e.g.: prisma). Migration notes‚Äã No changes needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Nested context query (#595) BREAKING: Nested context query (#595) Revert context flatteningEnable jsonpath-like key to access nested object fields or array items on the context. Migration notes‚Äã If you access the context directly in your application (through the token), access to nested fields shall be updated. E.g. the expression context[&quot;profile.id&quot;] have to turned tocontext.profile.id. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-3","content":" (release) Bump 0.3.5 (#613) Ready for release of v0.3.5 Motivation and context‚Äã Required by console. Migration notes‚Äã No changes required_. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Refactor‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#refactor-1","content":" (sdk) Move post-processing functions to the typegate (#586) Motivation and context‚Äã Depends on #579 Compiled wasm bin size is too large, goal is to reduce it to ~3MB. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Make fat meta-cli the default (#607) BREAKING: make fat meta-cli the default (#607) Switch the default meta-cli release to the fat version (the one that includes the typegate subcommand). Motivation and context‚Äã  ","version":"Next","tagName":"h3"},{"title":"v0.3.4 - 2024-02-10‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v034---2024-02-10","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-6","content":" (ci) upload-artifact@v4 migration, cross compilation for meta + typegate (#571) The recent update to upload-artifact@v4 has some breaking changes as describedhere. This PR addresses them. It also fixes the cross-compilation issues with the meta-cli job in the release workflow. Motivation and context‚Äã Issuein release workflow. Migration notes‚Äã No changes required. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (ci) Minor typo in release.yml/docker (#576) Small typo blocking the job that pushes the images to ghcr.io. Motivation and context‚Äã Broken run. Migration notes‚Äã No changes required. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (ci) Missing ts modules from typegate image (#577) Adds a check step to the typegate's Dockerfile and converts the.dockerignore to be a whitelist. Motivation and context‚Äã The image for 0.3.3 has some files missing. Migration notes‚Äã No changes required Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (typegate) Fix tmp dir issue, bump to 0.3.4 (#583) Fixes an issue with the prisma migration code being unable to properlymktmpd when running in the typegate images.Removes cross usage for all but the aarch64-unknown-linux-gnutarget in the meta-cli release jobs. Deno doesn't like being cross compiled, doesn't like being built by the cross toolchain in general (even for the native target). The consequence of all this is that theaarch64-unknown-linux-gnu target will temporarily lack the fullversion builds.This also bumps the version of the 0.3.4 to get the fix out. Motivation and context‚Äã The main TMP_DIR was not created properly in the typegateDockerfile. Migration notes‚Äã No changes required Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Remove unallowed fields (#569) Skip fields with policies in findListQueries. Motivation and context‚Äã Console. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Hotfix typo in release.yml (#580) Yes, another one lol. This removes the target param from the release builder which will default to the last stage of the Dockerfile, theepoint stage. I elected to remove the parameter rather than replacing the value in order to remove one more place future changes will have to consider. (convention better than configuration the saying goes (i think)). Motivation and context‚Äã The typegate images currently have the wrong target and thus the wrongentrypoint command. Migration notes‚Äã No changes required Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Documentation‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#documentation-2","content":" (website) Cleanup (#521) Describe your change‚Äã This mainly shuffles around the existing docs for better structure. Still a lot to be done. The following pages are also empty as I lack the info regarding their topics: ArchitectureQuery engine Super open to feedback. Bring up any points that you think should be mentioned on each page and I'll add them.  Getting started guide for the vscode extension (#578) Motivation and context‚Äã Documentation is missing. Migration notes‚Äã No changes needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-4","content":" (sdk) Testing framework integration (#566) Motivation and context‚Äã Enable deploying directly from the typegraph instead of always relying on meta-cli. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"v0.3.3 - 2024-01-31‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v033---2024-01-31","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-7","content":" (ci) Bug in typegraph release job (#545) Motivation and context‚Äã jco output path is wrong. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (ci) Typo in release.yml (#548) Fix small typo. Surprised act didn't catch this, it must evaluate expressions lazily.  (ci) Force/skip push to registries on manual release (#549) What it says on the tin can. Also fixes a typo in the vscode-extensionjob. Motivation and context‚Äã Manual re-release breaks otherwise as seenhere.  (ci) Typos in release.yml (#550) Oof, I can't believe I missed these. The publish steps are hard to test locally with act so ig they require extra scrutiny. Motivation and context‚Äã Bug on manual dispatch of releasae wflow.  (ci) Mismatch in location of $AZURE_DEVOPS_TOKEN (#551) Another minor issue with the release workflow. Motivation and context‚Äã Failure in release runhere.  (ci,release) Hack for broken arm64 builds, bump deno to 1.40.1, bump to 0.3.3 (#565) This provides a temporary fix for the broken build on arm64. The issue's related to wasm-opt builds not being availaible for install by ghjk/cargo-binstall. This PR uses cargo install directly instead when in the dockerfile. It also: bumps metatype version to 0.3.3 to ready the next releasebumps the deno version to 1.40.1 (which comes with some changes) Motivation and context‚Äã Failure in CI run.. Migration notes‚Äã No changes required Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (cli) Bad conditionals in loader detection (#559) BREAKING: bad conditionals in loader detection (#559) Fix bug in js typegraph loader detection.FIx bug where the cwd for loader was overridden in loader_cmddespite being set in get_loader_cmd.Update to latest ghjkRefresh setup task in whiz.yaml Motivation and context‚Äã The old conditionals were faulty. Migration notes‚Äã node and bun loaders are now run with the cwd set to the directory of the typegraph as opposed to the metatype.yml file. This should resolve settings to the nearest package.json despite location. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (cli, typegate) Explicitly import DenoRuntime.import modules from path (#564) When using the dynamic import function, if you provide it a raw path like /foo/bar/baz and deno detects the current module's loaded from a remote host, it'll convert it to a http url. Reasonable behavior but it turned out to be the cause of #560. This pr fixes this issue along with: Puts contents of main.ts in a try/catch block for better error logging.Fixes minor permission bugs with the bundled runtime. Motivation and context‚Äã #560 Migration notes‚Äã No changes required Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (oauth2-profiler) Fix OAuth2 profiler params (#562) Pass the appropriate request URL and headers to the profiler resolver. Motivation and context‚Äã It used the provider url instead of the (typegate) request URL, causing internal queries to fail. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (template/node) Update sdk version to 0.3.2 + add deno.static (#558) Motivation and context‚Äã Sync template examples with latest 0.3.2. Added missing deno.static and func.rate(...) on node. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (vscode-extension) Fix publisher name and version (#553) Change the publisher name to metatypedev to match the account name on Azure Devops.Add dev-tools projects to dev/lock.yml for automatic versioning. Motivation and context‚Äã Failureto publish the extension. Non-matching version. Migration notes‚Äã Blank Checklist‚Äã The change come with new or modified tests (N/A) Hard-to-understand functions have explanatory comments (N/A) End-user documentation is updated to reflect the change (N/A)  ","version":"Next","tagName":"h3"},{"title":"Documentation‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#documentation-3","content":" (website) Move typegraphs in separate folder + add ts version (#552) Motivation and context‚Äã Better organization + typescript examples. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-5","content":" (node) Node fontend missing features (#557) Motivation and context‚Äã Easier translation from python to typescript typegraph. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (prisma) Add support multi-field ids and id on struct (#556) Adds support for more advanced id fields and unique constraints: Multi-field idId on struct (foreign key)Multi-field unique constraintsUnique constraint on struct (foreign key) Motivation and context‚Äã Support these kind of construct: user = t.struct( { &quot;authProvider&quot;: t.string().from_context(&quot;provider&quot;), &quot;profileId&quot;: t.string().from_context(&quot;profile.id&quot;), # ... }, config={&quot;id&quot;: [&quot;authProvider&quot;, &quot;profileId&quot;]}, ).rename(&quot;User&quot;) project = t.struct( { &quot;id&quot;: t.uuid(as_id=True, config=[&quot;auto&quot;]), &quot;owner&quot;: g.ref(&quot;Account&quot;), &quot;name&quot;: t.string(min=3, pattern=&quot;^[A-Za-z_-]$&quot;), }, config={&quot;unique&quot;: [[&quot;owner&quot;, &quot;name&quot;]]} ).rename(&quot;Project&quot;) Migration notes‚Äã No migration needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (typegate) Oauth2 token validation endpoint (#567) Create an oauth2 token validation endpoint: /:tgName/auth/validate. Motivation and context‚Äã Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (typegate-rt) Extend typegate runtime (#561) Extend the typegate runtime with the following queries: findListQueries: find all the queries that returns a list oft.struct. Motivation and context‚Äã Console. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (vscode-ext) Logo, README, display name, description (#554) Added a better display name and descriptionAdded logo and README  Flattened context (#555) Flatten profile fields in the context. So instead of { provider: 'github', accessToken: 'xxxxxxxxxxxxxxxxxxxxxxxxxx', refreshToken: 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx', refreshAt: 1704717676, profile: { id: '43663718' }, exp: 1707280877, iat: 1704688876 } we would have: { provider: 'github', accessToken: 'xxxxxxxxxxxxxxxxxxxxxxxxxx', refreshToken: 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx', refreshAt: 1704717676, 'profile.id': '43663718', exp: 1707280877, iat: 1704688876 } Motivation and context‚Äã It was impossible to get the nested id into a from_context injection. Now we can inject .from_context(&quot;profile.id&quot;). Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Refactor‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#refactor-2","content":" (ci) workflow_dispatch for release wflow (#546) Manual trigger for release wflowAdds missing ghjk step for vscode-extension release job Motivation and context‚Äã Provides recovery path for when things break. Migration notes‚Äã Doesn't affect end users. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"v0.3.2 - 2024-01-12‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v032---2024-01-12","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-8","content":" (ci) Release changelog generation (#542) Describe your change‚Äã Configures the checkout action step in the workflow that generates the workflow to clone the full git history. Motivation and context‚Äã The updates to the release workflow that introduce git cliff based changelogs (back in #487) don't appear to be in effect. Migration notes‚Äã No end user changes required. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Fix stage iteration (#540) Describe your change‚Äã Fix the iterChildStages function. It does not yield accurate values in some edge cases.Update the testing framework to enable planning without executing on the GraphQLQuery object. Motivation and context‚Äã Sibling stages can be falsely registered as children, for example with the following stages: getUser.id getUser.identity getUser.ideas Migration notes‚Äã No migration needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments (N/A) End-user documentation is updated to reflect the change (N/A)  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-6","content":" (lsp) Simple diagnostics (#496) Describe your change‚Äã Adds a simple LSP implementation for diagnostics. Motivation and context‚Äã Better DX, catch potential errors while editing the typegraph module. Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (sdk/node) Move js deno to node (#539) Describe your change‚Äã Change deno frontend to pure node Motivation and context‚Äã Easier integration. Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Customizable oauth2 profiler (#538) Describe your change‚Äã Enable custom profiler for the std (predefined) Oauth2 providers: Default profilerNo profilerExtended default profilerCustom profiler Motivation and context‚Äã We may want for example to add the Github login in the profile in addition to the id. Migration notes‚Äã No migration needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Limited parallel loads (#537) Describe your change‚Äã Limit the number of parallel loads. The default max is the number of CPU cores, but it can be set with the option --max-parallel-loads=N. Motivation and context‚Äã When we have a high number of typegraphs, the loader processes exhaust the CPU load. Migration notes‚Äã No migration needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-4","content":" (release) Bump 0.3.2 (#543) Bump the version of all metatype libs to 0.3.2. Motivation and context‚Äã About to tag the next version. Migration notes‚Äã Change their manifests to point at the new version. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change ","version":"Next","tagName":"h3"},{"title":"Metatype Basics","type":0,"sectionRef":"#","url":"/docs/tutorials/metatype-basics","content":"","keywords":"","version":"Next"},{"title":"What are you building?‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#what-are-you-building","content":" For this tutorial, we'll be implementing an API to power a simple feature roadmap/request hybrid as can be seen on Productlane.  Looking through the app we can see that the api should allow:  Unauthenticated users to submit new &quot;ideas&quot; or vote on any of those already listed. Specify or vote on the importance of an &quot;idea&quot; from &quot;medium&quot; to &quot;critical&quot; or even submit text with more description. Admins will be able to move ideas across buckets like &quot;Backlog&quot;, &quot;Planned&quot;, &quot;In Progress&quot;.  ","version":"Next","tagName":"h2"},{"title":"Setup‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#setup","content":" To setup your Metatype development environment, please follow the installation guide here  ","version":"Next","tagName":"h2"},{"title":"Create a new project‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#create-a-new-project","content":" Metatype projects are composed of modular bundles of types, logic and policies called typegraphs. We author typegraphs using modern programming languages &amp; environments. Python and Typescript are currently available for use. The meta-cli allows us to create a new project based on pre-existing templates.  Typescript SDK Python SDK Run one the following commands to create a new project under a new directory titled tg_roadmap. # using Node/Bun runtimes meta new --template node tg_roadmap # ^ project name # ^ Use `meta new --help` find out more available templates. # using Deno meta new --template deno tg_roadmap When using Typescript, the @typegraph/sdk package exposes all the necessary functions and types we'll need to describe our typegraph. The templates already specify it as as a dependency so all we need to do now is run the following command to download it: # using Deno deno cache api/example.ts # cache dependencies # using Bun bun install # using pnpm pnpm install # using npm npm install # using yarn yarn install   ","version":"Next","tagName":"h3"},{"title":"Launch typegate‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#launch-typegate","content":" The typegate is a program that runs and orchestrates our typegraphs. We can run it locally for development purposes. Typegate currently requires the Redis database to function and to make it easy to run both, we'll make use of a linux container runtime for this. The Docker runtime to be specific which has installation guides located here.  We'll also need the Docker Compose orchestrator which usually comes by default with the docker command. Use the following command to check if it is available:  docker compose version # Docker Compose version 2.23.0   ...and if not, the official installation guide can be found here.  If you have your docker runtime installed and running correctly, you will be able to launch the compose.yml file that's bundled in every template. The compose file by default includes the postgres and mongo databases. You can disable the latter by commenting it out or removing it as we'll not be needing it for this tutorial.  To launch the services, navigate your shell to the project directory and run the following command:  docker compose up --detach # ^ detach means it'll run in the background. # Omit to get the all logs in the current terminal   This should download and start typegate and its dependent services.  We can observe their log of typegate or any of the other services with the following command. It has to be run from the same project directory.  docker compose logs typegate --follow # ^ Omit service name to look at the combined logs of all services   ","version":"Next","tagName":"h3"},{"title":"Make sure it's all working‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#make-sure-its-all-working","content":" Run the following to make sure everything's up and running.  meta doctor   After running the command, you should get a result similar to then one here.  ","version":"Next","tagName":"h3"},{"title":"Building our Models‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#building-our-models","content":" We will be using the type system from the typegraph SDK to describe the shape of the data that flows through our application. In this case, we'll build our typegraph around types that represent &quot;ideas&quot;, &quot;votes&quot; and &quot;buckets&quot;.  Typescript SDK Python SDK Modify the file at api/example.ts to look something like the following. // we'll need the following imports import { t, typegraph } from &quot;@typegraph/sdk.js&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ^ each typegraph has a name const bucket = t.struct({ // asId and other config items describe the logical properties // of our types beyond just the shape &quot;id&quot;: t.integer({}, { asId: true }), &quot;name&quot;: t.string(), }); const idea = t.struct({ // uuid is just a shorthand alias for `t.string({format: &quot;uuid&quot;})` &quot;id&quot;: t.uuid({ asId: true }), &quot;name&quot;: t.string(), // another string shorthand &quot;authorEmail&quot;: t.email(), }); const vote = t.struct({ &quot;id&quot;: t.uuid(), &quot;authorEmail&quot;: t.email(), // `enum_` is also a shorthand over `t.string` &quot;importance&quot;: t.enum_([&quot;medium&quot;, &quot;important&quot;, &quot;critical&quot;]).optional(), // makes it optional &quot;desc&quot;: t.string().optional(), }); });   The types here are very simple and we haven't yet added any thing that models their relationships but they should do for our purposes.  ","version":"Next","tagName":"h2"},{"title":"Exposing our application‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#exposing-our-application","content":" Typegraphs expose an API to the external world using Function objects. Functions describe the operation that transform some input type into an output type and we define them in scope of different Runtimes, where the actual logic runs. At this early stage, we can make use of the Random runtime which allows us to generate random test data for our types to get a feel of our API.  Typescript SDK Python SDK // add need the following imports import { Policy } from &quot;@typegraph/sdk/index.js&quot;; import { RandomRuntime } from &quot;@typegraph/sdk/runtimes/random.js&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... // every exposed function requires access control policies // for now, just use the public policy, anyone can access it const pub = Policy.public(); const random = new RandomRuntime({}); g.expose( { // generates a random object in the shape of idea &quot;get_idea&quot;: random.gen(idea).withPolicy(pub), }, ); });   At this point, we can push our typegraph to the locally running typegate node and access it. Run the following command in your project root:  # features auto-reload on any changes to your source files meta dev   Typegate has first-class support for consuming the API through a GraphQl interface and it is enabled by default. It also bundles the GrahpiQl API explorer and you should be able to access it at http://localhost:7890/roadmap once meta-cli has successfully pushed your typegraph.  You can go ahead and try out the following graphql on the interface and get a feel for it.  query { get_idea { id, name, authorEmail } }   Or, you can mess around on the playground below.  Loading...  ","version":"Next","tagName":"h2"},{"title":"The Prisma Runtime‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#the-prisma-runtime","content":" Now that we have created a simple endpoint that generates random values for our idea model/type, let's add a CRUD support to our app. A runtime most apps will be depend on is the Prisma Runtime which allows us to connect to different databases and peform database operations.  For this tutorial, we'll be making use of the PostgreSQL database. If you made use of the compose.yml to run typegate as outlined in this tutorial, there should be an instance of Postgres already up. You can check if postgres container is currently running by using the meta doctor command.  If a typegraph needs to access a database, it first needs to be made aware of its address. This is done through secrets. In the root of your project directory, you'll find a file titled metatype.yaml. It contains metatype specific configuration for our project such as the top level typegates object which we use to specify the location and credentials of the different typegate nodes we'll be using. Each typegate entry also takes an secrets object where we can specify secret to be passed to our typegraphs.  The keys in the secrets object are the names of the typegraphs and the values are objects mapping secret names to their values/sources.  The metatype.yaml should already have a few sample environment variables. Add an entry like the following to give our typegraph access to the database's address:  typegates: dev: # .. secrets: TG_ROADMAP_POSTGRES: &quot;postgresql://postgres:password@postgres:5432/db&quot;   Meta-cli will auto-reload when it detects changes to metatype.yaml. This is because Meta-cli was run in dev mode(through the meta dev command).  We can add the Prisma runtime to our typegraph now.  Typescript SDK Python SDK // new imports import { PrismaRuntime } from &quot;@typegraph/sdk/providers/prisma.js&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... // the constructor takes the name of the env var directly const db = new PrismaRuntime(&quot;db&quot;, &quot;POSTGRES&quot;); // ... });   One of the features that the Prisma runtime allows us to implement is relationships. Here, we are creating a one to many relationship between bucket and ideas, also another one to many between ideas and vote. We will be specifiying relationships by using the t.list List type and g.ref(method which accepts the name of the model/entity as a parameter) for creating the link. Check the example below for better understanding.  Typescript SDK Python SDK import { PrismaRuntime } from &quot;@typegraph/sdk/providers/prisma.js&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... const db = new PrismaRuntime(&quot;db&quot;, &quot;POSTGRES&quot;); const bucket = t.struct({ &quot;id&quot;: t.integer({}, { asId: true, // auto generate ids during creation config: { auto: true } }), &quot;name&quot;: t.string(), // one-to many relationship &quot;ideas&quot;: t.list(g.ref(&quot;idea&quot;)), }) // explicitly naming our types makes reference later easier .rename(&quot;bucket&quot;); const idea = t.struct({ &quot;id&quot;: t.uuid({ asId: true, config: { auto: true } }), &quot;name&quot;: t.string(), &quot;authorEmail&quot;: t.email(), // we need to specify the relationships on both types &quot;bucket&quot;: g.ref(&quot;bucket&quot;), &quot;votes&quot;: t.list(g.ref(&quot;vote&quot;)), }) .rename(&quot;idea&quot;); const vote = t.struct({ &quot;id&quot;: t.uuid({ asId: true, config: { auto: true } }), &quot;authorEmail&quot;: t.email(), &quot;importance&quot;: t.enum_([&quot;medium&quot;, &quot;important&quot;, &quot;critical&quot;]).optional(), &quot;desc&quot;: t.string().optional(), &quot;idea&quot;: g.ref(&quot;idea&quot;) }) .rename(&quot;vote&quot;); // ... });   g.ref declares logical relationships between our types which the Prisma runtime will be able to pick up. If you need more control on what the relationships will look like on the database, you can use the db.link function. More information can be found on the Prisma runtime reference.  When we save our file at this point, the meta dev watcher should automatically create and push the necessary migrations to our database to get it in its intended shape. You should see a new subdirectory in your project called prisma. It's where the generated migrations are contained.  If you mess something up in the migrations and want a clean slate, you can reset everything by recreating the containers like so:  # remove all containers and their volumes docker compose down -v # launch docker compose up --detach # meta dev will auto apply any pending changes to databases meta dev   At this point, we're ready to add functions to expose database queries to create or read data. The Prisma runtime allows us to run raw queries directly on the database but it also provides handy functions we can use for basic CRUD operations. We'll make use of those.  Typescript SDK Python SDK import { PrismaRuntime } from &quot;@typegraph/sdk/providers/prisma.js&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... const pub = Policy.public(); const db = new PrismaRuntime(&quot;db&quot;, &quot;POSTGRES&quot;); // ... g.expose( { &quot;get_buckets&quot;: db.findMany(bucket), &quot;create_bucket&quot;: db.create(bucket), &quot;get_idea&quot;: db.findFirst(idea), &quot;create_ideas&quot;: db.create(idea), }, pub // make all functions public by default ); });   We should be able to add a few buckets and ideas now.  Loading...  ","version":"Next","tagName":"h3"},{"title":"Policies‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#policies","content":" We now have the tools enough to allow coarse CRUD of our data. The next thing we usually add at this point is authorization. A way to control who can read or write what. The primary mechanism typegraphs use for this purpose are policies.  Policies are small functions that get the context of a request as input and return a boolean signaling weather access should be granted.  Metatype currently supports policies based on javascript functions that are run on the Deno runtime.  For this tutorial, we'll be making use of the basic auth extractor. It expects a string in the format &quot;Basic token&quot; to be set in the Authorization http header. The token is expected to be a base64 encoded string in the format username:secret.  Typescript SDK Python SDK import { DenoRuntime } from &quot;@typegraph/sdk/runtimes/deno.js&quot;; import { Auth } from &quot;@typegraph/sdk/params.js&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... const deno = new DenoRuntime(); // The basic extractor only populates the context when // it recognizes the username and the secret matches g.auth(Auth.basic([&quot;andim&quot;, /*more users*/])) // the `username` value is only availaible if the basic // extractor was successful const admins = deno.policy(&quot;admins&quot;, ` (_args, { context }) =&gt; !!context.username `); g.expose( { // .. // only admins are allowed to create new buckets &quot;create_bucket&quot;: db.create(bucket).withPolicy(admins), // .. }, pub ); // ... });   The basic extractors expects the secrets in environment variables named in a specific format. Add the following entries to the metatype.yaml file:  typegates: dev: # .. secrets: roadmap: # your typegraph name # .. # the basic extractor secret format # BASIC_[username] BASIC_ADMIN: hunter2   When you save the files, meta-cli will reload the new additions to your typegraph.create_bucket is now only accessible to requests bearing the right tokens (For the provided example, Basic YW5kaW06aHVudGVyMg== should work). If you are using the GraphiQl interface from earlier, there should be a panel in the bottom left called &quot;Headers&quot; for setting http headers  Loading...  ","version":"Next","tagName":"h2"},{"title":"More Customization for our app‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#more-customization-for-our-app","content":" ","version":"Next","tagName":"h2"},{"title":"Preventing Unauthorized Creation of Related Objects‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#preventing-unauthorized-creation-of-related-objects","content":" Reference: Parameter transformations  By default, Prisma generates types that supports the whole suite of usecases one might have on a CRUD operation such as allowing creation of objects of related types in a single operation. We don't always want this and in our case, we want to prevent users from being able to create buckets, which are protected, through the create_idea function which's public. We can use the reduce method to modify the input types of functions.  mutation CIdea { create_idea( data: { # we want to prevent bucket creation through `create_idea` bucket: { create: {name: &quot;Backlog&quot;} }, authorEmail: &quot;asdf@as.df&quot;, name: &quot;Add support for WASM GC&quot; } ) { id name } }   Even though the reduce method doesn't allow us to change the shape of the type, we can change the types of members and importantly here, hide the ones we don't need.  Typescript SDK Python SDK typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... g.expose( { // .. &quot;create_idea&quot;: db.create(idea).reduce({ &quot;data&quot;: { // `g.inherit` specifies that we keep the member // type of the original &quot;name&quot;: g.inherit(), &quot;authorEmail&quot;: g.inherit(), &quot;votes&quot;: g.inherit(), &quot;bucket&quot;: { &quot;connect&quot;: g.inherit(), // by omitting the `create` member, we hide it } } }), // .. }, pub ); });   Requests are now only able to connect new ideas with pre-existing buckets and won't be able to create them. If you try to create new bucket through create_idea, the typgate will return this response.  { &quot;errors&quot;: [ { &quot;message&quot;: &quot;Unexpected property 'create' for argument 'data.bucket' of type 'object' ('object_288') at create_idea; valid properties are: connect&quot;, &quot;locations&quot;: [], &quot;path&quot;: [], &quot;extensions&quot;: { &quot;timestamp&quot;: &quot;2024-04-21T09:46:33.177Z&quot; } } ] }   Instead, If you try using this mutation, it will work as expected. You can only specify buckets that are already created.  mutation { create_idea( data: { # we want to prevent bucket creation through `create_idea` bucket: { connect: {id: 1} }, authorEmail: &quot;asdf@as.df&quot;, name: &quot;Add support for WASM GC&quot; } ) { id name, bucket { id, name } } }   Loading...  ","version":"Next","tagName":"h3"},{"title":"Restrict Update Operation on Selected Fields‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#restrict-update-operation-on-selected-fields","content":" You'll notice that we had set the importance field on votes as optional. This is to allow users to just up-vote an idea from the main list without opening a form. If they want to add importance or a description to their vote at a later point, we want to update their already existing vote. It should be easy to expose a function for this using Prisma's db.update helper and reduce to restrict changes to only those field. But we'll take this opportunity to explore the feature of the Prisma runtime to execute raw queries.  Typescript SDK Python SDK import * as effects from &quot;@typegraph/sdk/effects.js&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... g.expose( { // .. &quot;set_vote_importance&quot;: db.execute( // query parameters are matched by name from the input type 'UPDATE &quot;vote&quot; SET importance = ${importance} WHERE id = ${vote_id}::uuid', // our input type t.struct({ &quot;vote_id&quot;: t.uuid(), &quot;importance&quot;: t.enum_([&quot;medium&quot;, &quot;important&quot;, &quot;critical&quot;]), }), // we use effects to signal what kind of operation we're doing // updates and creates will be exposed as mutations in GraphQl // the boolean signals that the query is idempotent effects.update(true), ) // .. }, pub ); });   Our query is exposed like any other function in the GraphQl api.  Loading...  ","version":"Next","tagName":"h3"},{"title":"Creating REST endpoints‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#creating-rest-endpoints","content":" We can easily expose an HTTP API for our typegraph using the g.rest method. It takes a string describe a graphql query to be executed when the http path is requested.  Typescript SDK Python SDK typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... g.rest( ` query get_buckets { get_buckets { id name ideas { id name authorEmail } } } ` ) g.rest( // query parameters present // expects a request of the type `roadmap/rest/get_bucket?id=uuidstr` ` query get_bucket($id: Integer) { get_bucket(where:{ id: $id }) { id name ideas { id name authorEmail } } } ` ) });   The exposed query is served at the path {typegate_url}/{typegraph_name}/rest/{query_name}. Any parameters that the query takes are processed from the search params of the request. You can check this link on your local machine and check the results.    This is it for this tutorial and thanks for following till the end! This was a long one but we hope it gave you an overview to the vast capabilties of Metatype. We ecourage you to keep exploring! ","version":"Next","tagName":"h3"},{"title":"Quick start","type":0,"sectionRef":"#","url":"/docs/tutorials/quick-start","content":"","keywords":"","version":"Next"},{"title":"1. Meta CLI‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#1-meta-cli","content":" info Metatype is only supported on macOS and Linux. Windows users should use Linux on Windows with WSL.  You can download the binary from thereleases page, make it executable and add it to your PATH or use the automated method below.  An installer script is also provided for the CLI in our repository. Curl and install in it with the following one-liner. The installer may ask for your password. curl -fsSL https://raw.githubusercontent.com/metatypedev/metatype/main/installer.sh | bash For later use, you can run the following command to upgrade Meta CLI to a newer version. If your Meta CLI is up to date, you will get an Already up to date! response. meta upgrade   That's it! You are done installing Meta CLI.  ","version":"Next","tagName":"h2"},{"title":"2. Typegraph SDK‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#2-typegraph-sdk","content":" Typescript SDK Python SDK Install the @typegraph/sdk package from npm using your preferred package manager and runtime. The SDK requires Node 16+ with Typescript 4.7+, Deno 1.28+ or Bun 1+. # using pnpm pnpm add @typegraph/sdk # using npm npm install @typegraph/sdk # using yarn yarn add @typegraph/sdk # using Deno import { ... } from &quot;npm:@typegraph/sdk/mod.ts&quot;; # using Bun bun add @typegraph/sdk When using Node, make sure to add this to your Typescript configuration: &quot;moduleResolution&quot;: &quot;node16&quot;, // Or &quot;nodenext&quot;   ","version":"Next","tagName":"h2"},{"title":"3. Typegate node‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#3-typegate-node","content":"       ","version":"Next","tagName":"h2"},{"title":"Using Embedded Typegate (Recommended)‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#using-embedded-typegate-recommended","content":" The Meta_CLI comes with an embedded typegate packaged inside it. A typegate instance is where you deploy your typegraphs where any logic written in them is exposed via an HTTP or GraphQL endpoints. You can run an embedded typegate node from the terminal, but you first need to set a couple of environment variables which are needed to instantiate the typegate node.  Set the tg_admin_password and tg_secret environment variables. You can use the following command to configure a sample value for the variables and test the embedded typegate.  // set up tg_secret and tg_admin_password export tg_secret=a4lNi0PbEItlFZbus1oeH/+wyIxi9uH6TpL8AIqIaMBNvp7SESmuUBbfUwC0prxhGhZqHw8vMDYZAGMhSZ4fLw== tg_admin_password=password   If you have not installed Meta_CLI or you have downloaded the thin version, you can check this installation guide of the CLI.  Everything is setup to run the embedded typegate. Just run the following command below.  meta typegate   The typegate instance runs on port 7890 by default. You can check if the typegate node is running by accessing http://localhost:7890 in your browser.  ","version":"Next","tagName":"h3"},{"title":"Using Docker‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#using-docker","content":" Install Docker and use the following compose.yml to launch a typegate node. For multi-instance production workloads, Redis and an S3 object store provider are required but the typegate will run using in-memory stores if no SYNC_* environment variable is detected. More details can be found here. In practice you might also want to add a database or other systems that the typegate can connect to.  services: typegate: image: ghcr.io/metatypedev/typegate:latest ports: - &quot;7890:7890&quot; extra_hosts: - &quot;host.docker.internal:host-gateway&quot; environment: # only for dev, generate secure values for production TG_SECRET: &quot;a4lNi0PbEItlFZbus1oeH/+wyIxi9uH6TpL8AIqIaMBNvp7SESmuUBbfUwC0prxhGhZqHw8vMDYZAGMhSZ4fLw==&quot; TG_ADMIN_PASSWORD: password DEBUG: &quot;true&quot;   # launch the containers docker compose up --detach # watch the typegate logs docker compose logs typegate --follow   ","version":"Next","tagName":"h3"},{"title":"4. Verify your installation‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#4-verify-your-installation","content":" The doctor subcommand will attempt to detect all the components and report any potential issue. Please make sure to run it before opening an issue and include the output in your report.  meta doctor   After Sucessful installation, the above command produces an output somewhat similar to the one below.  user@first-project:~$ meta doctor ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Global ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî curr. directory /Users/user/Documents/metatype-playground/projects/first-project global config /Users/user/Library/Application Support/dev.metatype.meta/config.json meta-cli version 0.3.6 docker version Docker version 24.0.7, build afdd53b containers bitnami/minio:2022 (Up 3 days), verdaccio/verdaccio (Up 3 days), postgres:15 (Up 3 days), bitnami/redis:7.0 (Up 3 days), envoyproxy/envoy:v1.26-latest (Up 3 days), redis:7 (Up 3 days), rabbitmq:3-management (Up 45 hours) ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Project ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî metatype file metatype.yaml targets [2] deploy (remote, 3 secrets), dev (local, 3 secrets) typegraphs [0] ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Python SDK ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî python version Python 3.11.3 python bin ../../../../../../Library/Caches/pypoetry/virtualenvs/example-paIt3smx-py3.11/bin/python venv folder not found pyproject file pyproject.toml pipfile file not found requirements file not found typegraph version 0.3.6 ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Typescript SDK ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî deno version deno 1.39.4 node version v18.16.0 ‚îå‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚îê | In case of issue or question, please raise a ticket on: | | https://github.com/metatypedev/metatype/issues | | Or browse the documentation: | | https://metatype.dev/docs | ‚îî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚îò   ","version":"Next","tagName":"h2"},{"title":"5. Install the development tools (Optional)‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#5-install-the-development-tools-optional","content":" warning üöß This is a work in progress and still experimental.  The development tools provide some additional real-time diagnostics on the typegraph definition and autocompletion (WIP).  Currently, it only works for TypeScript/JavaScript typegraph definitions and the VS Code editor.  ","version":"Next","tagName":"h2"},{"title":"VS Code‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#vs-code","content":" VS Code users can use the VSCode extension for Metatype.  To install it, launch VS Code Quick Open (Ctrl+P), paste the following command, and press enter.  ext install metatypedev.vscode-metatype   Alternatively, you can download the .vsix file from thereleases pageand manually install the extension.  ","version":"Next","tagName":"h3"},{"title":"Writing your First App‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#writing-your-first-app","content":" Now you are ready to develop for your first app! You can use meta doctor to check if neccessary components are installed. Let's start by creating a working directory for the project. Open your terminal and run the following commands.  mkdir first-project cd first-project   Now that you have your workspace and development environment setup, let's start building a simple CRUD application.  The SDK used for developing Metatype applications is the Typegraph. Currently, it's available through Typescript and Python.  Typescript SDK Python SDK There are two variations to write your app using Typescript. You can either use node or deno as the TypeScript runtime. For now, you will be using node. To bootstrap a node Metatype project, you can run the following commands. # create startup files meta new --template node # install dependencies npm install This will create the necessary files for development, some of which are: .graphqlrc.yaml: configuration file to define settings and options related to GraphQL.compose.yml: is where the typegate node and similar services are setup.metatype.yaml: is where you configure different variables such as authentication, secrets... used by the backend. The command also creates a directory called api where you will be building much of your applications's business logic. Inside the api directory, you will find a single file called example.ts which defines a simple Typegraph. import { Policy, t, typegraph } from &quot;@typegraph/sdk/index.js&quot;; import { DenoRuntime } from &quot;@typegraph/sdk/runtimes/deno.js&quot;; import { PythonRuntime } from &quot;@typegraph/sdk/runtimes/python.js&quot;; typegraph(&quot;example&quot;, (g) =&gt; { const pub = Policy.public(); const deno = new DenoRuntime(); const python = new PythonRuntime(); g.expose({ add: python .fromLambda( t.struct({ first: t.float(), second: t.float() }), t.float(), { code: &quot;lambda x: x['first'] + x['second']&quot; }, ) .withPolicy(pub), multiply: deno .func(t.struct({ first: t.float(), second: t.float() }), t.float(), { code: &quot;({first, second}) =&gt; first * second&quot;, }) .withPolicy(pub), }); }); Let's break down the above code snippet. The typegraph function is your building block and it encompasses most of the app logic inside. It takes a name and a callback function as an argument. All the magic is done inside the callback function. Metatype uses Policy Based Access Control for accessing resources in your backend and here you have defined a public access. const pub = Policy.public(); There are two runtimes defined namely PythonRuntime and DenoRuntime. You will be using these two runtimes to perform different data operations along with the other runtimes Metatype provides. const deno = new DenoRuntime(); const python = new PythonRuntime(); Now that you have runtimes to process data and you have specified your access control, you need to define endpoints to communicate with your backend. This is where you use the g.expose method to enumerate the endpoints you want in your application. From the starter file, you can see that you have defined two endpoints, add and multiply. g.expose({ add: python .fromLambda(t.struct({ first: t.float(), second: t.float() }), t.float(), { code: &quot;lambda x: x['first'] + x['second']&quot;, }) .withPolicy(pub), multiply: deno .func(t.struct({ first: t.float(), second: t.float() }), t.float(), { code: &quot;({first, second}) =&gt; first * second&quot;, }) .withPolicy(pub), }); Let's dive into what the add endpoint is doing. The add endpoint defines a custom function which does data processing using the PythonRuntime. When you are defining the custom function, you pass the input type, output type and then a function. That's it! You have created your first Metatype app. It's as easy as this. Before you go ahead and test your app, let's add two more endpoints which peform basic Create and Read database operation. In order to exercise database capabilities, you need to build a table schema or a model. The typegraph SDK provides rich Types which you can use to create any database table that fits to your usecase. Let's create a simple Message table which has fields id, title and body. This is what it will look like in code. const message = t.struct( { id: t.integer({}, { asId: true, config: { auto: true } }), // configuring your primary key title: t.string(), body: t.string(), }, { name: &quot;message&quot; } // the name of your type ); Great! Now you need a runtime which processes database requests. You will be using another runtime that comes out of the box with Metatype. i.e the PrismaRuntime. Let's go ahead and introduce the PrismaRuntime to your app. You can add the following code below the two runtimes that were predefined. ... const python = new PythonRuntime(); const db = new PrismaRuntime(&quot;database&quot;, &quot;POSTGRES_CONN&quot;); Last, you need to expose a Create and Read endpoints to your database table. Let's add these two lines to g.expose. ... g.expose({ ..., // add following to your typegraph create_message: db.create(message).withPolicy(pub), list_messages: db.findMany(message).withPolicy(pub), }); With these three simple steps, you were able to build a basic backend with database capabilities. Finally, this is what your typegraph looks like in example.ts. import { Policy, t, typegraph } from &quot;@typegraph/sdk/index.js&quot;; import { DenoRuntime } from &quot;@typegraph/sdk/runtimes/deno.js&quot;; import { PythonRuntime } from &quot;@typegraph/sdk/runtimes/python.js&quot;; import { PrismaRuntime } from &quot;@typegraph/sdk/providers/prisma.js&quot;; typegraph( { name: &quot;example&quot;, }, (g) =&gt; { // access control const pub = Policy.public(); // runtimes const deno = new DenoRuntime(); const python = new PythonRuntime(); const db = new PrismaRuntime(&quot;database&quot;, &quot;POSTGRES&quot;); // database tables const message = t.struct( { id: t.integer({}, { asId: true, config: { auto: true } }), // configuring our primary key title: t.string(), body: t.string(), }, { name: &quot;message&quot; } // the name of our type ); g.expose({ add: python .fromLambda( t.struct({ first: t.float(), second: t.float() }), t.float(), { code: &quot;lambda x: x['first'] + x['second']&quot; } ) .withPolicy(pub), multiply: deno .func(t.struct({ first: t.float(), second: t.float() }), t.float(), { code: &quot;({first, second}) =&gt; first * second&quot;, }) .withPolicy(pub), create_message: db.create(message).withPolicy(pub), list_messages: db.findMany(message).withPolicy(pub), }); } ); You are almost there to test your first Metatype application. You now need to spin a Tyepgate and deploy your typegraph to the instance. You can leverage the embedded typegate that comes with the Meta_CLI. To run the embedded typegate, you can follow this reference. Once you started your typegate instance using one of the available choice, if you open localhost:7890 in your browser, you will get a webpage similar to this one. To deploy your typegraph to the typegate engine, there are two approaces you can follow. You can either use self-deploy which comes with the typegraph SDK or the Meta CLI. For now, you will be deploying your typegraph using the Meta CLI. Execute the command below on your terminal to deploy the typegraph. meta deploy -f api/example.ts --allow-dirty --create-migration --target dev --gate http://localhost:7890 Upon successful deployment of the typegraph, you should recieve a response similar like this. (example-py3.11) user@pc first-project % meta deploy -f api/example.py --allow-dirty --create-migration --target dev --gate http://localhost:7890 [INFO] Loading module &quot;/Users/user/Documents/metatype-playground/projects/first-project/api/example.ts&quot; [INFO] Loaded 1 typegraph from &quot;/Users/user/Documents/metatype-playground/projects/first-project/api/example.ts&quot;: example [INFO] All modules have been loaded. Stopping the loader. [INFO] Pushing typegraph example (from '/Users/user/Documents/metatype-playground/projects/first-project/api/example.ts') [INFO] ‚úì Successfully pushed typegraph example. You have deployed your first typegraph. It's time to run and test your backend which is running on the typegate instance. Click here to open a GraphiQL interface and interact with your backend through graphql queries from your browser. You should get a page similar to the one below. Now you can play with your app through the interface. You can try this graphql query as a start. Create a message using the following mutation. mutation { create_message( data: { title: &quot;First typegraph&quot; body: &quot;Congrats on your first typegraph.&quot; } ) { id } } Then, fetch the created message using the query below. query { list_messages } You should get a response from the typegate similar to then one below. You can also try out what you have built so far here on this playground. Loading... ","version":"Next","tagName":"h2"},{"title":"Types","type":0,"sectionRef":"#","url":"/docs/reference/types","content":"","keywords":"","version":"Next"},{"title":"Overview‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#overview","content":" Types are used to describe the data to be processed. They constrain the range of value that can be accepted as input data or expected as result on each computation running in a runtime.  All the type definition functions are available under the t namespace.  Typescript SDK Python SDK import { t } from &quot;@typegraph/sdk&quot;;   ","version":"Next","tagName":"h2"},{"title":"Scalar types‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#scalar-types","content":" Type\tGraphQL type\tDescriptiont.integer()\tInt\tRepresents signed 32-bit integers. t.float()\tFloat\tRepresents signed double-precision values as specified by IEEE 754. t.boolean()\tBoolean\tRepresents true or false. t.string()\tString\tRepresents textual data as UTF-8 character sequences. t.file()\t‚Äî\tRepresents a file for upload.  The following scalar types are aliases to a t.string() type with a specific format.  t.uuid()t.json()t.email()t.uri()t.hostname()t.ean()t.phone()t.date()t.datetime()  ","version":"Next","tagName":"h3"},{"title":"Non-scalar types‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#non-scalar-types","content":" Type\tGraphQL type\tDescriptiont.optional()\tnullable\tRepresents a value that may be null. t.list()\tlist\tRepresents a list of values. t.struct()\tinterface\tRepresents a structured data value, consisting of fields which map to typed values. t.union()\tunion\tRepresents a value which can be one of a set of specified types. t.either()\tunion\tRepresents a value which can match one and only one of a set of specified types. t.func\t‚Äî\tRepresents an operation that has to be performed on the typegate.  ","version":"Next","tagName":"h3"},{"title":"Type constraints‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#type-constraints","content":" Type constraints define an additional narrowing of the range of values that can be accepted for the type.  They can be passed in an object after the last required parameter on the type definition.  See the reference for each type below for the list of constraints available.  Example:The min constraint on the type t.integer()  Typescript SDK Python SDK // represents integers greater than or equal to `12` t.integer({ min: 12 });   ","version":"Next","tagName":"h3"},{"title":"Names and type references‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#names-and-type-references","content":" Each type has a unique name. If none is setImmediate, a random name will be generated during typegraph serialization.  ","version":"Next","tagName":"h3"},{"title":"Injection‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#injection","content":" ","version":"Next","tagName":"h3"},{"title":"Types‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#types-1","content":" ","version":"Next","tagName":"h2"},{"title":"t.boolean()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tboolean","content":" The t.boolean() type represents boolean values, true or false.  ","version":"Next","tagName":"h3"},{"title":"t.integer()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tinteger","content":" The t.integer() type represents 32-bit integers.  t.integer([constraints]);   Constraints‚Äã  Constraint\tDescriptionmin\tThe minimum value of the integer. max\tThe maximum value of the integer. x_min\tThe minimum value of the integer, exclusive. x_max\tThe maximum value of the integer, exclusive. multiple_of\tThe integer must be a multiple of this value.  Examples‚Äã  Typescript SDK Python SDK // non-negative integer const nonNegative = t.integer({ min: 0 }); // an integer in the range [18, 120) const adultAge = t.integer({ min: 18, x_max: 120 }); // an even integer const even = t.integer({ multiple_of: 2 });   ","version":"Next","tagName":"h3"},{"title":"t.float()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tfloat","content":" t.float([constraints])   The t.float() type represents numbers, stored in double precision floating-point format (IEEE 754).  Constraints‚Äã  The t.float() type has the same constraints as t.integer(). See integer constraints.  ","version":"Next","tagName":"h3"},{"title":"t.string()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tstring","content":" t.string([constraints])   The t.string() type represents textual data represented as UTF-8 character sequences.  Constraints‚Äã  Constraint\tType\tDescriptionmin\tInteger\tMinimum length of the string. max\tInteger\tMaximum length of the string. pattern\tString\tRegular expression pattern that the string must match. format\tString\tJSON schema format that the string must match. See below for the list of supported formats.  Supported formats‚Äã  Here is the list of supported formats:  uuidjsonemailurihostnameeanphonedatedate-time  Examples‚Äã  Typescript SDK Python SDK // a non-empty string of maximum 64 characters t.string({ min: 1, max: 64 }); // an email address t.string({ format: &quot;email&quot; }); // a json data t.string({ format: &quot;json&quot; });   Aliases‚Äã  Typescript SDK Python SDK Alias\tEquivalent declarationt.uuid()\tt.string({ format: &quot;uuid&quot; }) t.email()\tt.string({ format: &quot;email&quot; }) t.uri()\tt.string({ format: &quot;uri&quot; }) t.json\tt.string({ format: &quot;json&quot; }) t.ean()\tt.string({ format: &quot;ean&quot; }) t.phone()\tt.string({ format: &quot;phone&quot; }) t.date()\tt.string({ format: &quot;date&quot; }) t.datetime()\tt.string({ format: &quot;date-time&quot; })  ","version":"Next","tagName":"h3"},{"title":"t.file()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tfile","content":" t.file([constraints])   The t.file() represents files for upload.  Type Constraints‚Äã  Constraint\tType\tDescriptionmin\tInteger\tMinimum size of the file in bytes. max\tInteger\tMaximum size of the file in bytes. allow\tArray of strings\tList of allowed content-types  Examples‚Äã  Typescript SDK Python SDK // A file of a minimum size of 1KB t.file({ min: 1024 }) // A JPEG or PNG file less than 2KB t.file({ max: 2048, allow: [&quot;image/jpeg&quot;, &quot;image/png&quot;] })   ","version":"Next","tagName":"h3"},{"title":"t.optional()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#toptional","content":" t.optional(item_type) item_type.optional() // equivalent syntactic sugar   Default value‚Äã    If the type is used as an input type, the default value can be specified in the type definition.  Typescript SDK Python SDK t.string().optional({ defaultItem: &quot;default value&quot; })   ","version":"Next","tagName":"h3"},{"title":"t.list()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tlist","content":" t.list(item_type, [constraints])   The t.list() type represents a sequence of values of the same type.  Constraints‚Äã  Constraint\tType\tDescriptionmin\tInteger\tMinimum number of items. max\tInteger\tMaximum number of items. unique_items\tBoolean\tWhether the items must be unique.  Examples‚Äã  Typescript SDK Python SDK # A list of strings t.list(t.string()) # A list of unique strings t.list(t.string(), { uniqueItems: true }) # A list of strings with at least 3 items # and at most 10 items t.list(t.string(), { min: 3, max: 10 })   ","version":"Next","tagName":"h3"},{"title":"t.struct()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tstruct","content":" t.struct(properties, [constraints])   The t.struct() type represents structured data, consisting of nemed properties with pre-defined types.  All the prperies are required unless the corresponding type is optional. In that case, the field is allowed to be missing from the value or be null.  Constraints‚Äã  Constraint\tType\tDescriptionmin\tInteger\tMinimum number of fields. max\tInteger\tMaximum number of fields.  Examples‚Äã  Typescript SDK Python SDK // A user profile const user = t.struct({ id: t.uuid({ as_id: true }), email: t.email(), username: t.string({ min: 3, max: 64 }), }); // A user profile with an optional `name const user = t.struct({ id: t.uuid({ as_id: true }), email: t.email(), username: t.string({ min: 3, max: 64 }), name: t.string({ min: 3, max: 64 }).optional(), });   ","version":"Next","tagName":"h3"},{"title":"t.union() and t.either()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tunion-and-teither","content":" t.union(variants) t.either(variants)   The t.union type represents a value that can be of any of the specified variants. The t.either type represents a value that must be of one and only one of the specified variants.  The variants parameter is an array of types.  ","version":"Next","tagName":"h3"},{"title":"t.func()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tfunc","content":" The t.func() type represents an operation to be performed on the typegate with the specified configuration associated to it.  Usually, the functions are not defined explicitly, but rather created with the runtime instance.  ","version":"Next","tagName":"h3"},{"title":"Parameters‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#parameters","content":" Parameter\tType\tDescriptioninput type\tt.struct()\tThe type of the input data. output type\tany type\tThe type of the output data. function\tFunction~\tThe abstraction to use to perform the operation/computation.  Methods‚Äã  Method\tPurpose\tReference pagerate\tRate limiting\tRate limiting reduce\tParameter transformation\treduce apply\tParameter transformation\tapply ","version":"Next","tagName":"h3"},{"title":"Instant APIs on your database","type":0,"sectionRef":"#","url":"/use-cases/automatic-crud-validation","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"Instant APIs on your database","url":"/use-cases/automatic-crud-validation#case-study","content":"   Let's say you are developing a web application for a retail store that allows customers to place orders online. In this scenario, you would need to use CRUD operations to create, read, update, and delete data related to orders, customers, products, and inventory.  You would have to model each of these entities as a data type, define the operations that can be performed on them and write the code to ensure the correctness of the data processed in the operations.  For example, you would need to define a Customer type with the following fields: id, name, email, and address. You would also need to define the operations that can be performed on the Customer type, such as createCustomer, updateCustomer, and deleteCustomer. You would also need to write the code to validate the data in the createCustomer operation to ensure that the customer's email address is valid and that the customer's address is not empty. Same for the other fields.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"Instant APIs on your database","url":"/use-cases/automatic-crud-validation#metatypes-solution","content":" Metatype simplifies the development of CRUD APIs by providing the Prisma runtime that automates the creation of the API for CRUD operations and corresponding data validation in PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB. It can even validate some advanced types like email which may not be supported by downstream system (databases often store email address into plain string instead of a specialized field). This makes it faster for developers to create scalable CRUD APIs and enable them to focus their expertise where it matters most like checkout or the search capabilities.  Loading... ","version":"Next","tagName":"h2"},{"title":"Backend for frontend","type":0,"sectionRef":"#","url":"/use-cases/backend-for-frontend","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"Backend for frontend","url":"/use-cases/backend-for-frontend#case-study","content":"   Imagine you have a web frontend and a mobile app that both consume data from a microservices-based backend. The web frontend requires certain data fields in a given format, and the mobile app requires the same additional fields in another format.  In a traditional architecture, both the web and mobile frontends would have to make separate API calls to the microservices, and then format the data into the appropriate structure themselves. This can lead to duplicated code, increased latency due heavier calls with non-necessary data, and decreased developer efficiency.  With a BFF in place, it handles the formatting of the data based on the specific needs of each client. All frontends can thus make a single API call to the BFF, which then communicates with the microservices, retrieves the data, and formats it into the required structure before returning it to the frontend.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"Backend for frontend","url":"/use-cases/backend-for-frontend#metatypes-solution","content":" Metatype can act as a generic BFF component, serving multiple dedicated APIs and handling security, authentication and authorization for you. By encapsulating the logic for communicating with the microservices, Metatype helps to ensure that the frontends are as decoupled as possible from the other services, making it easier to make changes to either the frontend or the backend without affecting the other side.  Loading... ","version":"Next","tagName":"h2"},{"title":"Cloud function runner","type":0,"sectionRef":"#","url":"/use-cases/faas-runner","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"Cloud function runner","url":"/use-cases/faas-runner#case-study","content":"   For example, imagine you have an e-commerce application that uses FaaS to process orders. When a customer places an order, multiple functions may need to be executed, such as validating the order, processing the payment, and updating the inventory.  Each function may be executed independently by the FaaS platform and may take varying amounts of time to complete. Those functions may also be executed for historical reason on different platforms like AWS Lambda, Google Cloud Functions, or Azure Functions.  To collect the results of all the functions in a timely manner, you need to ensure that each function is executed in the correct order and that you are not waiting for a slow function to complete before moving on to the next function.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"Cloud function runner","url":"/use-cases/faas-runner#metatypes-solution","content":" To solve the use case of executing multiple functions and collecting their results, Metatype provides two key features.  Function composition/chaining: functions can be chained together to form a pipeline. The output of one function can be used as the input of the next function in the pipeline. This allows us to execute multiple functions in a specific order. Embedded runner: you can easily write a function that glues together multiple functions and executes them in a specific order. This allows you to execute multiple functions in a specific order. Currently, both Python and Typescript are supported.  Loading... ","version":"Next","tagName":"h2"},{"title":"Composable GraphQL server","type":0,"sectionRef":"#","url":"/use-cases/graphql-server","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"Composable GraphQL server","url":"/use-cases/graphql-server#case-study","content":"   Suppose you are building a subscription platform with a GraphQL API. You need to design a schema that accurately represents the available products, their attributes, and the operations that clients can perform, such as searching, filtering, and sorting.  You also need to optimize the performance of complex queries that involve joining multiple data sources, such as products, categories, and user preferences. Additionally, you need to implement caching and pagination to improve the performance and scalability of your API.  Finally, you need to ensure that your API is secure and implements appropriate authentication and authorization mechanisms to protect sensitive data and operations. Some challenges like the N+1 problem (when a single query results in multiple nested queries, each of which requires a separate database or API call) can also make the development of GraphQL resolver slow and complex to manage.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"Composable GraphQL server","url":"/use-cases/graphql-server#metatypes-solution","content":" Metatype's approach is to focus on schema design solely, and leave the GraphQL resolver implementation to the engine. By providing where the data is stored and how to access it, the queries are optimized by the engine to minimize the number of external API/database calls and to cache the results.  This can be seen as a declarative GraphQL servers, where the server is orchestrated everything for you. Metatype also comes with pre-built functionalities like authentication, authorization, and rate limiting.  Loading... ","version":"Next","tagName":"h2"},{"title":"Programmable API gateway","type":0,"sectionRef":"#","url":"/use-cases/programmable-api-gateway","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"Programmable API gateway","url":"/use-cases/programmable-api-gateway#case-study","content":"   Suppose that your company needs to implement various policies and logic to manage and secure its APIs, such as rate limiting, caching, and request/response transformations.  To achieve this, the company can adopt a programmable API gateway that allows developers to create and deploy custom function to implement additional logic and policies for incoming requests and outgoing responses.  It also provides a platform for the company to manage its API infrastructure more efficiently and flexibly. Developers can leverage existing libraries and frameworks to quickly build and deploy custom logic, reducing the time and effort required to develop and maintain the API gateway.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"Programmable API gateway","url":"/use-cases/programmable-api-gateway#metatypes-solution","content":" Metatype provide a Python SDK for developers to create and deploy custom logic and policies, which can later be deployed to the gateway in a single command line. Importers can also be used to import existing API or logic definitions from other sources, such as OpenAPI, GraphQL, and gRPC.  This enables developer to quickly build and deploy any update the API or the business logic without having to worry about the underlying infrastructure.  Loading... ","version":"Next","tagName":"h2"},{"title":"IAM gateway","type":0,"sectionRef":"#","url":"/use-cases/iam-provider","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"IAM gateway","url":"/use-cases/iam-provider#case-study","content":"   Suppose a developer is building a social media platform that allows users to post updates and view other users' profiles. The developer wants to ensure that only authenticated users can access the platform's resources, and that each user can only access their own data.  To achieve this, the developer can use OAuth2 for user authentication and access control. OAuth2 allows users to log in using their Google or GitHub credentials, which are verified by Google or GitHub's IAM system. Once the user is authenticated, the social media platform can use OAuth2 to obtain an access token, which is used to authorize the user's access to the platform's resources.  The social media platform can also use IAM to control access to resources based on user roles and permissions. For example, only authenticated users can access the platform's resources, and each user can only access their own data.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"IAM gateway","url":"/use-cases/iam-provider#metatypes-solution","content":" Metatype comes with a built-in IAM gateway that can be used to manage user identities and their authorized privileges within a system. It supports any OpenID/OAuth2 providers and includes a list of pre-configured ones like Google, GitHub, Facebook, Twitter or LinkedIn. You can also use your own identity provider and rely on JSON Web Tokens (JWT) for authentication.  Once the user is authenticated, you can use policy access based control (PBAC) to control access to resources based on user identifies and permissions. For example, only authenticated users can access the platform's resources, and each user can only access their own data. Policies can be defined by any function, and run on or off Metatype.  Loading... ","version":"Next","tagName":"h2"},{"title":"Microservices orchestration","type":0,"sectionRef":"#","url":"/use-cases/microservice-orchestration","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"Microservices orchestration","url":"/use-cases/microservice-orchestration#case-study","content":"   Let's say your company develop a healthcare platform and that one of the microservices is responsible for handling patient records (owned by team A), and another microservice is responsible for handling appointment scheduling (owned by team B).  When a patient schedules an appointment, the appointment scheduling microservice needs access to the patient's records to ensure that the appointment is scheduled with the right provider and that the provider has the necessary information to provide effective care. However, since patient records contain sensitive information, it is important to ensure that only authorized users have access to them.  To achieve this, the healthcare platform must use authentication and authorization on each API, which allows sharing only required information.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"Microservices orchestration","url":"/use-cases/microservice-orchestration#metatypes-solution","content":" Metatype can act as a central entry point for all incoming requests and responses between the microservices themselves and external clients. It is responsible for routing requests to the appropriate microservices and handling responses from those microservices, while verifying the authentication and authorization for each request.  Additionally, Metatype gateway can provide other important features such as rate limiting, caching, and request/response transformations. It can even provide an API from another typegraph and delegate the query processing to it.  Loading... ","version":"Next","tagName":"h2"},{"title":"ORM for the edge","type":0,"sectionRef":"#","url":"/use-cases/orm-for-the-edge","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"ORM for the edge","url":"/use-cases/orm-for-the-edge#case-study","content":"   Suppose you are building a mobile app that allows users to order food from local restaurants. To provide a low-latency user experience, you want to run your server-side logic as close as possible to your users.  You can deploy your functions across multiple locations on distributed edge servers. For database interactions, you may need a lightweight relay API to remains compatible with the platform and offer an efficient interface like an ORM provide.  When a user makes a request to view the menu or place an order, the corresponding function running on the edge will make a request to the lightweight relay API to retrieve or modify the relevant data in the database.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"ORM for the edge","url":"/use-cases/orm-for-the-edge#metatypes-solution","content":" Metatype can act out of the box as a lightweight relay API, simplifying database interactions via HTTP/GraphQL requests, and allowing you to query your database through the Prisma runtime. Prisma is a well-known ORM library that provides a convenient interface to interact with PostgreSQL, MySQL, SQLite, SQL Server, MongoDB, CockroachDB databases.  Loading... ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}