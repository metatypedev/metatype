// This file was @generated by metagen and is intended
// to be generated again on subsequent metagen runs.
#![cfg_attr(rustfmt, rustfmt_skip)]

// gen-static-start
#![allow(dead_code)]

pub mod wit {
    wit_bindgen::generate!({
        pub_export_macro: true,
        

        inline: "package metatype:wit-wire;

interface typegate-wire {
  hostcall: func(op-name: string, json: string) -> result<string, string>;
}

interface mat-wire {
  type json-str = string;

  record mat-info {
    op-name: string,
    mat-title: string,
    mat-hash: string,
    mat-data-json: string,
  }

  record init-args {
    metatype-version: string,
    expected-ops: list<mat-info>
  }

  record init-response {
    ok: bool
  }

  variant init-error {
    version-mismatch(string),
    unexpected-mat(mat-info),
    other(string)
  }

  init: func(args: init-args) -> result<init-response, init-error>;

  record handle-req {
    op-name: string,
    in-json: json-str,
  }

  variant handle-err {
    no-handler,
    in-json-err(string),
    handler-err(string),
  }

  handle: func(req: handle-req) -> result<json-str, handle-err>;
}

world wit-wire {
  import typegate-wire;

  export mat-wire;
}
"
    });
}

use std::cell::RefCell;
use std::collections::HashMap;

use wit::exports::metatype::wit_wire::mat_wire::*;
use wit::metatype::wit_wire::typegate_wire::hostcall;

pub type HandlerFn = Box<dyn Fn(&str, Ctx) -> Result<String, HandleErr>>;

pub struct ErasedHandler {
    mat_id: String,
    mat_trait: String,
    mat_title: String,
    handler_fn: HandlerFn,
}

pub struct MatBuilder {
    handlers: HashMap<String, ErasedHandler>,
}

impl Default for MatBuilder {
    fn default() -> Self {
        Self::new()
    }
}

impl MatBuilder {
    pub fn new() -> Self {
        Self {
            handlers: Default::default(),
        }
    }

    pub fn register_handler(mut self, handler: ErasedHandler) -> Self {
        self.handlers.insert(handler.mat_trait.clone(), handler);
        self
    }
}

pub struct Router {
    handlers: HashMap<String, ErasedHandler>,
}

impl Router {
    pub fn from_builder(builder: MatBuilder) -> Self {
        Self {
            handlers: builder.handlers,
        }
    }

    pub fn init(&self, args: InitArgs) -> Result<InitResponse, InitError> {
        static MT_VERSION: &str = "0.5.1-rc.3";
        if args.metatype_version != MT_VERSION {
            return Err(InitError::VersionMismatch(MT_VERSION.into()));
        }
        for info in args.expected_ops {
            let mat_trait = stubs::op_to_trait_name(&info.op_name);
            if !self.handlers.contains_key(mat_trait) {
                return Err(InitError::UnexpectedMat(info));
            }
        }
        Ok(InitResponse { ok: true })
    }

    pub fn handle(&self, req: HandleReq) -> Result<String, HandleErr> {
        let mat_trait = stubs::op_to_trait_name(&req.op_name);
        let Some(handler) = self.handlers.get(mat_trait) else {
            return Err(HandleErr::NoHandler);
        };
        let qg = query_graph();
        let cx = Ctx {
            host: transports::hostcall(&qg),
            qg,
        };
        (handler.handler_fn)(&req.in_json, cx)
    }
}

pub type InitCallback = fn() -> anyhow::Result<MatBuilder>;

thread_local! {
    pub static MAT_STATE: RefCell<Router> = panic!("MAT_STATE has not been initialized");
}


pub struct Ctx {
    pub qg: QueryGraph,
    pub host: metagen_client::hostcall::HostcallTransport,
}

impl Ctx {
    pub fn gql<O>(
        &self,
        query: &str,
        variables: impl Into<serde_json::Value>,
    ) -> Result<O, GraphqlRunError>
    where
        O: serde::de::DeserializeOwned,
    {
        match hostcall(
            "gql",
            &serde_json::to_string(&serde_json::json!({
                "query": query,
                "variables": variables.into(),
            }))?,
        ) {
            Ok(json) => Ok(serde_json::from_str(&json[..])?),
            Err(json) => Err(GraphqlRunError::HostError(serde_json::from_str(&json)?)),
        }
    }
}

#[derive(Debug)]
pub enum GraphqlRunError {
    JsonError(serde_json::Error),
    HostError(serde_json::Value),
}

impl std::error::Error for GraphqlRunError {}

impl From<serde_json::Error> for GraphqlRunError {
    fn from(value: serde_json::Error) -> Self {
        Self::JsonError(value)
    }
}

impl std::fmt::Display for GraphqlRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GraphqlRunError::JsonError(msg) => write!(f, "json error: {msg}"),
            GraphqlRunError::HostError(serde_json::Value::Object(map))
                if map.contains_key("message") =>
            {
                write!(f, "host error: {}", map["message"])
            }
            GraphqlRunError::HostError(val) => write!(f, "host error: {val:?}"),
        }
    }
}

#[macro_export]
macro_rules! init_mat {
    (hook: $init_hook:expr) => {
        struct MatWireGuest;
        use wit::exports::metatype::wit_wire::mat_wire::*;
        wit::export!(MatWireGuest with_types_in wit);

        #[allow(unused)]
        impl Guest for MatWireGuest {
            fn handle(req: HandleReq) -> Result<String, HandleErr> {
                MAT_STATE.with(|router| {
                    let router = router.borrow();
                    router.handle(req)
                })
            }

            fn init(args: InitArgs) -> Result<InitResponse, InitError> {
                let hook = $init_hook;
                let router = Router::from_builder(hook());
                let resp = router.init(args)?;
                MAT_STATE.set(router);
                Ok(resp)
            }
        }
    };
}
// gen-static-end
use core::marker::PhantomData;
use metagen_client::prelude::*;

/// Contains constructors for the different transports supported
/// by the typegate. Namely:
/// - GraphQl transports ([sync](transports::graphql)/[async](transports::graphql_sync)): reqwest
///   based transports that talk to the typegate using GraphQl over HTTP.
/// - [Hostcall transport](transports::hostcall): used by custom functions running in the typegate to access typegraphs.
pub mod transports {
    use super::*;



    pub fn hostcall(qg: &QueryGraph) -> metagen_client::hostcall::HostcallTransport {
        metagen_client::hostcall::HostcallTransport::new(
            std::sync::Arc::new(super::hostcall),
            qg.ty_to_gql_ty_map.clone(),
        )
    }
}

//
// --- --- QueryGraph types --- --- //
//

#[derive(Clone)]
pub struct QueryGraph {
    ty_to_gql_ty_map: TyToGqlTyMap,
}

//
// --- --- Typegraph types --- --- //
//

#[allow(non_snake_case)]
mod node_metas {
    use super::*;
    pub fn scalar() -> NodeMeta {
        NodeMeta {
            arg_types: None,
            sub_nodes: None,
            variants: None,
            input_files: None,
        }
    }    
    pub fn HundredRandom() -> NodeMeta {
        NodeMeta {
            ..Entity()
        }
    }
    pub fn Entity() -> NodeMeta {
        NodeMeta {
            arg_types: None,
            variants: None,
            sub_nodes: Some(
                [
                    ("name".into(), scalar as NodeMetaFn),
                    ("age".into(), scalar as NodeMetaFn),
                    ("profile".into(), Profile as NodeMetaFn),
                ].into()
            ),
            input_files: None,
        }
    }
    pub fn Profile() -> NodeMeta {
        NodeMeta {
            arg_types: None,
            variants: None,
            sub_nodes: Some(
                [
                    ("level".into(), scalar as NodeMetaFn),
                    ("attributes".into(), scalar as NodeMetaFn),
                    ("category".into(), ProfileCategoryStruct as NodeMetaFn),
                    ("metadatas".into(), scalar as NodeMetaFn),
                ].into()
            ),
            input_files: None,
        }
    }
    pub fn ProfileCategoryStruct() -> NodeMeta {
        NodeMeta {
            arg_types: None,
            variants: None,
            sub_nodes: Some(
                [
                    ("tag".into(), scalar as NodeMetaFn),
                    ("value".into(), scalar as NodeMetaFn),
                ].into()
            ),
            input_files: None,
        }
    }
    pub fn RootRandomFn() -> NodeMeta {
        NodeMeta {
            ..Entity()
        }
    }
    pub fn Identity() -> NodeMeta {
        NodeMeta {
            arg_types: Some(
                [
                    ("age".into(), "range_args_a_add_output_optional".into()),
                    ("name".into(), "entity_name_string".into()),
                    ("profile".into(), "profile".into()),
                ].into()
            ),
            ..Entity()
        }
    }
    pub fn RecordCreation() -> NodeMeta {
        NodeMeta {
            ..Entity()
        }
    }
    pub fn Range() -> NodeMeta {
        NodeMeta {
            arg_types: Some(
                [
                    ("a".into(), "range_args_a_add_output_optional".into()),
                    ("b".into(), "add_output".into()),
                ].into()
            ),
            ..scalar()
        }
    }
    pub fn Add() -> NodeMeta {
        NodeMeta {
            arg_types: Some(
                [
                    ("a".into(), "add_args_a_float".into()),
                    ("b".into(), "add_args_a_float".into()),
                ].into()
            ),
            ..scalar()
        }
    }

}
use types::*;
#[allow(unused)]
pub mod types {
    // input types
    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    pub struct AddArgs {
        pub a: AddArgsAFloat,
        pub b: AddArgsAFloat,
    }
    pub type AddArgsAFloat = f64;
    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    pub struct RangeArgs {
        pub a: RangeArgsAAddOutputOptional,
        pub b: AddOutput,
    }
    pub type RangeArgsAAddOutputOptional = Option<AddOutput>;
    pub type AddOutput = i64;
    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    pub struct RecordCreationInput {
    }
    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    pub struct Entity {
        pub name: EntityNameString,
        pub age: RangeArgsAAddOutputOptional,
        pub profile: Profile,
    }
    pub type EntityNameString = String;
    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    pub struct Profile {
        pub level: ProfileLevelStringEnum,
        pub attributes: ProfileAttributesProfileAttributesStringEnumList,
        pub category: ProfileCategoryStruct,
        pub metadatas: ProfileMetadatasProfileMetadatasProfileMetadatasEitherListList,
    }
    pub type ProfileLevelStringEnum = String;
    pub type ProfileAttributesProfileAttributesStringEnumList = Vec<ProfileAttributesStringEnum>;
    pub type ProfileAttributesStringEnum = String;
    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    pub struct ProfileCategoryStruct {
        pub tag: ProfileCategoryStructTagStringEnum,
        pub value: ProfileCategoryStructValueEntityNameStringOptional,
    }
    pub type ProfileCategoryStructTagStringEnum = String;
    pub type ProfileCategoryStructValueEntityNameStringOptional = Option<EntityNameString>;
    pub type ProfileMetadatasProfileMetadatasProfileMetadatasEitherListList = Vec<ProfileMetadatasProfileMetadatasEitherList>;
    pub type ProfileMetadatasProfileMetadatasEitherList = Vec<ProfileMetadatasEither>;
    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    #[allow(clippy::large_enum_variant)]
    #[serde(untagged)]
    pub enum ProfileMetadatasEither {
        EntityNameString(EntityNameString),
        AddArgsAFloat(AddArgsAFloat),
    }
    // partial output types
    pub type RecordCreationOutputPartial = Vec<EntityPartial>;
    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    pub struct EntityPartial {
        pub name: Option<EntityNameString>,
        pub age: RangeArgsAAddOutputOptional,
        pub profile: Option<ProfilePartial>,
    }
    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    pub struct ProfilePartial {
        pub level: Option<ProfileLevelStringEnum>,
        pub attributes: Option<ProfileAttributesProfileAttributesStringEnumList>,
        pub category: Option<ProfileCategoryStructPartial>,
        pub metadatas: Option<ProfileMetadatasProfileMetadatasProfileMetadatasEitherListList>,
    }
    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    pub struct ProfileCategoryStructPartial {
        pub tag: Option<ProfileCategoryStructTagStringEnum>,
        pub value: ProfileCategoryStructValueEntityNameStringOptional,
    }
    // output types
    pub type RangeOutput = Vec<AddOutput>;
    pub type RecordCreationOutput = Vec<Entity>;
}
#[derive(Default, Debug)]
pub struct EntitySelections<ATy = NoAlias> {
    pub name: ScalarSelect<ATy>,
    pub age: ScalarSelect<ATy>,
    pub profile: CompositeSelect<ProfileSelections<ATy>, ATy>,
}
impl_selection_traits!(EntitySelections, name, age, profile);
#[derive(Default, Debug)]
pub struct ProfileSelections<ATy = NoAlias> {
    pub level: ScalarSelect<ATy>,
    pub attributes: ScalarSelect<ATy>,
    pub category: CompositeSelect<ProfileCategoryStructSelections<ATy>, ATy>,
    pub metadatas: ScalarSelect<ATy>,
}
impl_selection_traits!(ProfileSelections, level, attributes, category, metadatas);
#[derive(Default, Debug)]
pub struct ProfileCategoryStructSelections<ATy = NoAlias> {
    pub tag: ScalarSelect<ATy>,
    pub value: ScalarSelect<ATy>,
}
impl_selection_traits!(ProfileCategoryStructSelections, tag, value);

pub fn query_graph() -> QueryGraph {
    QueryGraph {
        ty_to_gql_ty_map: std::sync::Arc::new([
            ("add_args_a_float".into(), "Float!".into()),
            ("range_args_a_add_output_optional".into(), "Int".into()),
            ("add_output".into(), "Int!".into()),
            ("entity_name_string".into(), "String!".into()),
            ("profile".into(), "profile!".into()),
        ].into()),
    }
}
    impl QueryGraph{

    pub fn add(
        &self,
        args: impl Into<NodeArgs<AddArgs>>
    ) -> QueryNode<AddOutput>
    {
        let nodes = selection_to_node_set(
            SelectionErasedMap(
                [(
                    "add".into(),
                    SelectionErased::ScalarArgs(args.into().into()),
                )]
                .into(),
            ),
            &[
                ("add".into(), node_metas::Add as NodeMetaFn),
            ].into(),
            "$q".into(),
        )
        .unwrap();
        QueryNode(nodes.into_iter().next().unwrap(), PhantomData)
    }
    pub fn range(
        &self,
        args: impl Into<NodeArgs<RangeArgs>>
    ) -> QueryNode<RangeOutput>
    {
        let nodes = selection_to_node_set(
            SelectionErasedMap(
                [(
                    "range".into(),
                    SelectionErased::ScalarArgs(args.into().into()),
                )]
                .into(),
            ),
            &[
                ("range".into(), node_metas::Range as NodeMetaFn),
            ].into(),
            "$q".into(),
        )
        .unwrap();
        QueryNode(nodes.into_iter().next().unwrap(), PhantomData)
    }
    pub fn record(
        &self,
    ) -> QueryNode<RecordCreationOutputPartial>
    {
        let nodes = selection_to_node_set(
            SelectionErasedMap(
                [(
                    "record".into(),
                    SelectionErased::Scalar,
                )]
                .into(),
            ),
            &[
                ("record".into(), node_metas::RecordCreation as NodeMetaFn),
            ].into(),
            "$q".into(),
        )
        .unwrap();
        QueryNode(nodes.into_iter().next().unwrap(), PhantomData)
    }
    pub fn identity(
        &self,
        args: impl Into<NodeArgs<Entity>>
    ) -> UnselectedNode<EntitySelections, EntitySelections<HasAlias>, QueryMarker, EntityPartial>
    {
        UnselectedNode {
            root_name: "identity".into(),
            root_meta: node_metas::Identity,
            args: args.into().into(),
            _marker: PhantomData,
        }
    }
    pub fn random(
        &self,
    ) -> UnselectedNode<EntitySelections, EntitySelections<HasAlias>, QueryMarker, EntityPartial>
    {
        UnselectedNode {
            root_name: "random".into(),
            root_meta: node_metas::RootRandomFn,
            args: NodeArgsErased::None,
            _marker: PhantomData,
        }
    }
    pub fn hundred(
        &self,
    ) -> QueryNode<RecordCreationOutputPartial>
    {
        let nodes = selection_to_node_set(
            SelectionErasedMap(
                [(
                    "hundred".into(),
                    SelectionErased::Scalar,
                )]
                .into(),
            ),
            &[
                ("hundred".into(), node_metas::HundredRandom as NodeMetaFn),
            ].into(),
            "$q".into(),
        )
        .unwrap();
        QueryNode(nodes.into_iter().next().unwrap(), PhantomData)
    }
}
pub mod stubs {
    use super::*;
    pub trait Add: Sized + 'static {
        fn erased(self) -> ErasedHandler {
            ErasedHandler {
                mat_id: "add".into(),
                mat_title: "add".into(),
                mat_trait: "Add".into(),
                handler_fn: Box::new(move |req, cx| {
                    let req = serde_json::from_str(req)
                        .map_err(|err| HandleErr::InJsonErr(format!("{err}")))?;
                    let res = self
                        .handle(req, cx)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))?;
                    serde_json::to_string(&res)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))
                }),
            }
        }

        fn handle(&self, input: AddArgs, cx: Ctx) -> anyhow::Result<AddOutput>;
    }
    pub trait Range: Sized + 'static {
        fn erased(self) -> ErasedHandler {
            ErasedHandler {
                mat_id: "range".into(),
                mat_title: "range".into(),
                mat_trait: "Range".into(),
                handler_fn: Box::new(move |req, cx| {
                    let req = serde_json::from_str(req)
                        .map_err(|err| HandleErr::InJsonErr(format!("{err}")))?;
                    let res = self
                        .handle(req, cx)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))?;
                    serde_json::to_string(&res)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))
                }),
            }
        }

        fn handle(&self, input: RangeArgs, cx: Ctx) -> anyhow::Result<RangeOutput>;
    }
    pub trait RecordCreation: Sized + 'static {
        fn erased(self) -> ErasedHandler {
            ErasedHandler {
                mat_id: "record-creation".into(),
                mat_title: "record-creation".into(),
                mat_trait: "RecordCreation".into(),
                handler_fn: Box::new(move |req, cx| {
                    let req = serde_json::from_str(req)
                        .map_err(|err| HandleErr::InJsonErr(format!("{err}")))?;
                    let res = self
                        .handle(req, cx)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))?;
                    serde_json::to_string(&res)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))
                }),
            }
        }

        fn handle(&self, input: RecordCreationInput, cx: Ctx) -> anyhow::Result<RecordCreationOutput>;
    }
    pub trait Identity: Sized + 'static {
        fn erased(self) -> ErasedHandler {
            ErasedHandler {
                mat_id: "identity".into(),
                mat_title: "identity".into(),
                mat_trait: "Identity".into(),
                handler_fn: Box::new(move |req, cx| {
                    let req = serde_json::from_str(req)
                        .map_err(|err| HandleErr::InJsonErr(format!("{err}")))?;
                    let res = self
                        .handle(req, cx)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))?;
                    serde_json::to_string(&res)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))
                }),
            }
        }

        fn handle(&self, input: Entity, cx: Ctx) -> anyhow::Result<Entity>;
    }
    pub trait HundredRandom: Sized + 'static {
        fn erased(self) -> ErasedHandler {
            ErasedHandler {
                mat_id: "hundred-random".into(),
                mat_title: "hundred-random".into(),
                mat_trait: "HundredRandom".into(),
                handler_fn: Box::new(move |req, cx| {
                    let req = serde_json::from_str(req)
                        .map_err(|err| HandleErr::InJsonErr(format!("{err}")))?;
                    let res = self
                        .handle(req, cx)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))?;
                    serde_json::to_string(&res)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))
                }),
            }
        }

        fn handle(&self, input: RecordCreationInput, cx: Ctx) -> anyhow::Result<RecordCreationOutput>;
    }
    pub fn op_to_trait_name(op_name: &str) -> &'static str {
        match op_name {
            "add" => "Add",
            "hundred-random" => "HundredRandom",
            "identity" => "Identity",
            "range" => "Range",
            "record-creation" => "RecordCreation",
            _ => panic!("unrecognized op_name: {op_name}"),
        }
    }
}
