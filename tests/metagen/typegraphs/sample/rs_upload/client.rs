// This file was @generated by metagen and is intended
// to be generated again on subsequent metagen runs.

use core::marker::PhantomData;
use metagen_client::prelude::*;

//
// --- --- QueryGraph types --- --- //
//

#[derive(Clone)]
pub struct QueryGraph {
    ty_to_gql_ty_map: TyToGqlTyMap,
    addr: Url,
}

impl QueryGraph {
    pub fn graphql(&self) -> GraphQlTransportReqwest {
        GraphQlTransportReqwest::new(self.addr.clone(), self.ty_to_gql_ty_map.clone())
    }
    pub fn graphql_sync(&self) -> GraphQlTransportReqwestSync {
        GraphQlTransportReqwestSync::new(self.addr.clone(), self.ty_to_gql_ty_map.clone())
    }
}

//
// --- --- Typegraph types --- --- //
//

#[allow(non_snake_case)]
mod node_metas {
    use super::*;
    pub fn scalar() -> NodeMeta {
        NodeMeta {
            arg_types: None,
            sub_nodes: None,
            variants: None,
            input_files: None,
        }
    }
    pub fn RootUploadFn() -> NodeMeta {
        NodeMeta {
            arg_types: Some(
                [
                    ("file".into(), "ScalarFileShared1".into()),
                    (
                        "path".into(),
                        "RootUploadFnInputPathScalarString1Optional".into(),
                    ),
                ]
                .into(),
            ),
            input_files: Some(PathToInputFiles(&[TypePath(&[
                TypePathSegment::ObjectProp("file"),
            ])])),
            ..scalar()
        }
    }
    pub fn RootUploadManyFn() -> NodeMeta {
        NodeMeta {
            arg_types: Some(
                [
                    (
                        "prefix".into(),
                        "RootUploadManyFnInputPrefixScalarString1Optional".into(),
                    ),
                    (
                        "files".into(),
                        "RootUploadManyFnInputFilesScalarFileShared1List".into(),
                    ),
                ]
                .into(),
            ),
            input_files: Some(PathToInputFiles(&[TypePath(&[
                TypePathSegment::ObjectProp("files"),
                TypePathSegment::ArrayItem,
            ])])),
            ..scalar()
        }
    }
}
use types::*;
pub mod types {
    pub type ScalarFileShared1 = super::FileId;
    pub type ScalarString1 = String;
    pub type RootUploadFnInputPathScalarString1Optional = Option<ScalarString1>;
    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    pub struct RootUploadFnInputPartial {
        pub file: Option<ScalarFileShared1>,
        pub path: RootUploadFnInputPathScalarString1Optional,
    }
    pub type RootUploadManyFnInputPrefixScalarString1Optional = Option<ScalarString1>;
    pub type RootUploadManyFnInputFilesScalarFileShared1List = Vec<ScalarFileShared1>;
    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    pub struct RootUploadManyFnInputPartial {
        pub prefix: RootUploadManyFnInputPrefixScalarString1Optional,
        pub files: Option<RootUploadManyFnInputFilesScalarFileShared1List>,
    }
    pub type ScalarBoolean1 = bool;
}

impl QueryGraph {
    pub fn new(addr: Url) -> Self {
        Self {
            addr,
            ty_to_gql_ty_map: std::sync::Arc::new(
                [
                    ("ScalarFileShared1".into(), "scalar_file_shared_1!".into()),
                    (
                        "RootUploadFnInputPathScalarString1Optional".into(),
                        "String".into(),
                    ),
                    (
                        "RootUploadManyFnInputPrefixScalarString1Optional".into(),
                        "String".into(),
                    ),
                    (
                        "RootUploadManyFnInputFilesScalarFileShared1List".into(),
                        "[scalar_file_shared_1]!".into(),
                    ),
                ]
                .into(),
            ),
        }
    }

    pub fn upload(
        &self,
        args: impl Into<NodeArgs<RootUploadFnInputPartial>>,
    ) -> MutationNode<ScalarBoolean1> {
        let nodes = selection_to_node_set(
            SelectionErasedMap(
                [(
                    "upload".into(),
                    SelectionErased::ScalarArgs(args.into().into()),
                )]
                .into(),
            ),
            &[("upload".into(), node_metas::RootUploadFn as NodeMetaFn)].into(),
            "$q".into(),
        )
        .unwrap();
        MutationNode(nodes.into_iter().next().unwrap(), PhantomData)
    }
    pub fn upload_many(
        &self,
        args: impl Into<NodeArgs<RootUploadManyFnInputPartial>>,
    ) -> MutationNode<ScalarBoolean1> {
        let nodes = selection_to_node_set(
            SelectionErasedMap(
                [(
                    "uploadMany".into(),
                    SelectionErased::ScalarArgs(args.into().into()),
                )]
                .into(),
            ),
            &[(
                "uploadMany".into(),
                node_metas::RootUploadManyFn as NodeMetaFn,
            )]
            .into(),
            "$q".into(),
        )
        .unwrap();
        MutationNode(nodes.into_iter().next().unwrap(), PhantomData)
    }
}
