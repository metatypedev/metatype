export const snapshot = {};

snapshot[`Metagen within sdk 1`] = `
[
  {
    content: 'from types import NoneType
from typing import Callable, List, Union, get_origin, ForwardRef, Any
from dataclasses import dataclass, asdict, fields

FORWARD_REFS = {}

class Struct:
    def repr(self):
        return asdict(self)

    @staticmethod
    def try_new(dt_class, val: Any):
        # Object
        ftypes = {f.name: f.type for f in fields(dt_class)}
        attrs = {}
        for f in val:
            fval = val[f]
            ftype = ftypes[f]
            serialized = False
            # Union
            if get_origin(ftype) is Union:
                try:
                    attrs[f] = Struct.try_union(ftype.__args__, fval)
                    serialized = True
                except Exception:
                    pass
            # List
            elif get_origin(ftype) is list:
                try:
                    attrs[f] = Struct.try_typed_list(ftype.__args__, fval)
                    serialized = True
                except Exception:
                    pass
            # Any
            if not serialized:
                if isinstance(ftype, str) and ftype in FORWARD_REFS:
                    klass = FORWARD_REFS[ftype]
                    attrs[f] = Struct.new(klass, fval)
                else:
                    attrs[f] = Struct.new(ftype, fval)
        return dt_class(**attrs)

    @staticmethod
    def try_typed_list(tpe: Any, items: Any):
        hint = tpe.__args__[0]
        klass = (
            FORWARD_REFS[hint.__forward_arg__] if isinstance(hint, ForwardRef) else hint
        )
        return [Struct.new(klass, v) for v in items]

    @staticmethod
    def try_union(variants: List[Any], val: Any):
        errors = []
        for variant in variants:
            try:
                if variant is NoneType:
                    if val is None:
                        return None
                    else:
                        continue
                if get_origin(variant) is list:
                    if isinstance(val, list):
                        return Struct.try_typed_list(variant, val)
                    else:
                        continue
                klass = FORWARD_REFS[variant.__forward_arg__]
                return Struct.try_new(klass, val)
            except Exception as e:
                errors.append(str(e))
        raise Exception("\\\\n".join(errors))

    @staticmethod
    def new(dt_class: Any, val: Any):
        try:
            return Struct.try_new(dt_class, val)
        except Exception:
            return val


@dataclass
class Object7(Struct):
    name: str


FORWARD_REFS["Object7"] = Object7


@dataclass
class Student(Struct):
    id: int
    name: str
    peers: Union[List["Student"], None]


FORWARD_REFS["Student"] = Student



def __repr(value: Any):
    if isinstance(value, Struct):
        return value.repr()
    return value



def typed_three(user_fn: Callable[[Object7], Student]):
    def exported_wrapper(raw_inp):
        inp: Object7 = Struct.new(Object7, raw_inp)
        out: Student = user_fn(inp)
        if isinstance(out, list):
            return [__repr(v) for v in out]
        return __repr(out)

    return exported_wrapper


',
    overwrite: true,
    path: "./workspace/some/base/path/python/other_types.py",
  },
  {
    content: '# - NOTE: only modules that are imported relatively
#   are supported. I.e. prefixed by \`.\` or \`..\`
# - Make sure to include any module imports in the \`deps\`
#   array when using external modules with PythonRuntime 
from .other_types import Object7, Student, typed_three


@typed_three
def three(inp: Object7) -> Student:
    # TODO: write your logic here
    raise Exception("three not implemented")

',
    overwrite: false,
    path: "./workspace/some/base/path/python/other.py",
  },
  {
    content: 'from types import NoneType
from typing import Callable, List, Union, get_origin, ForwardRef, Any
from dataclasses import dataclass, asdict, fields

FORWARD_REFS = {}

class Struct:
    def repr(self):
        return asdict(self)

    @staticmethod
    def try_new(dt_class, val: Any):
        # Object
        ftypes = {f.name: f.type for f in fields(dt_class)}
        attrs = {}
        for f in val:
            fval = val[f]
            ftype = ftypes[f]
            serialized = False
            # Union
            if get_origin(ftype) is Union:
                try:
                    attrs[f] = Struct.try_union(ftype.__args__, fval)
                    serialized = True
                except Exception:
                    pass
            # List
            elif get_origin(ftype) is list:
                try:
                    attrs[f] = Struct.try_typed_list(ftype.__args__, fval)
                    serialized = True
                except Exception:
                    pass
            # Any
            if not serialized:
                if isinstance(ftype, str) and ftype in FORWARD_REFS:
                    klass = FORWARD_REFS[ftype]
                    attrs[f] = Struct.new(klass, fval)
                else:
                    attrs[f] = Struct.new(ftype, fval)
        return dt_class(**attrs)

    @staticmethod
    def try_typed_list(tpe: Any, items: Any):
        hint = tpe.__args__[0]
        klass = (
            FORWARD_REFS[hint.__forward_arg__] if isinstance(hint, ForwardRef) else hint
        )
        return [Struct.new(klass, v) for v in items]

    @staticmethod
    def try_union(variants: List[Any], val: Any):
        errors = []
        for variant in variants:
            try:
                if variant is NoneType:
                    if val is None:
                        return None
                    else:
                        continue
                if get_origin(variant) is list:
                    if isinstance(val, list):
                        return Struct.try_typed_list(variant, val)
                    else:
                        continue
                klass = FORWARD_REFS[variant.__forward_arg__]
                return Struct.try_new(klass, val)
            except Exception as e:
                errors.append(str(e))
        raise Exception("\\\\n".join(errors))

    @staticmethod
    def new(dt_class: Any, val: Any):
        try:
            return Struct.try_new(dt_class, val)
        except Exception:
            return val


@dataclass
class Object7(Struct):
    name: str


FORWARD_REFS["Object7"] = Object7


@dataclass
class Student(Struct):
    id: int
    name: str
    peers: Union[List["Student"], None]


FORWARD_REFS["Student"] = Student


@dataclass
class TwoInput(Struct):
    name: str


FORWARD_REFS["TwoInput"] = TwoInput


Type8Student = List["Student"]
TypeString6 = str

def __repr(value: Any):
    if isinstance(value, Struct):
        return value.repr()
    return value



def typed_fnOne(user_fn: Callable[[Object7], Type8Student]):
    def exported_wrapper(raw_inp):
        inp: Object7 = Struct.new(Object7, raw_inp)
        out: Type8Student = user_fn(inp)
        if isinstance(out, list):
            return [__repr(v) for v in out]
        return __repr(out)

    return exported_wrapper


def typed_fnTwo(user_fn: Callable[[TwoInput], TypeString6]):
    def exported_wrapper(raw_inp):
        inp: TwoInput = Struct.new(TwoInput, raw_inp)
        out: TypeString6 = user_fn(inp)
        if isinstance(out, list):
            return [__repr(v) for v in out]
        return __repr(out)

    return exported_wrapper


',
    overwrite: true,
    path: "./workspace/some/base/path/python/same_hit_types.py",
  },
  {
    content: '# - NOTE: only modules that are imported relatively
#   are supported. I.e. prefixed by \`.\` or \`..\`
# - Make sure to include any module imports in the \`deps\`
#   array when using external modules with PythonRuntime 
from .same_hit_types import Object7, TwoInput, Type8Student, TypeString6, typed_fnOne, typed_fnTwo


@typed_fnOne
def fnOne(inp: Object7) -> Type8Student:
    # TODO: write your logic here
    raise Exception("fnOne not implemented")

@typed_fnTwo
def fnTwo(inp: TwoInput) -> TypeString6:
    # TODO: write your logic here
    raise Exception("fnTwo not implemented")

',
    overwrite: false,
    path: "./workspace/some/base/path/python/same_hit.py",
  },
  {
    content: 'package.name = "example_metagen_fdk"
package.edition = "2021"
package.version = "0.0.1"

[lib]
path = "lib.rs"
crate-type = ["cdylib", "rlib"]

[dependencies]
anyhow = "1.0.86"
serde = { version = "1.0.203", features = ["derive"] }
serde_json = "1.0.117"
wit-bindgen = "0.26.0"


[profile.release]
strip = "symbols"
opt-level = "z"',
    overwrite: false,
    path: "./workspace/some/base/path/rust/Cargo.toml",
  },
  {
    content: \`// This file was @generated by metagen and is intended
// to be generated again on subsequent metagen runs.
#![cfg_attr(rustfmt, rustfmt_skip)]

// gen-static-start
#![allow(dead_code)]

pub mod wit {
    wit_bindgen::generate!({
        pub_export_macro: true,
        
        inline: "package metatype:wit-wire;

interface typegate-wire {
  hostcall: func(op-name: string, json: string) -> result<string, string>;
}

interface mat-wire {
  type json-str = string;

  record mat-info {
    op-name: string,
    mat-title: string,
    mat-hash: string,
    mat-data-json: string,
  }

  record init-args {
    metatype-version: string,
    expected-ops: list<mat-info>
  }

  record init-response {
    ok: bool
  }

  variant init-error {
    version-mismatch(string),
    unexpected-mat(mat-info),
    other(string)
  }

  init: func(args: init-args) -> result<init-response, init-error>;

  record handle-req {
    op-name: string,
    in-json: json-str,
  }

  variant handle-err {
    no-handler,
    in-json-err(string),
    handler-err(string),
  }

  handle: func(req: handle-req) -> result<json-str, handle-err>;
}

world wit-wire {
  import typegate-wire;

  export mat-wire;
}
"
    });
}

use std::cell::RefCell;
use std::collections::HashMap;

use wit::exports::metatype::wit_wire::mat_wire::*;
use wit::metatype::wit_wire::typegate_wire::hostcall;

pub type HandlerFn = Box<dyn Fn(&str, Ctx) -> Result<String, HandleErr>>;

pub struct ErasedHandler {
    mat_id: String,
    mat_trait: String,
    mat_title: String,
    handler_fn: HandlerFn,
}

pub struct MatBuilder {
    handlers: HashMap<String, ErasedHandler>,
}

impl MatBuilder {
    pub fn new() -> Self {
        Self {
            handlers: Default::default(),
        }
    }

    pub fn register_handler(mut self, handler: ErasedHandler) -> Self {
        self.handlers.insert(handler.mat_trait.clone(), handler);
        self
    }
}

pub struct Router {
    handlers: HashMap<String, ErasedHandler>,
}

impl Router {
    pub fn from_builder(builder: MatBuilder) -> Self {
        Self {
            handlers: builder.handlers,
        }
    }

    pub fn init(&self, args: InitArgs) -> Result<InitResponse, InitError> {
        static MT_VERSION: &str = "0.4.11-rc.0";
        if args.metatype_version != MT_VERSION {
            return Err(InitError::VersionMismatch(MT_VERSION.into()));
        }
        for info in args.expected_ops {
            let mat_trait = stubs::op_to_trait_name(&info.op_name);
            if !self.handlers.contains_key(mat_trait) {
                return Err(InitError::UnexpectedMat(info));
            }
        }
        Ok(InitResponse { ok: true })
    }

    pub fn handle(&self, req: HandleReq) -> Result<String, HandleErr> {
        let mat_trait = stubs::op_to_trait_name(&req.op_name);
        let Some(handler) = self.handlers.get(mat_trait) else {
            return Err(HandleErr::NoHandler);
        };
        let cx = Ctx {};
        (handler.handler_fn)(&req.in_json, cx)
    }
}

pub type InitCallback = fn() -> anyhow::Result<MatBuilder>;

thread_local! {
    pub static MAT_STATE: RefCell<Router> = panic!("MAT_STATE has not been initialized");
}

pub struct Ctx {}

impl Ctx {
    pub fn gql<O>(
        &self,
        query: &str,
        variables: impl Into<serde_json::Value>,
    ) -> Result<O, GraphqlRunError>
    where
        O: serde::de::DeserializeOwned,
    {
        match hostcall(
            "gql",
            &serde_json::to_string(&serde_json::json!({
                "query": query,
                "variables": variables.into(),
            }))?,
        ) {
            Ok(json) => Ok(serde_json::from_str(&json[..])?),
            Err(json) => Err(GraphqlRunError::HostError(serde_json::from_str(&json)?)),
        }
    }
}

#[derive(Debug)]
pub enum GraphqlRunError {
    JsonError(serde_json::Error),
    HostError(serde_json::Value),
}

impl std::error::Error for GraphqlRunError {}

impl From<serde_json::Error> for GraphqlRunError {
    fn from(value: serde_json::Error) -> Self {
        Self::JsonError(value)
    }
}

impl std::fmt::Display for GraphqlRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GraphqlRunError::JsonError(msg) => write!(f, "json error: {msg}"),
            GraphqlRunError::HostError(serde_json::Value::Object(map))
                if map.contains_key("message") =>
            {
                write!(f, "host error: {}", map["message"])
            }
            GraphqlRunError::HostError(val) => write!(f, "host error: {val:?}"),
        }
    }
}

#[macro_export]
macro_rules! init_mat {
    (hook: \$init_hook:expr) => {
        struct MatWireGuest;
        use wit::exports::metatype::wit_wire::mat_wire::*;
        wit::export!(MatWireGuest with_types_in wit);

        #[allow(unused)]
        impl Guest for MatWireGuest {
            fn handle(req: HandleReq) -> Result<String, HandleErr> {
                MAT_STATE.with(|router| {
                    let router = router.borrow();
                    router.handle(req)
                })
            }

            fn init(args: InitArgs) -> Result<InitResponse, InitError> {
                let hook = \$init_hook;
                let router = Router::from_builder(hook());
                let resp = router.init(args)?;
                MAT_STATE.set(router);
                Ok(resp)
            }
        }
    };
}
// gen-static-end
use types::*;
pub mod types {
    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    pub struct Object7 {
        pub name: String,
    }
    pub type Student3 = Vec<Student>;
    pub type Student43 = Option<Student3>;
    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    pub struct Student {
        pub id: i64,
        pub name: String,
        pub peers: Student43,
    }
    pub type Student8 = Vec<Student>;
    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    pub struct TwoInput {
        pub name: String,
    }
}
pub mod stubs {
    use super::*;
    pub trait Func18: Sized + 'static {
        fn erased(self) -> ErasedHandler {
            ErasedHandler {
                mat_id: "func_18".into(),
                mat_title: "func_18".into(),
                mat_trait: "Func18".into(),
                handler_fn: Box::new(move |req, cx| {
                    let req = serde_json::from_str(req)
                        .map_err(|err| HandleErr::InJsonErr(format!("{err}")))?;
                    let res = self
                        .handle(req, cx)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))?;
                    serde_json::to_string(&res)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))
                }),
            }
        }

        fn handle(&self, input: Object7, cx: Ctx) -> anyhow::Result<Student8>;
    }
    pub trait Func19: Sized + 'static {
        fn erased(self) -> ErasedHandler {
            ErasedHandler {
                mat_id: "func_19".into(),
                mat_title: "func_19".into(),
                mat_trait: "Func19".into(),
                handler_fn: Box::new(move |req, cx| {
                    let req = serde_json::from_str(req)
                        .map_err(|err| HandleErr::InJsonErr(format!("{err}")))?;
                    let res = self
                        .handle(req, cx)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))?;
                    serde_json::to_string(&res)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))
                }),
            }
        }

        fn handle(&self, input: TwoInput, cx: Ctx) -> anyhow::Result<String>;
    }
    pub trait Func20: Sized + 'static {
        fn erased(self) -> ErasedHandler {
            ErasedHandler {
                mat_id: "func_20".into(),
                mat_title: "func_20".into(),
                mat_trait: "Func20".into(),
                handler_fn: Box::new(move |req, cx| {
                    let req = serde_json::from_str(req)
                        .map_err(|err| HandleErr::InJsonErr(format!("{err}")))?;
                    let res = self
                        .handle(req, cx)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))?;
                    serde_json::to_string(&res)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))
                }),
            }
        }

        fn handle(&self, input: Object7, cx: Ctx) -> anyhow::Result<Student>;
    }
    pub fn op_to_trait_name(op_name: &str) -> &'static str {
        match op_name {
            _ => panic!("unrecognized op_name: {op_name}"),
        }
    }
}
\`,
    overwrite: true,
    path: "./workspace/some/base/path/rust/fdk.rs",
  },
  {
    content: "
mod fdk;
pub use fdk::*;

/*
init_mat! {
    hook: || {FdkGeneratorConfigBase
        // initialize global stuff here if you need it
        MatBuilder::new()
            // register function handlers here
            .register_handler(stubs::MyFunc::erased(MyMat))
    }
}

struct MyMat;

// FIXME: use actual types from your fdk here
impl stubs::MyFunc for MyMat {
    fn handle(&self, input: types::MyFuncIn, _cx: Ctx) -> anyhow::Result<types::MyFuncOut> {
        unimplemented!()
    }
}
*/
",
    overwrite: false,
    path: "./workspace/some/base/path/rust/lib.rs",
  },
  {
    content: '// This file was @generated by metagen and is intended
// to be generated again on subsequent metagen runs.

export type Ctx = {
  parent?: Record<string, unknown>;
  /**
   * Request context extracted by auth extractors.
   */
  context?: Record<string, unknown>;
  secrets: Record<string, string>;
  effect: "create" | "update" | "delete" | "read" | undefined | null;
  meta: {
    url: string;
    token: string;
  };
  headers: Record<string, string>;
};

/**
 * Access features on your typegraph deployment.
 */
export type Deployment = {
  gql: (query: readonly string[], ...args: unknown[]) => {
    run: (
      variables: Record<string, unknown>,
    ) => Promise<Record<string, unknown>>;
  };
};

export type Handler<In, Out> = (
  input: In,
  ctx: Ctx,
  tg: Deployment,
) => Out | Promise<Out>;

export type Object7 = {
  name: string;
};
export type Student3 = Array<Student>;
export type Student43 = Student3 | null | undefined;
export type Student = {
  id: number;
  name: string;
  peers?: Student43;
};
export type Student8 = Array<Student>;
export type TwoInput = {
  name: string;
};


export type Func18Handler = Handler<Object7, Student8>;
export type Func19Handler = Handler<TwoInput, string>;
export type Func20Handler = Handler<Object7, Student>;
',
    overwrite: true,
    path: "./workspace/some/base/path/ts/fdk.ts",
  },
  {
    content: "from datetime import timedelta
from typing import Any, Callable, Optional
from types import RetryStrategy


class Context:
    async def save(
        self,
        f: Callable,
        *,
        timeout: Optional[timedelta] = None,
        retry_strategy: Optional[RetryStrategy] = None,
    ):
        pass

    def handle(self, event_name: str, cb: Callable[[Any], Any]):
        pass

    async def ensure(self, f: Callable[[], bool]):
        pass

    async def sleep(self, duration: timedelta) -> Any:
        pass

    async def receive(name: str):
        pass


def workflow():
    def wrapper(f):
        pass

    return wrapper
",
    overwrite: true,
    path: "./workspace/some/base/path/ts/substantial.py",
  },
  {
    content: "from dataclasses import dataclass
from typing import Union


@dataclass
class RetryStrategy:
    max_retries: int
    initial_backoff_interval: Union[int, None]
    max_backoff_interval: Union[int, None]
",
    overwrite: true,
    path: "./workspace/some/base/path/ts/types.py",
  },
  {
    content: "from substantial import workflow, Context  # noqa
from substantial.types import RetryStrategy  # noqa


@workflow()
def workflow_name(c: Context):
    raise NotImplementedError
",
    overwrite: false,
    path: "./workspace/some/base/path/ts/workflow.py",
  },
]
`;

snapshot[`Metagen within sdk 2`] = `
[
  {
    content: 'from types import NoneType
from typing import Callable, List, Union, get_origin, ForwardRef, Any
from dataclasses import dataclass, asdict, fields

FORWARD_REFS = {}

class Struct:
    def repr(self):
        return asdict(self)

    @staticmethod
    def try_new(dt_class, val: Any):
        # Object
        ftypes = {f.name: f.type for f in fields(dt_class)}
        attrs = {}
        for f in val:
            fval = val[f]
            ftype = ftypes[f]
            serialized = False
            # Union
            if get_origin(ftype) is Union:
                try:
                    attrs[f] = Struct.try_union(ftype.__args__, fval)
                    serialized = True
                except Exception:
                    pass
            # List
            elif get_origin(ftype) is list:
                try:
                    attrs[f] = Struct.try_typed_list(ftype.__args__, fval)
                    serialized = True
                except Exception:
                    pass
            # Any
            if not serialized:
                if isinstance(ftype, str) and ftype in FORWARD_REFS:
                    klass = FORWARD_REFS[ftype]
                    attrs[f] = Struct.new(klass, fval)
                else:
                    attrs[f] = Struct.new(ftype, fval)
        return dt_class(**attrs)

    @staticmethod
    def try_typed_list(tpe: Any, items: Any):
        hint = tpe.__args__[0]
        klass = (
            FORWARD_REFS[hint.__forward_arg__] if isinstance(hint, ForwardRef) else hint
        )
        return [Struct.new(klass, v) for v in items]

    @staticmethod
    def try_union(variants: List[Any], val: Any):
        errors = []
        for variant in variants:
            try:
                if variant is NoneType:
                    if val is None:
                        return None
                    else:
                        continue
                if get_origin(variant) is list:
                    if isinstance(val, list):
                        return Struct.try_typed_list(variant, val)
                    else:
                        continue
                klass = FORWARD_REFS[variant.__forward_arg__]
                return Struct.try_new(klass, val)
            except Exception as e:
                errors.append(str(e))
        raise Exception("\\\\n".join(errors))

    @staticmethod
    def new(dt_class: Any, val: Any):
        try:
            return Struct.try_new(dt_class, val)
        except Exception:
            return val


@dataclass
class Object7(Struct):
    name: str


FORWARD_REFS["Object7"] = Object7


@dataclass
class Student(Struct):
    id: int
    name: str
    peers: Union[List["Student"], None]


FORWARD_REFS["Student"] = Student



def __repr(value: Any):
    if isinstance(value, Struct):
        return value.repr()
    return value



def typed_three(user_fn: Callable[[Object7], Student]):
    def exported_wrapper(raw_inp):
        inp: Object7 = Struct.new(Object7, raw_inp)
        out: Student = user_fn(inp)
        if isinstance(out, list):
            return [__repr(v) for v in out]
        return __repr(out)

    return exported_wrapper


',
    overwrite: true,
    path: "./workspace/some/base/path/python/other_types.py",
  },
  {
    content: '# - NOTE: only modules that are imported relatively
#   are supported. I.e. prefixed by \`.\` or \`..\`
# - Make sure to include any module imports in the \`deps\`
#   array when using external modules with PythonRuntime 
from .other_types import Object7, Student, typed_three


@typed_three
def three(inp: Object7) -> Student:
    # TODO: write your logic here
    raise Exception("three not implemented")

',
    overwrite: false,
    path: "./workspace/some/base/path/python/other.py",
  },
  {
    content: 'from types import NoneType
from typing import Callable, List, Union, get_origin, ForwardRef, Any
from dataclasses import dataclass, asdict, fields

FORWARD_REFS = {}

class Struct:
    def repr(self):
        return asdict(self)

    @staticmethod
    def try_new(dt_class, val: Any):
        # Object
        ftypes = {f.name: f.type for f in fields(dt_class)}
        attrs = {}
        for f in val:
            fval = val[f]
            ftype = ftypes[f]
            serialized = False
            # Union
            if get_origin(ftype) is Union:
                try:
                    attrs[f] = Struct.try_union(ftype.__args__, fval)
                    serialized = True
                except Exception:
                    pass
            # List
            elif get_origin(ftype) is list:
                try:
                    attrs[f] = Struct.try_typed_list(ftype.__args__, fval)
                    serialized = True
                except Exception:
                    pass
            # Any
            if not serialized:
                if isinstance(ftype, str) and ftype in FORWARD_REFS:
                    klass = FORWARD_REFS[ftype]
                    attrs[f] = Struct.new(klass, fval)
                else:
                    attrs[f] = Struct.new(ftype, fval)
        return dt_class(**attrs)

    @staticmethod
    def try_typed_list(tpe: Any, items: Any):
        hint = tpe.__args__[0]
        klass = (
            FORWARD_REFS[hint.__forward_arg__] if isinstance(hint, ForwardRef) else hint
        )
        return [Struct.new(klass, v) for v in items]

    @staticmethod
    def try_union(variants: List[Any], val: Any):
        errors = []
        for variant in variants:
            try:
                if variant is NoneType:
                    if val is None:
                        return None
                    else:
                        continue
                if get_origin(variant) is list:
                    if isinstance(val, list):
                        return Struct.try_typed_list(variant, val)
                    else:
                        continue
                klass = FORWARD_REFS[variant.__forward_arg__]
                return Struct.try_new(klass, val)
            except Exception as e:
                errors.append(str(e))
        raise Exception("\\\\n".join(errors))

    @staticmethod
    def new(dt_class: Any, val: Any):
        try:
            return Struct.try_new(dt_class, val)
        except Exception:
            return val


@dataclass
class Object7(Struct):
    name: str


FORWARD_REFS["Object7"] = Object7


@dataclass
class Student(Struct):
    id: int
    name: str
    peers: Union[List["Student"], None]


FORWARD_REFS["Student"] = Student


@dataclass
class TwoInput(Struct):
    name: str


FORWARD_REFS["TwoInput"] = TwoInput


Type8Student = List["Student"]
TypeString6 = str

def __repr(value: Any):
    if isinstance(value, Struct):
        return value.repr()
    return value



def typed_fnOne(user_fn: Callable[[Object7], Type8Student]):
    def exported_wrapper(raw_inp):
        inp: Object7 = Struct.new(Object7, raw_inp)
        out: Type8Student = user_fn(inp)
        if isinstance(out, list):
            return [__repr(v) for v in out]
        return __repr(out)

    return exported_wrapper


def typed_fnTwo(user_fn: Callable[[TwoInput], TypeString6]):
    def exported_wrapper(raw_inp):
        inp: TwoInput = Struct.new(TwoInput, raw_inp)
        out: TypeString6 = user_fn(inp)
        if isinstance(out, list):
            return [__repr(v) for v in out]
        return __repr(out)

    return exported_wrapper


',
    overwrite: true,
    path: "./workspace/some/base/path/python/same_hit_types.py",
  },
  {
    content: '# - NOTE: only modules that are imported relatively
#   are supported. I.e. prefixed by \`.\` or \`..\`
# - Make sure to include any module imports in the \`deps\`
#   array when using external modules with PythonRuntime 
from .same_hit_types import Object7, TwoInput, Type8Student, TypeString6, typed_fnOne, typed_fnTwo


@typed_fnOne
def fnOne(inp: Object7) -> Type8Student:
    # TODO: write your logic here
    raise Exception("fnOne not implemented")

@typed_fnTwo
def fnTwo(inp: TwoInput) -> TypeString6:
    # TODO: write your logic here
    raise Exception("fnTwo not implemented")

',
    overwrite: false,
    path: "./workspace/some/base/path/python/same_hit.py",
  },
  {
    content: 'package.name = "example_metagen_fdk"
package.edition = "2021"
package.version = "0.0.1"

[lib]
path = "lib.rs"
crate-type = ["cdylib", "rlib"]

[dependencies]
anyhow = "1.0.86"
serde = { version = "1.0.203", features = ["derive"] }
serde_json = "1.0.117"
wit-bindgen = "0.26.0"


[profile.release]
strip = "symbols"
opt-level = "z"',
    overwrite: false,
    path: "./workspace/some/base/path/rust/Cargo.toml",
  },
  {
    content: \`// This file was @generated by metagen and is intended
// to be generated again on subsequent metagen runs.
#![cfg_attr(rustfmt, rustfmt_skip)]

// gen-static-start
#![allow(dead_code)]

pub mod wit {
    wit_bindgen::generate!({
        pub_export_macro: true,
        
        inline: "package metatype:wit-wire;

interface typegate-wire {
  hostcall: func(op-name: string, json: string) -> result<string, string>;
}

interface mat-wire {
  type json-str = string;

  record mat-info {
    op-name: string,
    mat-title: string,
    mat-hash: string,
    mat-data-json: string,
  }

  record init-args {
    metatype-version: string,
    expected-ops: list<mat-info>
  }

  record init-response {
    ok: bool
  }

  variant init-error {
    version-mismatch(string),
    unexpected-mat(mat-info),
    other(string)
  }

  init: func(args: init-args) -> result<init-response, init-error>;

  record handle-req {
    op-name: string,
    in-json: json-str,
  }

  variant handle-err {
    no-handler,
    in-json-err(string),
    handler-err(string),
  }

  handle: func(req: handle-req) -> result<json-str, handle-err>;
}

world wit-wire {
  import typegate-wire;

  export mat-wire;
}
"
    });
}

use std::cell::RefCell;
use std::collections::HashMap;

use wit::exports::metatype::wit_wire::mat_wire::*;
use wit::metatype::wit_wire::typegate_wire::hostcall;

pub type HandlerFn = Box<dyn Fn(&str, Ctx) -> Result<String, HandleErr>>;

pub struct ErasedHandler {
    mat_id: String,
    mat_trait: String,
    mat_title: String,
    handler_fn: HandlerFn,
}

pub struct MatBuilder {
    handlers: HashMap<String, ErasedHandler>,
}

impl MatBuilder {
    pub fn new() -> Self {
        Self {
            handlers: Default::default(),
        }
    }

    pub fn register_handler(mut self, handler: ErasedHandler) -> Self {
        self.handlers.insert(handler.mat_trait.clone(), handler);
        self
    }
}

pub struct Router {
    handlers: HashMap<String, ErasedHandler>,
}

impl Router {
    pub fn from_builder(builder: MatBuilder) -> Self {
        Self {
            handlers: builder.handlers,
        }
    }

    pub fn init(&self, args: InitArgs) -> Result<InitResponse, InitError> {
        static MT_VERSION: &str = "0.4.11-rc.0";
        if args.metatype_version != MT_VERSION {
            return Err(InitError::VersionMismatch(MT_VERSION.into()));
        }
        for info in args.expected_ops {
            let mat_trait = stubs::op_to_trait_name(&info.op_name);
            if !self.handlers.contains_key(mat_trait) {
                return Err(InitError::UnexpectedMat(info));
            }
        }
        Ok(InitResponse { ok: true })
    }

    pub fn handle(&self, req: HandleReq) -> Result<String, HandleErr> {
        let mat_trait = stubs::op_to_trait_name(&req.op_name);
        let Some(handler) = self.handlers.get(mat_trait) else {
            return Err(HandleErr::NoHandler);
        };
        let cx = Ctx {};
        (handler.handler_fn)(&req.in_json, cx)
    }
}

pub type InitCallback = fn() -> anyhow::Result<MatBuilder>;

thread_local! {
    pub static MAT_STATE: RefCell<Router> = panic!("MAT_STATE has not been initialized");
}

pub struct Ctx {}

impl Ctx {
    pub fn gql<O>(
        &self,
        query: &str,
        variables: impl Into<serde_json::Value>,
    ) -> Result<O, GraphqlRunError>
    where
        O: serde::de::DeserializeOwned,
    {
        match hostcall(
            "gql",
            &serde_json::to_string(&serde_json::json!({
                "query": query,
                "variables": variables.into(),
            }))?,
        ) {
            Ok(json) => Ok(serde_json::from_str(&json[..])?),
            Err(json) => Err(GraphqlRunError::HostError(serde_json::from_str(&json)?)),
        }
    }
}

#[derive(Debug)]
pub enum GraphqlRunError {
    JsonError(serde_json::Error),
    HostError(serde_json::Value),
}

impl std::error::Error for GraphqlRunError {}

impl From<serde_json::Error> for GraphqlRunError {
    fn from(value: serde_json::Error) -> Self {
        Self::JsonError(value)
    }
}

impl std::fmt::Display for GraphqlRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GraphqlRunError::JsonError(msg) => write!(f, "json error: {msg}"),
            GraphqlRunError::HostError(serde_json::Value::Object(map))
                if map.contains_key("message") =>
            {
                write!(f, "host error: {}", map["message"])
            }
            GraphqlRunError::HostError(val) => write!(f, "host error: {val:?}"),
        }
    }
}

#[macro_export]
macro_rules! init_mat {
    (hook: \$init_hook:expr) => {
        struct MatWireGuest;
        use wit::exports::metatype::wit_wire::mat_wire::*;
        wit::export!(MatWireGuest with_types_in wit);

        #[allow(unused)]
        impl Guest for MatWireGuest {
            fn handle(req: HandleReq) -> Result<String, HandleErr> {
                MAT_STATE.with(|router| {
                    let router = router.borrow();
                    router.handle(req)
                })
            }

            fn init(args: InitArgs) -> Result<InitResponse, InitError> {
                let hook = \$init_hook;
                let router = Router::from_builder(hook());
                let resp = router.init(args)?;
                MAT_STATE.set(router);
                Ok(resp)
            }
        }
    };
}
// gen-static-end
use types::*;
pub mod types {
    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    pub struct Object7 {
        pub name: String,
    }
    pub type Student3 = Vec<Student>;
    pub type Student43 = Option<Student3>;
    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    pub struct Student {
        pub id: i64,
        pub name: String,
        pub peers: Student43,
    }
    pub type Student8 = Vec<Student>;
    #[derive(Debug, serde::Serialize, serde::Deserialize)]
    pub struct TwoInput {
        pub name: String,
    }
}
pub mod stubs {
    use super::*;
    pub trait Func18: Sized + 'static {
        fn erased(self) -> ErasedHandler {
            ErasedHandler {
                mat_id: "func_18".into(),
                mat_title: "func_18".into(),
                mat_trait: "Func18".into(),
                handler_fn: Box::new(move |req, cx| {
                    let req = serde_json::from_str(req)
                        .map_err(|err| HandleErr::InJsonErr(format!("{err}")))?;
                    let res = self
                        .handle(req, cx)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))?;
                    serde_json::to_string(&res)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))
                }),
            }
        }

        fn handle(&self, input: Object7, cx: Ctx) -> anyhow::Result<Student8>;
    }
    pub trait Func19: Sized + 'static {
        fn erased(self) -> ErasedHandler {
            ErasedHandler {
                mat_id: "func_19".into(),
                mat_title: "func_19".into(),
                mat_trait: "Func19".into(),
                handler_fn: Box::new(move |req, cx| {
                    let req = serde_json::from_str(req)
                        .map_err(|err| HandleErr::InJsonErr(format!("{err}")))?;
                    let res = self
                        .handle(req, cx)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))?;
                    serde_json::to_string(&res)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))
                }),
            }
        }

        fn handle(&self, input: TwoInput, cx: Ctx) -> anyhow::Result<String>;
    }
    pub trait Func20: Sized + 'static {
        fn erased(self) -> ErasedHandler {
            ErasedHandler {
                mat_id: "func_20".into(),
                mat_title: "func_20".into(),
                mat_trait: "Func20".into(),
                handler_fn: Box::new(move |req, cx| {
                    let req = serde_json::from_str(req)
                        .map_err(|err| HandleErr::InJsonErr(format!("{err}")))?;
                    let res = self
                        .handle(req, cx)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))?;
                    serde_json::to_string(&res)
                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))
                }),
            }
        }

        fn handle(&self, input: Object7, cx: Ctx) -> anyhow::Result<Student>;
    }
    pub fn op_to_trait_name(op_name: &str) -> &'static str {
        match op_name {
            _ => panic!("unrecognized op_name: {op_name}"),
        }
    }
}
\`,
    overwrite: true,
    path: "./workspace/some/base/path/rust/fdk.rs",
  },
  {
    content: "
mod fdk;
pub use fdk::*;

/*
init_mat! {
    hook: || {FdkGeneratorConfigBase
        // initialize global stuff here if you need it
        MatBuilder::new()
            // register function handlers here
            .register_handler(stubs::MyFunc::erased(MyMat))
    }
}

struct MyMat;

// FIXME: use actual types from your fdk here
impl stubs::MyFunc for MyMat {
    fn handle(&self, input: types::MyFuncIn, _cx: Ctx) -> anyhow::Result<types::MyFuncOut> {
        unimplemented!()
    }
}
*/
",
    overwrite: false,
    path: "./workspace/some/base/path/rust/lib.rs",
  },
  {
    content: '// This file was @generated by metagen and is intended
// to be generated again on subsequent metagen runs.

export type Ctx = {
  parent?: Record<string, unknown>;
  /**
   * Request context extracted by auth extractors.
   */
  context?: Record<string, unknown>;
  secrets: Record<string, string>;
  effect: "create" | "update" | "delete" | "read" | undefined | null;
  meta: {
    url: string;
    token: string;
  };
  headers: Record<string, string>;
};

/**
 * Access features on your typegraph deployment.
 */
export type Deployment = {
  gql: (query: readonly string[], ...args: unknown[]) => {
    run: (
      variables: Record<string, unknown>,
    ) => Promise<Record<string, unknown>>;
  };
};

export type Handler<In, Out> = (
  input: In,
  ctx: Ctx,
  tg: Deployment,
) => Out | Promise<Out>;

export type Object7 = {
  name: string;
};
export type Student3 = Array<Student>;
export type Student43 = Student3 | null | undefined;
export type Student = {
  id: number;
  name: string;
  peers?: Student43;
};
export type Student8 = Array<Student>;
export type TwoInput = {
  name: string;
};


export type Func18Handler = Handler<Object7, Student8>;
export type Func19Handler = Handler<TwoInput, string>;
export type Func20Handler = Handler<Object7, Student>;
',
    overwrite: true,
    path: "./workspace/some/base/path/ts/fdk.ts",
  },
  {
    content: "from datetime import timedelta
from typing import Any, Callable, Optional
from types import RetryStrategy


class Context:
    async def save(
        self,
        f: Callable,
        *,
        timeout: Optional[timedelta] = None,
        retry_strategy: Optional[RetryStrategy] = None,
    ):
        pass

    def handle(self, event_name: str, cb: Callable[[Any], Any]):
        pass

    async def ensure(self, f: Callable[[], bool]):
        pass

    async def sleep(self, duration: timedelta) -> Any:
        pass

    async def receive(name: str):
        pass


def workflow():
    def wrapper(f):
        pass

    return wrapper
",
    overwrite: true,
    path: "./workspace/some/base/path/ts/substantial.py",
  },
  {
    content: "from dataclasses import dataclass
from typing import Union


@dataclass
class RetryStrategy:
    max_retries: int
    initial_backoff_interval: Union[int, None]
    max_backoff_interval: Union[int, None]
",
    overwrite: true,
    path: "./workspace/some/base/path/ts/types.py",
  },
  {
    content: "from substantial import workflow, Context  # noqa
from substantial.types import RetryStrategy  # noqa


@workflow()
def workflow_name(c: Context):
    raise NotImplementedError
",
    overwrite: false,
    path: "./workspace/some/base/path/ts/workflow.py",
  },
]
`;

snapshot[`Metagen within sdk with custom template 1`] = `
[
  {
    content: 'from types import NoneType
from typing import Callable, List, Union, get_origin, ForwardRef, Any
from dataclasses import dataclass, asdict, fields

FORWARD_REFS = {}

class Struct:
    def repr(self):
        return asdict(self)

    @staticmethod
    def try_new(dt_class, val: Any):
        # Object
        ftypes = {f.name: f.type for f in fields(dt_class)}
        attrs = {}
        for f in val:
            fval = val[f]
            ftype = ftypes[f]
            serialized = False
            # Union
            if get_origin(ftype) is Union:
                try:
                    attrs[f] = Struct.try_union(ftype.__args__, fval)
                    serialized = True
                except Exception:
                    pass
            # List
            elif get_origin(ftype) is list:
                try:
                    attrs[f] = Struct.try_typed_list(ftype.__args__, fval)
                    serialized = True
                except Exception:
                    pass
            # Any
            if not serialized:
                if isinstance(ftype, str) and ftype in FORWARD_REFS:
                    klass = FORWARD_REFS[ftype]
                    attrs[f] = Struct.new(klass, fval)
                else:
                    attrs[f] = Struct.new(ftype, fval)
        return dt_class(**attrs)

    @staticmethod
    def try_typed_list(tpe: Any, items: Any):
        hint = tpe.__args__[0]
        klass = (
            FORWARD_REFS[hint.__forward_arg__] if isinstance(hint, ForwardRef) else hint
        )
        return [Struct.new(klass, v) for v in items]

    @staticmethod
    def try_union(variants: List[Any], val: Any):
        errors = []
        for variant in variants:
            try:
                if variant is NoneType:
                    if val is None:
                        return None
                    else:
                        continue
                if get_origin(variant) is list:
                    if isinstance(val, list):
                        return Struct.try_typed_list(variant, val)
                    else:
                        continue
                klass = FORWARD_REFS[variant.__forward_arg__]
                return Struct.try_new(klass, val)
            except Exception as e:
                errors.append(str(e))
        raise Exception("\\\\n".join(errors))

    @staticmethod
    def new(dt_class: Any, val: Any):
        try:
            return Struct.try_new(dt_class, val)
        except Exception:
            return val


@dataclass
class MyNamespaceObject7(Struct):
    name: str


FORWARD_REFS["Object7"] = Object7


@dataclass
class MyNamespaceStudent(Struct):
    id: int
    name: str
    peers: Union[List["Student"], None]


FORWARD_REFS["Student"] = Student



def __repr(value: Any):
    if isinstance(value, Struct):
        return value.repr()
    return value



def typed_three(user_fn: Callable[[Object7], Student]):
    def exported_wrapper(raw_inp):
        inp: Object7 = Struct.new(Object7, raw_inp)
        out: Student = user_fn(inp)
        if isinstance(out, list):
            return [__repr(v) for v in out]
        return __repr(out)

    return exported_wrapper


',
    overwrite: true,
    path: "tests/metagen/typegraphs/some/base/path/python/other_types.py",
  },
  {
    content: '# - NOTE: only modules that are imported relatively
#   are supported. I.e. prefixed by \`.\` or \`..\`
# - Make sure to include any module imports in the \`deps\`
#   array when using external modules with PythonRuntime 
from .other_types import Object7, Student, typed_three


@typed_three
def three(inp: Object7) -> Student:
    # TODO: write your logic here
    raise Exception("three not implemented")

',
    overwrite: false,
    path: "tests/metagen/typegraphs/some/base/path/python/other.py",
  },
  {
    content: 'from types import NoneType
from typing import Callable, List, Union, get_origin, ForwardRef, Any
from dataclasses import dataclass, asdict, fields

FORWARD_REFS = {}

class Struct:
    def repr(self):
        return asdict(self)

    @staticmethod
    def try_new(dt_class, val: Any):
        # Object
        ftypes = {f.name: f.type for f in fields(dt_class)}
        attrs = {}
        for f in val:
            fval = val[f]
            ftype = ftypes[f]
            serialized = False
            # Union
            if get_origin(ftype) is Union:
                try:
                    attrs[f] = Struct.try_union(ftype.__args__, fval)
                    serialized = True
                except Exception:
                    pass
            # List
            elif get_origin(ftype) is list:
                try:
                    attrs[f] = Struct.try_typed_list(ftype.__args__, fval)
                    serialized = True
                except Exception:
                    pass
            # Any
            if not serialized:
                if isinstance(ftype, str) and ftype in FORWARD_REFS:
                    klass = FORWARD_REFS[ftype]
                    attrs[f] = Struct.new(klass, fval)
                else:
                    attrs[f] = Struct.new(ftype, fval)
        return dt_class(**attrs)

    @staticmethod
    def try_typed_list(tpe: Any, items: Any):
        hint = tpe.__args__[0]
        klass = (
            FORWARD_REFS[hint.__forward_arg__] if isinstance(hint, ForwardRef) else hint
        )
        return [Struct.new(klass, v) for v in items]

    @staticmethod
    def try_union(variants: List[Any], val: Any):
        errors = []
        for variant in variants:
            try:
                if variant is NoneType:
                    if val is None:
                        return None
                    else:
                        continue
                if get_origin(variant) is list:
                    if isinstance(val, list):
                        return Struct.try_typed_list(variant, val)
                    else:
                        continue
                klass = FORWARD_REFS[variant.__forward_arg__]
                return Struct.try_new(klass, val)
            except Exception as e:
                errors.append(str(e))
        raise Exception("\\\\n".join(errors))

    @staticmethod
    def new(dt_class: Any, val: Any):
        try:
            return Struct.try_new(dt_class, val)
        except Exception:
            return val


@dataclass
class MyNamespaceObject7(Struct):
    name: str


FORWARD_REFS["Object7"] = Object7


@dataclass
class MyNamespaceStudent(Struct):
    id: int
    name: str
    peers: Union[List["Student"], None]


FORWARD_REFS["Student"] = Student


@dataclass
class MyNamespaceTwoInput(Struct):
    name: str


FORWARD_REFS["TwoInput"] = TwoInput


Type8Student = List["Student"]
TypeString6 = str

def __repr(value: Any):
    if isinstance(value, Struct):
        return value.repr()
    return value



def typed_fnOne(user_fn: Callable[[Object7], Type8Student]):
    def exported_wrapper(raw_inp):
        inp: Object7 = Struct.new(Object7, raw_inp)
        out: Type8Student = user_fn(inp)
        if isinstance(out, list):
            return [__repr(v) for v in out]
        return __repr(out)

    return exported_wrapper


def typed_fnTwo(user_fn: Callable[[TwoInput], TypeString6]):
    def exported_wrapper(raw_inp):
        inp: TwoInput = Struct.new(TwoInput, raw_inp)
        out: TypeString6 = user_fn(inp)
        if isinstance(out, list):
            return [__repr(v) for v in out]
        return __repr(out)

    return exported_wrapper


',
    overwrite: true,
    path: "tests/metagen/typegraphs/some/base/path/python/same_hit_types.py",
  },
  {
    content: '# - NOTE: only modules that are imported relatively
#   are supported. I.e. prefixed by \`.\` or \`..\`
# - Make sure to include any module imports in the \`deps\`
#   array when using external modules with PythonRuntime 
from .same_hit_types import Object7, TwoInput, Type8Student, TypeString6, typed_fnOne, typed_fnTwo


@typed_fnOne
def fnOne(inp: Object7) -> Type8Student:
    # TODO: write your logic here
    raise Exception("fnOne not implemented")

@typed_fnTwo
def fnTwo(inp: TwoInput) -> TypeString6:
    # TODO: write your logic here
    raise Exception("fnTwo not implemented")

',
    overwrite: false,
    path: "tests/metagen/typegraphs/some/base/path/python/same_hit.py",
  },
]
`;

snapshot[`Metagen within sdk with custom template 2`] = `
[
  {
    content: 'from types import NoneType
from typing import Callable, List, Union, get_origin, ForwardRef, Any
from dataclasses import dataclass, asdict, fields

FORWARD_REFS = {}

class Struct:
    def repr(self):
        return asdict(self)

    @staticmethod
    def try_new(dt_class, val: Any):
        # Object
        ftypes = {f.name: f.type for f in fields(dt_class)}
        attrs = {}
        for f in val:
            fval = val[f]
            ftype = ftypes[f]
            serialized = False
            # Union
            if get_origin(ftype) is Union:
                try:
                    attrs[f] = Struct.try_union(ftype.__args__, fval)
                    serialized = True
                except Exception:
                    pass
            # List
            elif get_origin(ftype) is list:
                try:
                    attrs[f] = Struct.try_typed_list(ftype.__args__, fval)
                    serialized = True
                except Exception:
                    pass
            # Any
            if not serialized:
                if isinstance(ftype, str) and ftype in FORWARD_REFS:
                    klass = FORWARD_REFS[ftype]
                    attrs[f] = Struct.new(klass, fval)
                else:
                    attrs[f] = Struct.new(ftype, fval)
        return dt_class(**attrs)

    @staticmethod
    def try_typed_list(tpe: Any, items: Any):
        hint = tpe.__args__[0]
        klass = (
            FORWARD_REFS[hint.__forward_arg__] if isinstance(hint, ForwardRef) else hint
        )
        return [Struct.new(klass, v) for v in items]

    @staticmethod
    def try_union(variants: List[Any], val: Any):
        errors = []
        for variant in variants:
            try:
                if variant is NoneType:
                    if val is None:
                        return None
                    else:
                        continue
                if get_origin(variant) is list:
                    if isinstance(val, list):
                        return Struct.try_typed_list(variant, val)
                    else:
                        continue
                klass = FORWARD_REFS[variant.__forward_arg__]
                return Struct.try_new(klass, val)
            except Exception as e:
                errors.append(str(e))
        raise Exception("\\\\n".join(errors))

    @staticmethod
    def new(dt_class: Any, val: Any):
        try:
            return Struct.try_new(dt_class, val)
        except Exception:
            return val


@dataclass
class MyNamespaceObject7(Struct):
    name: str


FORWARD_REFS["Object7"] = Object7


@dataclass
class MyNamespaceStudent(Struct):
    id: int
    name: str
    peers: Union[List["Student"], None]


FORWARD_REFS["Student"] = Student



def __repr(value: Any):
    if isinstance(value, Struct):
        return value.repr()
    return value



def typed_three(user_fn: Callable[[Object7], Student]):
    def exported_wrapper(raw_inp):
        inp: Object7 = Struct.new(Object7, raw_inp)
        out: Student = user_fn(inp)
        if isinstance(out, list):
            return [__repr(v) for v in out]
        return __repr(out)

    return exported_wrapper


',
    overwrite: true,
    path: "tests/metagen/typegraphs/some/base/path/python/other_types.py",
  },
  {
    content: '# - NOTE: only modules that are imported relatively
#   are supported. I.e. prefixed by \`.\` or \`..\`
# - Make sure to include any module imports in the \`deps\`
#   array when using external modules with PythonRuntime 
from .other_types import Object7, Student, typed_three


@typed_three
def three(inp: Object7) -> Student:
    # TODO: write your logic here
    raise Exception("three not implemented")

',
    overwrite: false,
    path: "tests/metagen/typegraphs/some/base/path/python/other.py",
  },
  {
    content: 'from types import NoneType
from typing import Callable, List, Union, get_origin, ForwardRef, Any
from dataclasses import dataclass, asdict, fields

FORWARD_REFS = {}

class Struct:
    def repr(self):
        return asdict(self)

    @staticmethod
    def try_new(dt_class, val: Any):
        # Object
        ftypes = {f.name: f.type for f in fields(dt_class)}
        attrs = {}
        for f in val:
            fval = val[f]
            ftype = ftypes[f]
            serialized = False
            # Union
            if get_origin(ftype) is Union:
                try:
                    attrs[f] = Struct.try_union(ftype.__args__, fval)
                    serialized = True
                except Exception:
                    pass
            # List
            elif get_origin(ftype) is list:
                try:
                    attrs[f] = Struct.try_typed_list(ftype.__args__, fval)
                    serialized = True
                except Exception:
                    pass
            # Any
            if not serialized:
                if isinstance(ftype, str) and ftype in FORWARD_REFS:
                    klass = FORWARD_REFS[ftype]
                    attrs[f] = Struct.new(klass, fval)
                else:
                    attrs[f] = Struct.new(ftype, fval)
        return dt_class(**attrs)

    @staticmethod
    def try_typed_list(tpe: Any, items: Any):
        hint = tpe.__args__[0]
        klass = (
            FORWARD_REFS[hint.__forward_arg__] if isinstance(hint, ForwardRef) else hint
        )
        return [Struct.new(klass, v) for v in items]

    @staticmethod
    def try_union(variants: List[Any], val: Any):
        errors = []
        for variant in variants:
            try:
                if variant is NoneType:
                    if val is None:
                        return None
                    else:
                        continue
                if get_origin(variant) is list:
                    if isinstance(val, list):
                        return Struct.try_typed_list(variant, val)
                    else:
                        continue
                klass = FORWARD_REFS[variant.__forward_arg__]
                return Struct.try_new(klass, val)
            except Exception as e:
                errors.append(str(e))
        raise Exception("\\\\n".join(errors))

    @staticmethod
    def new(dt_class: Any, val: Any):
        try:
            return Struct.try_new(dt_class, val)
        except Exception:
            return val


@dataclass
class MyNamespaceObject7(Struct):
    name: str


FORWARD_REFS["Object7"] = Object7


@dataclass
class MyNamespaceStudent(Struct):
    id: int
    name: str
    peers: Union[List["Student"], None]


FORWARD_REFS["Student"] = Student


@dataclass
class MyNamespaceTwoInput(Struct):
    name: str


FORWARD_REFS["TwoInput"] = TwoInput


Type8Student = List["Student"]
TypeString6 = str

def __repr(value: Any):
    if isinstance(value, Struct):
        return value.repr()
    return value



def typed_fnOne(user_fn: Callable[[Object7], Type8Student]):
    def exported_wrapper(raw_inp):
        inp: Object7 = Struct.new(Object7, raw_inp)
        out: Type8Student = user_fn(inp)
        if isinstance(out, list):
            return [__repr(v) for v in out]
        return __repr(out)

    return exported_wrapper


def typed_fnTwo(user_fn: Callable[[TwoInput], TypeString6]):
    def exported_wrapper(raw_inp):
        inp: TwoInput = Struct.new(TwoInput, raw_inp)
        out: TypeString6 = user_fn(inp)
        if isinstance(out, list):
            return [__repr(v) for v in out]
        return __repr(out)

    return exported_wrapper


',
    overwrite: true,
    path: "tests/metagen/typegraphs/some/base/path/python/same_hit_types.py",
  },
  {
    content: '# - NOTE: only modules that are imported relatively
#   are supported. I.e. prefixed by \`.\` or \`..\`
# - Make sure to include any module imports in the \`deps\`
#   array when using external modules with PythonRuntime 
from .same_hit_types import Object7, TwoInput, Type8Student, TypeString6, typed_fnOne, typed_fnTwo


@typed_fnOne
def fnOne(inp: Object7) -> Type8Student:
    # TODO: write your logic here
    raise Exception("fnOne not implemented")

@typed_fnTwo
def fnTwo(inp: TwoInput) -> TypeString6:
    # TODO: write your logic here
    raise Exception("fnTwo not implemented")

',
    overwrite: false,
    path: "tests/metagen/typegraphs/some/base/path/python/same_hit.py",
  },
]
`;
