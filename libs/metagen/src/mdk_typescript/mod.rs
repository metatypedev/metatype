// Copyright Metatype OÃœ, licensed under the Mozilla Public License Version 2.0.
// SPDX-License-Identifier: MPL-2.0

pub mod types;
pub mod utils;

use core::fmt::Write;

use crate::interlude::*;
use crate::shared::*;
use crate::*;

use crate::utils::GenDestBuf;

use self::shared::types::NameMemo;
use self::shared::types::TypeRenderer;

#[derive(Serialize, Deserialize, Debug, garde::Validate)]
pub struct MdkTypescriptGenConfig {
    #[serde(flatten)]
    #[garde(dive)]
    pub base: crate::config::MdkGeneratorConfigBase,
    /// Runtimes to generate stubbed materializer implementations for.
    #[garde(skip)]
    pub stubbed_runtimes: Option<Vec<String>>,
}

impl MdkTypescriptGenConfig {
    pub fn from_json(json: serde_json::Value, workspace_path: &Path) -> anyhow::Result<Self> {
        let mut config: MdkTypescriptGenConfig = serde_json::from_value(json)?;
        config.base.path = workspace_path.join(config.base.path);
        config.base.typegraph_path = config
            .base
            .typegraph_path
            .as_ref()
            .map(|path| workspace_path.join(path));
        Ok(config)
    }
}

pub struct Generator {
    config: MdkTypescriptGenConfig,
}

impl Generator {
    pub const INPUT_TG: &'static str = "tg_name";
    pub fn new(config: MdkTypescriptGenConfig) -> Result<Self, garde::Report> {
        use garde::Validate;
        config.validate(&())?;
        Ok(Self { config })
    }
}

impl crate::Plugin for Generator {
    fn bill_of_inputs(&self) -> HashMap<String, GeneratorInputOrder> {
        [(
            Self::INPUT_TG.to_string(),
            if let Some(tg_name) = &self.config.base.typegraph_name {
                GeneratorInputOrder::TypegraphFromTypegate {
                    name: tg_name.clone(),
                }
            } else if let Some(tg_path) = &self.config.base.typegraph_path {
                GeneratorInputOrder::TypegraphFromPath {
                    path: tg_path.clone(),
                    name: self.config.base.typegraph_name.clone(),
                }
            } else {
                unreachable!()
            },
        )]
        .into_iter()
        .collect()
    }

    fn generate(
        &self,
        inputs: HashMap<String, GeneratorInputResolved>,
    ) -> anyhow::Result<GeneratorOutput> {
        let tg = match inputs
            .get(Self::INPUT_TG)
            .context("missing generator input")?
        {
            GeneratorInputResolved::TypegraphFromTypegate { raw } => raw,
            GeneratorInputResolved::TypegraphFromPath { raw } => raw,
        };
        let mut out = HashMap::new();
        out.insert(
            self.config.base.path.join("mdk.ts"),
            GeneratedFile {
                contents: render_mdk_ts(&self.config, tg)?,
                overwrite: true,
            },
        );

        Ok(GeneratorOutput(out))
    }
}

fn render_mdk_ts(config: &MdkTypescriptGenConfig, tg: &Typegraph) -> anyhow::Result<String> {
    let mut mdk_ts = GenDestBuf {
        buf: Default::default(),
    };
    writeln!(
        &mut mdk_ts,
        "// This file was @generated by metagen and is intended"
    )?;
    writeln!(
        &mut mdk_ts,
        "// to be generated again on subsequent metagen runs."
    )?;
    writeln!(&mut mdk_ts)?;
    gen_static(&mut mdk_ts)?;
    let ty_name_memo = render_types(&mut mdk_ts, tg)?;
    writeln!(&mut mdk_ts)?;
    {
        let stubbed_rts = config
            .stubbed_runtimes
            .clone()
            .unwrap_or_else(|| vec!["deno".to_string()]);
        let stubbed_funs = filter_stubbed_funcs(tg, &stubbed_rts).wrap_err_with(|| {
            format!("error collecting materializers for runtimes {stubbed_rts:?}")
        })?;
        for fun in &stubbed_funs {
            let TypeNode::Function { base, data } = &fun.node else {
                unreachable!()
            };
            let inp_ty = ty_name_memo
                .get(&data.input)
                .context("input type for function not found")?;
            let out_ty = ty_name_memo
                .get(&data.output)
                .context("output type for function not found")?;
            let type_name: String = utils::normalize_type_title(&base.title);
            writeln!(
                &mut mdk_ts,
                "export type {type_name}Handler = Handler<{inp_ty}, {out_ty}>;"
            )?;
        }
    }
    Ok(mdk_ts.buf)
}

fn gen_static(dest: &mut GenDestBuf) -> core::fmt::Result {
    let mdk_ts = include_str!("static/mdk.ts");
    writeln!(dest, "{}", mdk_ts)?;
    Ok(())
}

fn render_types(dest: &mut GenDestBuf, tg: &Typegraph) -> anyhow::Result<NameMemo> {
    let mut renderer = TypeRenderer::new(
        tg.types.iter().cloned().map(Rc::new).collect::<Vec<_>>(),
        Rc::new(types::TypescriptTypeRenderer {}),
    );
    // remove the root type which we don't want to generate types for
    // TODO: gql types || function wrappers for exposed functions
    // skip object 0, the root object where the `exposed` items are locted
    for id in 1..tg.types.len() {
        _ = renderer.render(id as u32)?;
    }
    let (types_ts, name_memo) = renderer.finalize();
    writeln!(dest.buf, "{}", types_ts)?;
    Ok(name_memo)
}

#[test]
fn e2e() -> anyhow::Result<()> {
    use crate::tests::*;

    let tg_name = "gen-test";
    let config = config::Config {
        targets: [(
            "default".to_string(),
            config::Target(
                [GeneratorConfig {
                    generator_name: "mdk_typescript".to_string(),
                    other: serde_json::to_value(mdk_typescript::MdkTypescriptGenConfig {
                        stubbed_runtimes: Some(vec!["deno".into()]),
                        base: config::MdkGeneratorConfigBase {
                            typegraph_name: Some(tg_name.into()),
                            typegraph_path: None,
                            // NOTE: root will map to the test's tempdir
                            path: "./".into(),
                        },
                    })?,
                }]
                .into_iter()
                .collect(),
            ),
        )]
        .into_iter()
        .collect(),
    };
    tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .thread_stack_size(16 * 1024 * 1024)
        .build()?
        .block_on(async {
            let tg = test_typegraph_1().await?;
            e2e_test(vec![E2eTestCase {
                typegraphs: [(tg_name.to_string(), tg)].into_iter().collect(),
                target: "default".into(),
                config,
                build_fn: |args| {
                    Box::pin(async move {
                        let status = tokio::process::Command::new("deno")
                            .args("check mdk.ts".split(' ').collect::<Vec<_>>())
                            .current_dir(&args.path)
                            .kill_on_drop(true)
                            .spawn()?
                            .wait()
                            .await?;
                        if !status.success() {
                            anyhow::bail!("error checking generated crate");
                        }
                        let status = tokio::process::Command::new("deno")
                            .args("lint mdk.ts".split(' ').collect::<Vec<_>>())
                            .current_dir(&args.path)
                            .kill_on_drop(true)
                            .spawn()?
                            .wait()
                            .await?;
                        if !status.success() {
                            anyhow::bail!("error lint generated crate");
                        }
                        Ok(())
                    })
                },
                target_dir: None,
            }])
            .await
        })?;
    Ok(())
}
