{"searchDocs":[{"title":"Emulating your server nodes locally","type":0,"sectionRef":"#","url":"/blog/2023/03/15/emulating-servers","content":"","keywords":"","version":null},{"title":"Introducing the Embedded Typegate​","type":1,"pageTitle":"Emulating your server nodes locally","url":"/blog/2023/03/15/emulating-servers#introducing-the-embedded-typegate","content":" The embedded typegate is a feature that comes with the Meta CLI which provides the option of spinning a typegate instance from the CLI with minimum configurations and installations needed from the developer. All that is required to access the Embedded Typegate is to install Meta CLI. The spawned typegate instance behaves similarly to cloud-deployed typegates.  ","version":null,"tagName":"h2"},{"title":"The motive​","type":1,"pageTitle":"Emulating your server nodes locally","url":"/blog/2023/03/15/emulating-servers#the-motive","content":" There are more than a couple of reasons why a developer would be tempted to use an emedded typegate. While developers can start a typegate instance using docker compose, the developer needs to install docker as a dependency to run the typegate container. Even though docker is familiar among many developers, it can sometimes be tricky and unbeknownst to some developers. We at metatype highly value the developer experience and one reason for adding the embedded typegate feature to the Meta CLI is for users to have a smooth experience with our system by providing a docker compose free experience. This feature provides a great utility for developers to author and test typegraphs in their local machine before deploying them to production level typegate instances on the cloud. Additionally, developers need not concern themselves with deployment configurations which are needed only during deployment. The only need to focus their energy and time in developing the right application and easily test them on embedded typegate running from the terminal. To add more to what is said, as the typegate engine keeps evolving, users will be abstracted away from the different configurations which might be added on the future. The Meta CLI will abstract much of what's not needed in a dev environment. Thus, leaving less headaches to developers on new changes. Ultimately, The embedded typegate is designed to be a good dev environment friendly tool which faciliates development time.  ","version":null,"tagName":"h2"},{"title":"Quick First hand example​","type":1,"pageTitle":"Emulating your server nodes locally","url":"/blog/2023/03/15/emulating-servers#quick-first-hand-example","content":" ","version":null,"tagName":"h2"},{"title":"Install the v0.3.x series​","type":1,"pageTitle":"Emulating your server nodes locally","url":"/blog/2023/03/15/emulating-servers#install-the-v03x-series","content":" Either of the two Typegraph SDKs are needed to author typegraphs. For this example, the node SDK will be used.  First, make sure the Meta CLI is installed.  curl -fsSL https://raw.githubusercontent.com/metatypedev/metatype/main/installer.sh | bash   Next, create a new node project using this command.  meta new --template node   The above command will create a sample typegraph which you can use to test the embedded typegate.  Now, you need to install the typegraph SDK by running the command down below. The previous command generates a package.json with the SDK specified as a dependency.  npm install   Before deploying the typegraph to the embedded typegate, Run the following commands below.  meta dev   Now that there is running instance of a typegate, you can deploy the example typegraph. From another terminal, run the command below.  meta deploy -f api/example.ts --allow-dirty --create-migration --target dev --gate http://localhost:7890   The typegate runs on port 7890 by default. If you access http://localhost:7890/example on your browser, you can see an GraphQL interface to interact with the deployed typegraph. You can test the example typegraph using the following graphql query below.  query { multilpy(first: 3, second: 5) }     ","version":null,"tagName":"h3"},{"title":"Upgrade your Metatype development environment​","type":1,"pageTitle":"Emulating your server nodes locally","url":"/blog/2023/03/15/emulating-servers#upgrade-your-metatype-development-environment","content":" To Upgrade the Meta CLI to the latest version, you can run the following command below.  meta upgrade   Typescript SDK Python SDK To upgrade the Typescript SDK of the typegraph package, you can use one of the following commands: Node npm update @typegraph/sdk Deno deno cache --reload &quot;npm:@typegraph/sdk&quot;   ","version":null,"tagName":"h2"},{"title":"Learn more about Metatype​","type":1,"pageTitle":"Emulating your server nodes locally","url":"/blog/2023/03/15/emulating-servers#learn-more-about-metatype","content":" Wanna dive deep into the basics of Metaype? check our interactive tutorial revolving around the core features of the system. ","version":null,"tagName":"h2"},{"title":"Programmable glue for developers","type":0,"sectionRef":"#","url":"/blog/2023/06/18/programmable-glue","content":"","keywords":"","version":null},{"title":"What is Metatype?​","type":1,"pageTitle":"Programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#what-is-metatype","content":" Metatype is an open source platform to author and deploy APIs for the cloud and components eras. It provides a declarative programming model that helps you to efficiently design APIs and focus on the functional requirements.  The runtime embraces WebAssembly (WASM) as a first-class citizen to allow you to write your business logic in the language of your choice and run it on-demand. Those &quot;backend components&quot; are reusable across your stacks and deployable without pipelines or containers.  The platform provides a set of capabilities out of the box:  create/read/update/delete data in your databasestoring files in your cloud storageauthenticate users with different providers or using JWTsconnecting to third-party/internal APIs  And offers an opportunity to climb the one step higher in the abstraction ladder and drastically simplify the building of great APIs and systems!      Metatype is designed to be as simple as possible and horizontally scalable in existing container orchestration solution like Kubernetes. It consists of multiple parts, including:  Typegraph: a cross-language SDK to manage typegraphs - virtual graphs of types - and compose themTypegate: a serverless GraphQL/REST gateway to execute queries over typegraphsMeta CLI: a command-line tool to efficiently deploy the typegraphs on the gateway    ","version":null,"tagName":"h2"},{"title":"What are virtual graphs?​","type":1,"pageTitle":"Programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#what-are-virtual-graphs","content":" Typegraphs are a declarative way to expose all APIs, storage and business logic of your stack as a single graph. They take inspiration from domain-driven design principles and in the idea that the relation between of the data is as important as data itself, even though they might be in different locations or shapes.  Loading...  These elements can then be combined and composed together similarly on how you would compose web components to create an interface in modern frontend practices. This allows developers to build modular and strongly typed APIs using typegraph as a programmable glue.  ","version":null,"tagName":"h2"},{"title":"Where does this belong in the tech landscape?​","type":1,"pageTitle":"Programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#where-does-this-belong-in-the-tech-landscape","content":" Before Metatype, there was a gap in the technological landscape for a solution that specifically addressed the transactional, short-lived use cases. While there were existing tools for analytical or long-running use cases, such as Trino and Temporal, there was no generic engine for handling transactional, short-lived tasks.  \t← individual entities transactional\tlarge data → analytical instantaneous ↑ short-lived\tMetatype composition engine for entities in evolving systems\tTrino query engine for large data from multiples sources long-running asynchronous ↓\tTemporal workflow orchestration for long-running operations\tSpark batch/streaming engine for large data processing  ","version":null,"tagName":"h2"},{"title":"Give it a try!​","type":1,"pageTitle":"Programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#give-it-a-try","content":" Let us know what you think! Metatype is open source and we welcome any feedback or contributions. The community primarily lives on GitHub.  Next steps Build your first typegraph or read more about the concepts behind Metatype. ","version":null,"tagName":"h2"},{"title":"The Node/Deno SDK is now available","type":0,"sectionRef":"#","url":"/blog/2023/11/27/node-compatibility","content":"","keywords":"","version":null},{"title":"Meet wit​","type":1,"pageTitle":"The Node/Deno SDK is now available","url":"/blog/2023/11/27/node-compatibility#meet-wit","content":" In the realm of WebAssembly, the wit-bindgen project emerges as the most mature tool to create and maintain the language bindings for WebAssembly modules. This tool introduces WIT (WebAssembly Interface Types) as an Interface Definition Language (IDL) to describe the imports, exports, and capabilities of WebAssembly components seamlessly.  For example, Metatype implements the reactor pattern to handle requests as they come and delegate part of their execution in correct WASM runtime. The wit-bindgen helps there to define the interfaces between the guest (the Metatype runtime) and the host (the typegate) to ensure the correct serialization of the payloads. The wit definition could look like this:  package metatype:wit-wire; interface typegate-wire { hostcall: func(op-name: string, json: string) -&gt; result&lt;string, string&gt;; } interface mat-wire { record handle-req { op-name: string, in-json: string, } handle: func(req: handle-req) -&gt; result&lt;string, string&gt;; } world wit-wire { import typegate-wire; export mat-wire; }   The wit file is then used to generate the bindings for the host and the guest in Rust, TypeScript, Python, and other languages. The host bindings are used in the typegate to call the WASM runtime, and the guest bindings are used in the WASM runtime to call the typegate.  ","version":null,"tagName":"h2"},{"title":"Install the v0.2.x series​","type":1,"pageTitle":"The Node/Deno SDK is now available","url":"/blog/2023/11/27/node-compatibility#install-the-v02x-series","content":" The documentation contains now examples for Node and Deno.  ","version":null,"tagName":"h2"},{"title":"Upgrade with Node​","type":1,"pageTitle":"The Node/Deno SDK is now available","url":"/blog/2023/11/27/node-compatibility#upgrade-with-node","content":" npm install @typegraph/sdk meta new --template node .   ","version":null,"tagName":"h3"},{"title":"Upgrade with Deno​","type":1,"pageTitle":"The Node/Deno SDK is now available","url":"/blog/2023/11/27/node-compatibility#upgrade-with-deno","content":" meta new --template deno .   import { typegraph } from &quot;npm:@typegraph/sdk/index.js&quot;;   ","version":null,"tagName":"h3"},{"title":"Upgrade with Python​","type":1,"pageTitle":"The Node/Deno SDK is now available","url":"/blog/2023/11/27/node-compatibility#upgrade-with-python","content":" pip3 install --upgrade typegraph poetry add typegraph@latest   ","version":null,"tagName":"h3"},{"title":"Give us feedback!​","type":1,"pageTitle":"The Node/Deno SDK is now available","url":"/blog/2023/11/27/node-compatibility#give-us-feedback","content":" This new release enables us to provide a consistent experience across all languages and reduce the work to maintain the existing Python SDK.  As always, report issues and let us know what you think on GitHub. ","version":null,"tagName":"h2"},{"title":"Programmatic deployment (v0.4.x)","type":0,"sectionRef":"#","url":"/blog/2024/05/09/programmatic-deployment","content":"","keywords":"","version":null},{"title":"What has changed?​","type":1,"pageTitle":"Programmatic deployment (v0.4.x)","url":"/blog/2024/05/09/programmatic-deployment#what-has-changed","content":" Before v0.4.x, we had to entirely rely on the meta cli to deploy typegraphs to a typegate instance.  This is no longer the case, as all core logic has been moved to the TypeScript/Python typegraph SDKs, both of which share the same WebAssembly-based typegraph-core behind the scenes. This provides some degree of assurance that you will have nearly identical experiences with each SDK.  ","version":null,"tagName":"h2"},{"title":"What are the use-cases?​","type":1,"pageTitle":"Programmatic deployment (v0.4.x)","url":"/blog/2024/05/09/programmatic-deployment#what-are-the-use-cases","content":" Since typegraphs can be written using the programming language your preferred SDK is based on, you can dynamically create typegraphs with ease.  The missing piece was having an interface natively backed inside the SDK for doing deployment programmatically.  ","version":null,"tagName":"h2"},{"title":"Programmatic deployment​","type":1,"pageTitle":"Programmatic deployment (v0.4.x)","url":"/blog/2024/05/09/programmatic-deployment#programmatic-deployment","content":" ","version":null,"tagName":"h3"},{"title":"Initial setup​","type":1,"pageTitle":"Programmatic deployment (v0.4.x)","url":"/blog/2024/05/09/programmatic-deployment#initial-setup","content":" Just like any other dependency in your favorite programming language, each SDKs can be installed with your favorite package manager.  You can use one of the commands below to get started with the latest available version.  Typescript SDK Python SDK To upgrade the Typescript SDK of the typegraph package, you can use one of the following commands: Node npm update @typegraph/sdk Deno deno cache --reload &quot;npm:@typegraph/sdk&quot;   Configuration​  This is analoguous to the yaml configuration file when you are using meta cli.  It's the place where you tell which typegate you want to deploy to, how you want the artifacts to be resolved, among other settings.  Typescript SDK Python SDK const config = { typegate: { url: &quot;&lt;TYPEGATE_URL&gt;&quot;, auth: new BasicAuth(&quot;&lt;USERNAME&gt;&quot;, &quot;&lt;PASSWORD&gt;&quot;), }, typegraphPath: path.join(cwd, &quot;path-to-typegraph.ts&quot;), prefix: &quot;&quot;, secrets: { POSTGRES: &quot;&lt;DB_URL&gt;&quot; }, migrationsDir: path.join(&quot;prisma-migrations&quot;, tg.name), defaultMigrationAction: { create: true, reset: true, // allow destructive migrations }, };   ","version":null,"tagName":"h3"},{"title":"Deploy/remove​","type":1,"pageTitle":"Programmatic deployment (v0.4.x)","url":"/blog/2024/05/09/programmatic-deployment#deployremove","content":" Now, picture this, you have a lot of typegraphs and one or more typegate instance(s) running, you can easily make small scripts that does any specific job you want.  // .. import { tgDeploy, tgRemove } from &quot;@typegraph/sdk/tg_deploy.js&quot;; // .. const BASIC_AUTH = loadMyAuthsFromSomeSource(); const TYPEGATE_URL = &quot;...&quot;; export async function getTypegraphs() { // Suppose we have these typegraphs.. // Let's enumerate them like this to simplify return [ { tg: await import(&quot;path/to/shop-finances&quot;), location: &quot;path/to/shop-finances.ts&quot;, }, { tg: await import(&quot;path/to/shop-stats&quot;), location: &quot;path/to/shop-stats.ts&quot;, }, ]; } export function getConfig(tgName: string, tgLocation: string) { // Note: You can always develop various ways of constructing the configuration, // like loading it from a file. return { typegate: { url: &quot;&lt;TYPEGATE_URL&gt;&quot;, auth: new BasicAuth(&quot;&lt;USERNAME&gt;&quot;, &quot;&lt;PASSWORD&gt;&quot;), }, typegraphPath: path.join(cwd, &quot;path-to-typegraph.ts&quot;), prefix: &quot;&quot;, secrets: { POSTGRES: &quot;&lt;DB_URL&gt;&quot; }, migrationsDir: path.join(&quot;prisma-migrations&quot;, tg.name), defaultMigrationAction: { create: true, reset: true, // allow destructive migrations }, }; } export async function deployAll() { const typegraphs = await getTypegraphs(); for (const { tg, location } of typegraphs) { try { const config = getConfig(tg.name, location); // use tgDeploy to deploy typegraphs, it will contain the response from typegate const { typegate } = await tgDeploy(tg, config); const selection = typegate?.data?.addTypegraph; if (selection) { const { messages } = selection; console.log(messages.map(({ text }) =&gt; text).join(&quot;\\n&quot;)); } else { throw new Error(JSON.stringify(typegate)); } } catch (e) { console.error(&quot;[!] Failed deploying&quot;, tg.name); console.error(e); } } } export async function undeployAll() { const typegraphs = await getTypegraphs(); for (const { tg } of typegraphs) { try { // use tgRemove to remove typegraphs const { typegate } = await tgRemove(&quot;&lt;TYPEGRAPH_NAME&gt;&quot;, { baseUrl: TYPEGATE_URL, auth: BASIC_AUTH, }); console.log(typegate); } catch (e) { console.error(&quot;Failed removing&quot;, tg.name); console.error(e); } } }   ","version":null,"tagName":"h3"},{"title":"Going beyond​","type":1,"pageTitle":"Programmatic deployment (v0.4.x)","url":"/blog/2024/05/09/programmatic-deployment#going-beyond","content":" With these new additions, you can automate virtually anything programmatically on the typegraph side. Starting from having highly dynamic APIs to providing ways to deploy and configure them, you can even build a custom framework around the ecosystem!  Please tell us what you think and report any issues you found on Github.  Notes You can check the Programmatic deployment reference page for more information. ","version":null,"tagName":"h3"},{"title":"Python on WebAssembly: How?","type":0,"sectionRef":"#","url":"/blog/2024/08/26/python-on-webassembly","content":"","keywords":"","version":null},{"title":"Why?​","type":1,"pageTitle":"Python on WebAssembly: How?","url":"/blog/2024/08/26/python-on-webassembly#why","content":" You have probably heard of &quot;Function as a Service&quot; or FaaS. In simple terms, FaaS are platforms that allow users to run code in response to events without the hassle of managing the underlying infrastructure. Users submit their programs and the platform takes care of the rest including, usually, scaling, availability, and configuration. AWS Lambda is one such example and FaaS as a whole are a popular implementation of the serverless model.  Metatype has this model at heart with applications composed of small functions that respond to events like http requests and authorization checks. This is achieved through runtimes like the DenoRuntime which implements a way to execute functions authored in Typescript using Web Workers as implemented by Deno (not based on Deno Deploy).  note Metatype supports running multiple apps or typegraphs on a single deployed cluster but we're still in the kitchen on a hosted cloud solution. Subscribe to the blog or the Github repository for updates.  Implementing the DenoRuntime was a very straightforward affair as the Typegate (the engine at the heart of Metatype) is primarily written in Typescript and runs on a slightly modified version of the Deno runtime. What's more, JavaScript has single threaded and asynchronous semantics and the v8 engine that it commonly runs on is of very high-quality by all regards. These qualities lend themselves very well to the requirements of running a serverless platform like security (good sandboxing) and performance (low start-up latencies). This fact is reflected in the dominance of JavaScript in the serverless market though it doesn't hurt that it's also the most popular language in use today.  Another very popular language is Python; and its standard library can be quite resourceful for this type of use case. However, as we shall see, integrating the Python runtime isn't as simple as integrating Deno.  ","version":null,"tagName":"h2"},{"title":"What are the requirements?​","type":1,"pageTitle":"Python on WebAssembly: How?","url":"/blog/2024/08/26/python-on-webassembly#what-are-the-requirements","content":" There are a number of Python runtimes available but a set of extra factors limit what we can achieve.  Security: functions should have limited access to the execution environment. Python doesn't have built-in features for sandboxing out of the box unlike Deno.Speed: functions should run fast and with low latency. We're interested in metrics like cold-start latency and overhead of any cross process/system communication.User-friendliness: functionalities provided in any of the languages supported by Metatype should, within reason, mirror each other and maintain a degree of uniformity. We support inline code snippets and external file references for DenoRuntime and this should be the case for Python as well.Interoperability: functions running in Python will need to have access to other parts of the app running on the Typegate like being able to invoke other functions.  The Typegate is a TypeScript program with a bit of Rust sprinkled in. It runs as a traditional POSIX process. Think Linux containers. This fact renders multi-processing, one of the readily apparent approaches, undesirable as it would require investing is robust worker process management and distribution schemes. It'd be great if we could keep everything inside the Typegate process.  One solution that presents itself here is the PyO3 project which provide Rust bindings to different Python runtimes like CPython and PyPy. It'd not only allow us to run Python code in-process but it also provide an easy way to expose the functions written in Rust to Python and vice-versa. A good solution for the bidirectional communication needed for our interoperability requirements.  Unfortunately, PyO3 doesn't have any provisions for sandboxing which is critical for our use case. This is where WebAssembly enters into the picture. WebAssembly or Wasm for short is a executable bytecode format that originates from the web world and is designed for applications that run inside web-browsers. This use case shares most of our requirements and the Wasm world promises excellent sandboxing properties that should be perfect for our use case. We just have to find a way to run Python inside of it.  ","version":null,"tagName":"h2"},{"title":"An aside on WASI​","type":1,"pageTitle":"Python on WebAssembly: How?","url":"/blog/2024/08/26/python-on-webassembly#an-aside-on-wasi","content":" WebAssembly System Interface (WASI) is an additional spec for the bytecode format that formalizes how Wasm programs access their host environment. A lot like POSIX, this generally means OS capabilities such as file system access and networking but also, in it's latest iteration extends to any custom host defined functionality.  Wasm + WASI fits very well to our use case. As opposed to mutli-processing, we can instantiate, manage, and expose resources programmatically with ease. And as luck would have it, some community work has already been done at the time that led to wasm builds of CPython being available.  Unfortunately, the WASI spec itself is a work in progress. When we started out, only the limited &quot;preview1&quot; implementation was supported by most runtimes.preview1 only focused on a standard set of host functionalities much like a libc implementation. Well enough but any custom functionality meant having to rely on simple C ABI alike functions for intra-process communication. In order to make this work easier, we elected to bring PyO3 back into the picture so that all the IPC stuff is written in Rust, the language with the most support in the Wasm ecosystem today.  All in all, this would mean the python interpreter wrapped in a PyO3 based native API. An assembly that accepts user code as strings and then invokes them in response to events. All of this would be running inside a Wasm runtime, WasmEdge in this case, which ticks of all of the sandboxing and security requirements. This approach is well described as the Reactor pattern, a common pattern used in Wasm land.    ","version":null,"tagName":"h2"},{"title":"File system access​","type":1,"pageTitle":"Python on WebAssembly: How?","url":"/blog/2024/08/26/python-on-webassembly#file-system-access","content":" Since the PyO3 project doesn't support statically linking the Python runtime, we'll need to find a way dynamically link libpython. Thankfully, Wasm does support dynamic linking and wasm builds of libpython are available curtsy of the WebAssembly Language Runtimes project. Bringing all of this together isn't as simple though as PyO3's tries to load libpython from certain paths, a concept that isn't exactly clearly defined in Wasm's post POSIX webtopia.  Our first solution was to use wasi-vfs, a tool which allows you to embed a virtual file system, accessible through preview1 APIs, directly into your wasm binaries. This way, we could prepare a single wasm artifact that contains both the libpython build and the custom glue code.  This approach turned out to be quite hacky though and after encountering several issues, we ultimately decided to go with preopens. Preopens are another virtual file-system solution where you map an actual file-system directory to a virtual directory visible to a running Wasm instance. This means we'll need to prepare the libpython Wasm file on disk before running the instance but it was an acceptable solution. We also use preopens to provide some of the user submitted code to our custom python runtime.  The following rust snippet demonstrates the preopens looked like in use:  fn init_Python_vm() -&gt; Result&lt;Rt&gt; { let preopens = vec![ // User script will be uploaded at ./src/Python which is virtually seen as /app // Each script has access only to /app &quot;/app:./src/Python:readonly&quot;.to_owned() ]; // This follow the same idea as above, but for clarity's sake we decided to separate it let pylib = PathBuf::from(&quot;./vendor/libpython/usr/local/lib&quot;); // This is our wasm module reponsible for running Python scripts at runtime // It assumes /app and libpython to be available in its world let wasi_mod = PathBuf::from(&quot;./build/Python-wasi-reactor.wasm&quot;); // Now we can instantiate the WASI module with all the configurations above let rt = instantiate_custom_python_runtime(preopens, pylib, wasi_mod)?; rt.run_func(None, &quot;init_Python&quot;, params!())?; // .. Ok(rt) }   ","version":null,"tagName":"h3"},{"title":"WASI 0.2​","type":1,"pageTitle":"Python on WebAssembly: How?","url":"/blog/2024/08/26/python-on-webassembly#wasi-02","content":" The solution described above worked well to an extent but the limitations of preview1 and all the wrangling with PyO3 resulted in complexity that we were always ready to get rid of. This was exactly what we did after the Bytecode Alliance finalized WASI 0.2 back in January 2024 and with it, a slew of new opportunuties.  WASI 0.2 introduces a whole new concept of components, wasm modules that come with pre-specifed interfaces using the Wit format and based on a whole new ABI to boot. These new capabilities suggest that it should possible to replace our PyO3 based glue code with the WASI based layer. Let's see how.  We first used the new found WASI powers to implement support for Wasm based functions through the WasmRuntime. This lead us to implement the wit_wire protocol, a simple JSON based WIT interface that'd be used by any wasm component that intenteds to run on the WasmRuntime. Simple enough that it's reproduced down below in it's entirety.  package metatype:wit-wire; // what the host provides interface typegate-wire { hostcall: func(op-name: string, json: string) -&gt; result&lt;string, string&gt;; } // what's expected from the guest interface mat-wire { // init function called when we first make the component init: func(args: init-args) -&gt; result&lt;init-response, init-error&gt;; // general purpose event handler handle: func(req: handle-req) -&gt; result&lt;json-str, handle-err&gt;; type json-str = string; record init-args { // the list of operations the application is expecting // from this component expected-ops: list&lt;mat-info&gt; metatype-version: string, } record mat-info { op-name: string, mat-title: string, mat-data-json: string, } record init-response { ok: bool } variant init-error { version-mismatch(string), unexpected-mat(mat-info), other(string) } record handle-req { op-name: string, in-json: json-str, } variant handle-err { no-handler, in-json-err(string), handler-err(string), } } // a world defines what interfaces get imported // and exported world wit-wire { import typegate-wire; export mat-wire; }   Squint your eyes tight enough and the wit_wire protocol as implemented wasn't far off from what the PyO3 based glue code was doing in the previous implementation. Specifically, register a list of operations that the Typegate is expecting from the module and execute them for incoming event. We just need to add support for the operation metadata to contain extra items. In the case of the PythonRuntime, this would be the Python code itself.  Now that we have the wit_wire implementation taking care of bidirectional communication, we have little reason to keep the PyO3 based glue code around. This glue was doing a bit more than acting as a boundary though. It was also responsible for setting up the operating environment for the Python code. For example, we'd need some kind of initialization to execute the user's Python snippets which are in free standing lambda form. How does one create components out of Python anyways?  componentize-py is a tool authored by the Bytecode Alliance that allows you to produce WASI components that are authored in Python. It has code generation suite that emits guest bindings in Python for any WIT specification you feed it. It then takes your Python code written against these bindings and embeds them in a Wasm build of the Python interpreter to produce a component that supports the specified Wit.  Unsurprisingly, componentize-py relies on PyO3 and preopens itself in addition to component-init, a solution to pre-intialize components up to a certain point for improved startup latencies. This pre-intialization means we won't need to provide the actual preopens for the resulting component, baking the libpython object code directly into it as PyO3 will have dynamically loaded the object code by that point. Ultimately, this allows us to write all of our glue code in Python itself.  We still need a bit of Rust to support the wit_wire interface on the Typegate but this implementation is general across both the PythonRuntime and WasmRuntime. We'd also moved to the Wasmtime, also by Bytecode Alliance, for our wasm workloads at this point and their Rust bindings are a pleasure to use. It's all smooth sailing from here.  ","version":null,"tagName":"h3"},{"title":"Cloudy skies?​","type":1,"pageTitle":"Python on WebAssembly: How?","url":"/blog/2024/08/26/python-on-webassembly#cloudy-skies","content":" A final stumbling block for this approach was the many seconds Wasmtime spends cooking all your CPU cores when it compiles the fat wasm module that contains the Python interpreter, Pyo3 bindings and more. This happens because Wasmtime does't (yet) implement any schemes for tiered compilation, all code being greeted by their optimizing compiler, Cranelift. And optimizations take time. Sure, you only pay this cost the first time you load the Python runtime module as Wasmtime has great support for caching including on-disk caching. But, 10+ second cold-starts, as measured on one developer's machine, are unacceptable in a system that primarily serves HTTP requests. What to do?  Wasmtime has just the feature for this problem, pre-compilation. Ahead-of-time compilation of wasm bytecode into a native instruction set. Such files are commonly given the .cwasm extesion, c for compiled, and they are not a standalone executable but inteded to be run within Wasmtime's sandbox. This eliminates the compliation cost but the semantics of the source wasm bytecode and the runtime safe-guards means that this should be just as safe as JITting it (just-in-time compilation). We then statically embed this pre-compiled wasm artifact, after compressing it, in the Typegate binary removing the need for sidecar files while ensuring minimal cold-starts for our python workloads. To be concrete, this means roughly around 200 ms of overhead for a cold function and 5 ms for a warm one. Good enough.  This post describes the technical journey we took to arrive to the current implementation of the PythonRuntime. Hopefully, all details were clear enough and please direct any feedback, questions, and thoughts to the comments down below and our Github issues/discussion board. ","version":null,"tagName":"h2"},{"title":"Distributed execution flow paradigms","type":0,"sectionRef":"#","url":"/blog/2024/08/27/distributed-execution-flow-paradigms","content":"","keywords":"","version":null},{"title":"1. Event-Driven Architecture with Message Queues​","type":1,"pageTitle":"Distributed execution flow paradigms","url":"/blog/2024/08/27/distributed-execution-flow-paradigms#1-event-driven-architecture-with-message-queues","content":" This architecture relies heavily on services communicating by publishing and subscribing to events using message queues. Message queues are persistent storages that ensure data is not lost during failures or service unavailability. Components in a distributed system synchronize by using events/messages through these independent services. While this approach offers service decomposability and fault tolerance, it has some shortcomings. For example, using message queues comes with the overhead of managing messages (e.g., deduplication and message ordering). It also isn’t ideal for systems requiring immediate consistency across components. Some technologies and patterns that utilize this architecture include:  RabbitMQAmazon SQS    Fig. Event Driven Architecture with Message Queues - RabbitMQ  Advantages​  Improved ScalabilityEnhanced ResponsivenessEnhanced Fault ToleranceSimplified Complex WorkflowsReal-Time Data Processing  Challenges​  Event OrderingData ConsistencyMonitoring and DebuggingEvent Deduplication  You can mitigate or reduce these challenges by following best practices like Event Sourcing, Idempotent Processing, CQRS (Command Query Responsibility Segregation), and Event Versioning.  ","version":null,"tagName":"h3"},{"title":"2. The Saga Pattern​","type":1,"pageTitle":"Distributed execution flow paradigms","url":"/blog/2024/08/27/distributed-execution-flow-paradigms#2-the-saga-pattern","content":" This design pattern aims to achieve consistency across different services in a distributed system by breaking complex transactions spanning multiple components into a series of local transactions. Each of these transactions triggers an event or message that starts the next transaction in the sequence. If any local transaction fails to complete, a series of compensating actions roll back the effects of preceding transactions. While the orchestration of local transactions can vary, the pattern aims to achieve consistency in a microservices-based system. Events are designed to be stored in durable storage systems or logs, providing a trail to reconstruct the system to a state after a failure. While the saga pattern is an effective way to ensure consistency, it can be challenging to implement timer/timeout-based workflows and to design and implement the compensating actions for local transactions.  Note: In the Saga pattern, a compensating transaction must be idempotent and retryable. These principles ensure that transactions can be managed without manual intervention.    Fig. The Saga Pattern for Order delivery system  Advantages​  Ensures data consistency in a distributed system without tight coupling.Provides Roll back if one of the operations in the sequence fails.  Drawbacks​  Might be challenging to implement initially.Hard to debug.Compensating transactions don’t always work.  ","version":null,"tagName":"h3"},{"title":"3. Stateful Orchestrators​","type":1,"pageTitle":"Distributed execution flow paradigms","url":"/blog/2024/08/27/distributed-execution-flow-paradigms#3-stateful-orchestrators","content":" Stateful orchestrators provide a solution for long-running workflows by maintaining the state of each step in a workflow. Each step in a workflow represents a task, and these tasks are represented as states inside workflows. Workflows are defined as state machines or directed acyclic graphs (DAGs). In this approach, an orchestrator handles task execution order, transitioning, handling retries, and maintaining state. In the event of a failure, the system can recover from the persisted state. Stateful orchestrators offer significant value in fault tolerance, consistency, and observability. It’s one of the solutions proven effective in modern distributed computing. Some well-known services that provide this solution include:  Apache AirflowAzure Logic Apps  Advantages​  High Resiliency: Stateful orchestrators provide high resiliency in case of outages, ensuring that workflows can continue from where they left off.Data Persistence: They allow you to keep, review, or reference data from previous events, which is useful for long-running processes.Extended Runtime: Stateful workflows can continue running for much longer than stateless workflows, making them suitable for complex and long-running tasks.  Challenges​  Additional Complexity: They introduce additional complexity, requiring you to manage issues such as load balancing, CPU and memory usage, and networking.Cost: With stateful workflows, you pay for the VMs that are running in the cluster, whereas with stateless workflows, you pay only for the actual compute resources consumed.  ","version":null,"tagName":"h3"},{"title":"4. Durable Execution​","type":1,"pageTitle":"Distributed execution flow paradigms","url":"/blog/2024/08/27/distributed-execution-flow-paradigms#4-durable-execution","content":" Durable execution refers to the ability of a system to preserve the state of an application and persist execution despite failures or interruptions. Durable execution ensures that for every task, its inputs, outputs, call stack, and local variables are persisted. These constraints, or rather features, allow a system to automatically retry or continue running in the face of infrastructure or system failures, ultimately ensuring completion.  Durable execution isn’t a completely distinct solution from the ones listed above but rather incorporates some of their strengths while presenting a more comprehensive approach to achieving consistency, fault tolerance, data integrity, resilience for long-running processes, and observability.    Fig. Durable workflow engine  Advantages​  Reduced Manual Intervention: Minimizes the need for human intervention by handling retries and failures programmatically.Improved Observability: Provides a clear audit trail and visibility into the state of workflows, which aids in debugging and monitoring.Scalability: Scales efficiently across distributed systems while maintaining workflow integrity.  Challenges​  Resource Intensive: Persistent state storage and management can consume significant resources, especially in large-scale systems.Latency: The need to persist state and handle retries can introduce latency in the execution flow.  As durable execution grows to be a fundamental driver of distributed computing, some of the solutions which use this architecture are  TemporalUber Cadence  Among these, Temporal has grown in influence, used by companies like SnapChat, HashiCorp, Stripe, DoorDash, and DataDog. Its success is driven by its practical application in real-world scenarios and the expertise of its founders.  At Metatype, we recognize the value of durable execution and are committed to making it accessible. Our Temporal Runtime integrates seamlessly into our declarative API development platform, enabling users to harness the power of Temporal directly within Metatype. For those interested in exploring further, our documentation provides a detailed guide on getting started with Temporal Runtime.  Below is an example of how you can build a simple API to interact with an order delivery temporal workflow within Metatype.  note If you are new to Metatype or haven’t set it up yet in your development environment. You can follow this guideline.  For this example, the order delivery system will have few components/services such as Payment, Inventory and Delivery.  Your temporal workflow definition should look similar to the one below.  Typescript SDK Python SDK Activities definition inside src/activities.ts:` async function sleep(time: number) { return new Promise((resolve) =&gt; { setTimeout(resolve, time); }); } export async function processPayment(orderId: string): Promise&lt;string&gt; { console.log(`Processing payment for order ${orderId}`); // Simulate payment processing logic await sleep(2); return &quot;Payment processed&quot;; } export async function checkInventory(orderId: string): Promise&lt;string&gt; { console.log(`Checking inventory for order ${orderId}`); // Simulate inventory check logic await sleep(2); return &quot;Inventory available&quot;; } export async function deliverOrder(orderId: string): Promise&lt;string&gt; { console.log(`Delivering order ${orderId}`); // Simulate delivery logic await sleep(5); return &quot;Order delivered&quot;; } Workflow definition inside src/workflows.ts: export const { processPayment, checkInventory, deliverOrder } = proxyActivities&lt;{ processPayment(orderId: string): Promise&lt;string&gt;; checkInventory(orderId: string): Promise&lt;string&gt;; deliverOrder(orderId: string): Promise&lt;string&gt;; }&gt;({ startToCloseTimeout: &quot;10 seconds&quot;, }); export async function OrderWorkflow(orderId: string): Promise&lt;string&gt; { const paymentResult = await processPayment(orderId); const inventoryResult = await checkInventory(orderId); const deliveryResult = await deliverOrder(orderId); return `Order ${orderId} completed with results: ${paymentResult}, ${inventoryResult}, ${deliveryResult}`; } Worker definintion inside src/worker.ts: import { NativeConnection, Worker } from &quot;@temporalio/worker&quot;; import * as activities from &quot;./activities&quot;; import { TASK_QUEUE_NAME } from &quot;./shared&quot;; async function run() { const connection = await NativeConnection.connect({ address: &quot;localhost:7233&quot;, }); const worker = await Worker.create({ connection, namespace: &quot;default&quot;, taskQueue: TASK_QUEUE_NAME, workflowsPath: require.resolve(&quot;./workflows&quot;), activities, }); await worker.run(); } run().catch((err) =&gt; { console.error(err); process.exit(1); }); After you have setup the above components, now you need a client to start of any OrderWorkflow. Here is where metatype comes in, through the simple APIs Temporal Runtime exposes, you can communicate with your temporal cluster. Down below is the workflow communication bridge for this system expressed within a typegraph which includes endpoints to start a new workflow and describe an existing one. import { Policy, t, typegraph } from &quot;@typegraph/sdk/index.ts&quot;; import { TemporalRuntime } from &quot;@typegraph/sdk/providers/temporal.ts&quot;; typegraph( { name: &quot;order_delivery&quot;, }, (g: any) =&gt; { const pub = Policy.public(); const temporal = new TemporalRuntime({ name: &quot;order_delivery&quot;, hostSecret: &quot;HOST&quot;, namespaceSecret: &quot;NAMESPACE&quot;, }); const workflow_id = &quot;order-delivery-1&quot;; const order_id = t.string(); g.expose( { start: temporal.startWorkflow(&quot;OrderWorkflow&quot;, order_id), describe: workflow_id ? temporal.describeWorkflow().reduce({ workflow_id }) : temporal.describeWorkflow(), }, pub, ); }, );   You need to add the secrets HOST and NAMESPACE under your typegraph name inside the metatype.yaml file. These secrets are important to connect with your temporal cluster and can be safely stored in the config file as shown below.  metatype.yaml typegate: dev: url: &quot;http://localhost:7890&quot; username: admin password: password secrets: example: POSTGRES: &quot;postgresql://postgres:password@postgres:5432/db&quot; MONGO: &quot;mongodb://root:password@mongo:27017/db&quot; HOST: &quot;http://localhost:7233&quot; NAMESPACE: &quot;default&quot;   You need to add only the last two lines as the others are auto-generated. Note that secrets are defined under the example parent, which is the name of your typegraph. If the name doesn't match, you will face secret not found issues when deploying your typegraph.  Before deploying the above typegraph, you need to start the temporal server and the worker. You need to have temporal installed on your machine.  Boot up temporal Start the temporal server. temporal server start-dev Start the worker. Typescript SDK Python SDK typescript npx ts-node src/worker.ts   After booting the temporal server, run the command down below to get a locally spinning typegate instance with your typegraph deployed.  meta dev   After completing the above steps, you can access the web GraphQL client of the typegate at http://localhost:7890/example. Run this query inside the client to start your workflow.  mutation { start( workflow_id: &quot;order-delivery-3&quot; task_queue: &quot;order-delivery-queue&quot; args: [&quot;order12&quot;] ) }   After a successful run, you will get the following result which includes the run_id of the workflow which has just been started.    You can also check the temporal web UI to monitor your workflows and you should see a result similar to this one.    You can explore the Temporal Runtime for more info.  This wraps up the blog, thanks for reading until the end :) ","version":null,"tagName":"h3"},{"title":"Welcome to Metatype!","type":0,"sectionRef":"#","url":"/docs","content":"","keywords":"","version":"Next"},{"title":"Start building with the tutorials​","type":1,"pageTitle":"Welcome to Metatype!","url":"/docs#start-building-with-the-tutorials","content":" 📄️ Quick-start Install the requirements and start building. 📄️ Metatype basics Learn the basics by building a real world API.  ","version":"Next","tagName":"h2"},{"title":"Explore and learn more functionalities​","type":1,"pageTitle":"Welcome to Metatype!","url":"/docs#explore-and-learn-more-functionalities","content":" The platform provides out of the box support for many use cases:  create/read/update/delete data in your databasestoring files in your cloud storageauthenticate users with different providers or using JWTsconnecting to third-party/internal APIsrunning custom business logic in your preferred languageproviding fine-grained access control to your dataand more...  📄️ All about types 📄️ List of support runtimes 📄️ Deploy with Meta CLI 📄️ Deep into the typegate  ","version":"Next","tagName":"h2"},{"title":"Understand Metatype in depth​","type":1,"pageTitle":"Welcome to Metatype!","url":"/docs#understand-metatype-in-depth","content":" Once you are familiar with the basics, you can learn more about the motivation behind Metatype and the underlying implementation.  📄️ Mental model 📄️ Comparing Metatype ","version":"Next","tagName":"h2"},{"title":"Architecture","type":0,"sectionRef":"#","url":"/docs/concepts/architecture","content":"","keywords":"","version":"Next"},{"title":"Artifacts​","type":1,"pageTitle":"Architecture","url":"/docs/concepts/architecture#artifacts","content":" While developing and building an application using Metatype, different types of artifacts can be used in different parts of the application. An artifact is an external file that your application uses as a dependency to execute tasks.  For instance, while working with PythonRuntime, we import an external Python script artifacts/hasher.py which has some hashing functionality. The script which we imported will be marked as an artifact and run inside the PythonRuntime. There can be numerous artifacts which can be used by different Runtimes inside Metatype.  The way Metatype tracks depends on the mode in which the typegate is running.  In the single-replica mode (default), the artifacts are stored in only in the filesystem of the Typegate node.In the Synchronized mode, they are stored in a shared S3-compatible object store.    ","version":"Next","tagName":"h2"},{"title":"Reference counting​","type":1,"pageTitle":"Architecture","url":"/docs/concepts/architecture#reference-counting","content":" Artifacts are tracked using reference counts. After a successful upload, each artifact is assigned a zero reference count.  When a typegraph is deployed for the first time, the reference counts associated to each of its artifacts are incremented.  When a typegraph is updated, reference counts are updated according to the diff of the artifact list between new and old versions of the typegraph (list of artifact hashes): removal → decrementation, addition → incrementation, no change → no change.  When a typegraph is undeployed, the reference count of each artifact associated to the typegraph is decremented.  Rationale​  Why do we use reference counts instead of removing unused artifacts after each typegraph update/undeployment?  Artifacts are shared between typegraphs: multiple typegraphs from a single projects might share the same artifacts.We might have orphaned artifacts due to uncompleted typegraph process.  ","version":"Next","tagName":"h3"},{"title":"Artifact removal​","type":1,"pageTitle":"Architecture","url":"/docs/concepts/architecture#artifact-removal","content":" GC: Garbage collection​  Artifacts that have a zero reference count are removed.  Triggers: The GC is triggerred at the end of each typegraph deployment/undeployment process.  Full GC​  Not implemented  A full GC can be triggered manually with the Meta CLI or on the console.  Remove orphaned artifacts from uncompleted typegraph deployment process or uncompleted GC.Recompute all the reference counts, then run the GC. It might be necessary as the reference count might get wrong due to lack of a proper transaction support for the typegraph deployment/undeployment process. ","version":"Next","tagName":"h3"},{"title":"Comparing Metatype","type":0,"sectionRef":"#","url":"/docs/concepts/comparisons","content":"","keywords":"","version":"Next"},{"title":"Development platforms​","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#development-platforms","content":" FirebaseSupabaseHasuraPostGraphile  These are great platforms to quickly start a new project. However, they hardly scale in terms of architecture evolution, technology freedom, number of developers on the project, and you will eventually have to move out due to increasing costs or iterations slowness.  When to choose Metatype  You want to build modular APIs by composing pre-defined blocks and import the ones you need from existing systems.You want to take advantage of developers tooling you are familiar with, like version controls or multiple environments.You favor interoperability and extensibility over vendor lock-in, and follow your future needs with ease.You want to decouple your database from your API and change where the data is stored as the project evolves.  ","version":"Next","tagName":"h2"},{"title":"Headless CMS​","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#headless-cms","content":" StrapiDirectus  Headless Content Management Systems (CMS) are great tools to manage content and providing great editing experience. However, they are not designed to build complex APIs like a cart checkout or integrate with other systems.  When to choose Metatype  You want an all-in-one APIs development platforms and offer the same editing experience through a user-friendly interfaceYou care about end-user performance and want to use the best underlying technology for each use casesYou are more than one on the project and want to manage your data models using preferred programming language  ","version":"Next","tagName":"h2"},{"title":"Low Code Platforms​","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#low-code-platforms","content":" RetoolAirtableWindmill  Low Code platforms are a game changer when it comes to faster development cycle, great collaboration options and the gentle learning curve. However, this comes at the cost of losing degree of flexibility and cusomizability. They are also hard to apply different scalability and come with limited performance optimization.  When to choose Metatype  When you want more control over your application instances running on the cloud.When you want to build more complex APIs.When you want to have the freedom to make detailed changes to your application to gain that extra performance.  Feature/Capability Key:  ✅ 1st class, with no extra dependencies.⚪ supported, but with extra 3rd party dependencies🔶 supported, but with extra 3rd party dependencies and user code.🔴 not officially supported or documented.  \tMetatype\tDevelopment Platforms\tHeadless CMS\tLow code platformLicensing\tOpen Source\tOpen Source Proprietary\tOpen Source\tProprietary Platform's Requirements\t- Cloud-based: None - Locally: Deno/Node.js/Python Runtime, Redis, Docker\t- Cloud-based: None - Running Locally: Docker, DBMS\t- NodeJS runtime - DBMS\tCloud-based: None Architecture Model\t- Declarative - Less Code - Serverless\t- API over Database - Serverless\t- Headless Architecture - Serverless\t- Visual drag and drop - Serverless REST/HTTP\t✅\t✅\t✅\t✅ GraphQL\t✅\t⚪\t✅\t🔶 gRPC\t🔶*\t🔶\t🔶\t🔶 GUI for non programmers\t✅\t✅\t✅\t✅ Development SDKs\t✅\t✅\t🔴\t🔴 (Most) ✅ (few) CLI\t✅\t✅ (some) 🔴 (some)\t✅\t🔴 Dev Tools\t✅\t✅\t✅\t🔴 LSP and Extensions\t✅*\t⚪\t⚪\t🔴 Authentication\t- Basic Auth - JWT - OAuth\t- Basic Auth - JWT - OAuth - JWT\t- email/phone/password - JWT - OAuth\t- email/phone/password - JWT - OAuth - JWT Authorization\t- policy-based access control (PBAC)\t- policy-based access control (PBAC) - role-based access control (RBAC)\t- role-based access control (RBAC)\t- Custom Authorization logic from the User Type System\tCustom Types\t- JS objects - GraphQL Schemas - Database Types\tJS objects\tCustom Types Custom Code Support\t✅\t✅\t✅\t✅ Version Control Friendly\t✅\t✅\t✅\t✅ GitOPs Friendly\t✅\t✅\t⚪\t⚪ Vertical Scalability\tFlexibile\tLimited\tFlexibile\tLimited Service Decomposition\t✅\t✅\t✅\t🔴 Deployment Options\t- On premise - Cloud-based platforms\t- On premise - Cloud-based platforms\t- On premise - Cloud-based platforms\t- On premise - Cloud-based platforms Monitoring and Tracking\t✅*\t✅\t✅\t🔶 Logging\t✅*\t✅\t✅\t🔶  ","version":"Next","tagName":"h2"},{"title":"Table Parameters Legend​","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#table-parameters-legend","content":" Solution's Meta​  Licensing: The type of licensing model the software solution adopts, such as open-source, proprietary, freemium, etc.  Platform's Requirements: The prerequisites and dependencies required for the software to run efficiently, including hardware, operating system, runtime environment, etc.  Architecture Model: The underlying design principles and patterns governing the behavior/structure of the software solution.  Network comms​  REST/HTTP: Support for Representational State Transfer (REST) or Hypertext Transfer Protocol (HTTP) communication protocol used for network communication.  GraphQL: Support for GraphQL.  gRPC: Support for gRPC.  Ecosystem​  GUI for non programmers: Graphical User Interface (GUI) tools designed to facilitate interaction with the software by individuals with limited programming knowledge or expertise.  Development SDKs: Software Development Kits (SDKs) provided by the solution to aid developers in building applications using the platform.  CLI: Command-Line Interface tools provided for developers or administrators to interact with the software from the terminal or command prompt.  Dev Tools: Tools and utilities provided to aid developers in coding, debugging, testing, and profiling applications.  LSP and Extensions: Language Server Protocol (LSP) and Extensions support for enhanced development experience, including features like syntax highlighting, auto-completion, and error checking.  Security​  Authentication: Mechanisms for verifying the identity of users or entities accessing the software solution.  Authorization: The process of determining whether an authenticated user or system entity is allowed to perform a specific action or access a particular resource.  Database Interaction​  Type System: The system governing the data types and structures used by which the application entities and models are constructed.    System Flexibility​  Custom Code support: The ability of the software solution to accommodate custom code or extensions developed by users or third-party developers.    Versioning and CI/CD​  Version Control: The support for versioning and revision control of software artifacts, typically using systems like Git, SVN, etc.  GitOPs Friendly: Compatibility or support for the GitOps methodology, where infrastructure and application deployments are managed through Git workflows.  Scalability​  Vertical Scalability: The ability of the software solution to handle increased workload or demand by adding more resources to a single node or instance.  Service Decomposition: The architectural principle of breaking down the software into smaller, independent services (microservices) to improve scalability, maintainability, and flexibility.  Deployment​  Deployment Options: The available methods and strategies for deploying the software solution, including on-premises, cloud-based, containerized, etc.  Monitoring, Logging and maintenance​  Monitoring and Tracking: Tools and mechanisms provided for monitoring the health, performance, and usage of the software solution, as well as tracking user activities and behaviors.  Logging: Facilities for recording and storing system events, errors, and other relevant information for troubleshooting, analysis, and auditing purposes.  ","version":"Next","tagName":"h3"},{"title":"RFCs","type":0,"sectionRef":"#","url":"/docs/concepts/RFCs","content":"RFCs N°\tName\tDateM0\tTemplate\t2024-05-01","keywords":"","version":"Next"},{"title":"M0 - Template","type":0,"sectionRef":"#","url":"/docs/concepts/RFCs/M0-template","content":"","keywords":"","version":"Next"},{"title":"Summary​","type":1,"pageTitle":"M0 - Template","url":"/docs/concepts/RFCs/M0-template#summary","content":" One paragraph explanation of the feature.  ","version":"Next","tagName":"h2"},{"title":"Motivation​","type":1,"pageTitle":"M0 - Template","url":"/docs/concepts/RFCs/M0-template#motivation","content":" Why are we doing this? What use cases does it support? What is the expected outcome?  ","version":"Next","tagName":"h2"},{"title":"Guide-level explanation​","type":1,"pageTitle":"M0 - Template","url":"/docs/concepts/RFCs/M0-template#guide-level-explanation","content":" Explain the proposal as if it were already included in the language, and you were teaching it to another peer programmer. That generally means:  Introducing new named concepts.Explaining the feature largely in terms of examples.Explaining how Metatype programmers should think about the feature, and how it should impact the way they use the platform. It should explain the impact as concretely as possible.If applicable, provide sample error messages, deprecation warnings, or migration guidance.If applicable, describe the differences between teaching this to existing Metatype programmers and to new Metatype programmers.Discuss how this impacts the ability to read, understand, and maintain Metatype code. Code is read and modified far more often than written; will the proposed feature make code easier to maintain?  For implementation-oriented RFCs (e.g. for compiler internals), this section should focus on how compiler contributors should think about the change, and give examples of its concrete impact. For policy RFCs, this section should provide an example-driven introduction to the policy, and explain its impact in concrete terms.  ","version":"Next","tagName":"h2"},{"title":"Reference-level explanation​","type":1,"pageTitle":"M0 - Template","url":"/docs/concepts/RFCs/M0-template#reference-level-explanation","content":" This is the technical portion of the RFC. Explain the design in sufficient detail that:  Its interaction with other features is clear.It is reasonably clear how the feature would be implemented.Corner cases are dissected by example.  The section should return to the examples given in the previous section, and explain more fully how the detailed proposal makes those examples work.  ","version":"Next","tagName":"h2"},{"title":"Drawbacks​","type":1,"pageTitle":"M0 - Template","url":"/docs/concepts/RFCs/M0-template#drawbacks","content":" Why should we not do this?  ","version":"Next","tagName":"h2"},{"title":"Rationale and alternatives​","type":1,"pageTitle":"M0 - Template","url":"/docs/concepts/RFCs/M0-template#rationale-and-alternatives","content":" Why is this design the best in the space of possible designs?Why is this design the best among possible designs?What other designs have been considered, and what is the rationale for not choosing them?What is the impact of not doing this?  ","version":"Next","tagName":"h2"},{"title":"Prior art​","type":1,"pageTitle":"M0 - Template","url":"/docs/concepts/RFCs/M0-template#prior-art","content":" Discuss prior art, both the good and the bad, in relation to this proposal. A few examples of what this can include are:  Does this feature exist in other framework, and what experience have their community had?For community proposals: Is this done by some other community, and what were their experiences with it?For other teams: What lessons can we learn from what other communities have done here?Papers: Are there any published papers or great posts that discuss this? If you have some relevant papers to refer to, this can serve as a more detailed theoretical background.  This section is intended to encourage you as an author to think about the lessons from other framework, provide readers of your RFC with a fuller picture. If there is no prior art, that is fine - your ideas are interesting to us whether they are brand new or if it is an adaptation from other framework.  ","version":"Next","tagName":"h2"},{"title":"Unresolved questions​","type":1,"pageTitle":"M0 - Template","url":"/docs/concepts/RFCs/M0-template#unresolved-questions","content":" What parts of the design do you expect to resolve through the RFC process before this gets merged?What parts of the design do you expect to resolve through the implementation of this feature before stabilization?What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC?  ","version":"Next","tagName":"h2"},{"title":"Future possibilities​","type":1,"pageTitle":"M0 - Template","url":"/docs/concepts/RFCs/M0-template#future-possibilities","content":" Think about what the natural extension and evolution of your proposal would be and how it would affect the project as a whole in a holistic way. Try to use this section as a tool to more fully consider all possible interactions with the project in your proposal.  This is also a good place to &quot;dump ideas&quot;, if they are out of scope for the RFC you are writing but otherwise related. ","version":"Next","tagName":"h2"},{"title":"Mental model","type":0,"sectionRef":"#","url":"/docs/concepts/mental-model","content":"","keywords":"","version":"Next"},{"title":"Why does Metatype exist?​","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#why-does-metatype-exist","content":" Building great APIs is a thought challenge. Developers usually spend a non-negligible amount of time on low-value added tasks (CRUD generation, data validation, authorization, etc.) and managing deployments. This gives them little time to design great interfaces and experiment with the best technical approaches, eventually increasing the time to delivery and weakening innovation.  Metatype's vision is to enable everyone to build modular API with as little effort as possible. By helping developers to re-use existing systems and APIs, it enables teams to focus on what matters: their expert knowledge in business domain, modelling and technologies. Metatype manage the complex aspects for them, making them productive and innovation-friendly for the next iterations.  ","version":"Next","tagName":"h2"},{"title":"How does Metatype work?​","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#how-does-metatype-work","content":" When developing a feature, the classical approach is to define what data will be at play, how to transform them, where the execution shall take place and who should be authorized. Instead, Metatype define an abstraction for each of those steps and put the emphasis on composing pre-defined APIs or defining re-usable ones when there is no existing solution.  \tClassical model\tMetatype's model\txWhat (data)\tfixed response defined by the logic\tAPI clients selects what they need from types How (transformations)\tad-hoc code logic\tcomposed data with interchangeable functions Where (execution)\t1 code base + 1 database\torchestrate the request across multiple runtimes Who (authentication)\thard-coded rules or system\trequest context based and controlled by policies When (event)\trequest arrival\tbased on triggers\t  This computing model brings numerous advantages:  it offers multiple runtimes with pre-defined operations and can replace the needs for an ad-hoc backendwhen the project grows, you easily introduce new APIs or break existing ones in smaller partsyou write complex business logic directly in Typescript, Python or WebAssembly and run them on-demandthird-parties APIs can be easily integrated, providing you visibility and control over themit is interoperable with existing (legacy) systems, and can be introduced step by stepit can be easily self-hosted in your own infrastructure or customized according to your needs  ","version":"Next","tagName":"h2"},{"title":"What's exactly Metatype?​","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#whats-exactly-metatype","content":" Metatype is an open source platform to author and deploy APIs for the cloud and components eras. It provides a declarative programming model that helps you to efficiently design APIs and focus on the functional requirements.  The runtime embraces WebAssembly (WASM) as a first-class citizen to allow you to write your business logic in the language of your choice and run it on-demand. Those &quot;backend components&quot; are reusable across your stacks and deployable without pipelines or containers.  The platform provides a set of capabilities out of the box:  create/read/update/delete data in your databasestoring files in your cloud storageauthenticate users with different providers or using JWTsconnecting to third-party/internal APIs  And offers an opportunity to climb the one step higher in the abstraction ladder and drastically simplify the building of great APIs and systems!      Metatype is designed to be as simple as possible and horizontally scalable in existing container orchestration solution like Kubernetes. It consists of multiple parts, including:  Typegraph: a cross-language SDK to manage typegraphs - virtual graphs of types - and compose themTypegate: a serverless GraphQL/REST gateway to execute queries over typegraphsMeta CLI: a command-line tool to efficiently deploy the typegraphs on the gateway    ","version":"Next","tagName":"h2"},{"title":"Core abstractions​","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#core-abstractions","content":" ","version":"Next","tagName":"h2"},{"title":"Types​","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#types","content":" Types are the building block of typegraphs. They define a type system describing all data objects processed in Metatype. They can be easily extended to support new data types according to the needs of the application.  t.struct( { &quot;id&quot;: t.uuid(), &quot;age&quot;: t.integer(), &quot;cars&quot;: t.list( t.struct( { &quot;model&quot;: t.string(), &quot;name&quot;: t.string().optional(), } ) ), } )   Analogy in SQL: types are similar to the Data Definition Language (DDL) with the extended capacity of describing any type of data.  ","version":"Next","tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#functions","content":" Types can also describe functions and functions define how the input type gets transformed into the output type. The input and output types are similar to a function signature, the runtime + configuration associated to it, to its implementation.  deno = DenoRuntime() deno.func( t.struct({&quot;input&quot;: t.string()}), t.string(), code=&quot;({ input }) =&gt; `hello ${input}`&quot;, # with logic ) http = HttpRuntime(&quot;https://random.org/api&quot;) http.get( &quot;/flip_coin&quot;, t.struct({}), t.enum([&quot;head&quot;, &quot;tail&quot;]), )   ","version":"Next","tagName":"h3"},{"title":"Runtimes​","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#runtimes","content":" Every type and function have a runtime associated to it. This runtime describes where the types are physically located. It can be another API, a database, or any other services the typegate can connect to. The typegates uses that information to optimize the execution of the queries and minimize the amount of data moved.  In practice, function types are often not explicitly used and the usage of runtime sugar syntax is preferred.  http = HttpRuntime(&quot;https://random.org/api&quot;) # same func as above http.get( &quot;/flip_coin&quot;, t.struct({}), t.enum([&quot;head&quot;, &quot;tail&quot;]) ) # implicitly attaches runtime to all types   Analogy in SQL: a runtime is similar to a database instance running some requests.  ","version":"Next","tagName":"h3"},{"title":"Policies​","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#policies","content":" Policies are a special type of function t.func(t.struct({...}), t.boolean().optional()) attachable to any other type. They are evaluated once per request and determine whether one of the polices authorizes the access or not. They receive the request context (see typegate) as argument allowing you to implement authorization, access control, or any other business logic.  The policy decision can be:  true: the access is authorizedfalse: the access is deniednull: the access in inherited from the parent types  deno = DenoRuntime() public = deno.policy(&quot;public&quot;, &quot;() =&gt; true&quot;) # noqa team_only = deno.policy(&quot;team&quot;, &quot;(ctx) =&gt; ctx.user.role === 'admin'&quot;) # noqa   Analogy in SQL: policies are similar to Row Security Policies (RSP) or Row Level Security (RLS) concepts.  ","version":"Next","tagName":"h3"},{"title":"Triggers​","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#triggers","content":" Triggers are events launching the execution of one or multiple functions. They fire when a GraphQL request is received for the specific typegraph.  @typegraph( ) def triggers(g: Graph): # ... g.expose( public, flip=http.get(&quot;/flip_coin&quot;, t.struct({}), t.enum([&quot;head&quot;, &quot;tail&quot;])), )   Analogy in SQL: a trigger is similar to receiving a new query. ","version":"Next","tagName":"h3"},{"title":"","type":0,"sectionRef":"#","url":"/docs/guides/contributing","content":"","keywords":"","version":"Next"},{"title":"Table of Contents​","type":1,"pageTitle":"","url":"/docs/guides/contributing#table-of-contents","content":" Code of ConductI Have a QuestionI Want To ContributeReporting BugsSuggesting EnhancementsYour First Code Contribution  ","version":"Next","tagName":"h2"},{"title":"Code of Conduct​","type":1,"pageTitle":"","url":"/docs/guides/contributing#code-of-conduct","content":" This project and everyone participating in it is governed by our Code of Conduct. By participating, you are expected to uphold this code.  ","version":"Next","tagName":"h2"},{"title":"I Have a Question​","type":1,"pageTitle":"","url":"/docs/guides/contributing#i-have-a-question","content":" If you want to ask a question, we assume that you have read the available documentation.  Before you ask a question, it is best to search for existing Issues that might help you. In case you have found a suitable issue and still need clarification, you can write your question in this issue. It is also advisable to search the internet for answers first.  If you then still feel the need to ask a question and need clarification, we recommend the following:  Open an Issue.Provide as much context as you can about what you're running into.Provide project and platform versions depending on what seems relevant.  ","version":"Next","tagName":"h2"},{"title":"I Want To Contribute​","type":1,"pageTitle":"","url":"/docs/guides/contributing#i-want-to-contribute","content":" Legal Notice​ When contributing to this project, you must agree that you have authored 100% of the content, that you have the necessary rights to the content and that the content you contribute may be provided under the project license.  ","version":"Next","tagName":"h2"},{"title":"Reporting Bugs​","type":1,"pageTitle":"","url":"/docs/guides/contributing#reporting-bugs","content":" Before Submitting a Bug Report​  A good bug report shouldn't leave others needing to chase you up for more information. Therefore, we ask you to investigate carefully, collect information and describe the issue in detail in your report. Please complete the following steps in advance to help us fix any potential bug as fast as possible.  Make sure that you are using the latest version.Determine if your bug is really a bug and not an error on your side e.g. using incompatible environment components/versions (Make sure that you have read the documentation. If you are looking for support, you might want to check this section).To see if other users have experienced (and potentially already solved) the same issue you are having, check if there is not already a bug report existing for your bug or error in the bug tracker.Also make sure to search the internet (including Stack Overflow) to see if users outside the GitHub community have discussed the issue.Collect information about the bug:Stack traceOS, Platform and Version (Windows, Linux, macOS, x86, ARM)Version of the interpreter, compiler, SDK, runtime environment, package manager, depending on what seems relevant.Possibly your input and the outputCan you reliably reproduce the issue? And can you also reproduce it with older versions?  How Do I Submit a Good Bug Report?​  You must never report security related issues, vulnerabilities or bugs including sensitive information to the issue tracker, or elsewhere in public. Instead sensitive bugs must be reported according to the Security Policy.  We use GitHub issues to track bugs and errors. If you run into an issue with the project:  Open an Issue. (Since we can't be sure at this point whether it is a bug or not, we ask you not to talk about a bug yet and not to label the issue.)Explain the behavior you would expect and the actual behavior.Please provide as much context as possible and describe the reproduction steps that someone else can follow to recreate the issue on their own. This usually includes your code. For good bug reports you should isolate the problem and create a reduced test case.Provide the information you collected in the previous section.  ","version":"Next","tagName":"h3"},{"title":"Suggesting Enhancements​","type":1,"pageTitle":"","url":"/docs/guides/contributing#suggesting-enhancements","content":" This section guides you through submitting an enhancement suggestion for Metatype, including completely new features and minor improvements to existing functionality. Following these guidelines will help us and the community to understand your suggestion and find related suggestions.  Before Submitting an Enhancement​  Make sure that you are using the latest version.Read the documentation carefully and find out if the functionality is already covered, maybe by an individual configuration.Perform a search to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one.Find out whether your idea fits with the scope and aims of the project. It's up to you to make a strong case to convince the project's developers of the merits of this feature. Keep in mind that we want features that will be useful to the majority of our users and not just a small subset. If you're just targeting a minority of users, consider writing an add-on/plugin library.  How Do I Submit a Good Enhancement Suggestion?​  Enhancement suggestions are tracked as GitHub issues.  Use a clear and descriptive title for the issue to identify the suggestion.Provide a step-by-step description of the suggested enhancement in as many details as possible.Describe the current behavior and explain which behavior you expected to see instead and why. At this point you can also tell which alternatives do not work for you.Explain why this enhancement would be useful to most Metatype users. You may also want to point out the other projects that solved it better and which could serve as inspiration.  ","version":"Next","tagName":"h3"},{"title":"Your First Code Contribution​","type":1,"pageTitle":"","url":"/docs/guides/contributing#your-first-code-contribution","content":" Metatype is using a mono-repository approach. This means that all code is centralized and requires many different tools to work with. The following sections will guide you through the setup process.  Dependencies​  Ghjk is used for managing development environments. You can install it using the following instructions.  # install ghjk GHJK_VERSION=&quot;v0.2.1&quot; GHJK_INSTALL_HOOK_SHELLS=bash # add more shells if needed curl -fsSL https://raw.githubusercontent.com/metatypedev/ghjk/$GHJK_VERSION/install.sh | sh bash # re-open your shells to have the hooks register # this will activate the environment after installing # the required programs first ghjk sync # install system libraries ghjk x install-sys | bash # enable pre-commit hook pre-commit install   Running The Project​  ghjk sync dev # prepare python virtual environment ghjk x install-py source .venv/bin/activate # depends on your shell   Environments And Tests​  ghjk x dev-compose all # or only the envs required (e.g. base prisma s3) ghjk x build-tgraph # build typegraph ghjk x test-e2e # all tests ghjk x test-e2e tests/runtimes/prisma/full_prisma_mapping_test.ts # isolated test ghjk x # more test tasks are availaible ghjk x dev-compose # shutdown all envs   There are many more developer scripts in the dev folder, however most of them should only be needed for advanced tasks.  Commit Messages​  Pre-commit hooks enforce some basic checks, namely that all commit messages follow the conventional commit format. This is a simple set of rules that makes review easier and help us to generate a changelog.  Faster compilation​  We recommend using sccache giving a roughly 2x speedup in compilation time once warm.  Faster linking​  mold is enabled by default for Linux targets whithin the ghjk environments. For macOS, there's a new parallel linker available for faster linking. You can use it through aliases or configure them in your ~/.cargo/config.toml file.  [target.aarch64-apple-darwin] rustflags = [ &quot;-C&quot;, &quot;link-arg=-fuse-ld=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld&quot;, &quot;-C&quot;, &quot;link-arg=-ld_new&quot; # makes sure the new parallel linker is used ] # ghjk aliases `ld` to `mold` by default so the following # is not necessary # [target.x86_64-unknown-linux-gnu] # rustflags = [ # &quot;-C&quot;, &quot;link-arg=-fuse-ld=/path/to/mold&quot; # ]   Local typegraph with Nodejs​  Currently, the src/typegraph/node/ project is generated dynamically using the build-tgraph-ts-node ghjk task. Depending on your package manager, the protocol used may differ.  # uses the `file:..` protocol npm install path/to/typegraph/sdk/node/ # uses the `link:..` protocol (equivalent to `file:..` but for directories only) pnpm install path/to/typegraph/sdk/node/  ","version":"Next","tagName":"h3"},{"title":"Custom functions","type":0,"sectionRef":"#","url":"/docs/guides/external-functions","content":"","keywords":"","version":"Next"},{"title":"Accessing function context​","type":1,"pageTitle":"Custom functions","url":"/docs/guides/external-functions#accessing-function-context","content":" Beta The following feature is currently only implemented for the DenoRuntime.  On some runtimes, custom functions are passed to the context object along with the function inputs. This object provides access to all kinds of information about the context in which the function is running. The following example illustrates availaible fields:  Loading...  Note, the typescript version of the sample uses a closure instead of a string snippet to define the function. This is a simple syntax sugar availaible when using DenoRuntime through the typescript sdk or the PythonRuntime the python one. Consult the reference for each runtime to look at what's availaible.  ","version":"Next","tagName":"h2"},{"title":"Accessing the typegraph​","type":1,"pageTitle":"Custom functions","url":"/docs/guides/external-functions#accessing-the-typegraph","content":" Beta The following feature is currently only implemented for the DenoRuntime.  To do anything meaningful with custom functions, you'll want to access the rest of functionality implemented on your typegraph. The primary way of doing this is by sending GraphqQl queries from within your function. On the DenoRuntime, to make this easier, there's a gql object passed to all functions. The following exapmle illustrates how it functions:  Loading...  And scripts/createVote.ts looks like:  Loading...  ","version":"Next","tagName":"h2"},{"title":"Generating types​","type":1,"pageTitle":"Custom functions","url":"/docs/guides/external-functions#generating-types","content":" Beta The following feature is not yet stable.  Custom functions can be made smoother to develop or more robust to changes by using the metagen to generate code for them. By using the generated types along with static analysis tools in your workflow, this allows you to avoid many cases of drift between your custom functions and your typegraph. Not to mention improving the development experience of writing custom functions. The code generated for Python and Rust targets also includes the serialization boilerplate and utilities that you'd need for those to even get started in those languages.  The metagen library is availaible within the meta CLI or the typegraph SDK. In the following example we'll use the CLI to generate typescript code for a simple typegraph.  Loading...  We'll need to configure metagen through the metatype.yaml file. We add a new target to the metagen section that does what we need.  metagen: targets: # named targets to configure a bunch of generators together metagen_deno: - generator: fdk_typescript # generator to use # path to generate to path: ./metagen/ts/ # point to the typegraph location # or name of typegraph on a typegate somehwere typegraph_path: ./metagen-deno.ts   We can configure multiple target in our config file. Each target can have mutiple generator configurations. Metagen currently implements for the Typescript, Python and Rust targets.  We can then invoke the target using the following command:  meta gen metagen_deno   This results in the following files.  ❯ lsd --tree metagen  metagen └──  ts └──  fdk.ts   Within fdk.ts and the types and helpers, all the types from your typegraph should be there. Something like:  Code generation sample. Collapsed for aesthetic reasons. Loading...  Note, this also include typescript function types for specific typegraph functions. By default, the fdk_typescript generator will only include stub function types for those defined on the DenoRuntime but this is configurable.  We can then use these types in the following manner. Add the following snippet into metagen/ts/remix.ts.  Loading...  Ofcourse, we'll need to include both our implementation and the generated code when defining our typegraph functions. ","version":"Next","tagName":"h2"},{"title":"Importing External Modules","type":0,"sectionRef":"#","url":"/docs/guides/import-external-modules","content":"Importing External Modules So far, the functinos we've looked at have been generated by helpers like the CRUD helpers from the Prisma runtime or the the Random runtime's generate helper. The deno.policy function we used for authoring policies was also based on function objects. All these helpers are shorthands for creating function objects and now we'll look at how to roll a custom function ourselves. We'll be using the Deno runtime to run our code. Instead of including the code inline through a string, the Deno runtime allows us to import modules from disk. Our modules are allowed to use ESM imports to access libraries on different registries like npm and deno.land. We'll use these features to write a simple function that converts markdown to html. import * as marked from &quot;https://deno.land/x/marked/mod.ts&quot;; export function parse({ raw }: { raw: string }): string { return marked.parse(raw); } We'll expose our module using the deno runtime. Typescript SDK Python SDK typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... g.expose( { // .. parse_markdown: deno.import(t.struct({ raw: t.string() }), t.string(), { name: &quot;parse&quot;, // the path is parsed relative to the typegraph file module: &quot;md2html.ts&quot;, }), // .. }, pub, ); }); We can now access our func through the GraphQl api. Loading...","keywords":"","version":"Next"},{"title":"Write REST endpoints","type":0,"sectionRef":"#","url":"/docs/guides/rest","content":"Write REST endpoints The root functions, the ones we expose from our typegraphs, are served through a GraphQl API over HTTP. In addition, we can also expose REST APIs using the rest method. The method takes GraphQl queries and provides RESTly endpoints for them. Loading... The effect of the root function accessed in the query determines the HTTP verb used, and the mapping can be found here. There's also an OpenAPI schema generated from the rest endpoints served under {typegate_url}/{typegraph}/rest/_schema. A browser-based explorer for the OpenAPI schema is served under {typegate_url}/{typegraph}/rest as well. You can refer to the REST reference section for more information.","keywords":"","version":"Next"},{"title":"Upload files to cloud storage","type":0,"sectionRef":"#","url":"/docs/guides/files-upload","content":"","keywords":"","version":"Next"},{"title":"Uploading file using GraphQL multipart request​","type":1,"pageTitle":"Upload files to cloud storage","url":"/docs/guides/files-upload#uploading-file-using-graphql-multipart-request","content":" Metatype supportsGraphQL multipart requestfor uploading files. You may use one of the clients in thislistthat support GraphQL multipart request.  const image = await Deno.readFile(&quot;website/static/images/logo.png&quot;); const formData = new FormData(); formData.append( &quot;operations&quot;, JSON.stringify({ query: ` mutation UploadImage($file: Upload!) { upload(file: $file) { id path size contentType } } `, variables: { file: null, }, }), ); formData.append(&quot;map&quot;, JSON.stringify({ 0: [&quot;variables.file&quot;] })); formData.append(&quot;0&quot;, image, &quot;logo.png&quot;); const upload = await fetch(&quot;http://localhost:7891/files-upload&quot;, { method: &quot;POST&quot;, body: formData, }); console.log(await upload.json());  ","version":"Next","tagName":"h3"},{"title":"Features overview","type":0,"sectionRef":"#","url":"/docs/concepts/features-overview","content":"","keywords":"","version":"Next"},{"title":"Typegate​","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#typegate","content":" GraphQL API COMPLETE Expose select functions in your graph through a GraphQL API. These root-functions will serve as the entry point to your graph for any incoming request. The typegraph model is a great fit for GraphQL semantics and this is the best supported way to consume typegraphs. GraphQL Subscriptions FUTURE Get real-time data to clients. REST API COMPLETE You can expose select root functions through a simple REST API. This is handy to serve endpoints for clients that are not GraphQl capable, even though it hampers access to some typegraph features. Inputs will be sourced from either HTTP bodies or search parameters according to HTTP verb. gRPC API COMPLETE Expose your gRPC API, enabling high-performance, bi-directional communication between services. This allows you to call gRPC methods directly from the typegraph, providing more flexibility and better integration with existing gRPC-based microservices. This approach supports a broader range of real-time use cases . Cron triggers FUTURE Execute functions at certain time intervals. Useful for cleanup jobs. Rate-limiting COMPLETE Rate-limit parts of your graph to minimize abuse. The limits can be configured granularly for each function and for custom time windows. Use custom request identifiers, in addition to ip addresses, to track limits counters. CORS COMPLETE Specify cross-origin request rules to control which domains can access your API from within a browser. Prevents abuse from websites trying to use your API without permission. Single-node COMPLETE The typegate can be run as a single node mode for simple deployments and using the filesystem as its artifact store. Useful for local development and testing. Multi-node COMPLETE Deploy multiple instances of the typegate to distribute loads across machines and scale horizontally. You'll only need a Redis compatible key-value cache, an S3 compatible object store, and your favorite load-balancer in front of the instances to get it going. This mode is recommended for production deployments even if only a single node is used.    ","version":"Next","tagName":"h2"},{"title":"Typegraph​","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#typegraph","content":" Loading... Scalar types COMPLETE The primitive types integer, float, boolean, string and file. All data that flows through a typegraph reduces down to these types. Type constraints COMPLETE Declare types in your graph that are subset of primitives like string and integers by using regular expressions or min/max limits. Useful to validate incoming data even more and distribute invariants through your app. Composite types COMPLETE Support for struct, list, union, either and optional types. These allow you to represent types equivalent to most modern type systems. Injections COMPLETE Injections resolve part of your graph inline instead of from functions or provide defaults for incoming request data. This can be used to set static values or source them from the context, other parts of the graph...etc. Functions COMPLETE Nodes in your typegraph that represent data to be resolved after running some logic on a Runtime. Function chaining FUTURE Compose functions together by feeding the output of one as the input of another. Encourages code reuse by allowing one to extract common middleware logic from each function, all within the typegraph layer. reduce COMPLETE reduce is useful to transform function input types so that only certain struct fields are used, discarding the others. Required fields can be hidden from the user and can instead be injected from the request's context or a static default. This is useful for remixing generated or core domain types to more targeted forms appropriate for a function. apply COMPLETE apply allows the flattening of deeply nested function input types to something friendlier. Injection can also be used to substitute required fields in the original type from another source. Imports FUTURE Imports will allow graphs to include nodes from other API descriptions like GraphQL, OpenAPI, gRPC and database schemas. These APIs can then be consumed in a typesafe manner through the GraphQL and Http runtimes. Secrets COMPLETE First-class support for secrets to ease runtime substitution of sensetive values. API keys or dynamic values only discovrable after deployment, this is how you get them into your app.    ","version":"Next","tagName":"h2"},{"title":"Runtimes​","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#runtimes","content":" Deno runtime COMPLETE Write functions that execute pieces of TypeScript code on a Deno worker. Includes easy access to ESM and libraries through standard Deno features. Loading... Python runtime BETA Implement functions that execute python functions in code snippets or on disk modules. from typegraph import typegraph, Policy, t, Graph from typegraph.runtimes.deno import PythonRuntime @typegraph() def example_python(g: Graph): public = Policy.public() python = PythonRuntime() g.expose( public, add=t.func( t.struct({&quot;a&quot;: t.integer(), &quot;b&quot;: t.integer()}), t.integer(), # we can provide the code inline using lambdas python.from_lambda(lambda x: x[&quot;a&quot;] + x[&quot;b&quot;]), ), sayHello=python.import_( t.struct({&quot;name&quot;: t.string()}), t.string(), # point to pythoin a file on disc module=&quot;hello.py&quot;, name=&quot;say_hello&quot; ), ) } S3 runtime COMPLETE Store large blobs in S3 compatible object stores. This includes support for GraphQL file uploads and presigned URLs making working with images and large uploads a breeze. Temporal runtime COMPLETE Kick off and query Temporal workflows from a typegraph. Temporal is a durable execution engine that can be used to implement long-running, failure-resistant business processes. Wasm runtime BETA Make functions that use WASM components to implement their logic. Write core-wasm or wasi 0.2 based wasm components in languages like Rust, Python and Javascript to power all your custom functions. GraphQL runtime COMPLETE Include external GraphQL APIs as part of your typegraph. This runtime provides functions that resolve the data by querying an external GraphQL API. Http runtime COMPLETE Include external Http APIs as part of your typegraph. Source the data for your graph using external HTTP requests. Random runtime COMPLETE Functions to generate random data based on your types. Useful for quickly throwing together an API and testing. gRPC runtime COMPLETE Include external gRPC APIs as part of your typegraph.  ","version":"Next","tagName":"h2"},{"title":"Prisma​","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#prisma","content":" Access a myriad of databases directly from your typegraph. Run queries, mange it's schema, the full orm featureset.  Loading... Relational schemas COMPLETE Use the types in your graph to declare and manage relational schemas to be used on your databse. This means support for primary keys, unique constraints, one-to-one, one-to-many, many-to-many relationships...etc. CRUD queries COMPLETE Easily generate functions for common create, update, read and delete queries. Includes nested filtering and aggregration paramters for efficent and targeted requests. Raw queries COMPLETE Drop down to raw SQL queries for cases not covered by the CRUD generators. Useful to access unique features native to your database or craft extra efficient queries. PostgreSQL support COMPLETE Support for PostgreSQL, a modern and established DBMS. Beta databases BETA MySQL, MariaDB, AWS Aurora, AWS Aurora Serverless, Microsoft SQL Server, Azure SQL, MongoDB, CockroachDB.    ","version":"Next","tagName":"h3"},{"title":"Authentication​","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#authentication","content":" Policy-based access control COMPLETE Policies are simple functions that take the request as input and return values to signal whether it's allowed/denied access. They can be attached to any function in the graph and are evaluated right before the request triggers one. They compose well and are the primary authorization primitive available to typegraphs. Loading... Basic authentication COMPLETE Requests can authenticate themselves using Basic HTTP headers. Simple but useful for getting started or protecting admin only requests. Loading... JWT authentication COMPLETE Json Web Tokens can be used to attach more authentication and context information to requests. The data in the tokens can then be used by policies to make authorization decisions. Loading... OAuth2 authorization COMPLETE Use the Oauth2 scheme to implement social-sign in from common identity providers like Github, Meta and Google. Loading...    ","version":"Next","tagName":"h2"},{"title":"Tooling​","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#tooling","content":" Meta CLI COMPLETE Full-featured CLI to aid development and manage typegraph deployments on the typegate. Supports watch mode to aid rapid-iteration, including support for interactive database migration management. Bundles the typegate within it making the CLI all one needs to get started. (And a text editor, of course.) ❯ meta --help at 02:03:36 Declarative API development platform. Build backend components with WASM/Typescript/Python, no matter where and how your (legacy) systems are. Usage: meta [OPTIONS] [COMMAND] Commands: serialize Serialize the typegraphs defined in the specified python file(s) into JSON dev Push typegraph(s) with development mode features enabled deploy Push typegraph(s) to typegate undeploy Undeploy typegraph(s) from typegate gen Access metagen generators upgrade Upgrade completion Generate shell completion doctor Troubleshoot the installation new Create a new Metatype project typegate Access a minimal deno CLI help Print this message or the help of the given subcommand(s) Options: --version -v, --verbose... Increase logging verbosity -q, --quiet... Decrease logging verbosity -C, --dir &lt;DIR&gt; [default: .] --config &lt;CONFIG&gt; path to the config file -h, --help Print help Metagen BETA Code generation suite that supports Rust, Python and Typescript. Generate types from your graph and other helper functions for authoring custom functions for the Wasm, Python and Deno runtimes respectively. Can be accessed through the CLI under the gen subcommand or through the different SDKs. Meta LSP BETA Extension for your IDE to help authoring of typegraphs. Supports VSCode as of now. Docker images COMPLETE The typegate is primarily distributed as a docker image for deployment as a container. All the available configuration environment variables can be found here. Helm charts COMPLETE Helm charts are published to ease installation of a typegate deployment in your Kubernetes cluster. docker run --rm --pull always \\ -p 7890:7890 \\ -e TG_SECRET=$(openssl rand -base64 64 | tr -d '\\n') \\ -e TG_ADMIN_PASSWORD=&quot;password&quot; \\ ghcr.io/metatypedev/typegate:latest     ","version":"Next","tagName":"h2"},{"title":"SDKs​","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#sdks","content":" Typescript SDK COMPLETE Use typescript to author typegraphs and access other SDK tooling. Supports Node and compatible runtimes like Deno and Bun. Python SDK COMPLETE Use Python to author typegraphs and access other SDK tooling. Dart SDK FUTURE Use Dart to author typegraphs and access other SDK tooling. Deployments COMPLETE Programmatically upload your typegraphs to the typegate from within the SDK. Useful for writing tests or building on top of the Metatype platform. Migrations BETA Programmaticaly manage necessary migrations returned by the Prisma runtime. Useful for writing tests or building on top of the Metatype platform. Codegen BETA Access metagen through the SDK directly to generate type declarations and other helpful code. Useful for testing and to build custom workflows/tooling. ","version":"Next","tagName":"h2"},{"title":"Secure your requests","type":0,"sectionRef":"#","url":"/docs/guides/securing-requests","content":"","keywords":"","version":"Next"},{"title":"Authentication​","type":1,"pageTitle":"Secure your requests","url":"/docs/guides/securing-requests#authentication","content":" Typegraphs supports multiple auth schemes for incoming requests including:  Basic accessJSON Web Tokens (JWT)OAuth2  Each scheme relies on tokens that will be expected on the Authorization header of any incoming request. Information extracted from any found tokens will then be added to the context of every request. Each scheme allows for different secrets to be encoded in the tokens, secrets like user identification and access tokens. You can then use policies to examine the context and determine if a request is allowed access to parts of your typegraph. You can also inject data from the context, to set materalizer inputs for example, using from_context.  The following example uses basic authentication in order to only allow access for admin users. Basic authentication relies on a username and password pair. We specify the password through typegraph secrets with the format BASIC_{username}. In this case, the secret BASIC_andim=password is set.  Loading...  Note, the token is encoded in base64. Decoded, it'd read andim:password.  If you were to try to send a request without the header, you'd notice that get_full_context still returns a result. An empty object. Authentication is only responsible for populating the context object and without a policy to shoot down the request, it'll access the materalizers.  On the other hand, get_context returns an empty object when no header is found. from_context acts as guard preventing the materalizer from being accessed unless the named data is found in the context.  More details about authentication can be found here.  ","version":"Next","tagName":"h2"},{"title":"Policies​","type":1,"pageTitle":"Secure your requests","url":"/docs/guides/securing-requests#policies","content":" The primary authorization paradigm used in typegraphs is policy based access control. Policies are small pieces of logic that evaluate a request and determine whether access is allowed or not. They're attached to materalizers and are evaluated whenever a request tries to access the materalizer.  Concretely, policies are implemented using custom function. These functions take the request's context object as input and return an optional bool. Typescript functions running on DenoRuntime is the recommended way for writing policies today and the following example demonstrates how.  Before anything, the following secrets are required to enable the basic authentication scheme.  typegates: dev: # .. secrets: policies: BASIC_admin: &quot;admin_pass&quot; BASIC_user: &quot;user_pass&quot;   Loading...  More than one policy can be attached to a single materalizer and combining policies allows for compositionaly defining our access control rules. If a materalizer has more than one policy, they are evaluated in turn and:  If any one of attached policy returns true, the request immediately gains access.If a policy returns false, the request is immediately denied access.If the policy means to defer decision to other attached policies, it can return null instead.If all attached policies return null, the request is denied access.  There are helper functions on the Policy object that allow easy construction of common policy patterns.  Policy.public: allow any request.Policy.internal: allow requests originating from within typegraph like custom functions.Policy.on: use different policies depending on request effect. Useful for policy shared across many materalizers.Policy.context: generate a policy using a simple pattern matching on context object fields. ","version":"Next","tagName":"h2"},{"title":"Self-host the Typegate","type":0,"sectionRef":"#","url":"/docs/guides/self-hosting","content":"","keywords":"","version":"Next"},{"title":"Helm​","type":1,"pageTitle":"Self-host the Typegate","url":"/docs/guides/self-hosting#helm","content":" Helm must be installed to use the charts. Please refer to Helm's documentation to get started. The chart can be accessed on the dedicatedrepository.  Once Helm has been set up correctly, add the repo as follows:  helm repo add metatype https://charts.metatype.dev helm show values metatype/typegate &gt; values.yml # customize values.yaml helm install my-gate --values values.yml metatype/typegate  ","version":"Next","tagName":"h2"},{"title":"Programmatic deployment","type":0,"sectionRef":"#","url":"/docs/guides/programmatic-deployment","content":"","keywords":"","version":"Next"},{"title":"Deploy typegraphs​","type":1,"pageTitle":"Programmatic deployment","url":"/docs/guides/programmatic-deployment#deploy-typegraphs","content":" This can be done using the tgDeploy/tg_deploy function. You are required to provide the configurations and also handle migrations by yourself (if any).  Typescript SDK Python SDK import { Policy, t, typegraph } from &quot;@typegraph/sdk/index.ts&quot;; import { DenoRuntime } from &quot;@typegraph/sdk/runtimes/deno.ts&quot;; // deno-lint-ignore no-external-import import * as path from &quot;node:path&quot;; import { BasicAuth, tgDeploy } from &quot;@typegraph/sdk/tg_deploy.ts&quot;; // Your typegraph export const tg = await typegraph(&quot;example&quot;, (g) =&gt; { const deno = new DenoRuntime(); const pub = Policy.public(); g.expose( { sayHello: deno.import(t.struct({ name: t.string() }), t.string(), { module: &quot;scripts/say_hello.ts&quot;, name: &quot;sayHello&quot;, }), }, pub, ); }); // Configure your deployment let baseUrl = &quot;&lt;TYPEGATE_URL&gt;&quot;; let auth = new BasicAuth(&quot;&lt;USERNAME&gt;&quot;, &quot;&lt;PASSWORD&gt;&quot;); const config = { typegate: { url: baseUrl, auth: auth, }, typegraphPath: path.join(cwd, &quot;path-to-typegraph.ts&quot;), prefix: &quot;&quot;, secrets: {}, migrationsDir: path.join(&quot;prisma-migrations&quot;, tg.name), defaultMigrationAction: { apply: true, create: true, reset: true, // allow destructive migrations }, }; // Deploy to typegate const deployResult = await tgDeploy(tg, config);   ","version":"Next","tagName":"h2"},{"title":"Undeploy typegraphs​","type":1,"pageTitle":"Programmatic deployment","url":"/docs/guides/programmatic-deployment#undeploy-typegraphs","content":" Similarly to the above, you can undeploy typegraphs using the tgRemove/tg_remove function.  Typescript SDK Python SDK import { typegraph } from &quot;@typegraph/sdk/index.ts&quot;; import { BasicAuth, tgRemove } from &quot;@typegraph/sdk/tg_deploy.ts&quot;; // Your typegraph const tg = await typegraph(&quot;example&quot;, (_g) =&gt; { // ... }); // Response from typegate, const result = await tgRemove(tg.name, { // pass the typegraph name typegate: { url: baseUrl, auth: auth, }, });  ","version":"Next","tagName":"h2"},{"title":"Ecosystem","type":0,"sectionRef":"#","url":"/docs/reference/ecosystem","content":"","keywords":"","version":"Next"},{"title":"ghjk​","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#ghjk","content":" ghjk /gk/ is a programmable runtime manager and an attempt at a successor for asdf. It powers the development of Metatype on its authors' machines, on the CI and containers.  ","version":"Next","tagName":"h2"},{"title":"Substantial​","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#substantial","content":" Substantial is brokerless durable execution for Python. It serves as a sandbox to develop Metatype workflows engine.  ","version":"Next","tagName":"h2"},{"title":"Lade​","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#lade","content":" Lade automatically load secrets from your preferred vault as environment variables, and clear them once your shell command is over. The Meta CLI bundles Lade and use it to load secret seamlessly into your typegates.    ","version":"Next","tagName":"h2"},{"title":"Whiz​","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#whiz","content":" Whiz is a modern DAG/tasks runner for multi-platform monorepos. It enables to develop the core components of the ecosystem together and reloading only the necessary tasks on file change.   ","version":"Next","tagName":"h2"},{"title":"Meta CLI","type":0,"sectionRef":"#","url":"/docs/reference/meta-cli","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Meta CLI","url":"/docs/reference/meta-cli#installation","content":" info Metatype is only supported on macOS and Linux. Windows users should use Linux on Windows with WSL.  You can download the binary from thereleases page, make it executable and add it to your PATH or use the automated method below.  An installer script is also provided for the CLI in our repository. Curl and install in it with the following one-liner. The installer may ask for your password. curl -fsSL https://raw.githubusercontent.com/metatypedev/metatype/main/installer.sh | bash   info For later use, you can run the following command to upgrade Meta CLI to a newer version. If your Meta CLI is up to date, you will get an Already up to date! response. meta upgrade   That's it! You are done installing Meta CLI.  For development purposes, the cli bundles the typegate itself and this can be accessed through the meta dev subcommand.    📄️ Available commands 📄️ Configuration file ","version":"Next","tagName":"h2"},{"title":"Available commands","type":0,"sectionRef":"#","url":"/docs/reference/meta-cli/available-commands","content":"","keywords":"","version":"Next"},{"title":"Managing typegraphs​","type":1,"pageTitle":"Available commands","url":"/docs/reference/meta-cli/available-commands#managing-typegraphs","content":" Command\tExample of use\tDescriptiondeploy meta deploy --target dev --file path/to/typegraph.py meta --dir folder/to/typegraphs dev --run-destructive-migrations Deploy typegraph to a typegate instance undeploy meta undeploy --target dev --typegraph logs accounting services Undeploy typegraphs by name gen meta gen mod --file path/to/typegraph.py meta gen fdk Generate script or files that are used in your typegraph typegate meta typegate --quiet Access a minimal deno CLI dev meta dev Launch CLI in dev mode  info The typegate sub-command is not available on the thin version of the meta binary.  ","version":"Next","tagName":"h2"},{"title":"Troubleshooting and others​","type":1,"pageTitle":"Available commands","url":"/docs/reference/meta-cli/available-commands#troubleshooting-and-others","content":" Command\tExample of use\tDescriptiondoctor meta doctor Help troubleshoot all your installations completion meta completion meta completion --shell bash Generate shell completion (supports bash, elvish, fish, powershell, zsh) serialize meta serialize --file path/to/typegraph.py Inspect serialized version of your typegraph upgrade meta upgrade meta upgrade --version 0.3.4 Upgrade current cli  Feel free to use the --help flag if you want more information on each command and sub-command.  meta -h meta deploy -h meta gen mod -h   ","version":"Next","tagName":"h2"},{"title":"Environment variables​","type":1,"pageTitle":"Available commands","url":"/docs/reference/meta-cli/available-commands#environment-variables","content":" Name\tDescription\tDefault valueLOADER_TIMEOUT_SECS\tSet deploy timeout in seconds\t120 ","version":"Next","tagName":"h2"},{"title":"Configuration file","type":0,"sectionRef":"#","url":"/docs/reference/meta-cli/configuration-file","content":"","keywords":"","version":"Next"},{"title":"metatype.yml Example file​","type":1,"pageTitle":"Configuration file","url":"/docs/reference/meta-cli/configuration-file#metatypeyml-example-file","content":" The metatype.yml is a configuration file where we store environment variables, secrets and configs in which our app will use during deployment and runtime.  typegates: dev: url: http://localhost:7890 username: admin password: password secrets: my-app: POSTGRES_URL: postgres://user:password@localhost:5432/db?schema=public typegraphs: python: include: &quot;**/*.py&quot; materializers: prisma: migrations_path: &quot;migrations&quot;   ","version":"Next","tagName":"h2"},{"title":"Typegate configuration​","type":1,"pageTitle":"Configuration file","url":"/docs/reference/meta-cli/configuration-file#typegate-configuration","content":" Each typegate node is configured under typegates.&lt;name&gt;. The typegate node selection is done by the --target option in the CLI.  ","version":"Next","tagName":"h2"},{"title":"Named secrets​","type":1,"pageTitle":"Configuration file","url":"/docs/reference/meta-cli/configuration-file#named-secrets","content":" Named secrets are used to configure runtimes. Their values are provided in the secrets section of the configuration file directly or indirectly using lade. Each entry in the secrets section is the set of secrets for a specific typegraph. The typegraph name is the key of the entry and the value is an object mapping each secret name to its value or vault source (see next section).  To sum up, each secret is defined in secrets.&lt;typegraph-name&gt;.&lt;secret-name&gt;.&lt;secret-value-or-source&gt;.  ","version":"Next","tagName":"h3"},{"title":"Automatic secret loading support​","type":1,"pageTitle":"Configuration file","url":"/docs/reference/meta-cli/configuration-file#automatic-secret-loading-support","content":" Lade is a secret loading tool that transparently inject environment variables from a variety of sources. It works with Fish, Bash or Zsh and currently supports Doppler, Infisical and 1Password as vault source.  To use Lade with Metatype, you can use the op://, infisical:// or doppler:// prefixes in your configuration file. It will then use the CLI of the vault to securely load the required secrets. For example:  typegates: dev: url: http://localhost:7890 username: op://VAULT_NAME/SECRET_NAME/FIELD_NAME password: infisical://app.infisical.com/PROJECT_NAME/ENV_NAME/SECRET_NAME  ","version":"Next","tagName":"h2"},{"title":"Embedded Typegate","type":0,"sectionRef":"#","url":"/docs/reference/meta-cli/embedded-typegate","content":"","keywords":"","version":"Next"},{"title":"Test typegraphs","type":0,"sectionRef":"#","url":"/docs/guides/test-your-typegraph","content":"Test typegraphs Typegraph is the SDK for Metatype, used to author and define applications.. Typegraphs can be easily tested using common test suites in your preferred programming language. The following next lines describe how you can test your typegraph. For Typescript SDK, we will be using vitest and pytest for the Python SDK in this example. Typescript SDK Python SDK To test typegraphs in the typescript SDK, you first need to add vitest as a dev dependency to your metatype project. info You can follow this link on how to bootstrap a metatype application. To install vitest, you can execute the command below in your terminal based on the runtime you are using for the project. pnpm npm jsr deno yarn bun npm install -D vitest After you have installed vitest, your project is set up for some tests. Create a test tg.test.ts in /tests directory from the root project dir. vitest discovers tests by file names, so ensure that your test names follow the following format below. **/*.test.ts **/*.spec.ts For this example, the template typegraph generated from the meta new command is used, which is the one down below. ... export const tg = typegraph(&quot;example&quot;, (g) =&gt; { const pub = Policy.public(); const deno = new DenoRuntime(); const python = new PythonRuntime(); g.expose({ add: python .fromLambda( t.struct({ first: t.float(), second: t.float() }), t.float(), { code: &quot;lambda x: x['first'] + x['second']&quot; }, ) .withPolicy(pub), multiply: deno .func(t.struct({ first: t.float(), second: t.float() }), t.float(), { code: &quot;({first, second}) =&gt; first * second&quot;, }) .withPolicy(pub), }); }); For the typegraph test file, you can write these simple test cases to check the validity of your typegraphs. import { assert, assertType, expect, test } from &quot;vitest&quot;; import { BasicAuth, tgDeploy, DeployResult } from &quot;@typegraph/sdk/tg_deploy&quot;; test(&quot;checks if typegraph output is computed&quot;, async () =&gt; { const tg_output = await tg; assertType&lt;TypegraphOutput&gt;(tg_output); }); test(&quot;test if typegraph name is correct&quot;, async () =&gt; { const tg_output = await tg; assert(tg_output.name === &quot;example&quot;, &quot;typegraph name is correct&quot;); }); test(&quot;test if serialize function exists&quot;, async () =&gt; { const tg_output = await tg; assertType&lt;Function&gt;(typeof tg_output.serialize); }); The above were simple tests you can execute against the output of the typegraph function. You can also do a serialization test to check if the typegraph is serialized successfully. To run the tests in watch mode, you can use the following command. vitest watch ... let reusableTgOutput; test(&quot;test if typegraph serialization works&quot;, async () =&gt; { const tg_output = await tg; const params = { typegraphPath: &quot;api/example.mjs&quot;, prefix: &quot;&quot;, artifactResolution: true, codegen: false, prismaMigration: { migrationsDir: &quot;prisma-migrations&quot;, migrationActions: Object.entries({}), defaultMigrationAction: { apply: true, create: false, reset: false, }, }, pretty: false, }; const serialized = tg_output.serialize(params); // cache the serialize result as the serialize function can only be called one time reusableTgOutput = { ...tg_output, serialize: (params) =&gt; serialized, }; assert(serialized !== null, &quot;Serialization Successful&quot;); assertType&lt;TgFinalizationResult&gt;(serialized); }); Furthermore, you can test typegraph deployment and running a query against a typegate instance. You first test for typegraph deploy, then querying into a typegate instance. The following tests depict on how you can do that. info Make sure you have a typegate node running for the next tests to work. ... const gate = &quot;http://localhost:7891&quot;; const typegraph_name = &quot;example&quot;; test(&quot;test typegraph deploy to typegate&quot;, async () =&gt; { const auth = new BasicAuth(&quot;admin&quot;, &quot;password&quot;); const deploy_result = await tgDeploy(reusableTgOutput, { typegate: { url: gate, auth: auth }, typegraphPath: &quot;api/example.mjs&quot;, prefix: &quot;&quot;, secrets: {}, migrationsDir: &quot;prisma-migrations&quot;, migrationActions: {}, defaultMigrationAction: { apply: false, create: false, reset: false } }); assertType&lt;DeployResult&gt;(deploy_result); assert(deploy_result.serialized !== null); expect(deploy_result.response).toMatchObject({ name: &quot;example&quot;, messages: [], migrations: [], }); }); test(&quot;test defined endpoints from the typegraph&quot;, async () =&gt; { const query = ` { add(first: 17, second: 20) } `; const url = `${gate}/${typegraph_name}`; const response = await fetch(url, { method: &quot;POST&quot;, headers: { &quot;Content-Type&quot;: &quot;application/json&quot;, }, body: JSON.stringify({query}) }); assert(response.ok); expect(response.status).toBe(200); const responseBody = await response.json(); const expectedResult = {data: {add: 37}}; assert.exists(responseBody); expect(responseBody).toMatchObject(expectedResult) }); test(&quot;test typegraph undeployment&quot;, async () =&gt; { const undeploy_result = await tgRemove( &quot;example&quot;, { typegate: { auth: new BasicAuth(&quot;admin&quot;, &quot;password&quot;), url: gate } } ); expect(undeploy_result.typegate).toMatchObject( { data: { removeTypegraphs: true } } ); }); info It's recommended to setup an after and before test hooks to clean up any database changes. So make sure to include those keep the state before and after tests the same. You don't have to stop here, you can test various outputs you get from running the typegraph function and querying directly into the deployed typegraphs. You can add more test cases to make your app robust.","keywords":"","version":"Next"},{"title":"1. dev subcommand​","type":1,"pageTitle":"Embedded Typegate","url":"/docs/reference/meta-cli/embedded-typegate#1-dev-subcommand","content":" You can start the embedded typegatxe easily with default configs using the following command.  meta dev   The above command can be a good gateway to get started and also for development purposes. But if you want more granular control, you can use the second approach.  ","version":"Next","tagName":"h3"},{"title":"2. typegate subcommand​","type":1,"pageTitle":"Embedded Typegate","url":"/docs/reference/meta-cli/embedded-typegate#2-typegate-subcommand","content":" Set the tg_admin_password and tg_secret environment variables. You can use the following command to configure a sample value for the variables and test the embedded typegate.  export tg_secret=a4lNi0PbEItlFZbus1oeH/+wyIxi9uH6TpL8AIqIaMBNvp7SESmuUBbfUwC0prxhGhZqHw8vMDYZAGMhSZ4fLw== tg_admin_password=password   Run the instance  meta typegate   The typegate instance runs on port 7890 by default. You can check if the typegate node is running by accessing http://localhost:7890 in your browser. ","version":"Next","tagName":"h3"},{"title":"Wasm functions","type":0,"sectionRef":"#","url":"/docs/guides/wasm-functions","content":"","keywords":"","version":"Next"},{"title":"Tooling​","type":1,"pageTitle":"Wasm functions","url":"/docs/guides/wasm-functions#tooling","content":" We need to install several programs to be able to produce the components. The following checklist contains links to get you started:  Rust compiler toolchain: this guide assumes moderate familiartiy of development with rust and won't spend many words on how to get it functional. In any case, you can get started with rust here.wasm32-unknown-unknown target for rustc: This is the backend that rustc uses to produce wasi compatible wasm components. If you're using rustup to manage your toolchain, Cargo will automatically install the target when you're building.wasm-tools: this is the swiss army knife for working with wasm artifacts, courtesy of the Bytecode Alliance. Installation instructions can be found here.  ","version":"Next","tagName":"h2"},{"title":"Typegraph​","type":1,"pageTitle":"Wasm functions","url":"/docs/guides/wasm-functions#typegraph","content":" The WasmRuntime currently comes in two flavours that are both based on the wasm component spec. This guide focues on the wire flavour, where your component is expected to implement a standard WIT interface that's designed around a simple Json based RPC wire format. Thankfully, all of that boilerplate is easy to automate away and that's exactly what we'll do using metagen to generate the binding code.  Before anything though, we need to author the typegraph:  Loading...  Note that the WasmRuntime constructor mentions a non-existent wasm file on disk. This won't be a problem for the metagen generators but we'll need to produce the artifact before we deploy the typegraph. We'll see what buliding the artifact entails in just a minute.  ","version":"Next","tagName":"h2"},{"title":"Metagen​","type":1,"pageTitle":"Wasm functions","url":"/docs/guides/wasm-functions#metagen","content":" We can now tackle the boilerplate. Metagen bundles the fdk_rust generator which can generate all the glue code along with Rust types that correspond to our typegraph types. Let's configure a metagen target in our configuration file to get just that done.  metagen: targets: metagen_rs: # this is the generator we're interested in - generator: fdk_rust # the location where to put the generated files path: ./metagen/rs/ # the path to our typegraph typegraph_path: ./metagen-rs.ts   The configuration file is read by the meta CLI which also bundles the metagen suite. This means we can invoke the target from the command line like so:  meta gen metagen_rs   This should give us the following files:  ❯ lsd --tree metagen/rs/  rs ├──  Cargo.toml ├──  lib.rs └──  fdk.rs   By default, the fdk_rust generator outputs all the necessary files required to build our wasm file. This includes the Cargo.toml manifest for our Rust crate.  package.name = &quot;metagen_rs_fdk&quot; package.edition = &quot;2021&quot; package.version = &quot;0.0.1&quot; # we need to use a specific library crate type to build # wasm components in rust [lib] path = &quot;lib.rs&quot; crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;] # the following dependencies are used by the generated code [dependencies] anyhow = &quot;1&quot; # error handling serde = { version = &quot;1&quot;, features = [&quot;derive&quot;] } # serialization serde_json = &quot;1&quot; #json serialization wit-bindgen = &quot;0.22.0&quot; # wasm component biding # we set the following flags to minimize code size # when buliding in the release mode # this keeps our wasm files small [profile.release] strip = &quot;symbols&quot; opt-level = &quot;z&quot;   fdk_rust will not overwrite a Cargo.toml file discovered at generation path so you can add other dependencies if need be.  The fdk.rs file contains all the glue code including the typegraph types.  Code generation sample. It's collapsed here as it's for the most part an uninteresting implementation detail. // This file was @generated by metagen and is intended // to be generated again on subsequent metagen runs. #![cfg_attr(rustfmt, rustfmt_skip)] // gen-static-start #![allow(dead_code)] pub mod wit { wit_bindgen::generate!({ pub_export_macro: true, inline: &quot;package metatype:wit-wire; interface typegate-wire { hostcall: func(op-name: string, json: string) -&gt; result&lt;string, string&gt;; } interface mat-wire { type json-str = string; record mat-info { op-name: string, mat-title: string, mat-hash: string, mat-data-json: string, } record init-args { metatype-version: string, expected-ops: list&lt;mat-info&gt; } record init-response { ok: bool } variant init-error { version-mismatch(string), unexpected-mat(mat-info), other(string) } init: func(args: init-args) -&gt; result&lt;init-response, init-error&gt;; record handle-req { op-name: string, in-json: json-str, } variant handle-err { no-handler, in-json-err(string), handler-err(string), } handle: func(req: handle-req) -&gt; result&lt;json-str, handle-err&gt;; } world wit-wire { import typegate-wire; export mat-wire; } &quot; }); } use std::cell::RefCell; use std::collections::HashMap; use wit::exports::metatype::wit_wire::mat_wire::*; use wit::metatype::wit_wire::typegate_wire::hostcall; pub type HandlerFn = Box&lt;dyn Fn(&amp;str, Ctx) -&gt; Result&lt;String, HandleErr&gt;&gt;; pub struct ErasedHandler { mat_id: String, mat_trait: String, mat_title: String, handler_fn: HandlerFn, } pub struct MatBuilder { handlers: HashMap&lt;String, ErasedHandler&gt;, } impl MatBuilder { pub fn new() -&gt; Self { Self { handlers: Default::default(), } } pub fn register_handler(mut self, handler: ErasedHandler) -&gt; Self { self.handlers.insert(handler.mat_trait.clone(), handler); self } } pub struct Router { handlers: HashMap&lt;String, ErasedHandler&gt;, } impl Router { pub fn from_builder(builder: MatBuilder) -&gt; Self { Self { handlers: builder.handlers, } } pub fn init(&amp;self, args: InitArgs) -&gt; Result&lt;InitResponse, InitError&gt; { static MT_VERSION: &amp;str = &quot;0.5.0-rc.1&quot;; if args.metatype_version != MT_VERSION { return Err(InitError::VersionMismatch(MT_VERSION.into())); } for info in args.expected_ops { let mat_trait = stubs::op_to_trait_name(&amp;info.op_name); if !self.handlers.contains_key(mat_trait) { return Err(InitError::UnexpectedMat(info)); } } Ok(InitResponse { ok: true }) } pub fn handle(&amp;self, req: HandleReq) -&gt; Result&lt;String, HandleErr&gt; { let mat_trait = stubs::op_to_trait_name(&amp;req.op_name); let Some(handler) = self.handlers.get(mat_trait) else { return Err(HandleErr::NoHandler); }; let cx = Ctx {}; (handler.handler_fn)(&amp;req.in_json, cx) } } pub type InitCallback = fn() -&gt; anyhow::Result&lt;MatBuilder&gt;; thread_local! { pub static MAT_STATE: RefCell&lt;Router&gt; = panic!(&quot;MAT_STATE has not been initialized&quot;); } pub struct Ctx {} impl Ctx { pub fn gql&lt;O&gt;( &amp;self, query: &amp;str, variables: impl Into&lt;serde_json::Value&gt;, ) -&gt; Result&lt;O, GraphqlRunError&gt; where O: serde::de::DeserializeOwned, { match hostcall( &quot;gql&quot;, &amp;serde_json::to_string(&amp;serde_json::json!({ &quot;query&quot;: query, &quot;variables&quot;: variables.into(), }))?, ) { Ok(json) =&gt; Ok(serde_json::from_str(&amp;json[..])?), Err(json) =&gt; Err(GraphqlRunError::HostError(serde_json::from_str(&amp;json)?)), } } } #[derive(Debug)] pub enum GraphqlRunError { JsonError(serde_json::Error), HostError(serde_json::Value), } impl std::error::Error for GraphqlRunError {} impl From&lt;serde_json::Error&gt; for GraphqlRunError { fn from(value: serde_json::Error) -&gt; Self { Self::JsonError(value) } } impl std::fmt::Display for GraphqlRunError { fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result { match self { GraphqlRunError::JsonError(msg) =&gt; write!(f, &quot;json error: {msg}&quot;), GraphqlRunError::HostError(serde_json::Value::Object(map)) if map.contains_key(&quot;message&quot;) =&gt; { write!(f, &quot;host error: {}&quot;, map[&quot;message&quot;]) } GraphqlRunError::HostError(val) =&gt; write!(f, &quot;host error: {val:?}&quot;), } } } #[macro_export] macro_rules! init_mat { (hook: $init_hook:expr) =&gt; { struct MatWireGuest; use wit::exports::metatype::wit_wire::mat_wire::*; wit::export!(MatWireGuest with_types_in wit); #[allow(unused)] impl Guest for MatWireGuest { fn handle(req: HandleReq) -&gt; Result&lt;String, HandleErr&gt; { MAT_STATE.with(|router| { let router = router.borrow(); router.handle(req) }) } fn init(args: InitArgs) -&gt; Result&lt;InitResponse, InitError&gt; { let hook = $init_hook; let router = Router::from_builder(hook()); let resp = router.init(args)?; MAT_STATE.set(router); Ok(resp) } } }; } // gen-static-end use types::*; pub mod types { pub type Idv3TitleString = String; pub type Idv3ReleaseTimeStringDatetime = String; pub type Idv3Mp3UrlStringUri = String; #[derive(Debug, serde::Serialize, serde::Deserialize)] pub struct Idv3 { pub title: Idv3TitleString, pub artist: Idv3TitleString, #[serde(rename = &quot;releaseTime&quot;)] pub release_time: Idv3ReleaseTimeStringDatetime, #[serde(rename = &quot;mp3Url&quot;)] pub mp3_url: Idv3Mp3UrlStringUri, } } pub mod stubs { use super::*; pub trait RemixTrack: Sized + 'static { fn erased(self) -&gt; ErasedHandler { ErasedHandler { mat_id: &quot;remix_track&quot;.into(), mat_title: &quot;remix_track&quot;.into(), mat_trait: &quot;RemixTrack&quot;.into(), handler_fn: Box::new(move |req, cx| { let req = serde_json::from_str(req) .map_err(|err| HandleErr::InJsonErr(format!(&quot;{err}&quot;)))?; let res = self .handle(req, cx) .map_err(|err| HandleErr::HandlerErr(format!(&quot;{err}&quot;)))?; serde_json::to_string(&amp;res) .map_err(|err| HandleErr::HandlerErr(format!(&quot;{err}&quot;))) }), } } fn handle(&amp;self, input: Idv3, cx: Ctx) -&gt; anyhow::Result&lt;Idv3&gt;; } pub fn op_to_trait_name(op_name: &amp;str) -&gt; &amp;'static str { match op_name { &quot;remix_track&quot; =&gt; &quot;RemixTrack&quot;, _ =&gt; panic!(&quot;unrecognized op_name: {op_name}&quot;), } } }   When working on the typegraph, we can run metagen again to regenerate this file and get the latest types.  The generator also includes a sample lib.rs entrypoint file for our crate. We'll modify it now to implement our custom function.  mod fdk; pub use fdk::*; // the macro sets up all the glue init_mat! { // the hook is expected to return a MatBuilder instance hook: || { // initialize global stuff here if you need it MatBuilder::new() // register function handlers here // each trait will map to the name of the // handler found in the typegraph .register_handler(stubs::RemixTrack::erased(MyMat)) } } struct MyMat; impl stubs::RemixTrack for MyMat { fn handle(&amp;self, input: types::Idv3, _cx: Ctx) -&gt; anyhow::Result&lt;types::Idv3&gt; { Ok(types::Idv3 { title: format!(&quot;{} (Remix)&quot;, input.title), artist: format!(&quot;{} + DJ Cloud&quot;, input.artist), release_time: input.release_time, mp3_url: &quot;https://mp3.url/shumba2&quot;.to_string(), }) } }   ","version":"Next","tagName":"h2"},{"title":"Building​","type":1,"pageTitle":"Wasm functions","url":"/docs/guides/wasm-functions#building","content":" We'll now use the rust toolchain and wasm-tools to build the wasm component. This requires multiple commands. It's presented below as a shell script that you can modify from.  # flags to make script execution visible set -eux # regenerate code before building meta gen metagen_rs # variablize common names TARGET=wasm32-wasi CRATE_NAME=metagen_rs_fdk # build in release mode for smallest sizes cargo build -p $CRATE_NAME --target $TARGET --release # use wasm-tools to change wasm file into wasm component wasm-tools component new \\ # rust builds the wasm file under the name of the crate ./target/$TARGET/debug/$CRATE_NAME.wasm \\ -o ./target/rust-component.wasm \\ # copy the component to a location that we specified # in our typegraph cp ./target/rust-component.wasm ./rust.wasm   Put the shell script into a file like build.sh and execute it with a posix compatible shell like bash. You should now have all the files to deploy your typegraph.  Loading... ","version":"Next","tagName":"h2"},{"title":"Policies","type":0,"sectionRef":"#","url":"/docs/reference/policies","content":"","keywords":"","version":"Next"},{"title":"Policy based access control (PBAC)​","type":1,"pageTitle":"Policies","url":"/docs/reference/policies#policy-based-access-control-pbac","content":" The Deno runtime enable to understand the last abstraction. Policies are a way to verify for each type whether the user is authorized or not to access it. It's a very powerful concept that can be for instance used to guarantee a given type is never accidentally exposed to the outside world.  Metatype comes with some built-in policies, but you can use the Deno runtime to define your own:  policies.public() is an alias for Policy(PureFunMat(&quot;() =&gt; true&quot;)) providing everyone open access.policies.ctx(&quot;role_value&quot;, &quot;role_field&quot;) is a companion policy for the authentication strategy you learned in the previous section. It will verify the context and give adequate access to the user.  Policies are hierarchical in the sense that the request starts with a denial, and the root functions must explicitly provide an access or not. Once access granted, any further types can either inherit or override the access. Policies evaluate in order in case multiple ones are defined.  Loading... ","version":"Next","tagName":"h2"},{"title":"REST","type":0,"sectionRef":"#","url":"/docs/reference/rest","content":"","keywords":"","version":"Next"},{"title":"General rule​","type":1,"pageTitle":"REST","url":"/docs/reference/rest#general-rule","content":" query_type endpoint_name($param1: T1, $param2: T2, ..) { exposed(..) { f1 f2 .. } }   There is no rule in what type of query you should do most of the time as everything is up to you, however the type of query you set will define how your endpoint should be used.  In other words, depending on what query_type (query or mutation), $param1, $param2, .. will be defined from the request parameters (GET) or the request body (POST).  query: Perform a GET at {TYPEGATE_URL}/{TG_NAME} /rest/endpoint_name?param1=..&amp;param2=..mutation: Perform a POST at {TYPEGATE_URL}/{TG_NAME} /rest/endpoint_name with Content-Type set as application/json  { &quot;param1&quot;: .., &quot;param2&quot;: .., .. }   In the example above, for a local instance, the endpoint might look like: http://localhost:7890/example/rest/users?name=Bob&amp;rows=10  ","version":"Next","tagName":"h2"},{"title":"Dynamic queries​","type":1,"pageTitle":"REST","url":"/docs/reference/rest#dynamic-queries","content":" This enables/disables all non-static queries, i.e. queries whose output or side effects depend on certain parameters.  By default, dynamic is always on.  Typescript SDK Python SDK typegraph({ name: &quot;my-typegraph&quot;, dynamic: false }, (g) =&gt; { // .. });   ","version":"Next","tagName":"h2"},{"title":"Auto-generated docs​","type":1,"pageTitle":"REST","url":"/docs/reference/rest#auto-generated-docs","content":" In any case, you can always check the auto-generated documentation of the available endpoints, parameters, output shapes.  You can browse it at {TYPEGATE_URL}/{TG_NAME}/rest.  ","version":"Next","tagName":"h2"},{"title":"OpenAPI clients​","type":1,"pageTitle":"REST","url":"/docs/reference/rest#openapi-clients","content":" In some cases, as your typegraph gets more complicated, you may want to automate the step of writing clients and focus on the actual logic of your application instead.  The OpenAPI spec will be available at {TYPEGATE_URL}/{TG_NAME}/rest/__schema, which is very useful considering that there are already a number of tools that enable you to create clients from an existing OpenAPI specification file.  Once you download the specification file for your API, it should look like something like this:  // {TYPEGATE_URL}/my_awesome_typegraph/rest/__schema { &quot;openapi&quot;: &quot;3.0.3&quot;, &quot;info&quot;: { &quot;title&quot;: &quot;my_awesome_typegraph&quot;, &quot;license&quot;: { &quot;name&quot;: &quot;MIT&quot; }, &quot;description&quot;: &quot;Rest endpoints for typegraph \\&quot;my_awesome_typegraph\\&quot;&quot;, &quot;version&quot;: &quot;1.0.0&quot; }, &quot;servers&quot;: [{ &quot;url&quot;: &quot;http://localhost:7890&quot; }], &quot;paths&quot;: { // typing each path manually on a custom client can be very tedious as your API grows &quot;/my_awesome_typegraph/rest/get_post&quot;: { &quot;get&quot;: { &quot;summary&quot;: &quot;Perform get_post&quot;, &quot;operationId&quot;: &quot;get_my_awesome_typegraph_get_post&quot;, &quot;responses&quot;: { ... }, // you will have various types per response status &quot;parameters&quot;: [ ... ] } }, &quot;/my_awesome_typegraph/rest/get_post_id&quot;: { ... }, &quot;/my_awesome_typegraph/rest/read_post&quot;: { ... } }, &quot;components&quot;: { ... } }   Here are some of the most used generators:  Multilang: OpenAPITools/openapi-generatorMultilang: @openapitools/openapi-generator-cliFlutter: openapi_generator  To keep our setup simple, let us look at @openapitools/openapi-generator-cli, which is just a wrapper around openapi-generator and will download the appropriate dependencies for you.  First, install the cli globally  npm i -g @openapitools/openapi-generator-cli   In this example, let's generate a simple fetch client, you can refer to their official documentation for other generators.  openapi-generator-cli generate \\ -i http://localhost:7890/my_awesome_typegraph/rest/__schema \\ -g typescript-fetch \\ -o my-client \\ --skip-validate-spec   This will generate a fetch-based typescript project.  . +-- apis ¦ +-- DefaultApi.ts ¦ +-- index.ts +-- models ¦ +-- Either10.ts ¦ +-- ErrorExtensions.ts ¦ ... ¦ +-- GetMyAwesomeTypegraphGetIdentity200Response.ts ¦ +-- Post.ts ¦ +-- User.ts ¦ +-- index.ts +-- runtime.ts +-- index.ts  ","version":"Next","tagName":"h2"},{"title":"Deno/typescript","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/deno","content":"","keywords":"","version":"Next"},{"title":"Runtimes","type":0,"sectionRef":"#","url":"/docs/reference/runtimes","content":"","keywords":"","version":"Next"},{"title":"Specialized runtimes​","type":1,"pageTitle":"Runtimes","url":"/docs/reference/runtimes#specialized-runtimes","content":" This refers to any runtime embedded within typegate that performs specialized tasks.  This includes:  PrismaHTTPGraphQLRandomTemporalS3KVGRPC  Missing your favorite runtime? Submit your request and vote for your preferred ones here.  ","version":"Next","tagName":"h2"},{"title":"Embedded language runtimes​","type":1,"pageTitle":"Runtimes","url":"/docs/reference/runtimes#embedded-language-runtimes","content":" This type of runtime covers any runtime that uses a sandboxed programming language runtime that you can define custom logic on.  This includes:  DenoPythonWasm  ","version":"Next","tagName":"h2"},{"title":"Custom embedded runtimes​","type":1,"pageTitle":"Runtimes","url":"/docs/reference/runtimes#custom-embedded-runtimes","content":" This describes any user defined runtimes, you can write your own runtime logic and package it along with your typegraph. This type of runtime refers to any runtime that uses the materializer development kit, which can be generated from the meta gen fdk command. ","version":"Next","tagName":"h2"},{"title":"Deno runtime​","type":1,"pageTitle":"Deno/typescript","url":"/docs/reference/runtimes/deno#deno-runtime","content":" The DenoRuntime allows you to run lightweight and short-lived typescript function in a sandboxed environment. Permissions can be customized per typegraph and by default only include some HTTPs domains. It's a great way to implement custom logic and functions. All typegraphs can lazily spawn a web worker and get an incredible cold-start and continuous performance thanks to the V8 engine powering Deno.  Loading...  Instead of providing the typescript code inline, we can also point to a file on disk:  # my_typegraph.py from typegraph import typegraph, Policy, t, Graph from typegraph.runtimes.deno import DenoRuntime @typegraph() def deno(g: Graph): public = Policy.public() deno = DenoRuntime() g.expose( public, add=deno.import_( t.struct({&quot;a&quot;: t.number(), &quot;b&quot;: t.number()}), t.number(), module=&quot;main.ts&quot;, # path to ts file name=&quot;doAddition&quot;, # function export from ts file to use ), )   Where main.ts looks like:  // main.ts interface AddInput { a: number; b: number; } export function doAddition({ a, b }: AddInput) { return a + b; }  ","version":"Next","tagName":"h2"},{"title":"gRPC Runtime","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/grpc","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"gRPC Runtime","url":"/docs/reference/runtimes/grpc#overview","content":" The GrpcRuntime allows your Typegraphs to interact with external gRPC services. Similar to the HTTP runtime, this enables integrating gRPC services into your graph through a unified interface.  Common use cases include:  Consuming a gRPC API within a TypegraphCalling gRPC methods programmatically via a type-safe structure  In a GrpcRuntime, several key parameters help define how the graph interacts with the service, such as the gRPC endpoint, the protofile that describes the service, and the method to be called.  ","version":"Next","tagName":"h2"},{"title":"GraphQL","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/graphql","content":"","keywords":"","version":"Next"},{"title":"GraphQL runtime​","type":1,"pageTitle":"GraphQL","url":"/docs/reference/runtimes/graphql#graphql-runtime","content":" While you can store users in the same database, it's wiser to avoid data duplication and re-use your service for user management available at GraphQLZero endpoint. Let's introduce the GraphQL runtime that allows remote GraphQL queries.  Update typegraph.py with the highlighted lines below:  Loading...  Again, a few interesting things happened here:  No migration has been run. The field user comes from another runtime and doesn't exist in the database. The typegate will orchestrate the query execution in all runtimes and minimize the work done.The from_parent rule automatically fills the input type with the parent field named uid. The g(·) rule allows making named references to another type and avoids circular references.  Other type enforcement rules also exist:  from_secret(key) to fill the input type with the secret in the TG_[typegraph name]_[key] formatfrom_context(·) to fill the input type with content from the request context, such as JSON Web Token (JWT), etc.set(x) to fill the input type with content xThe Entity which you fetch from the external API should have a matching name to that specified in the external API. Taking the above example, you need to specify the name(User) of the type the external API uses in your entity definition. As you can see, the name User is included in the user type declared in the typegraph. This is crucial as the query engine uses this information when making the external GraphQL call.  Typescript SDK Python SDK const user = t.struct({ &quot;id&quot;: t.string(), &quot;name&quot;: t.string() }, {name: &quot;User&quot;});   You should now start to see the power provided by Metatype and might wonder how to integrate it step by step with your existing systems. Writing all those types by hand is tedious and error-prone. The next section will show you how to generate types from existing sources. ","version":"Next","tagName":"h2"},{"title":"Variables​","type":1,"pageTitle":"gRPC Runtime","url":"/docs/reference/runtimes/grpc#variables","content":" ","version":"Next","tagName":"h2"},{"title":"proto_file​","type":1,"pageTitle":"gRPC Runtime","url":"/docs/reference/runtimes/grpc#proto_file","content":" The proto_file is the path to the .proto file that defines the gRPC service. This file contains the service definitions, including message types and method signatures, that the Typegraph will use to communicate with the gRPC server.  ","version":"Next","tagName":"h3"},{"title":"endpoint​","type":1,"pageTitle":"gRPC Runtime","url":"/docs/reference/runtimes/grpc#endpoint","content":" The endpoint is the address of the gRPC server that the Typegraph will communicate with. It uses the format tcp://&lt;host&gt;:&lt;port&gt;, and is specified to point to the correct server and port where the gRPC service is running.  ","version":"Next","tagName":"h3"},{"title":"Method​","type":1,"pageTitle":"gRPC Runtime","url":"/docs/reference/runtimes/grpc#method","content":" ","version":"Next","tagName":"h2"},{"title":"call​","type":1,"pageTitle":"gRPC Runtime","url":"/docs/reference/runtimes/grpc#call","content":" This method creates a typegraph function for gRPC method calls. It accepts the full path to the gRPC method, usually in the form /package_name.service_name/method_name. The package_name refers to the package defined in the .proto file, and it must be included when calling the method. In the example below, greet will call the SayHello method of the Greeter service within the helloworld package, as defined in the helloworld.proto file.  ","version":"Next","tagName":"h3"},{"title":"Example​","type":1,"pageTitle":"gRPC Runtime","url":"/docs/reference/runtimes/grpc#example","content":" Loading... ","version":"Next","tagName":"h2"},{"title":"Kv","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/kv","content":"","keywords":"","version":"Next"},{"title":"Kv Runtime​","type":1,"pageTitle":"Kv","url":"/docs/reference/runtimes/kv#kv-runtime","content":" The KvRuntime enables interaction with a Redis database by setting, retrieving, deleting, and managing keys and values.  Loading...  Operation\tDescription\tMethodget\tRetrieve the value associated with a specific key.\tkv.get() set\tAssign a value to a specific key.\tkv.set() delete\tRemove a key and its associated value from Redis.\tkv.delete() keys\tList all keys currently stored in Redis.\tkv.keys() values\tList all values currently stored in Redis.\tkv.values() ","version":"Next","tagName":"h2"},{"title":"HTTP/REST","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/http","content":"","keywords":"","version":"Next"},{"title":"HTTP Runtime​","type":1,"pageTitle":"HTTP/REST","url":"/docs/reference/runtimes/http#http-runtime","content":" The HTTPRuntime allows your typegraphs to access external REST APIs.  Common use cases (but not limited to):  Enable consuming one or more REST APIs through the same interfaceProgrammatically generate typegraphs from an existing openapi specs or similar  Example:  Loading...  ","version":"Next","tagName":"h2"},{"title":"Verbs​","type":1,"pageTitle":"HTTP/REST","url":"/docs/reference/runtimes/http#verbs","content":" This runtime supports GET, POST, PUT, DELETE http verbs.  In most cases, queries are not limited to a simple query parameter or use the default application/json content type. You can assign what parts of your request description each field in the input struct belongs to.  In the example bellow, this endpoint corresponds to POST &lt;API_URL&gt;/submit_user?form_type=.. with a body requiring the fields: pseudo, age and with header accept set as application/json.  Typescript SDK Python SDK // .. const remote = new HttpRuntime(&quot;&lt;API_URL&gt;&quot;); g.expose({ add_user: remote.post( // define your input/output t.struct( { id: t.uuid(), username: t.float(), years_lived: t.integer(), form_type: t.integer() }, ), t.struct({ message: t.string() }), { path: &quot;/submit_user&quot;, // specify where each field in your input should be associated with bodyFields: [&quot;username&quot;, &quot;years_lived&quot;], queryFields: [&quot;form_type&quot;], // you may want to rename a few fields // if you are using your own naming conventions or reusing types renameFields: [ [&quot;username&quot;, &quot;pseudo&quot;], [&quot;years_lived&quot;, &quot;age&quot;], ], contentType: &quot;multipart/form-data&quot;, } )}, pub); // ..  ","version":"Next","tagName":"h2"},{"title":"Prisma","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/prisma","content":"","keywords":"","version":"Next"},{"title":"Prisma runtime​","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#prisma-runtime","content":" Prisma is a &quot;Next-generation Node.js and Typescript ORM&quot; supporting PostgreSQL, MySQL/MariaDB, SQLite, MongoDB, CockroachDB and Microsoft SQL Server. It is one of the main runtimes provided by Metatype and doesn't require any additional installation.  Go ahead and update typegraph.py with the highlighted lines below:  Loading...  A few things to note on the changes:  You can import runtimes from typegraph.runtime.Y or typegraph.providers.X.runtimes.Y for non-core providers.The config method allows specifying runtime specific attributes. In this case, id shall be automatically set and incremented by the database.Types get generated names unless you manually specify them. You can find the exact names in the playground documentation. Here you want to have a human friendly name as it will also be the name of the table in your database.Runtimes often come with some sugar syntax to generate types and avoid manipulating functions directly. A corresponding declaration would have looked like this:  In order to use the Prisma runtime, you need to add a new environment variable. Runtimes don't take raw secrets, but instead a secret key used to look up environment variables named under the format TG_[typegraph name]_[key]. You can either add it in your metatype.yml (recommended) or in your compose.yml.  $ cat metatype.yml typegates: dev: # .. secrets: database POSTGRES_CONN: postgresql://postgres:password@postgres:5432/db $ meta dev   And now, you can iteratively continue to improve your interface, running migrations and having data stored inside your database.  ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#usage","content":" with TypeGraph(&quot;prisma-runtime-example&quot;) as g: db = PrismaRuntime(&quot;main_db&quot;, &quot;DB_CONNECTION&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email(), } ) g.expose( createUser=db.create(user).add_policy(public) )   ","version":"Next","tagName":"h2"},{"title":"Raw query​","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#raw-query","content":" Generate a raw SQL query operation on the runtime  db = PrismaRuntime(&quot;my-app&quot;, &quot;POSTGRES&quot;) g.expose( countUsers=db.raw_query( &quot;SELECT COUNT(*) as total FROM User&quot;, t.struct({}), t.list(t.struct({&quot;total&quot;: t.integer()})) ) )   Generate a raw SQL query operation without return  db = PrismaRuntime(&quot;my-app&quot;, &quot;POSTGRES&quot;) g.expose( setActive=db.raw_execute( &quot;UPDATE User SET active = TRUE WHERE id=${id}&quot;, t.struct({&quot;id&quot;: t.uuid()}), effect=effects.update() ), )   ","version":"Next","tagName":"h3"},{"title":"Models​","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#models","content":" Any t.struct that is passed to a generator of a PrismaRuntime defines a model. Models must have an ID field specified by the &quot;id&quot; config.  Here is the list of all the available configs for model fields:  Config\tEffectid\tdefines the field ID for the model (a.k.a. primary key) auto\tthe value of this field can be auto generated; supported for t.integer() (auto-increment) and t.uuid() unique\tmake this field unique among all instances of the model  ","version":"Next","tagName":"h2"},{"title":"Relationships​","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#relationships","content":" Relationship fields must be defined on both sides of the relationship. A relationship is always defined for t.struct types and t.optional or t.list of t.struct.  Relationships can also be defined implicitly using the link instance method of PrismaRuntime.  runtime = PrismaRuntime(&quot;example&quot;, &quot;POSTGRES&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email().config(&quot;unique&quot;), &quot;posts&quot;: t.list(g(&quot;Post&quot;)), } ).named(&quot;User&quot;) post = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;title&quot;: t.string(), &quot;author&quot;: g(&quot;User&quot;), } ).named(&quot;Post&quot;)   The PrismaRuntime supports two kinds of relationship between models.  ","version":"Next","tagName":"h2"},{"title":"Python","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/python","content":"","keywords":"","version":"Next"},{"title":"Python Runtime​","type":1,"pageTitle":"Python","url":"/docs/reference/runtimes/python#python-runtime","content":" The PythonRuntime allows you to run short-lived code on a Python virtual machine.  # my_typegraph.py from typegraph import typegraph, Policy, t, Graph from typegraph.runtimes.deno import PythonRuntime @typegraph() def example_python(g: Graph): public = Policy.public() python = PythonRuntime() g.expose( public, add=t.func( t.struct({&quot;a&quot;: t.integer(), &quot;b&quot;: t.integer()}), t.integer(), # we can provide the code inline using lambdas python.from_lambda(lambda x: x[&quot;a&quot;] + x[&quot;b&quot;]), ), sayHello=python.import_( t.struct({&quot;name&quot;: t.string()}), t.string(), # point to pythoin a file on disc module=&quot;hello.py&quot;, name=&quot;say_hello&quot; ), )   # hello.py def say_hello(x: any): return f&quot;Hello {x[&quot;name&quot;]}&quot;  ","version":"Next","tagName":"h2"},{"title":"One-to-one relationships​","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#one-to-one-relationships","content":" A one-to-one relationship must be in one of these two variants.  Cardinality\tField type in Model1\tField type in Model21..1 ↔ 0..1\tg(&quot;Model2&quot;)\tg(&quot;Model1&quot;).optional() 0..1 ↔ 0..1\tg(&quot;Model2&quot;).optional()\tg(&quot;Model1&quot;).optional()  For the optional (0..1 ↔ 0..1) one-to-one relationship, you need to indicate on which field/model the foreign key will be by:  wrapping the type in a runtime.link(.) with fkey=True: runtime.link(g(&quot;Model2&quot;).optional(), fkey=True); or adding .config(&quot;unique&quot;): g(&quot;Model2&quot;).optional().config(&quot;unique&quot;).  ","version":"Next","tagName":"h3"},{"title":"One-to-many relationships​","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#one-to-many-relationships","content":" A one-to-many relationship must be in one of these two variants.  Cardinality\tField type in Model1\tField type in Model21..1 ↔ 0..n\tg(&quot;Model2&quot;)\tt.list(g(&quot;Model1&quot;)) 0..1 ↔ 0..n\tg(&quot;Model2&quot;).optional()\tt.list(g(&quot;Model1&quot;))  ","version":"Next","tagName":"h3"},{"title":"Many-to-many relationships​","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#many-to-many-relationships","content":" Many-to-many relationships must be modelled explicitly using a join model.  ","version":"Next","tagName":"h3"},{"title":"Link​","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#link","content":" Explicitly declare a relationship between models. The return value of this function shall be the type of a property of a t.struct that defines a model. If the other end of the relationship is also defined using link, both links must have the same name.  runtime = PrismaRuntime(&quot;example&quot;, &quot;POSTGRES&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email().config(&quot;unique&quot;), &quot;posts&quot;: runtime.link(t.list(g(&quot;Post&quot;)), &quot;postAuthor&quot;), } ).named(&quot;User&quot;) post = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;title&quot;: t.string(), &quot;author&quot;: runtime.link(g(&quot;User&quot;), &quot;postAuthor&quot;), } ).named(&quot;Post&quot;)   ","version":"Next","tagName":"h3"},{"title":"Generators​","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#generators","content":" Generators are instance methods of PrismaRuntime that can be used to generate a t.func that represents a specific operation on a specific model of the runtime. They match to the model queries defined for the prisma client API. for the type of the input t.struct and the return type.  Example:  with TypeGraph(&quot;prisma-runtime-example&quot;) as g: db = PrismaRuntime(&quot;main_db&quot;, &quot;DB_CONNECTION&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email(), } ) g.expose( createUser=db.create(user).add_policy(public), findUser=db.find(user).add_policy(public), findManyUsers=db.find_many(user).add_policy(public), )   Here is a list of all available generators:  find_uniquefind_firstfind_manycreateupdateupsertdeletedelete_many  ","version":"Next","tagName":"h2"},{"title":"Dealing with migrations​","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#dealing-with-migrations","content":" Migrations are basically blueprints that ensure that your local database and remote database both have the same schema. Migration files are generated as modifications are made in your typegraph as you deploy.  meta cli offers various ways to deal with failing migrations. In general, you will be required manually edit the SQL changes that made your migration fails, most of the time failing migrations are related to columns/tables that were removed, renamed or added.  However, if you wish to ignore failing migrations (eg. in a testing environment), you can use the --run-destructive-migrations flag, it will reset your database schema. ","version":"Next","tagName":"h2"},{"title":"Random","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/random","content":"","keywords":"","version":"Next"},{"title":"Random runtime​","type":1,"pageTitle":"Random","url":"/docs/reference/runtimes/random#random-runtime","content":" The Random runtime allows you to produce structured datas randomly.  One use case is to use this runtime as way of testing, for example you can rapidly draft a small backend that produces structured data for your frontend application.  The seed parameter ensures repeatability if set.  Loading...  Another use case is to inject random values to a function input  Loading...  ","version":"Next","tagName":"h2"},{"title":"Generators​","type":1,"pageTitle":"Random","url":"/docs/reference/runtimes/random#generators","content":" Here is a list of some standard generators that you can attach to your type, if unspecifed, it will default on generating any values that the associated type can hold.  Type\tGenerator configt.string()\tname, address, postcode, country, email, uuid, uri, hostname, date, time, phone, ean t.integer(), t.float()\tage  Typescript SDK Python SDK const user = t.struct( { id: t.uuid(), // random uuid name: t.string({}, { config: { gen: &quot;name&quot; } }), // random name age: t.integer({}, { config: { gen: &quot;age&quot;, type: &quot;adult&quot; } }), // type: &quot;child&quot;, &quot;adult&quot; email: t.email(), address: t.struct( { street: t.string({}, { config: { gen: &quot;address&quot; } }), city: t.string({}, { config: { gen: &quot;city&quot; } }), postcode: t.string({}, { config: { gen: &quot;postcode&quot;} }), country: t.string({}, { config: { gen: &quot;country&quot;, full: true } }), } ), } )  ","version":"Next","tagName":"h2"},{"title":"","type":0,"sectionRef":"#","url":"/docs/reference/changelog","content":"","keywords":"","version":"Next"},{"title":"v0.5.0-rc.1 - 2024-10-22​","type":1,"pageTitle":"","url":"/docs/reference/changelog#v050-rc1---2024-10-22","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes​","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes","content":" (ci) Disable sccache when secrets not avail (#874) Makes sccache optional so PRs from dependabot and forks can still run the test suite.Increases sccache allotment to 50g.  (cli) Change default installation directory (#873) Remplacement PR for #843. ... Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (docs) Grpc docs (#852) Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (gate) Make __typename returns the variant name on unions (#838) Add missing implementation for static injection for parameter transformations on the typegateSolvesMET-642: Fix the __typename result on union variants: return the variant name instead of the parent type name Migration notes​ N/A Checklist​ The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (subs) Key collision on redis (#865) Follow up of #863 When multiple start occurs for redis, some schedules can happenexactly at the same time resulting into the same identifier (and leading to an inconsistent state). This solution simply combines the schedule with the run_id making it unique instead of using it as is. mutation AllAtOnce { a: start_retry(kwargs: { .. }) # =&gt; calls add_schedule( ... date ...) b: start_retry(kwargs: { .. }) c: start_retry(kwargs: { .. }) d: start_retry(kwargs: { .. }) e: start_retry(kwargs: { .. }) f: start_retry(kwargs: { .. }) # .. } Migration notes​ None The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Fix missing images (#847) Fix missing images for durable execution blog​ Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Improve name generation for prisma types (#849) SolveMET-657 Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Documentation​","type":1,"pageTitle":"","url":"/docs/reference/changelog#documentation","content":" (blog) Running python with WebAssembly part 1 (#823) Running python with webassembly (part 1) Migration notes​ None The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit​ Summary by CodeRabbit​ New Features Introduced a comprehensive guide for integrating Python runtime with WebAssembly (WASI) in the Metatype ecosystem. Detailed the advantages of using WebAssembly over Docker for platform independence and resource management. Provided technical requirements and a refined solution for executing Python scripts in a sandboxed environment. Expanded vocabulary with new relevant terms for enhanced text processing and validation. Documentation Updated YAML configuration structure in documentation for clarity on type gate usage.  /docs/reference/typegraph/client (#777) Pre-documentation for the code-first queries feature. Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"","url":"/docs/reference/changelog#features","content":" (dev) Typegraph explorer (#859) Add a web version of tree-view which is more interactiveEnable typegraph serialization without metatype.yml config file  (gate) Empty object as custom scalar (#876) Allow empty object on the output without any changeJust like Int, String, and such, rightfully refer the constant{} as a scalarAny empty object will now be refered as EmptyObject scalar Migration notes​ None The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (mdk) Overridable templates (#842) SolveMET-630 Make templates in the static sections overridable mdk_rust mdk_python mdk_typescript Add a CLI tool to generate extract the default template Migration notes​ No changes needed. The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (metagen) Union/either for clients (#857) Add union support for the client_xx metagen implementations. There are still some edge cases especially around variant identification in the client languages. I tried many things but our hands are tied by serde. Basically, users will have to be careful when designing their union types to avoid ambiguity cases. Hopefully,674will help there. Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit​ New Features Introduced new methods for rendering union types in both TypeScript and Python. Enhanced GraphQL query generation with support for multiple union types. Added a new variants property to the NodeMeta type for improved selection handling. Bug Fixes Improved error handling for node selections and argument processing. Tests Updated test cases to reflect schema changes and added new tests for client functionality.  (subs) Redis backend (#855) Redis Backend base logic port + some improvementsMoved SUBSTANTIAL_POLL_INTERVAL_SEC andSUBSTANTIAL_LEASE_LIFESPAN_SEC to config Migration notes​ Renamed Backend.fs() and Backend.memory() to Backend.dev_fs()and Backend.dev_memory()Removed SUBSTANTIAL_RELAUNCH_MS as it was relevant only for purely worker-based runs, which rendered the newSUBSTANTIAL_POLL_INTERVAL_SEC redundant when an interrupt hits. The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit​ Release Notes​ New Features Introduced Redis as a new backend option for enhanced data management. Added Docker Compose configuration for a Redis service. Implemented comprehensive testing for Redis functionality and backend integration. Bug Fixes Improved error handling during backend initialization. Documentation Updated type definitions for backend configurations to streamline Redis integration. Chores Refactored test cases for clarity and consistency across different backend types.  (subs) Retry + timeout on save (#863) Port and improve retry/timeout. Migration notes​ N/A The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (subs) Child workflows + docs (#867) Support for child workflows. Solves MET-689 and MET-668. Migration notes​ Previously sub = SubstantialRuntime(backend) hello = sub.deno(file=&quot;workflow.ts&quot;, name=&quot;sayHello&quot;, deps=[]) g.expose( # each function start, stop, result, ... holds a copy of the workflow data start_hello = hello.start(...), stop_hello = hello.stop() ) This approach relied on workflow files being referenced in each materializer, but the constructs were too restrictive to support something like mutation { results(name: &quot;nameManuallyGiven&quot;) }. We now have instead file = ( WorkflowFile .deno(file=&quot;workflow.ts&quot;, deps=[]) .import_([&quot;sayHello&quot;]) .build() ) # workflow data are refered only once sub = SubstantialRuntime(backend, [file]) g.expose( start_hello = sub.start(...).reduce({ &quot;name&quot;: &quot;sayHello&quot; }), stop = sub.stop() ) The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (subs,gate) Substantial integration (#844)  (subs,gate) Port agent concept (#845) Continuation of #844  Well-defined type comparison semantics (#846) SolveMET-655 Document the type comparison semantics Improve the implementation (EnsureSubtypeOf trait) Add more test cases for type comparisons Migration notes​ No change is needed. ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit​ Release Notes​ New Features Introduced comprehensive type comparison rules and semantics for scalar types, optionals, lists, objects, and unions. Added support for enumerated types in the type system, allowing for more precise type definitions. Enhanced parent injection mechanism documentation to clarify type compatibility requirements. Implemented a new suite of type comparison tests and validation mechanisms. Bug Fixes Improved error reporting and handling in the type validation process. Documentation Updated and expanded documentation for type comparisons, enumerations, and parent injections. Tests Added new tests for type comparison and validation scenarios.  Grpc runtime (#819) Migration notes​ ... The change comes with new or modified tests End-user documentation is updated to reflect the change Hard-to-understand functions have explanatory comments  Python hostcall (#860) Dead lock on python worker Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks​","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks","content":" Checks/validation on t.either (#868) BREAKING: Checks/validation on t.either (#868) Emit a warning or an error when a variant is a subtype of another one. Migration notes​ BREAKING CHANGE: Previously valid typegraph might fail validation. You will need to fix your types to add some consistency int.either/t.union types. The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Update prisma + deno + rust deps (#869) Bump deno to 1.46.3Update prisma-engines to 5.20Update other rust deps. Closes MET-669 and MET-622 and MET-680. Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Refactor​","type":1,"pageTitle":"","url":"/docs/reference/changelog#refactor","content":" (gate) Add err msg for missing env vars (#827) Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (gate) Use stream during artifact upload to s3 (#841) Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (gen, doc) Rename mdk to fdk (#851) Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (sdk) Remove index based names (#848) BREAKING: remove index based names (#848) Replace index based names for types by one that relies on type context in graphTests for type deduplication Migration notes​ TODO The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Move as_id out of TypeNode (#866) BREAKING: Move as_id out of TypeNode (#866) SolveMET-684andMET-471 common/typegraph Store the id field in ObjectTypeData instead of in the target type (as_id) Add id() method on t.integer and t.string typegraph/core Store as_id, injection and policy in TypeRef::attribute Add support for direct and link target in TypeRef Only allow name registration for TypeDef Semantics Use property name instead of type name in from_parent injection source Migration notes​ BREAKING CHANGEfrom_parent injections source shall be changed to the key in the parent t.struct instead of the type name. Checklist​ The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Move injection data to t.func (#871) MET-682 Move all injection data in ObjectTypeData (i.e. t.func) MET-656 Translate reduce to injection specification on t.func MET-94 Remove runtime field from TypeNode (#858) MET-683 Move runtime-related configs to MaterializerData orRuntimeDataMisc.Enable random ports for the typegate (when TG_PORT=0); this will work with meta dev with embedded typegate if you set the --gateoption with port 0. Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"v0.4.10 - 2024-09-04​","type":1,"pageTitle":"","url":"/docs/reference/changelog#v0410---2024-09-04","content":" ","version":"Next","tagName":"h2"},{"title":"Miscellaneous Tasks​","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-1","content":" Bump to v0.4.10 (#835) Bump v0.4.10  ","version":"Next","tagName":"h3"},{"title":"v0.4.10-rc1 - 2024-09-03​","type":1,"pageTitle":"","url":"/docs/reference/changelog#v0410-rc1---2024-09-03","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes​","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-1","content":" Use import_map at runtime (#833) Bump to release v0.4.10-rc1Use import_map.json at runtime since remote configs aren't supported  ","version":"Next","tagName":"h3"},{"title":"v0.4.9 - 2024-09-02​","type":1,"pageTitle":"","url":"/docs/reference/changelog#v049---2024-09-02","content":" ","version":"Next","tagName":"h2"},{"title":"Miscellaneous Tasks​","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-2","content":" Bump to v0.4.9 (#831) Bump version to v0.4.9Fix issue with cross config context  ","version":"Next","tagName":"h3"},{"title":"v0.4.9-rc2 - 2024-09-02​","type":1,"pageTitle":"","url":"/docs/reference/changelog#v049-rc2---2024-09-02","content":" ","version":"Next","tagName":"h2"},{"title":"Miscellaneous Tasks​","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-3","content":" (release) Prepare 0.4.9-rc2 (#829) Fix the minor issues with rc1Bump to rc2  ","version":"Next","tagName":"h3"},{"title":"v0.4.9-rc1 - 2024-09-02​","type":1,"pageTitle":"","url":"/docs/reference/changelog#v049-rc1---2024-09-02","content":" ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-1","content":" (docs) Post on Durable Execution. (#816)  (metagen) Client_ts (#790) Implements client_ts as described in #777 . Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit​ Bug Fixes Improved error handling in the typegraph function to provide better error messages. Chores Updated Docker image references to use docker.io prefix for consistency. Excluded unnecessary files from the VSCode settings.Enhanced configurability of Docker commands in development tasks. Updated environment variable GHJK_VERSION to reflect a semantic versioning format. New Features Introduced modules and methods for TypeScript and Python code generation in the metagen library, enhancing client generation capabilities. Added test_typegraph_3 function for improved testing capabilities.Included metadata for the package manager in the project settings.  (sub) Sdk and typing (#811) User side of substantial Migration notes​ None The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Add caching to Secrets struct to improve performance (#813) Migration notes​ The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Refactor​","type":1,"pageTitle":"","url":"/docs/reference/changelog#refactor-1","content":" (docs, gate) Push for meta dev instead of meta typegate on docs (#822) Ensure documentation is pushing for meta dev instead of meta typegate​ add a warning that envs are not set. MET-635 Migration notes​ No Migration Needed The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Flatten deps and improve repo folder (#821) Renames libs/ to src/.Moves typegate/, meta-cli, typegraph/, meta-lsp/ to src/.Renames dev/ to tools/Moves website/ to docs/metatype.dev/Moves src/typegate/tests to tests/Moves src/typegraph/deno/dev to tools/jsr/Moves src/typegraph/deno/sdk to src/typegraph/deno/Renames src/deno to src/mt_denoBumps deno to 1.46.1Bumps rust toolchain to 1.80.1Moves all rust dependencies to workspace sectionMoves tools/task-*.ts to tools/task/*.tsMoves cliff.toml, Cross.toml, ruff.toml to tools/Uses denoworkspaces to organize src/typegraph/deno, src/typegate, tools/, tests/ and more.Closes MET-607Updates poetry to 1.8.3Bumps metatype to version 0.4.9-rc1 Update CONTRIBUTING.md Fix CI workflows Fix Dockerfile Fix all tests Migration notes​ No end user changes required The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"v0.4.8 - 2024-08-16​","type":1,"pageTitle":"","url":"/docs/reference/changelog#v048---2024-08-16","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes​","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-2","content":" Table method for kv runtime (#815) I discover an issue in the KV runtime documentationkvruntime docs  wasm_backtrace config bug (#814) $WASM_BACKTRACE_DETAILS was enabled in main ghjk env which affected embedded wasm module compilation to have backtrace enabled. This broke typegate runs without the flag enabled due to mismatch.Fixes Cargo.lock not being used in Dockerfile.Prepare 0.4.8 release  ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-2","content":" Kv runtime (#797) Migration notes​ ... The change comes with new or modified tests End-user documentation is updated to reflect the change Hard-to-understand functions have explanatory comments  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks​","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-4","content":" Bump to 0.4.8-0 (#810) Bump prereleaseFix minor issue with release pipeline  ","version":"Next","tagName":"h3"},{"title":"v0.4.7 - 2024-08-08​","type":1,"pageTitle":"","url":"/docs/reference/changelog#v047---2024-08-08","content":" ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-3","content":" (cli) Fix auto deployment (#806) Upgrade lade-sdkFix discoveryRemove obsolete dep: actix-web lade-sdk uses the main branch, which now has the fix for the following issues:dependency version conflict withdeno:url is set at &lt;2.5.0;required ProjectID error for infisical: the project id is added explicitly on the command. Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Cors headers on error (#803) Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks​","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-5","content":" Bump to 0.4.7-0 (#805) Bump version to 0.4.7-0  ","version":"Next","tagName":"h3"},{"title":"Refactor​","type":1,"pageTitle":"","url":"/docs/reference/changelog#refactor-2","content":" (docs) Add how to test typegraphs doc (#798) How to test your typegraphs documentation add python doc add ts doc upgrade bitnami/minIo image to 2024? Migration notes​ No Migrations Needed The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit​ New Features Updated the Minio service to the latest version for improved performance and potential new features. Introduced comprehensive documentation for testing typegraphs in both TypeScript and Python, enhancing developer experience. Documentation Enhanced readability of the Meta CLI upgrade instructions. Reformatted installation instructions for the typegraph package for better clarity. Chores Updated dependency management configuration for improved compatibility and performance across different platforms.  Improve JSR score (part 1) (#807) Add symbol documentationsFix slow types Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"v0.4.6 - 2024-08-01​","type":1,"pageTitle":"","url":"/docs/reference/changelog#v046---2024-08-01","content":" ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-4","content":" Better arg split logic for MCLI_LOADER (#799) Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks​","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-6","content":" Prepare 0.4.6 (#795) Bump version to 0.4.6-0Add sanity tests for published SDKsBump deno to 1.45.2Bump rust to 1.79.0Fix myriad of bugs Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit​ New Features Introduced new logging capabilities in the ConnectedEngine with adjustable logging levels. Implemented cleanup procedures in tests to enhance resource management. Bug Fixes Fixed import paths for permissions to ensure correct functionality in tests and applications. Version Updates Incremented version numbers across multiple projects and packages to reflect ongoing development and improvements. Documentation Added comments to clarify code behavior and potential future considerations in various modules. Refactor Optimized string handling in several functions and adjusted method signatures for improved clarity and efficiency.  ","version":"Next","tagName":"h3"},{"title":"Refactor​","type":1,"pageTitle":"","url":"/docs/reference/changelog#refactor-3","content":" (docs) Better documentation on quick-start page (#793) Improve the documentation on quick-start page​ add dev hunt result to homepage. Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"v0.4.5 - 2024-07-18​","type":1,"pageTitle":"","url":"/docs/reference/changelog#v045---2024-07-18","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes​","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-3","content":" Broken pipeline for 0.4.4 (#782) Fixes erroneous usage of setup-deno which has been replaced by ghjkitself. Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Broken release pipeline 2 (#783) Fix issue with the three remaining failing jobs. Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Release pipeline 3 (#784) Remove accidental dry-run from jsr publishFix cross dockerfile Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Skip deno stack trace from error message (#787) Skip the deno stack trace from the error message when tg_manage fails. Migration notes​ N/A The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-5","content":" (cli) Configurable backoff (#789) BREAKING: configurable backoff (#789) Make the backoff configurable through the --retry and--retry-interval-ms options.The default max retry count is changed to 0 on the default mode, and remains 3 on the watch mode.The --max-parallel-loads option has been renamed to --threads. Migration notes​ The --max-parallel-loads option has been renamed to --threads. The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Add list subcommand features to meta_cli (#775) new branch after conflict with main branch Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Upgrade www and gha (#786)  Add back gleap (#791) Gleap.io was removed a while backthis adds it back so visitors can open ticket and suggest feedbackinternally, we will use this to fine tune the documentation  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks​","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-7","content":" Bump v0.4.5 (#792) Bumps metatype version to 0.4.5Bumps ghjk to latest commitFixes setup whiz task to avoid issues on macosFixes release pipeline to publish JSR MET-614 MET-606 MET-605 MET-613 Migration notes​ No changes required. The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"v0.4.4 - 2024-07-05​","type":1,"pageTitle":"","url":"/docs/reference/changelog#v044---2024-07-05","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes​","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-4","content":" (gate) Ensure all deps are defined in import_map.json (#768) Ensure that all deps are defined in import_map.json with a specific version.  Missing typegraphs (#755) fix the typegraphs that were incorrectly formatted The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Stable formatting and uniformize the code-loader (#766) add prettier to avoid doc formatting issuenow explicitly require !!code-loader! to load code inside the documentation (will hopefully help also with the missing typegraphs issues, still under investigation) The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Documentation​","type":1,"pageTitle":"","url":"/docs/reference/changelog#documentation-1","content":" Generate clients from openapi (#778) Demonstrate how to use the openapi spec to generate clients in most languages/frameworks. Migration notes​ None The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit​ DocumentationUpdated REST API documentation URLs with placeholders for easier configuration.Added information on generating and using OpenAPI clients, including TypeScript fetch client generation.Bug FixesCorrected a regular expression in import handling to ensure accurate replacements.ChoresImproved file writing by appending a newline character to JSON strings.  ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-6","content":" Move all the configs to one single file (#733) Move all the configs to one single fileRemove some specific configs from the global config variable and make them accessible on the Typegate instance, to improve test configurability. Migration notes​ SYNC_REDIS_PASSWORD has been removed, can only be set on theSYNC_REDIS_URL. The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Remove restrictions for union/either types (#761) In the previous versions, we restricted the variant types allowed in union/either to be all in the same category (after flattening multi-level unions): Category 1 - GraphQL leaf types: scalar type, or array of scalar type, which require no selection set on GraphQL.Category 2 - GraphQL non-leaf types: object type or array of object type, which require a selection set on GraphQL (aka selectable types in the codebase). Those restrictions can be lifted, and the selection field of an union-type field will have inline fragments with type conditions for each Category 2 variant. No type condition is required for Category 1 types, the selection sets are not relevant. The case that is not handled by this PR is when one of the variants is an array of union type. Migration notes​ N/A The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Typegate in meta dev, upgrade test (#776) Test the typegate upgrade from the latest published version to the current version.Add a flag to run an instance of the typegate with the target configuration (port, admin passsword) to meta deploy, enabled by default for meta dev. Migration notes​ If you have a script that runs meta dev, add the flag --no-typegateif you already have a typegate. The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks​","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-8","content":" Add programmatic deploy tests (#769) Add Programmatic deploy tests for the docs​ Add programmatic typegraph deploy/remove tests refactor tg_remove to accept typegraph_name instead ofTypegraphOutput obj. MET-591 Migration notes​ No Migrations Needed ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Bump to version 0.4.4 (#779) Prepare release of the 0.4.4 version. Migration notes​ The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Refactor​","type":1,"pageTitle":"","url":"/docs/reference/changelog#refactor-4","content":" (sdk) Back to deno + jsr exploration (#760) BREAKING: back to deno + jsr exploration (#760) Try reverting back to deno runtime for the typescript sdk in hope of making the dx easier. Hosting a custom node/npm project adds more layer of indirection which may result in cryptic issues sometimes. This should also facilitate publishing on jsr although additional work are still required on the jco codegen side. Migration notes​ N/A The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Move to ghjk 0.2.0 (#754) Refactors the ghjk.ts, CI to the latest version of ghjkBumps version to 0.4.4-0Fixes race bug in python_sync testsFixes flakeout of wasm build.sh scripts due to wasm-tools EOF issue#763#746 Migration notes​ The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit​ ChoresUpdated GitHub Actions workflows to use the latest version ofmetatypedev/setup-ghjk for improved stability and performance.Modified GHJK_VERSION and various environment variables across multiple configuration files to ensure compatibility with updated dependencies.Revised Dockerfiles to streamline environment setup and improve build efficiency.Updated dependency management in pyproject.toml for better security and performance. Enhanced logging and error handling in test scripts. These updates collectively optimize the development environment, ensuring smoother builds and more reliable workflows.  ","version":"Next","tagName":"h3"},{"title":"Testing​","type":1,"pageTitle":"","url":"/docs/reference/changelog#testing","content":" (full) Update test runner (#705) New test runner, by default: Less verboseNo output for successful tests Parallel tests re-enabled. Migration notes​ N/A  ","version":"Next","tagName":"h3"},{"title":"v0.4.3 - 2024-06-22​","type":1,"pageTitle":"","url":"/docs/reference/changelog#v043---2024-06-22","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes​","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-5","content":" (ci) Poetry lockfile (#732) Fixes poetry lockfile and adds pre-commit hook to prevent issue from happening  (docs) Fix demo typegraphs 2 (#756) Fix example typegraphs on metatype.dev. reduce.ts policies.ts graphql.ts authentication.ts MET_574 Migration notes​ No Migrations Needed The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (docs) Fix programmatic deployment guides (#762) Fix typo fix/test tg deploy fix/test tg remove MET-587 Migration notes​ No Migration Needed ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Only build xtask once for the tests (#720) Use the xtask binary to run the tests. The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit​ New Features Updated platform compatibility to x86_64-linux. Added new configuration entry for enhanced versioning and platform support. Improvements Modified test script to use a custom build script for better test management. These changes improve platform compatibility and streamline the testing process.  Missing typegraphs (#741) Fix Missing Typegraphs attempt to fix the missing typegraphs on metatype.dev. MET-563 Migration notes​ No Migrations Needed... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Upload url path and add logging in the SDK (#740) Fix upload url: prepare-upload returns upload tokens instead of upload urlsAdd logging in the typegraph SDKRefactor the actor system in the CLIUse jsonrpc for communication between the CLI and typegraph processes (over stdin/stdout) Migration notes​ The typegraphs.deno section of the metatype.yaml config file has been replaced by typegraphs.typescript and typegraphs.javascript. tg_deploy params has changed. The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Failed typegraph deployment (#758) Fix casing typo in the typescript sdkFix error reporting in the typescript sdkDisplay the retry numberWarning on cancelled retry Migration notes​ N/A The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Documentation​","type":1,"pageTitle":"","url":"/docs/reference/changelog#documentation-2","content":" /docs/concepts/features-overview/ (#725) Re-does the feature overview page of the documentation. Summary by CodeRabbit​ New Features Added a &quot;Features Roadmap&quot; component to the website, displaying a list of features with details and links. Documentation Updated various guides and reference documents to improve clarity and presentation of code examples. Added new sections for various features such as Typegate, Typegraph, Runtimes, Prisma, Auth, Tooling, and SDK. Bug Fixes Corrected a typo in the GraphQL runtimes reference documentation. Refactor Replaced SDKTabs and TabItem components with TGExample for better code example presentation. Adjusted the MiniQL component to handle optional properties and default settings.  /docs/reference/metagen + /docs/guides/wasm-functions (#751) Adds /docs/reference/metagenAdds /docs/guides/wasm-functionsAdds a codegen section to /docs/guides/external-functions MDK-492. Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit​ New Features Added new targets for metagen with different generators and paths for TypeScript, Python, and Rust. Introduced new functionality for defining and exposing typegraphs with policies in various environments (Deno, Python, Rust). Added automated Rust WebAssembly project generation and compilation script. Enhanced documentation with new sections and updated code examples using TGExample. Bug Fixes Updated .gitignore to exclude *.wasm files. Documentation Updated links and added detailed instructions for generating types using metagen. Refactor Switched from HashMap to BTreeMap and HashSet to BTreeSet in various modules for better data structure handling. Added logging enhancements in the Typegate class. Chores Updated build script for Rust WebAssembly target.  Programmatic deployment blogpost (#752) Blogpost to help discover programmatic deployment additions. Migration notes​ ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit​ New Features Introduced programmatic deployment feature for deploying typegraphs within the Metatype ecosystem using TypeScript/Python SDKs. Added new configuration options and deployment functions to enhance automation and flexibility in deployment processes. Documentation Added a new blog post detailing the programmatic deployment feature and its usage.  ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-7","content":" (SDK) Add globs and dir support for artifact deps. (#698) Include glob and dir support for PythonRuntime deps. Include glob and dir support for DenoRuntime deps. add tests The change includes support for declaring artifact dependencies throughglobs and dirs MET-441 Migration notes​ In the deps parameter for python.import(...) and deno.import(...), globs and dirs can be passed in addition to files. The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit​ New Features Introduced functionality for defining and deploying Typegraphs for Deno and Python runtimes. Added support for defining a Deno runtime dependency graph with policies for test scenarios. Bug Fixes Corrected the structure of the Deno.serve call in the servefunction. Refactor Enhanced method chaining for better readability in the MetaTestclass. Tests Updated test coverage reporting to include new Deno runtime test files. Commented out and removed outdated test cases in Deno runtime tests. Chores Updated platform specification in configuration files.  (docs) Add embedded typegate page (#747) Embedded typegate docs page need a page under meta-cli/embedded typegate to explain how that works tutorials should take advantage of the embedded one the embedded one should be the default everything explain that there is 2 flavors in reference/meta-cli MET-562 Migration notes​ No Migrations Needed... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (mdk) Mdk python (#707) Mdk for python runtime Migration notes​ None Summary by CodeRabbit​ New Features Introduced new functionalities for generating Python code based on configurations, including handling of templates and required objects. Added Python script templates for defining typed functions and structured objects with comprehensive data type handling. Enhanced type management and priority handling in utility functions. Documentation Provided detailed summaries and documentation for new functionalities and templates. Refactor Implemented new structures and methods for efficient code generation and type handling. Tests Added tests for defining typegraph structures and policies in Python. Chores Updated URLs in the .ghjk/deno.lock file to reflect new changes in the codebase.  (mdk) mdk_typescript (#739) BREAKING: mdk_typescript (#739) Implements the mdk_typescript code generator for typescript type inference on Deno runtime external modules.Ports the very simple generator already present in meta-cli.Removes old codegen from cli and sdk. Migration notes​ Metagen section of metatype.yaml has changed. Targets are now lists instead of maps, items no sporting generator field instead of key acting as ref to generator.(sdk) WasmRuntime's fromExport method has been renamed to exportto make it more uniform to handler.(sdk) WasmRuntime export and handler method's now expect handler/func name under name instead of func.(sdk) codegen flag has been removed from ArtifactsConfig object.(cli) gen mod/mdk has been simplified to just gen as the previous mod option is no longer avail. The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (mdk,gate) Hostcall (#706) Introduces a mechanism for wasm materializers to access hostgate functions. This implements a pretty basic JSON wire interface, a singularhostcall function that's exposed to materializers. The only implemented function on this interface are gql queries. This is a stacked PR on top of #687. MET-473. The change come with new or modified tests Summary by CodeRabbit​ New Features Added an import statement for std_url and a new task for installing WASI adapter related files. Introduced new functionalities in the application's runtime to support additional parameters and error handling. Enhancements Improved the application's handling of GraphQL queries with new error types and display methods. Enhanced the WASM runtime build process to target a more appropriate architecture. Bug Fixes Fixed issues in Python and WASM runtime tests to ensure reliability and performance. Documentation Updated internal documentation to reflect new command interfaces and environmental interactions in the application's CLI tools. Refactor Refactored various internal APIs to improve code maintainability and efficiency.  (meta-test) Update t.engine() impl (#716) Update the implementation of t.engine() The change comes with removing the different spin-offs of t.enginewhich arose from the previous impl of t.engine incompatibility with artifact upload protocol. The change will make t.engine deploy the artifacts in Artifact Resolution mode by running a shell command to deploy the typegraph. ... MET-500 remove different versions of t.engine add tg_deploy caller script which imports typegraphs dynamically and deploys them. make changes to make t.engine run in artifact resolution mode update existing tests to adhere to the current change pass unique different tempDirs to all the typegate instances created during test. add support for authoring multiple typegraphs in a single file inmeta-test and add multi typegraph tests. Migration notes​ python SDK test typegraphs' function names should be the same with the filename of the typegraph file, for dynamic import compatibility reasons. Summary by CodeRabbit​ New Features Introduced a new function wasm_duplicate to handle WebAssembly runtimes with specific policies. Refactor Renamed and refactored functions and test setups to align with updated test frameworks and improve code clarity. Bug Fixes Added error handling in the getLocalPath function to log warnings if linking errors occur. Tests Updated test scripts to reflect changes in function calls, imports, and engine instantiation for better test accuracy and reliability.  Doc polish (#735) doc polish and cleanupupgrade website except Docusaurus as the css issue is stil presentbump to next pre-releasenot everything is done, but let's iterate! Summary by CodeRabbit​ New Features Added platform compatibility for x86_64-linux. Introduced new functionalities for generating Python code and enhanced type management. Added import statement for std_url and new task for installing WASI adapter files. Enhanced runtime support for additional parameters and error handling. Improvements Enhanced GraphQL query handling with new error types and display methods. Improved WASM runtime build process for better architecture targeting. Documentation Updated feature overview and added a &quot;Features Roadmap&quot; component.Enhanced various guides and references for better clarity. Added new sections for Typegate, Typegraph, Runtimes, Prisma, Auth, Tooling, and SDK. Corrected typos and improved code example presentation. Bug Fixes Fixed issues in Python and WASM runtime tests to ensure reliability.  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks​","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-9","content":" (docs) Replace term materializer with function for user facing concepts (#736) Materializer and function might introduce confusion as they are pretty much the same thing from the user point of view, one can be defined in terms of the other. Migration notes​ None The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit​ DocumentationUpdated terminology from &quot;materializers&quot; to &quot;functions&quot; across various documentation files to reflect a semantic shift and provide clearer descriptions.Improved clarity in descriptions of custom functions, runtimes, and their roles in the Metatype computing model.Corrected typos and refined explanations in multiple guides and reference documents. These changes enhance the readability and consistency of our documentation, making it easier for users to understand and implement the features and concepts within the system.  (docs) Embedded typegate (v0.3.x) blog (#750) Add a blog about Embedded Typegate. MET-564 Migration notes​ No Migrations Needed The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit​ New Features Introduced a new blog post on emulating server nodes locally using the Embedded Typegate feature in Meta CLI. Added a new BlogIntro component to the website for displaying styled blog introductions. Documentation Updated documentation to explain how to spin up a local instance of Typegate for testing and development. Chores Updated platform compatibility from &quot;x86_64-linux&quot; to &quot;aarch64-darwin&quot;.  (website) g.rest reference at /docs/reference/rest (#734) Add reference page for g.rest(..) Migration notes​ None The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit​ Documentation Added a reference to the REST reference section in the REST guide.Introduced new documentation for consuming APIs using Metatype. Included examples in Python and TypeScript for interacting with REST APIs. Explained query types, dynamic queries, and endpoint access. Provided guidance on accessing auto-generated documentation and downloading the OpenAPI spec.  Bump deno to 1.43.6 (#737) Update deno to 1.43.6 and make requisite changes. Required because of dep conflicts with latest lade-sdk. Migration notes​ The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Update rust dependencies (#748) update Rust dependencies MET-479 Migration notes​ No Migrations Needed ... The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Bump METATYPE_VERSION to 0.4.3 (#764)  ","version":"Next","tagName":"h3"},{"title":"v0.4.2 - 2024-05-22​","type":1,"pageTitle":"","url":"/docs/reference/changelog#v042---2024-05-22","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes​","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-6","content":" (release) Fix fat CLI compilation (#730) Fix fat CLI compilation Bump to 0.4.2 Bump wasmtime to 21 Bump rust to 1.78.0 The change comes with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"v0.4.1 - 2024-05-20​","type":1,"pageTitle":"","url":"/docs/reference/changelog#v041---2024-05-20","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes​","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-7","content":" (SDK) Artifact upload fails when same file referred multiple times (#715) fix the bug where duplicate artifact references causing failure during artifact resolution(typegate) during runtime. add sync mode tests for Python and Deno runtime. add other edge test cases to artifact upload. test for no artifact in typegraph test for duplicate artifact reference in the same typegraph  (gate) Improve logging and responses, prepare 0.4.1 (#714) Logging before and after each faillible operation Runtimes: foreign resolvers Always log before reporting error: HTTP responseFix error code in artifact_serviceAdd BaseError class for structured messages in responses Summary by CodeRabbit​ New Features Updated Docker image versions and dependency versions to ensure compatibility and stability. Added a search functionality to the app. Bug Fixes Enhanced error handling with specific error classes for more detailed error messages. Refactor Replaced generic Error instances with specific error classes for better error categorization. Refactored error handling in HTTP response functions to use aBaseError class. Chores Updated version numbers across multiple configuration files to0.4.1-0.  ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-8","content":" Polish documentation and project (#696) update the headline, the overviews and many other documentation areasupgrades the dependencies. The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit​ Bug Fixes Updated Docker image version for the typegate service to ensure stability and compatibility. Documentation Revised TAGLINE for better clarity on supported languages: WASM, Typescript, and Python. Updated version declarations for improved consistency and functionality across multiple files.  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks​","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-10","content":" (docs) Final polish to comparison table. (#709) some changes to comparison table(docs) Migration notes​ No Migrations Needed Summary by CodeRabbit​ DocumentationIntroduced a new section on Artifact Tracking Protocol in the architecture documentation, explaining artifact classification and tracking modes in Metatype.Updated comparisons documentation with additional platforms, criteria for choosing Metatype, and detailed feature comparison tables.Renamed project directory for clarity and consistency in project setup documentation.Bug Fixes Removed outdated TODO comment in installation documentation.  Bump to version 0.4.1-0 (#713) Bumps version to 0.4.1-0.Fixes broken release CI.#719Adds 20 minutes to test-full timeout. Summary by CodeRabbit​ Summary by CodeRabbit​ New Features Updated platform support for better compatibility with &quot;x86_64-linux&quot;. Bug Fixes Minor version updates across multiple configurations to enhance stability. Chores Updated version numbers from &quot;0.4.0&quot; to &quot;0.4.1-0&quot; across various files and configurations. Refactor Adjusted build and test scripts for improved efficiency and compatibility. Documentation Enhanced internal documentation to reflect version and platform changes.  ","version":"Next","tagName":"h3"},{"title":"v0.4.0 - 2024-05-09​","type":1,"pageTitle":"","url":"/docs/reference/changelog#v040---2024-05-09","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes​","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-8","content":" (gh-tests) Fix local npm registry config (#692) Fix the NPM registry config in the Github tests. Migration notes​ N/A  Website and headline (#691) Motivation and context​ Fix the CSS issue introduced by docusaurus 3.2.0 (https://github.com/facebook/docusaurus/issues/10005). 3.2.1 should fix it but the affected version maybe loaded by dependencies, so we will have to wait a bit more. Checklist​ The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Do not override log level when no verbosity flag is present (#694) Remove log level override by the verbosity flag when no flag is present. It will default to the configured env_logger default level (or env variable). ... The default log level became &quot;error&quot; after #664, and RUST_LOGenvironment variable where ignored. Migration notes​ N/A  ","version":"Next","tagName":"h3"},{"title":"Documentation​","type":1,"pageTitle":"","url":"/docs/reference/changelog#documentation-3","content":" Add examples for each command (#684) Motivation and context​ Getting started with meta cli should be easy Migration notes​ None Checklist​ The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Improve /tutorials/quick-start section. (#681) Improve Layout Include a simple project. Add the result/outputs to running CLI commands. Remove Metatype cloud registration form. Separate the CLI commands to separate code blocks Add links to references and concepts. Add playground. Motivation and context​ Docs Meta-task Migration notes​ No Migration Needed Checklist​ Test the commands and the examples. The change come with new or modified tests  Improve /docs/tutorials/metatype-basics (#688) Improve /docs/tutorials/metatype-basics Motivation and context​ Docs Meta-task Migration notes​ No Migrations Needed Checklist​ The change come with new or modified tests  Improve /reference/runtimes/ (#676) Motivation and context​ Better documentation Migration notes​ N/A Checklist​ The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Improve /guides/external-functions (#677) Improvements to the /guides/external-functions page.Adds a configuration file for git-town Motivation and context​ N/A Migration notes​ N/A Checklist​ The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Improve docs/reference/types (#685) Improves docs/reference/types Motivation and context​ N/A Migration notes​ N/A Checklist​ The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Add a comparison b/n metatype and other similar solutions/products. (#697) Adds a comparison table between metatype and other similar services.Add artifact upload protocol to Architecture section in docs. MET-443 Migration notes​ No Migration Needed  ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-9","content":" (cli) Timeout loader process (#693)  (cli,sdk) Better error messages (#689) Motivation and context​ Make it more clear where failures happen Migration notes​ None Checklist​ The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Upload artifacts to s3 (#638) Upload artifacts to S3 when sync-mode is enabled Motivation and context​ Sharing artifacts between replicas without including it in the typegraph (and sync through redis) Migration notes​ No changes needed. Checklist​ The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Upload PythonRuntime artifacts and deps (#672) Motivation and context​ Track artifact/module dependencis for PythonRuntime Migration notes​ python.import(...) and python.import_(...) accept an optional parameter deps that accepts list of dependencies for the python module. Checklist​ The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Upload DenoRuntime artifacts and deps (#674) Track deno runtime artifacts(also dependencies) Upload artifacts during deploy to either local(single replica) or shared(s3) resolve artifacts(module and deps) upon typegate runtime. Motivation and context​ Persisting deno runtime artifacts to a local/shared storage. Migration notes​ deno.import(...) and deno.import_(...) accept an optional parameter that accepts list of dependencies for the deno/ts module. Checklist​ The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Enable batch prisma queries in the typegate runtime (#682) Enable batch prisma queries (and transaction) in the typegate runtime Motivation and context​ Console MET-381 Migration notes​ Checklist​ The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Artifact removal (#668) Add GC: remove artifacts when unreferenced by any deployed typegraphImprove resource management: use AsyncDisposable andAsyncDisposableStackImprove testability (for parallel testing): always read the tmpDir config from the Typegate object Motivation and context​ MET-433 Migration notes​ N/A Checklist​ The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change Summary by CodeRabbit​ New Features Enhanced search functionality with the addition of a new search bar.Introduced new test configurations to improve script execution. Updated artifact storage documentation to clarify management processes. Added new extensions to support improved code commenting. Bug Fixes Removed outdated Deno import mapping settings to streamline development environment setup. Documentation Expanded documentation on artifact tracking and management, including reference counting and garbage collection mechanisms. Refactor Implemented interface changes in QueryEngine for better async disposal management. Code restructuring in artifact management for enhanced performance and maintainability. Chores Adjusted settings and configurations in the development environment to align with current best practices. Tests Introduced new test cases for artifact upload and management functionalities.  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks​","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-11","content":" (release) Prepare 0.4.0 (#710) Bumps version to release 0.4.0. Summary by CodeRabbit​ New FeaturesUpdated the software across various components to version 0.4.0, enhancing functionality and potentially introducing new features or fixes.DocumentationUpdated version documentation in multiple configuration files to reflect new version 0.4.0.Bug FixesAdjusted version constants and dependencies to ensure compatibility and stability with the new software version 0.4.0.  (sdk,gate) Bump wasmtime to 20.0.0 and wit-bindgen to 0.24.0 (#695)  ","version":"Next","tagName":"h3"},{"title":"Refactor​","type":1,"pageTitle":"","url":"/docs/reference/changelog#refactor-5","content":" (gate) Wasi 0.2 pyrt (#687) Rewrites the PythonRuntime host using a componentize-py based component.Leaf through thismemo for a mental model.  (libs/xtask,gate) Remove xtask/codegen (#700) Faster build time Migration notes​ Make sure to sync typegate/src/types.ts when an update is made on the typegraph schema. ","version":"Next","tagName":"h3"},{"title":"Substantial","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/substantial","content":"","keywords":"","version":"Next"},{"title":"Substantial runtime​","type":1,"pageTitle":"Substantial","url":"/docs/reference/runtimes/substantial#substantial-runtime","content":" The Substantial runtime enables the execution of durable workflows in one or accross multiple typegates.  Why use it?  Long-running &quot;processes&quot;: Durable tasks that need to run over extended periods (days, weeks or months), handling retries and restarts seamlessly.Fault-tolerant execution: Ensure reliable execution of tasks, even upon failures, by maintaining a durable state of the latest run.Task orchestration: Coordinate complex sequences of workflows (analogous to microservices interactions).  For example, the workflow bellow will continue running until a confirmation event is sent to the associated run.  export async function sendEmail(ctx: Context) { // 1. A workflow can receive parameters whose type is defined on the typegraph const { to } = ctx.kwargs; // 2. When a function call produces effects, we can make it durable const info = await ctx.save(() =&gt; sendSubscriptionEmail(to)); const timeSent = await ctx.save(() =&gt; new Date().toJSON()); const confirmation = ctx.receive&lt;boolean&gt;(&quot;confirmation&quot;); if (!confirmation) { throw new Error(`${to} has denied the subscription sent at ${timeSent}`); } return `${to} confirmed (${info})`; }   Additionally, if we were to shut down the Typegate node executing it and then restart it, the state will be preserved. This means that if the subscription email was already sent, upon relaunch, it will not be sent again, same thing for the value of timeSent.  ","version":"Next","tagName":"h2"},{"title":"Key Concepts​","type":1,"pageTitle":"Substantial","url":"/docs/reference/runtimes/substantial#key-concepts","content":" ","version":"Next","tagName":"h2"},{"title":"Workflows​","type":1,"pageTitle":"Substantial","url":"/docs/reference/runtimes/substantial#workflows","content":" A special type of function with durable state and an execution mechanism directly tied to time. A workflow can also trigger other workflows (child workflows).  ","version":"Next","tagName":"h3"},{"title":"Backend​","type":1,"pageTitle":"Substantial","url":"/docs/reference/runtimes/substantial#backend","content":" This abstraction implements a set of atomic operations that allows Typegate to persist and recover the workflow state. Currently, we have the Redis backend available, along with others like fs and memory, which are primarily intended for development or testing purposes.  ","version":"Next","tagName":"h3"},{"title":"Run​","type":1,"pageTitle":"Substantial","url":"/docs/reference/runtimes/substantial#run","content":" When a workflow is started, a run is created and Substantial will provide you a run_id to uniquely identify it.  You can send an event or abort an ongoing run from its run_id.  ","version":"Next","tagName":"h3"},{"title":"Child workflows​","type":1,"pageTitle":"Substantial","url":"/docs/reference/runtimes/substantial#child-workflows","content":" Child workflows are like any other workflows, they are just run by another workflow (parent).  If a workflow parent is explicitly stopped or aborted, all of its descendants will also be aborted.  For example, suppose you want to write a workflow that sends a subscription request to a list of emails and then receive a notification for each confirmation or denial, but only during your work hours.  You can easily translate that logic as if you were writing generic sequential code using Substantial workflows.  import { nextTimeWhenAdminIsAvailable, sendSubscriptionEmail, notifyAdmin } from &quot;./utils.ts&quot;; export async function sendEmail(ctx: Context) { // 1. A workflow can receive parameters whose type is defined on the typegraph const { to } = ctx.kwargs; // 2. When a function call produces effects, we can make it durable const info = await ctx.save(() =&gt; sendSubscriptionEmail(to)); const timeSent = await ctx.save(() =&gt; new Date()); const confirmation = ctx.receive&lt;boolean&gt;(&quot;confirmation&quot;); if (!confirmation) { throw new Error(`${to} has denied the subscription sent at ${timeSent}`); } // 3. In this scenario, we use a durable sleep to wait until the admin // is available const duration = await ctx.save(() =&gt; nextTimeWhenAdminIsAvailable(new Date())); ctx.sleep(duration); const _ = await ctx.save(() =&gt; notifyAdmin(info), { retry: { minBackoffMs: 1000, maxBackoffMs: 5000, maxRetries: 4, } }); return `${to} confirmed`; } export async function sendMultipleEmails(ctx: Context) { const { emails } = ctx.kwargs; // 1. Persist the state of the child workflows const handlersDef = await ctx.save(async () =&gt; { const handlersDef = []; for (const email of emails) { const handleDef = await ctx.startChildWorkflow(sendEmail, { to: email, }); handlersDef.push(handleDef); } return handlersDef; }); // 2. Create handles for your child workflows const handles = handlersDef.map((def) =&gt; ctx.createWorkflowHandle(def)); // 3. In this example, we wait on all child workflows to complete await ctx.ensure(async () =&gt; { for (const handle of handles) { if (!(await handle.hasStopped())) { return false; } } return true; }); const ret = await ctx.save(async () =&gt; { const ret = []; for (const handle of handles) { const childResult = await handle.result&lt;string&gt;(); ret.push(childResult); } return ret; }); return ret; }   In your typegraph, you will have:  Typescript SDK Python SDK import { Policy, t, typegraph } from &quot;@typegraph/sdk/index.ts&quot;; import { SubstantialRuntime, Backend, WorkflowFile, } from &quot;@typegraph/sdk/runtimes/substantial.ts&quot;; typegraph( { name: &quot;substantial-example&quot;, }, (g) =&gt; { const pub = Policy.public(); const backend = Backend.redis(&quot;REDIS_SECRET&quot;); const file = WorkflowFile.deno(&quot;my_workflow.ts&quot;, []) .import([&quot;sendEmail&quot;, &quot;sendMultipleEmails&quot;]) .build(); const sub = new SubstantialRuntime(backend, [file]); g.expose( { stop: sub.stop(), send_multiple_emails: sub .start(t.struct({ emails: t.list(t.email()) })) .reduce({ name: &quot;sendMultipleEmails&quot; }), send_single_email: sub .start(t.struct({ to: t.email() })) .reduce({ name: &quot;sendEmail&quot; }), results_raw: sub.queryResultsRaw(), workers: sub.queryResources(), ...sub.internals(), // Required for child workflows }, pub ); } );  ","version":"Next","tagName":"h2"},{"title":"S3","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/s3","content":"","keywords":"","version":"Next"},{"title":"S3 runtime​","type":1,"pageTitle":"S3","url":"/docs/reference/runtimes/s3#s3-runtime","content":" The S3Runtime can be used to interact with object storage APIs that are S3 compatible. Object storages like S3 are commonly used to cover app needs around large blob data like uploading and serving images. Most object storage services provide S3 compatible APIs including the open-source MinIO engine which you can run locally for development.  For the following example, you'll need to setup your S3 compatible store first. The following snippet can get you started using minio on docker compose:  services: minio: image: bitnami/minio:2022 platform: linux/amd64 restart: always ports: - &quot;9000:9000&quot; - &quot;9001:9001&quot; environment: MINIO_REGION_NAME: local MINIO_ROOT_USER: minio MINIO_ROOT_PASSWORD: password MINIO_DEFAULT_BUCKETS: &quot;bucket:none&quot;   We then provide the following secrets to our typegraph through metatype.yml.  typegates: dev: secrets: # .. # replace &quot;files-upload&quot; by the name of your typegraph files-upload: S3_HOST: http://localhost:9000 S3_REGION: local S3_ACCESS_KEY: minio S3_SECRET_KEY: password S3_PATH_STYLE: true   Our typegraph will then look something like:  Loading...  Peruse the reference on the S3Runtime for more information. ","version":"Next","tagName":"h2"},{"title":"index","type":0,"sectionRef":"#","url":"/docs/reference/metagen","content":"","keywords":"","version":"Next"},{"title":"/typegrap/typegraphh--- sidebar_position: 50​","type":1,"pageTitle":"index","url":"/docs/reference/metagen#typegraptypegraphh---sidebar_position-50","content":"   Metagen  Beta The following feature is not yet stable.  Metagen is a code-generator suite that contains implementations that help with development on the Metatype platform. Today, this means a set of generators to:  Generate code-first, typesafe clients for your typegraphHelp with custom functions by generating types, serializers and bindings.  It's availaible bundled within the meta CLI and the typegraph SDKs.  ","version":"Next","tagName":"h2"},{"title":"Access through CLI​","type":1,"pageTitle":"index","url":"/docs/reference/metagen#access-through-cli","content":" The meta-cli has a dedicated gen command for interacting with metagen. We configure the generators through the standard configuration file under the metagen key.  typegates: # bla bla typegraphs: # bla bla metagen: targets: main: # generator to use - generator: fdk_rust # path to generate to path: ./bff/ # typegraph path to use typegraph_path: ./typegraphs/svc-bff.ts # we can have multiple generators per target - generator: fdk_rust path: ./telemetry/ typegraph_path: ./typegraphs/svc-telemetry.ts # generators might have custom keys stubbed_runtimes: [&quot;wasm_wire&quot;, &quot;deno&quot;] # more than one targets avail if you need them iter: - generator: client_ts path: ./next_app/ # name of typegraph to read from typegate typegraph: svc_bff   This allows us to invoke the targets from the CLI.  meta cli gen main   This will resolve the requisite typegraphs, serialize as needed and put the resulting files at the appropriate locations. If no target name is provied, the CLI will look for a target under the key main and invoke it instead.  ","version":"Next","tagName":"h2"},{"title":"Access through SDK​","type":1,"pageTitle":"index","url":"/docs/reference/metagen#access-through-sdk","content":" Metagen is availaible through the SDK for programmatic access needs and can be helpful when writing tests or when relying on the CLI is not an option.  Loading...  ","version":"Next","tagName":"h2"},{"title":"Generators​","type":1,"pageTitle":"index","url":"/docs/reference/metagen#generators","content":" Chicken or the egg? As most of the generators are intended for types to be used by custom functions, they'll require that you declare the custom functions in your typegraph first. This begs the question, how does one declare custom functions that depend on artifacts that are yet to be generated? Typegraphs error out when referenced artifacts aren't found, how does it work in this scenario? To resolve this concern, the SDKs support a serialization mode that skips resolution of artifacts. This mode is activated when serialization is done for codegen purposes. What this means is that, you can declare non-existent files in your typegraph and codegen should work. Some generators are even smart enough to work around your expected files. Of course, if the files aren't present when you're trying to deply to the typegate, it'll raise an error.  ","version":"Next","tagName":"h2"},{"title":"client_ts​","type":1,"pageTitle":"index","url":"/docs/reference/metagen#client_ts","content":" This generator supports:  Types and query builders based on your typegraphfetch based GraphQlTransport implementation Requires Node.js version v17.5.0 and up.Requires using --experimental-fetch flag if on Node.js version below v18.0.0Provides async queries Prepared requests and aliases  Refer to the client reference for usage guidelines and examples.  ","version":"Next","tagName":"h3"},{"title":"client_py​","type":1,"pageTitle":"index","url":"/docs/reference/metagen#client_py","content":" This generator supports:  Types and query builders based on your typegraphurlib based GraphQlTransport implementation. Provides sync and async queries Prepared requests and aliases  Refer to the client reference for usage guidelines and examples.  ","version":"Next","tagName":"h3"},{"title":"client_rs​","type":1,"pageTitle":"index","url":"/docs/reference/metagen#client_rs","content":" This generator supports:  Types and query builders based on your typegraphreqwest based GraphQlTransport implementation Provides sync and async queries Prepared requests and aliases  Refer to the client reference for usage guidelines and examples.  ","version":"Next","tagName":"h3"},{"title":"fdk_typescript​","type":1,"pageTitle":"index","url":"/docs/reference/metagen#fdk_typescript","content":" This generator supports:  Typescript types that map to typegraph typesStub function types for custom functions implementors that adhere to typegraph functions. By default, all function types from the DenoRuntime get stub types.Use stubbed_runtimes to select which runtimes get stubs. client_ts based typegraph client Special HostcallTransport implementation  The following example showcases the generator.  Typegraph:  Loading...  Custom function:  Loading...  Code generation sample. Loading...  It supports the following extra configuration keys.  Key\tType\tDefault\tDescriptionstubbed_runtimes\tstring[]\t[&quot;deno&quot;]\tRuntimes for which to generate stub types.  ","version":"Next","tagName":"h3"},{"title":"fdk_python​","type":1,"pageTitle":"index","url":"/docs/reference/metagen#fdk_python","content":" This generator supports:  Python classes that map to typegraph typesDecorators for custom functions implementors that require adherance to typegraph function types. By default, all functions from the PythonRuntime get stub types.TODO: stubbed_runtimes for fdk_python TODO: types for interacting with the typegate from within custom functions.  If the referenced module for the custom function is not found, the generator will also output stub implementation (in addition to the types) at the given type. It will not replace our code on a second run.  The following example showcases the generator.  Typegraph:  Loading...  Custom function:  Loading...  Code generation sample. Loading...  ","version":"Next","tagName":"h3"},{"title":"fdk_rust​","type":1,"pageTitle":"index","url":"/docs/reference/metagen#fdk_rust","content":" This generator generates types, serializers and bindings needed to implement custom functions in Rust. Rust implementations will need to be compiled to wasm components to be executed on the metatype platform and the generator assumes such usage.  To be more specific, it supports:  Rust types that map to typegraph defined types Serialization is handled out of sight through serde_json Stub traits for custom functions implementors that adhere to typegraph functions. By default, all functions from the WasmRuntime get stub types.The generator assumes the wire based wasm interface is being targetted.stubbed_runtimes key can be used to configure stub generation from additional runtimes. Types for interacting with the typegate from within custom functions.Glue code for setting up the wasm component to be run within the WasmRuntime.  By default the generator will also output a library crate entrypoint and a functional Cargo.toml with all the required dependencies. These additional files wlil not be overwritten on a second run. The generator can also be configured to avoid generating them even if not present.  The following example showcases the generator.  Typegraph:  Loading...  Custom function:  mod fdk; pub use fdk::*; // the macro sets up all the glue init_mat! { // the hook is expected to return a MatBuilder instance hook: || { // initialize global stuff here if you need it MatBuilder::new() // register function handlers here // each trait will map to the name of the // handler found in the typegraph .register_handler(stubs::RemixTrack::erased(MyMat)) } } struct MyMat; impl stubs::RemixTrack for MyMat { fn handle(&amp;self, input: types::Idv3, _cx: Ctx) -&gt; anyhow::Result&lt;types::Idv3&gt; { Ok(types::Idv3 { title: format!(&quot;{} (Remix)&quot;, input.title), artist: format!(&quot;{} + DJ Cloud&quot;, input.artist), release_time: input.release_time, mp3_url: &quot;https://mp3.url/shumba2&quot;.to_string(), }) } }   Code generation sample. // This file was @generated by metagen and is intended // to be generated again on subsequent metagen runs. #![cfg_attr(rustfmt, rustfmt_skip)] // gen-static-start #![allow(dead_code)] pub mod wit { wit_bindgen::generate!({ pub_export_macro: true, inline: &quot;package metatype:wit-wire; interface typegate-wire { hostcall: func(op-name: string, json: string) -&gt; result&lt;string, string&gt;; } interface mat-wire { type json-str = string; record mat-info { op-name: string, mat-title: string, mat-hash: string, mat-data-json: string, } record init-args { metatype-version: string, expected-ops: list&lt;mat-info&gt; } record init-response { ok: bool } variant init-error { version-mismatch(string), unexpected-mat(mat-info), other(string) } init: func(args: init-args) -&gt; result&lt;init-response, init-error&gt;; record handle-req { op-name: string, in-json: json-str, } variant handle-err { no-handler, in-json-err(string), handler-err(string), } handle: func(req: handle-req) -&gt; result&lt;json-str, handle-err&gt;; } world wit-wire { import typegate-wire; export mat-wire; } &quot; }); } use std::cell::RefCell; use std::collections::HashMap; use wit::exports::metatype::wit_wire::mat_wire::*; use wit::metatype::wit_wire::typegate_wire::hostcall; pub type HandlerFn = Box&lt;dyn Fn(&amp;str, Ctx) -&gt; Result&lt;String, HandleErr&gt;&gt;; pub struct ErasedHandler { mat_id: String, mat_trait: String, mat_title: String, handler_fn: HandlerFn, } pub struct MatBuilder { handlers: HashMap&lt;String, ErasedHandler&gt;, } impl MatBuilder { pub fn new() -&gt; Self { Self { handlers: Default::default(), } } pub fn register_handler(mut self, handler: ErasedHandler) -&gt; Self { self.handlers.insert(handler.mat_trait.clone(), handler); self } } pub struct Router { handlers: HashMap&lt;String, ErasedHandler&gt;, } impl Router { pub fn from_builder(builder: MatBuilder) -&gt; Self { Self { handlers: builder.handlers, } } pub fn init(&amp;self, args: InitArgs) -&gt; Result&lt;InitResponse, InitError&gt; { static MT_VERSION: &amp;str = &quot;0.5.0-rc.1&quot;; if args.metatype_version != MT_VERSION { return Err(InitError::VersionMismatch(MT_VERSION.into())); } for info in args.expected_ops { let mat_trait = stubs::op_to_trait_name(&amp;info.op_name); if !self.handlers.contains_key(mat_trait) { return Err(InitError::UnexpectedMat(info)); } } Ok(InitResponse { ok: true }) } pub fn handle(&amp;self, req: HandleReq) -&gt; Result&lt;String, HandleErr&gt; { let mat_trait = stubs::op_to_trait_name(&amp;req.op_name); let Some(handler) = self.handlers.get(mat_trait) else { return Err(HandleErr::NoHandler); }; let cx = Ctx {}; (handler.handler_fn)(&amp;req.in_json, cx) } } pub type InitCallback = fn() -&gt; anyhow::Result&lt;MatBuilder&gt;; thread_local! { pub static MAT_STATE: RefCell&lt;Router&gt; = panic!(&quot;MAT_STATE has not been initialized&quot;); } pub struct Ctx {} impl Ctx { pub fn gql&lt;O&gt;( &amp;self, query: &amp;str, variables: impl Into&lt;serde_json::Value&gt;, ) -&gt; Result&lt;O, GraphqlRunError&gt; where O: serde::de::DeserializeOwned, { match hostcall( &quot;gql&quot;, &amp;serde_json::to_string(&amp;serde_json::json!({ &quot;query&quot;: query, &quot;variables&quot;: variables.into(), }))?, ) { Ok(json) =&gt; Ok(serde_json::from_str(&amp;json[..])?), Err(json) =&gt; Err(GraphqlRunError::HostError(serde_json::from_str(&amp;json)?)), } } } #[derive(Debug)] pub enum GraphqlRunError { JsonError(serde_json::Error), HostError(serde_json::Value), } impl std::error::Error for GraphqlRunError {} impl From&lt;serde_json::Error&gt; for GraphqlRunError { fn from(value: serde_json::Error) -&gt; Self { Self::JsonError(value) } } impl std::fmt::Display for GraphqlRunError { fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result { match self { GraphqlRunError::JsonError(msg) =&gt; write!(f, &quot;json error: {msg}&quot;), GraphqlRunError::HostError(serde_json::Value::Object(map)) if map.contains_key(&quot;message&quot;) =&gt; { write!(f, &quot;host error: {}&quot;, map[&quot;message&quot;]) } GraphqlRunError::HostError(val) =&gt; write!(f, &quot;host error: {val:?}&quot;), } } } #[macro_export] macro_rules! init_mat { (hook: $init_hook:expr) =&gt; { struct MatWireGuest; use wit::exports::metatype::wit_wire::mat_wire::*; wit::export!(MatWireGuest with_types_in wit); #[allow(unused)] impl Guest for MatWireGuest { fn handle(req: HandleReq) -&gt; Result&lt;String, HandleErr&gt; { MAT_STATE.with(|router| { let router = router.borrow(); router.handle(req) }) } fn init(args: InitArgs) -&gt; Result&lt;InitResponse, InitError&gt; { let hook = $init_hook; let router = Router::from_builder(hook()); let resp = router.init(args)?; MAT_STATE.set(router); Ok(resp) } } }; } // gen-static-end use types::*; pub mod types { pub type Idv3TitleString = String; pub type Idv3ReleaseTimeStringDatetime = String; pub type Idv3Mp3UrlStringUri = String; #[derive(Debug, serde::Serialize, serde::Deserialize)] pub struct Idv3 { pub title: Idv3TitleString, pub artist: Idv3TitleString, #[serde(rename = &quot;releaseTime&quot;)] pub release_time: Idv3ReleaseTimeStringDatetime, #[serde(rename = &quot;mp3Url&quot;)] pub mp3_url: Idv3Mp3UrlStringUri, } } pub mod stubs { use super::*; pub trait RemixTrack: Sized + 'static { fn erased(self) -&gt; ErasedHandler { ErasedHandler { mat_id: &quot;remix_track&quot;.into(), mat_title: &quot;remix_track&quot;.into(), mat_trait: &quot;RemixTrack&quot;.into(), handler_fn: Box::new(move |req, cx| { let req = serde_json::from_str(req) .map_err(|err| HandleErr::InJsonErr(format!(&quot;{err}&quot;)))?; let res = self .handle(req, cx) .map_err(|err| HandleErr::HandlerErr(format!(&quot;{err}&quot;)))?; serde_json::to_string(&amp;res) .map_err(|err| HandleErr::HandlerErr(format!(&quot;{err}&quot;))) }), } } fn handle(&amp;self, input: Idv3, cx: Ctx) -&gt; anyhow::Result&lt;Idv3&gt;; } pub fn op_to_trait_name(op_name: &amp;str) -&gt; &amp;'static str { match op_name { &quot;remix_track&quot; =&gt; &quot;RemixTrack&quot;, _ =&gt; panic!(&quot;unrecognized op_name: {op_name}&quot;), } } }   It supports the following extra configuration keys.  Key\tType\tDefault\tDescriptionstubbed_runtimes\tstring[]\t[&quot;wasm_wire&quot;]\tRuntimes for which to generate stub types. crate_name\tstring\t${typegraphName}_fdk\tName to assign to crate when generating Cargo.toml. skip_cargo_toml\tboolean\tfalse\tDo not generate Cargo.toml. skip_lib_rs\tboolean\tfalse\tDo not generate lib.rs, the sample entrypoint. ","version":"Next","tagName":"h3"},{"title":"Temporal","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/temporal","content":"","keywords":"","version":"Next"},{"title":"Temporal runtime​","type":1,"pageTitle":"Temporal","url":"/docs/reference/runtimes/temporal#temporal-runtime","content":" Temporal is an open-source durable execution engine that can be used to develop workflows that are long lived and failure resistant. Common use cases include:  Implementing multi-step, complicated transactionaly business logic.Guaranteed event processing.Control planes for driving processes.  The TemporalRuntime in Metatype can be used to directly start, query, signal and describe workflows on your temporal cluster. Refer to the temporal docs for more on what you can accomplish with this tech.  An interesting use case is to dynamically describe the operations you want to expose, this enables reusing typegraphs accross different projects or even building a small framework around it.  Here is a simple example of a typegraph that takes some value from an environment variable.  Loading... ","version":"Next","tagName":"h2"},{"title":"Wasm","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/wasm","content":"","keywords":"","version":"Next"},{"title":"Wasm runtime​","type":1,"pageTitle":"Wasm","url":"/docs/reference/runtimes/wasm#wasm-runtime","content":" The Wasm runtime enables the execution of functions authored in any language that can be compiled into WebAssembly and that follows the component model.  Common use cases:  Integrating an existing WebAssembly componentBuilding language-agnostic services  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Wasm","url":"/docs/reference/runtimes/wasm#example","content":" Here is a simple wit component description using wit IDL that exports the add function.  package example:host; world host { export add: func(a: u32, b: u32) -&gt; u32; }   In your typegraph:  Typescript SDK Python SDK import { Policy, t, typegraph } from &quot;@typegraph/sdk&quot;; import { WasmRuntime } from &quot;@typegraph/sdk/runtimes/wasm.js&quot;; typegraph(&quot;example&quot;, (g) =&gt; { const pub = Policy.public(); const wasm = WasmRuntime.reflected(&quot;path/to/your-compiled-component.wasm&quot;); g.expose({ add: wasm .export(t.struct({ a: t.integer(), b: t.integer() }), t.integer(), { name: &quot;add&quot;, // exported function }) .withPolicy(pub), }); });   ","version":"Next","tagName":"h2"},{"title":"Wit to Typegraph types​","type":1,"pageTitle":"Wasm","url":"/docs/reference/runtimes/wasm#wit-to-typegraph-types","content":" Wit ensures that you have statically typed values backed directly in your component. You can refer to the correspondence table bellow in how the input/output values are shaped in your typegraph.  wit\ttypegraph\tExample valuesstring\tt.string(), t.uuid()\t&quot;Hello world&quot;, &quot;H&quot;, .. u8, u16, u32, u64, s8, s16, s32, s64\tt.integer(), t.float()\t1, 2, 0, .. f32, f64\tt.float()\t3.14, 100, 2, .. char\tt.string() (truncated), t.integer() (truncated as u8), t.float() (truncated as u8)\t&quot;A&quot;, 65, 65.0, .. option&lt;T&gt;\t&lt;T&gt;.optional()\tnull, &quot;hello world&quot;, .. list&lt;T&gt;\tt.list(&lt;T&gt;)\t[&quot;one&quot;, &quot;two&quot; ], [1, 2], .. tuple&lt;T1, T2, ..&gt;\tt.list(t.enum([t1, t2, ..]))\t[1, &quot;one&quot;], [2, &quot;two&quot;], .. enum example { one, two }\tt.enum([&quot;one&quot;, &quot;two&quot;])\t&quot;one&quot;, &quot;two&quot; variant example { one(string), two }\tt.struct({ &quot;tag&quot;: t.enum([&quot;one&quot;, &quot;two&quot;]), &quot;value&quot;: t.string().optional() )\t{ &quot;tag&quot;: &quot;two&quot;, &quot;value&quot;: null } record example { id: string, description: option&lt;string&gt; }\tt.struct({ &quot;id&quot;: t.integer(), &quot;description&quot;: t.string().optional() )\t{ &quot;id&quot;: 123, &quot;description&quot;: &quot;some text&quot;} flags example { read, write, delete }\tt.list(t.enum([&quot;read&quot;, &quot;write&quot;, &quot;delete&quot;]))\t[&quot;read&quot;], [&quot;read&quot;, &quot;write&quot;, &quot;delete&quot;], .. ","version":"Next","tagName":"h2"},{"title":"Typegate","type":0,"sectionRef":"#","url":"/docs/reference/typegate","content":"","keywords":"","version":"Next"},{"title":"Using Embedded Typegate (Recommended)​","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#using-embedded-typegate-recommended","content":" meta dev   note You can launch the embedded typegate via two subcommands, meta dev and meta typegate. Check the Embedded Typegate for more info.  The typegate instance runs on port 7890 by default. You can check if the typegate node is running by accessing http://localhost:7890 in your browser.   Using docker (Not Recommended) Install Docker and use the following compose.yml to launch a typegate node. For multi-instance production workloads, Redis and an S3 object store provider are required but the typegate will run using in-memory stores if no SYNC_* environment variable is detected. More details can be found here. In practice you might also want to add a database or other systems that the typegate can connect to. services: typegate: image: ghcr.io/metatypedev/typegate:latest ports: - &quot;7890:7890&quot; extra_hosts: - &quot;host.docker.internal:host-gateway&quot; environment: # only for dev, generate secure values for production TG_SECRET: &quot;a4lNi0PbEItlFZbus1oeH/+wyIxi9uH6TpL8AIqIaMBNvp7SESmuUBbfUwC0prxhGhZqHw8vMDYZAGMhSZ4fLw==&quot; TG_ADMIN_PASSWORD: password DEBUG: &quot;true&quot; # launch the containers docker compose up --detach # watch the typegate logs docker compose logs typegate --follow   ","version":"Next","tagName":"h3"},{"title":"Internal APIs​","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#internal-apis","content":" Most of the internal APIs are still unstable, and may change without notice. If you still want to experiment with them, you can use the GraphQL introspection to discover them.  /typegate/prisma-migration  The typegate nodes - or typegates - are the central components of the ecosystems. They build and type check typegraphs, and expose them through a HTTP/GraphQL interface. They enforce the type safety of the data flows, connect to all the runtimes and orchestrate the execution of incoming requests.  ","version":"Next","tagName":"h2"},{"title":"Request lifecycle​","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#request-lifecycle","content":" When a new request fires a trigger, the typegate orchestrates the following stages:  extract the secure request context from custom authentication or JSON Web Token (JWT)retrieve cached execution plan or compute a new one traverse the typegraph to create a DAG of the required typesoptimize the DAG to reduce the number of calls to the runtimespre-compute all structural elements and data resolutions execute the plan type check the argumentsverify lazily policies on the needrun the DAG executionenforce the rate-limitingtype check the response manage metadata of the request  ","version":"Next","tagName":"h2"},{"title":"HTTP/GraphQL interface​","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#httpgraphql-interface","content":" For now, the typegate nodes are only accessible through HTTP/1.1 and HTTP/2. More protocols could be supported in the future. Typegates expose a GraphQL interface which is the result of a typegraph projected onto corresponding GraphQL types. While this reduces the type safety of the data flowing, it makes more interoperable thanks to the many high-quality and well-known GraphQL tooling already available. The underlying types are also exposed in order for API clients to verify the underlying types.  GraphQL, being a query language, offers a great asset for Metatype's philosophy:  Efficient querying: the client can specify exactly what data it needs, reducing the amount of over- or under-fetchingFlexibility: allows for retrieving multiple resources in a single request, unlike REST, which often requires multiple onesTyping: GraphQL has a built-in type system that allows for better documentation and stronger validation of the requestsImproved tooling: tools and libraries around GraphQL are rapidly growing and great a development experience  ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#configuration","content":" ","version":"Next","tagName":"h2"},{"title":"Environment variables.​","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#environment-variables","content":" The following environment variables can be used to configure the typegate. SYNC_* variables have special semantics which you can read about here.  Environment variables\tDesc\tDefault\tExamplesHOSTNAME\tHostname that typegate is deployed on.\tgetHostname() result.\ttypegate-123 TG_PORT\tTcp port to serve typegate APIs at.\t7890\t7891 TG_ADMIN_PASSWORD\tPassword use by the CLI/SDK to configure the typegate.\tRequired\tMy5up3r53cr37 TG_SECRET\tSymmetric key used to encrypt cookies and other things (64-byte binary string encoded in base64).\tRequired.\t0p64wJCpQCTiPqPOEze92HLBieszD3sGLtnx6tWm67kqo1tCYcNZ17rjFjEzMl7HJ/SOFZsTVWU0fUjndMrhsQ== TMP_DIR\tTop-level temporary directory.\t$PWD/tmp\t/tmp/typegate-tmp-dir DEBUG\tEnable debug output and other development paths.\tfalse\ttrue TIMER_MAX_TIMEOUT_MS\tTimeout for custom runtime functions and other proccesses.\t3000\t5000 TIMER_POLICY_EVAL_RETRIES\tNumber of retries when evaluating policies that have timed out\t1\t3 TIMER_DESTROY_RESOURCES\tForce abort and attempt to restart operations that did not respond after multiple retries\ttrue\tfalse JWT_MAX_DURATION_SEC\tThe lifetime of generated JWT access tokens.\t30 * 24 * 3600\t604800 JWT_REFRESH_DURATION_SEC\tThe lifetime of generated JWT refresh tokens.\t5 * 60\t600 SENTRY_DSN\tData source name for sentry\tnull\thttps://public@sentry.example.com/1 SENTRY_SAMPLE_RATE\tThe rate of error events to be sent to Sentry (between 0.0 and 1.0)\t1.0\t0.5 SENTRY_TRACES_SAMPLE_RATE\tThe rate of transactions be sent to Sentry (between 0.0 and 1.0)\t1.0\t0.2 TRUST_PROXY\tWhether to accept proxy headers when resolving request contexts.\tfalse\ttrue TRUST_HEADER_IP\tThe header key on which to resolve request origin addresses.\tX-Forwarded-For\tX-Forwarded-For DENO_V8_FLAGS\tFlags for tuning the v8 javascript engine. Use the --help flag here to see what options are available. --stack-size=1968 SYNC_REDIS_URL\tURL to the Redis database. Must include the database number.\t**Required (sync mode)\thttp://:password@localhost:6379/0 SYNC_S3_HOST\tHostname of the S3 store.\t**Required (sync mode)\tplay.min.io:9000 SYNC_S3_REGION\tS3 region.\tRequired (sync mode)\tus-west-2 SYNC_S3_ACCESS_KEY\tAccess key for the S3 store credentials.\tRequired (sync mode)\tuser SYNC_S3_SECRET_KEY\tAccess key secret for the S3 store credentials.\tRequired (sync mode)\tpassword SYNC_S3_PATH_STYLE\ttrue or false, force path style if true.\tfalse\ttrue SYNC_S3_BUCKET\tThe bucket to be used for the system (dedicated).\tRequired (sync mode)\tmybucket SUBSTANTIAL_POLL_INTERVAL_SEC\tRate at which new schedules are read.\t1.0\t0.6 SUBSTANTIAL_LEASE_LIFESPAN_SEC\tLease duration associated to a workflow run\t2.0\t6 SUBSTANTIAL_MAX_ACQUIRE_PER_TICK\tMax amount of new acquired replay requests per tick\t3\t5 ","version":"Next","tagName":"h3"},{"title":"Authentication","type":0,"sectionRef":"#","url":"/docs/reference/typegate/authentication","content":"","keywords":"","version":"Next"},{"title":"Basic authentication​","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#basic-authentication","content":" Basic authentication is the simplest way to authenticate requests. It is done by sending a base64 encoded string of your username and password in the authorization header. Recall that base64 encoding is not encryption and can be easily reversed, thus the traffic must be encrypted with SSL/TLS when using basic authentication as your password will otherwise be visible.  Components\tValuesSecrets\tBASIC_[username]=password Header\tAuthorization: Basic base64(username:password) Context\t{ username }  Loading...  ","version":"Next","tagName":"h2"},{"title":"JWT authentication​","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#jwt-authentication","content":" A more secure way to authenticate requests is to use JSON Web Tokens. The context of a user is signed with a secret key and the typegate will verify the signature to ensure the context has not been tampered with. The JWT is then sent in the authorization header.  The JWT is usually generated by an external identity provider (IdP) such as Keycloak or Auth0 and limited in time. The typegate will check that the exp (expiration time) and nbf (not before) are valid if they exist in the context. The logic of refreshing expired tokens is left to the user or the IdP client library being used.  The typegate supports the most frequently used algorithms for signing the JWT and can be imported as using &quot;jwk&quot;, &quot;raw&quot;, &quot;pkcs8&quot; or &quot;spki&quot; formats (see SubtleCrypto documentation). For instance, an asymmetric key pair can be generated with the following command:  const keys = await crypto.subtle.generateKey( { name: &quot;ECDSA&quot;, namedCurve: &quot;P-384&quot; }, true, [&quot;sign&quot;, &quot;verify&quot;], ); const publicKey = await crypto.subtle.exportKey(&quot;jwk&quot;, keys.publicKey); // save keys.privateKey for later use console.log(JSON.stringify(publicKey)); // in typegraph: Auth.jwt(&quot;keycloak&quot;, &quot;jwk&quot;, {&quot;name&quot;: &quot;ECDSA&quot;, &quot;namedCurve&quot;: &quot;P-384&quot;})   Even though, asymmetric encryption is recommended, HMAC-SHA256 is so commonly used that an alias is provided for it.  Components\tValuesSecrets\t[authentication]_JWT=secret Header\tAuthorization: Bearer token Context\t{ your_own_content }  Loading...  Note that for the sake of the demo, the token has no expiration time. Tokens should always be shorted lived and refreshed frequently to reduce the risk of unexpected access.  ","version":"Next","tagName":"h2"},{"title":"OAuth2 authorization​","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#oauth2-authorization","content":" OAuth2 allows a user to grant limited access to their resources on one site, to another site, without having to expose their credentials. It is commonly used when the typegate needed to access restricted information in third-parties such as Google or GitHub.  Most of the time, the OAuth2 is managed by your identity provider and relies on the JWT authentication as explained above. However the typegate provides a simple way to handle the OAuth2 flow without IdP or when the system should be lightweight.  Components\tValuesSecrets\t[authentication]_CLIENT_ID=client_id, [authentication]_CLIENT_SECRET=client_secret Header\tAuthorization: Bearer token Context\t{ content_from_your_idp }  ","version":"Next","tagName":"h2"},{"title":"Take flow​","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#take-flow","content":" Redirect the user to https://[typegate].metatype.cloud/[typegraph]/auth/[authentication]?redirect_uri=https://your-website.com/login and the OAuth2 starts for the user When the user has completed the flow, the typegate will redirect the user to https://your-website.com/login and you can &quot;take&quot; the token from the typegate as follows. This can be only done once and is limited in time:  const take = await fetch( &quot;https://[typegate].metatype.cloud/[typegraph]/auth/take&quot;, { credentials: &quot;include&quot;, }, ); const { token } = await take.json();   The token can then be used as JWT in the Authorization header of your requests, and the response of the typegate will contain a header Next-Authorization. When this header is present, the value should be used in follow-up calls (value will be empty if the authentication has expired).    Loading...  ","version":"Next","tagName":"h3"},{"title":"OpenID Connect​","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#openid-connect","content":" OpenID Connect is an authentication layer on top of OAuth2. It is used to verify the identity of the user and retrieve basic information about them. You can add openid to the OAuth2 scope and you will receive an id_token in the response. The id_token is a JWT that contains the user's information and is signed by the IdP.  ","version":"Next","tagName":"h3"},{"title":"Embedded providers​","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#embedded-providers","content":" Frequent OAuth2 providers are embedded and can be directly used in the typegraph.  from typegraph.graph.auth import oauth2 oauth2.github(&quot;openid profile email&quot;)   The whole list is available here. ","version":"Next","tagName":"h3"},{"title":"CORS","type":0,"sectionRef":"#","url":"/docs/reference/typegate/cors","content":"CORS Cross-Origin Resource Sharing (CORS) is a mechanism that allows or denies cross-origin requests in the browser. It prevents websites that you've not explicitly allowed from using your API. Note that it doesn't protect non-browser clients like server side code or a mobile app from using your typegraphs, only browsers implements the CORS mechanism. More details can be found here. Typescript SDK Python SDK Loading... If your browser support well CORS, you should the following error if you try to run the interactive demo. { &quot;errors&quot;: [ { &quot;message&quot;: &quot;NetworkError when attempting to fetch resource.&quot;, &quot;stack&quot;: &quot;&quot; } ] } Look in the network tab of your browser inspect tools to see the error proper. By the way, there is a hidden cors header in all interactive demos you have met so far: # .. Cors(allow_origin=[&quot;https://metatype.dev&quot;, &quot;http://localhost:3000&quot;]) # .. ","keywords":"","version":"Next"},{"title":"Client","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/client","content":"","keywords":"","version":"Next"},{"title":"Guide​","type":1,"pageTitle":"Client","url":"/docs/reference/typegraph/client#guide","content":" Even though there are minor differences across language implementations, the generated clients adhere to a common design that contains the following elements.  ","version":"Next","tagName":"h2"},{"title":"QueryGraph​","type":1,"pageTitle":"Client","url":"/docs/reference/typegraph/client#querygraph","content":" The root type generated for the client, it includes:  Query builders for all the root functionsTransport constructors for all the transports exposed by the typegraph  Loading...  ","version":"Next","tagName":"h3"},{"title":"Transports​","type":1,"pageTitle":"Client","url":"/docs/reference/typegraph/client#transports","content":" Different transport implementations are used to send the requests to the typegate for different use cases. The QueryGraph will sport methods to construct transports supported by the typegraph (see examples below). Not all transports have the same feature sets.  GraphQLTransport​  This transport converts to equivalent GraphQL query strings that get sent over http. It includes the following features for all implementations:  Sync or async queries and mutationsMultiple queries or mutations in one request  HostcallTransport​  This transport uses host functions exposed by the typegate for use with custom functions.  Sync queries and mutationsMultiple queries or mutations in one request  ","version":"Next","tagName":"h3"},{"title":"Requests​","type":1,"pageTitle":"Client","url":"/docs/reference/typegraph/client#requests","content":" Requests consist of two parts:  Describe the operations using methods on QueryGraph. Methods are typesafe according to each typegraph root functions. Transport methods that take the query description and perform request to the typegate. Mutations and queries use separate methods and types.Some transports like the GraphQLTransport support multiple operations in one request  Loading...  ","version":"Next","tagName":"h3"},{"title":"Nested arguments​","type":1,"pageTitle":"Client","url":"/docs/reference/typegraph/client#nested-arguments","content":" Some fields are themselves composite types that have fields that also require selection. And functions are used to resolve certain fields which require arguments.  Loading...  ","version":"Next","tagName":"h3"},{"title":"Selecting fields​","type":1,"pageTitle":"Client","url":"/docs/reference/typegraph/client#selecting-fields","content":" Booleans indicate interest when selecting fields on an object. By default a field isn't included if it's null, or unspecified. Selections can include selection flags to flip the default so that all unspecified fields get included. This won't apply if the field requires an argument explicitly requiring them for inclusion.  Note that these patterns are different in the client_rs implementations as demonstrated below:  Loading...  Note that this only applies to scalar fields and those that require arguments or are structs must still be explicitly included.  ","version":"Next","tagName":"h3"},{"title":"Preparing requests​","type":1,"pageTitle":"Client","url":"/docs/reference/typegraph/client#preparing-requests","content":" Some transports like the GraphQLTransport allows one to prepare requests before hand and reuse them. This isn't immediately useful but will be critical when persisted queries are available in Metatype.  Loading...  Caution Note that in all three implementations, the closures are only invoked once and it's critical that there are no branching logic present in them.  ","version":"Next","tagName":"h3"},{"title":"Aliases​","type":1,"pageTitle":"Client","url":"/docs/reference/typegraph/client#aliases","content":" Aliasing allows the querying of a node multiple times under different names. This is very similar to the GraphQL aliases and uses them under the hood when using the GraphQLTransport. Note that not all Runtimes support aliasing so make sure your target does before using this feature.  Loading...  ","version":"Next","tagName":"h3"},{"title":"Unions​","type":1,"pageTitle":"Client","url":"/docs/reference/typegraph/client#unions","content":" Union and either types that have composite variants require special forms when querying them. The generated selection types will have fields for selecting composite variants. If the value from the API wasn't of a selected variant, an empty object will be returned. Scalar variants are always selected.  Loading... ","version":"Next","tagName":"h3"},{"title":"Rate limiting","type":0,"sectionRef":"#","url":"/docs/reference/typegate/rate-limiting","content":"Rate limiting The rate limiting algorithm works as follows: each function type can either count the # of calls it gets or the # of results returned rate_calls=Falseeach function type can have a weight rate_weight=1each request is identified by its IP or by one value of its context if set context_identifiera single query can score a maximum of query_limitmultiple queries can sum up to window_limit in a window_sec windowwhen there is multiple typegates (N), you can improve performance by avoiding score synchronizing while the typegate has not reached local_excess: the real maximum score is thus window_limit + min(local_excess, query_limit) * N Loading... Playing with the above should allow you to quickly hit the limits.","keywords":"","version":"Next"},{"title":"Synchronization","type":0,"sectionRef":"#","url":"/docs/reference/typegate/synchronization","content":"","keywords":"","version":"Next"},{"title":"System setup​","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#system-setup","content":" To enable multiple typegate instance support, the system need the following services:  Service\tRoleLoad balancer\tShare the loads accross the different typegate instances Redis database\tUsed for synchronization between typegate instances S3 storage\tStore all the shared files/artifacts for the typegate instances Typegate instances\tObvious    ","version":"Next","tagName":"h2"},{"title":"Load balancer​","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#load-balancer","content":" The setup does not require a specific load balancer software/hardware. Any load balancer can do the job.  ","version":"Next","tagName":"h3"},{"title":"Redis database​","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#redis-database","content":" A single redis instance can be shared by multiple systems, configured with different database numbers.  ","version":"Next","tagName":"h3"},{"title":"S3 storage​","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#s3-storage","content":" Any S3-compatible object store is supported for the file/artifact storage.  One S3 storage might be shared by multiple systems. However, each system must be configured to use its own dedicated bucket.  ","version":"Next","tagName":"h3"},{"title":"Typegate instances​","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#typegate-instances","content":" The typegate instances are configured with environment variables. All the instances of the system must share the same value for the synchronization variables.  See configuration for details.  ","version":"Next","tagName":"h3"},{"title":"Typegate configuration​","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#typegate-configuration","content":" The typegate instances that at the core of the system must share the configuration variables.  Synchronization variable names start with SYNC_.  warning If no SYNC_* variable is present, the typegate will run in the default single instance mode.The typegate will fail to start if any of the SYNC_* variables is present and some required SYNC_* variable is missing.  Variable\tDescriptionSYNCREDIS_URL (_Required)\tURL to the Redis database. Must include the database number. SYNCREDIS_PASSWORD (_Optional)\tRedis database password, can be included in SYNC_REDIS_URL; SYNCS3_HOST (_Required)\tHostname of the S3 store; SYNCS3_REGION (_Required)\tS3 region; SYNCS3_ACCESS_KEY (_Required)\tAccess key for the S3 store credentials; SYNCS3_SECRET_KEY (_Required)\tAccess key secret for the S3 store credentials; SYNCS3_PATH_STYLE (_Optional)\ttrue or false, force path style if true. SYNCS3_BUCKET (_Required)\tThe bucket to be used for the system (dedicated).  ","version":"Next","tagName":"h2"},{"title":"Synchronized mode features​","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#synchronized-mode-features","content":" Sharing typegraphs accross multiple typegate instancesHistory (WIP) ","version":"Next","tagName":"h2"},{"title":"Typegraph","type":0,"sectionRef":"#","url":"/docs/reference/typegraph","content":"","keywords":"","version":"Next"},{"title":"SDKs​","type":1,"pageTitle":"Typegraph","url":"/docs/reference/typegraph#sdks","content":" You can author typegraphs using one of the SDKs available.  Typescript SDK Python SDK Install the @typegraph/sdk package from npm using your preferred package manager and runtime. The SDK requires Node 16+ with Typescript 4.7+, Deno 1.28+ or Bun 1+. pnpm npm jsr deno yarn bun npm install @typegraph/sdk When using Node, make sure to add this to your Typescript configuration: &quot;moduleResolution&quot;: &quot;node16&quot;, // Or &quot;nodenext&quot;  ","version":"Next","tagName":"h2"},{"title":"Functions","type":0,"sectionRef":"#","url":"/docs/reference/types/functions","content":"","keywords":"","version":"Next"},{"title":"Effects​","type":1,"pageTitle":"Functions","url":"/docs/reference/types/functions#effects","content":" Effects are a property of functions and help categorization what happens to data when it gets transformed. Although they are similar to REST verbs and SQL statements, there is no direct one-to-one mapping.  Effects\tREST verbs\tSQL statementsnone\tGET\tSELECT create\tPOST\tINSERT update\tPUT/PATCH\tUPDATE upsert\tPUT\tINSERT ON CONFLICT delete\tDELETE\tDELETE  They provide hints to the typegates for the query orchestration by splitting the queries and mutations. For example, the create effect is exposed as a mutation. They also allow setting different policies based on them, that's for the next page. ","version":"Next","tagName":"h2"},{"title":"Injections","type":0,"sectionRef":"#","url":"/docs/reference/types/injections","content":"","keywords":"","version":"Next"},{"title":"Static​","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#static","content":" Description: Static injection sets a static value to the parameter.  Method: .set(value)  Parameter: The value to be set, it must be compatible with the target type.  ","version":"Next","tagName":"h2"},{"title":"Parent​","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#parent","content":" Description: Parent injection gets the value output of a sibling field (source) in the parent struct. It adds a dependency to the sibling field, so make sure to prevent circular dependencies. Additionally, it requires that the source type is a subtype of the target type.  Note: the parent struct is relative to the function in which the current type is an input.  Method: .from_parent(key)  Parameter: The name (key) of the source field in the parent struct.  ","version":"Next","tagName":"h2"},{"title":"Context​","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#context","content":" Description: Context injection gets the value from the request context that contains authentication data.  Method: .from_context(prop_name)  Parameter: The name or jsonpath of the property in the context.  ","version":"Next","tagName":"h2"},{"title":"Secret​","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#secret","content":" Description: Secret injection gets the value from the secrets defined when deploying the typegraph.  Method: .from_secret(secret_name)  Parameter: The name of the secret.  ","version":"Next","tagName":"h2"},{"title":"Dynamic​","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#dynamic","content":" Description: Dynamic injection gets the value from a predefined generator evaluated at runtime.  Method: .inject(generator_name)  Parameter: The name of the generator.  Available generators:  now: produces the current datetime as a valid ISO string format. This value depends on the configuration of the typegate host machine.  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#example","content":" Loading... ","version":"Next","tagName":"h2"},{"title":"Type comparison","type":0,"sectionRef":"#","url":"/docs/reference/types/comparison","content":"","keywords":"","version":"Next"},{"title":"Semantics​","type":1,"pageTitle":"Type comparison","url":"/docs/reference/types/comparison#semantics","content":" In this section A and B denote types, U and V denote lists of types.  If A is a subtype of B, then A and B are either both scalar types or both non-scalar types.  ","version":"Next","tagName":"h2"},{"title":"Scalar types​","type":1,"pageTitle":"Type comparison","url":"/docs/reference/types/comparison#scalar-types","content":" If A is a scalar type and A is a subtype of B thenB is a scalar type or a union type with at least one variant that is a supertype of A. Note that this is stricter than it should be because we currently only check individually on each union variant. If A is a subtype of B and B is a scalar type thenA is a scalar type of a union type in which any variant is a subtype of B. Suppose that A and B are scalar types. Then A is subtype of B if and only if the following conditions hold: A and B are the same type or A is a t.integer() and B is a t.float(); Type constraints defined on B are all defined on A and satisfy: Type\tType Constraint\tConditiont.integer(), t.float()\tmin\tA.min &gt;= B.min t.integer(), t.float()\tx_min\tA.x_min &gt;= B.x_min t.integer(), t.float()\tmax\tA.max &lt;= B.max t.integer(), t.float()\tx_max\tA.x_max &lt;= B.x_max t.integer(), t.float()\tmultiple_of\tA.multiple_of is a multiple of B.multiple_of t.string()\tmin\tA.min &gt;= B.min t.string()\tmax\tA.max &lt;= B.max t.string()\tpattern\tA.pattern == B.pattern1 t.string()\tformat\tA.format == B.format t.file()\tmin\tA.min &gt;= B.min t.file()\tmax\tA.max &lt;= B.max t.file()\tallow\tA.allow is a subset of B.allow Note that type constraints defined on A are not required to be defined on B. If B is an enum, then A is an enum and all enumeration values defined for A are defined for B.  ","version":"Next","tagName":"h3"},{"title":"Optionals​","type":1,"pageTitle":"Type comparison","url":"/docs/reference/types/comparison#optionals","content":" A is a subtype of t.optional(B) if and only if A is subtype of B. t.optional(A) is a subtype of t.optional(B) if and only if A is a subtype of B. If B is not an optional type, then t.optional(A) is not a subtype of B.  ","version":"Next","tagName":"h3"},{"title":"Lists​","type":1,"pageTitle":"Type comparison","url":"/docs/reference/types/comparison#lists","content":" Suppose that A and B are non-optional types and A is a subtype of B. If A is a list then B is a list and vice-versa. Let X a list type whose item type is A, and Y a list type whose item type is B.X is a subtype of Y if and only if A is a subtype of B,Type constraints defined on X are all defined on Y and satisfy:Type constraint\tConditionmin\tX.min &gt;= Y.min max\tX.max &lt;= Y.max unique_items\tX.unique_items == Y.unique_items  Note that the type constraints defined on X are not required to be defined on Y.  ","version":"Next","tagName":"h3"},{"title":"Objects: t.struct()​","type":1,"pageTitle":"Type comparison","url":"/docs/reference/types/comparison#objects-tstruct","content":" Suppose that A and B are non-optional types and A is a subtype of B. If A is an object type then B is an object type, and vice-versa. If A and B are object types, thenA is a subtype of B if and only if All field key defined in A is defined in B,For all field defined in B with key K, either the field is optional on Bor A has a field with key K whose type is a subtype of the one in B;Type constraints defined on B are all defined on A and satisfy:Type constraint\tConditionmin\tA.min &gt;= B.min max\tA.max &lt;= B.max  ","version":"Next","tagName":"h3"},{"title":"Unions: t.union() and t.either()​","type":1,"pageTitle":"Type comparison","url":"/docs/reference/types/comparison#unions-tunion-and-teither","content":" If A is a type and V a list of types thenA is a subtype of t.union(V) if and only if there is a type B in V such that A is a subtype of B. If A is a type and V a list of types thenA is a subtype of t.either(V) if and only if there is a unique type B in V such that A is a subtype of B. If U is a list of types and B a type then t.union(U) is a subtype of B if and only if each type A in U is a subtype of B;t.either(U) is a subtype of B if and only if each type A in U is a subtype of B.  ","version":"Next","tagName":"h3"},{"title":"Examples​","type":1,"pageTitle":"Type comparison","url":"/docs/reference/types/comparison#examples","content":" You can find examples of type comparison in thetype comparison test suite.    Footnotes​ The patterns are required to be exactly the same because we currently do not have any other comparison semantic for regular expressions. ↩ ","version":"Next","tagName":"h2"},{"title":"Parameter Transformations","type":0,"sectionRef":"#","url":"/docs/reference/types/parameter-transformations","content":"","keywords":"","version":"Next"},{"title":"func::reduce(tree)​","type":1,"pageTitle":"Parameter Transformations","url":"/docs/reference/types/parameter-transformations#funcreducetree","content":" The reduce method allows you to only enable some paths in the graph of the input type of the function.  The only required parameter to func::reduce is the reduce tree.  ","version":"Next","tagName":"h2"},{"title":"Reduce tree​","type":1,"pageTitle":"Parameter Transformations","url":"/docs/reference/types/parameter-transformations#reduce-tree","content":" A reduce tree (reduce sub-tree) is plain object whose property values are either a reduce sub-tree or a g.inherit() expression.  Each plain object represents a t.struct() in the input type subgraph.  All the nodes that are missing from the reduce tree will set the argument to its default value. Therefore they must be optional.  Consider the following typegraph:  Typescript SDK Python SDK const post = t.struct({ id: t.uuid(), title: t.string(), content: t.string(), }); const user = t.struct({ id: t.uuid(), email: t.email(), posts: t.list(post), }); const filter = t.struct({ id: t.uuid().optional(), email: t.email().optional(), posts: t.struct({ count: t.struct({ gt: t.integer({ min: 1 }).optional(), lt: t.integer({ min: 1 }).optional(), }), tag: t.list(t.string()), }), }); const deno = DenoRuntime(); const findUsers = deno.func(filter, t.list(user), { code: &quot;...&quot; }); g.expose({ findUserById: findUsers.reduce({ id: g.inherit(), }), findUsersByPostCount: findUsers.reduce({ posts: { count: g.inherit(), }, }), currentUser: findUsers.reduce({ id: g.inherit().fromContext(&quot;profile.userId&quot;), }), });   The following queries are valid:  query FindUsersById($id: String!) { findUserById(id: $id) { id email } } query FindUsersByPostCount($min: Int!) { findUsersByPostCount(posts: { count: { gt: $min } }) { id email } }   However the following query is invalid:  query Q { findUserById(email: &quot;user@example.com&quot;) { id email } }   The currentUser function will not accept any parameter.  Notes:  The only fully supported non-leaf node is t.struct().Support for t.either() and t.union() is experimental.t.list() is not supported.Each non-leaf node may be optional or not.  ","version":"Next","tagName":"h3"},{"title":"func::apply(tree)​","type":1,"pageTitle":"Parameter Transformations","url":"/docs/reference/types/parameter-transformations#funcapplytree","content":" The apply method allows you to rewrite the input type of the function, enabling flat input type whatever is the level of nesting in the original input type.  The only required parameter to func::apply is the apply tree.  ","version":"Next","tagName":"h2"},{"title":"Apply tree​","type":1,"pageTitle":"Parameter Transformations","url":"/docs/reference/types/parameter-transformations#apply-tree","content":" Lexicon\tDefinitionApply node\tObject node, list node or leaf-node Apply tree\tObject node Object node\tA plain object whose property values are nodes. It represents a t.struct(). List node\tAn array or list whose items are nodes. It represents a t.list(). Leaf node\tAn apply expression. See below.  From the code blocks in previouse section, let's make the following changes.  Typescript SDK Python SDK g.expose( findUsersByPostCount: findUsers.apply({ posts: { count: { lt: g.as_arg(), gt: g.as_arg(), } } }), findTechWriters: findUsers.apply({ posts: { tags: [g.set(&quot;tech&quot;)] } }), )   In this case, the matching queries are the following:  query FindUsersByPostCount($lt: Int, $gt: Int) { findUsersByPostCount(lt: $lt, gt: $gt) { id email } } query FindTechWriters { findTechWriters { id email } }   Those queries will be translated to the following:  query FindUsersByPostCount($lt: Int, $gt: Int) { findUsers({ posts: { count: { lt: $lt, gt: $gt } } }) { id email } } query FindTechWriters { findUsers({ posts: { tags: [&quot;tech&quot;] } }) { id email } }   ","version":"Next","tagName":"h3"},{"title":"Apply expressions​","type":1,"pageTitle":"Parameter Transformations","url":"/docs/reference/types/parameter-transformations#apply-expressions","content":" An apply expression indicates the source of the value for a specific leaf node in the apply tree.  Apply expression\tSourceg.as_arg([name])\tThe value will be provided as a parameter, under the name name. It is optional for object properties where the default is the property key. g.from_parent(type_name)\tThe node will have the same value as the field of the parent t.struct (of the t.func) that has the type name type_name. g.from_context(path)\tThe node will have the value of the context field accessible by the path path. g.from_secret(key)\tThe node will have the value of the secret named key on the current typegraph. g.set(literal_value)\tThe passed literal_value will be used. ","version":"Next","tagName":"h3"},{"title":"Instant APIs on your database","type":0,"sectionRef":"#","url":"/use-cases/automatic-crud-validation","content":"","keywords":"","version":"Next"},{"title":"Case study​","type":1,"pageTitle":"Instant APIs on your database","url":"/use-cases/automatic-crud-validation#case-study","content":"   Let's say you are developing a web application for a retail store that allows customers to place orders online. In this scenario, you would need to use CRUD operations to create, read, update, and delete data related to orders, customers, products, and inventory.  You would have to model each of these entities as a data type, define the operations that can be performed on them and write the code to ensure the correctness of the data processed in the operations.  For example, you would need to define a Customer type with the following fields: id, name, email, and address. You would also need to define the operations that can be performed on the Customer type, such as createCustomer, updateCustomer, and deleteCustomer. You would also need to write the code to validate the data in the createCustomer operation to ensure that the customer's email address is valid and that the customer's address is not empty. Same for the other fields.  ","version":"Next","tagName":"h2"},{"title":"Types","type":0,"sectionRef":"#","url":"/docs/reference/types","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Types","url":"/docs/reference/types#overview","content":" Types are used to describe the data to be processed. They constrain the range of value that can be accepted as input data or expected as result on each computation running in a runtime.  All the type definition functions are available under the t namespace.  Typescript SDK Python SDK import { t } from &quot;@typegraph/sdk&quot;;   ","version":"Next","tagName":"h2"},{"title":"Scalar types​","type":1,"pageTitle":"Types","url":"/docs/reference/types#scalar-types","content":" Type\tGraphQL type\tDescriptiont.integer()\tInt\tRepresents signed 32-bit integers. t.float()\tFloat\tRepresents signed double-precision values as specified by IEEE 754. t.boolean()\tBoolean\tRepresents true or false. t.string()\tString\tRepresents textual data as UTF-8 character sequences. t.file()\t—\tRepresents a file for upload.  The following scalar types are aliases to a t.string() type with a specific format.  t.uuid()t.json()t.email()t.uri()t.hostname()t.ean()t.phone()t.date()t.datetime()  ","version":"Next","tagName":"h3"},{"title":"Non-scalar types​","type":1,"pageTitle":"Types","url":"/docs/reference/types#non-scalar-types","content":" Type\tGraphQL type\tDescriptiont.optional()\tnullable\tRepresents a value that may be null. t.list()\tlist\tRepresents a list of values. t.struct()\tinterface\tRepresents a structured data value, consisting of fields which map to typed values. t.union()\tunion\tRepresents a value which can be one of a set of specified types. t.either()\tunion\tRepresents a value which can match one and only one of a set of specified types. t.func\t—\tRepresents an operation that has to be performed on the typegate.  ","version":"Next","tagName":"h3"},{"title":"Type constraints​","type":1,"pageTitle":"Types","url":"/docs/reference/types#type-constraints","content":" Type constraints define an additional narrowing of the range of values that can be accepted for the type.  They can be passed in an object after the last required parameter on the type definition.  See the reference for each type below for the list of constraints available.  Example: The min constraint on the type t.integer()  Typescript SDK Python SDK // represents integers greater than or equal to `12` t.integer({ min: 12 });   ","version":"Next","tagName":"h3"},{"title":"Enumerations​","type":1,"pageTitle":"Types","url":"/docs/reference/types#enumerations","content":" t.integer(), t.float(), t.string(), t.struct(...) can have a list of enumerated values. In this case the only valid values for the type are the ones that are listed in the enumeration.  Examples:  Typescript SDK Python SDK t.integer().enum([1, 2, 3]) t.float().enum([1.2, 3.6, 12.4]) t.string().enum([&quot;hello&quot;, &quot;halo&quot;, &quot;salut&quot;]) t.struct({ a: t.string(), b: t.integer() }) .enum([{ a: &quot;one&quot;, b: 1 }, { a: &quot;two&quot;, b: 2 }])     t.enum(array) is an alias to t.string().enum(array).  ","version":"Next","tagName":"h3"},{"title":"Names and type references​","type":1,"pageTitle":"Types","url":"/docs/reference/types#names-and-type-references","content":" Each type has a unique name. If none is set, a random name will be generated during typegraph serialization.  ","version":"Next","tagName":"h3"},{"title":"Injection​","type":1,"pageTitle":"Types","url":"/docs/reference/types#injection","content":" ","version":"Next","tagName":"h3"},{"title":"Types​","type":1,"pageTitle":"Types","url":"/docs/reference/types#types-1","content":" ","version":"Next","tagName":"h2"},{"title":"t.boolean()​","type":1,"pageTitle":"Types","url":"/docs/reference/types#tboolean","content":" The t.boolean() type represents boolean values, true or false.  ","version":"Next","tagName":"h3"},{"title":"t.integer()​","type":1,"pageTitle":"Types","url":"/docs/reference/types#tinteger","content":" The t.integer() type represents 32-bit integers.  t.integer([constraints]);   Constraints​  Constraint\tDescriptionmin\tThe minimum value of the integer. max\tThe maximum value of the integer. x_min\tThe minimum value of the integer, exclusive. x_max\tThe maximum value of the integer, exclusive. multiple_of\tThe integer must be a multiple of this value.  Examples​  Typescript SDK Python SDK // non-negative integer const nonNegative = t.integer({ min: 0 }); // an integer in the range [18, 120) const adultAge = t.integer({ min: 18, x_max: 120 }); // an even integer const even = t.integer({ multiple_of: 2 });   ","version":"Next","tagName":"h3"},{"title":"t.float()​","type":1,"pageTitle":"Types","url":"/docs/reference/types#tfloat","content":" t.float([constraints]);   The t.float() type represents numbers, stored in double precision floating-point format (IEEE 754).  Constraints​  The t.float() type has the same constraints as t.integer(). See integer constraints.  ","version":"Next","tagName":"h3"},{"title":"t.string()​","type":1,"pageTitle":"Types","url":"/docs/reference/types#tstring","content":" t.string([constraints]);   The t.string() type represents textual data represented as UTF-8 character sequences.  Constraints​  Constraint\tType\tDescriptionmin\tInteger\tMinimum length of the string. max\tInteger\tMaximum length of the string. pattern\tString\tRegular expression pattern that the string must match. format\tString\tJSON schema format that the string must match. See below for the list of supported formats.  Supported formats​  Here is the list of supported formats:  uuidjsonemailurihostnameeanphonedatedate-time  Examples​  Typescript SDK Python SDK // a non-empty string of maximum 64 characters t.string({ min: 1, max: 64 }); // an email address t.string({ format: &quot;email&quot; }); // a json data t.string({ format: &quot;json&quot; });   Aliases​  Typescript SDK Python SDK Alias\tEquivalent declarationt.uuid()\tt.string({ format: &quot;uuid&quot; }) t.email()\tt.string({ format: &quot;email&quot; }) t.uri()\tt.string({ format: &quot;uri&quot; }) t.json\tt.string({ format: &quot;json&quot; }) t.ean()\tt.string({ format: &quot;ean&quot; }) t.phone()\tt.string({ format: &quot;phone&quot; }) t.date()\tt.string({ format: &quot;date&quot; }) t.datetime()\tt.string({ format: &quot;date-time&quot; })  ","version":"Next","tagName":"h3"},{"title":"t.file()​","type":1,"pageTitle":"Types","url":"/docs/reference/types#tfile","content":" t.file([constraints]);   The t.file() represents files for upload.  Type Constraints​  Constraint\tType\tDescriptionmin\tInteger\tMinimum size of the file in bytes. max\tInteger\tMaximum size of the file in bytes. allow\tArray of strings\tList of allowed content-types  Examples​  Typescript SDK Python SDK // A file of a minimum size of 1KB t.file({ min: 1024 }); // A JPEG or PNG file less than 2KB t.file({ max: 2048, allow: [&quot;image/jpeg&quot;, &quot;image/png&quot;] });   ","version":"Next","tagName":"h3"},{"title":"t.optional()​","type":1,"pageTitle":"Types","url":"/docs/reference/types#toptional","content":" t.optional(item_type); item_type.optional(); // equivalent syntactic sugar   Default value​  If the type is used as an input type, the default value can be specified in the type definition.  Typescript SDK Python SDK t.string().optional({ defaultItem: &quot;default value&quot; });   ","version":"Next","tagName":"h3"},{"title":"t.list()​","type":1,"pageTitle":"Types","url":"/docs/reference/types#tlist","content":" t.list(item_type, [constraints]);   The t.list() type represents a sequence of values of the same type.  Constraints​  Constraint\tType\tDescriptionmin\tInteger\tMinimum number of items. max\tInteger\tMaximum number of items. unique_items\tBoolean\tWhether the items must be unique.  Examples​  Typescript SDK Python SDK # A list of strings t.list(t.string()) # A list of unique strings t.list(t.string(), { uniqueItems: true }) # A list of strings with at least 3 items # and at most 10 items t.list(t.string(), { min: 3, max: 10 })   ","version":"Next","tagName":"h3"},{"title":"t.struct()​","type":1,"pageTitle":"Types","url":"/docs/reference/types#tstruct","content":" t.struct(properties, [constraints]);   The t.struct() type represents structured data, consisting of nemed properties with pre-defined types.  All the prperies are required unless the corresponding type is optional. In that case, the field is allowed to be missing from the value or be null.  Constraints​  Constraint\tType\tDescriptionmin\tInteger\tMinimum number of fields. max\tInteger\tMaximum number of fields.  Examples​  Typescript SDK Python SDK // A user profile const user = t.struct({ id: t.uuid({ as_id: true }), email: t.email(), username: t.string({ min: 3, max: 64 }), }); // A user profile with an optional `name const user = t.struct({ id: t.uuid({ as_id: true }), email: t.email(), username: t.string({ min: 3, max: 64 }), name: t.string({ min: 3, max: 64 }).optional(), });   ","version":"Next","tagName":"h3"},{"title":"t.union() and t.either()​","type":1,"pageTitle":"Types","url":"/docs/reference/types#tunion-and-teither","content":" t.union(variants); t.either(variants);   The t.union type represents a value that can be of any of the specified variants. The t.either type represents a value that must be of one and only one of the specified variants.  The variants parameter is an array of types.  ","version":"Next","tagName":"h3"},{"title":"t.func()​","type":1,"pageTitle":"Types","url":"/docs/reference/types#tfunc","content":" The t.func() type represents an operation to be performed on the typegate with the specified configuration associated to it.  Usually, the functions are not defined explicitly, but rather created with the runtime instance.  ","version":"Next","tagName":"h3"},{"title":"Parameters​","type":1,"pageTitle":"Types","url":"/docs/reference/types#parameters","content":" Parameter\tType\tDescriptioninput type\tt.struct()\tThe type of the input data. output type\tany type\tThe type of the output data. function\tFunction~\tThe abstraction to use to perform the operation/computation.  Methods​  Method\tPurpose\tReference pagerate\tRate limiting\tRate limiting reduce\tParameter transformation\treduce apply\tParameter transformation\tapply ","version":"Next","tagName":"h3"},{"title":"Metatype's solution​","type":1,"pageTitle":"Instant APIs on your database","url":"/use-cases/automatic-crud-validation#metatypes-solution","content":" Metatype simplifies the development of CRUD APIs by providing the Prisma runtime that automates the creation of the API for CRUD operations and corresponding data validation in PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB. It can even validate some advanced types like email which may not be supported by downstream system (databases often store email address into plain string instead of a specialized field). This makes it faster for developers to create scalable CRUD APIs and enable them to focus their expertise where it matters most like checkout or the search capabilities.  Loading... ","version":"Next","tagName":"h2"},{"title":"Cloud function runner","type":0,"sectionRef":"#","url":"/use-cases/faas-runner","content":"","keywords":"","version":"Next"},{"title":"Case study​","type":1,"pageTitle":"Cloud function runner","url":"/use-cases/faas-runner#case-study","content":"   For example, imagine you have an e-commerce application that uses FaaS to process orders. When a customer places an order, multiple functions may need to be executed, such as validating the order, processing the payment, and updating the inventory.  Each function may be executed independently by the FaaS platform and may take varying amounts of time to complete. Those functions may also be executed for historical reason on different platforms like AWS Lambda, Google Cloud Functions, or Azure Functions.  To collect the results of all the functions in a timely manner, you need to ensure that each function is executed in the correct order and that you are not waiting for a slow function to complete before moving on to the next function.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution​","type":1,"pageTitle":"Cloud function runner","url":"/use-cases/faas-runner#metatypes-solution","content":" To solve the use case of executing multiple functions and collecting their results, Metatype provides two key features.  Function composition/chaining: functions can be chained together to form a pipeline. The output of one function can be used as the input of the next function in the pipeline. This allows us to execute multiple functions in a specific order. Embedded runner: you can easily write a function that glues together multiple functions and executes them in a specific order. This allows you to execute multiple functions in a specific order. Currently, both Python and Typescript are supported.  Loading... ","version":"Next","tagName":"h2"},{"title":"Composable GraphQL server","type":0,"sectionRef":"#","url":"/use-cases/graphql-server","content":"","keywords":"","version":"Next"},{"title":"Case study​","type":1,"pageTitle":"Composable GraphQL server","url":"/use-cases/graphql-server#case-study","content":"   Suppose you are building a subscription platform with a GraphQL API. You need to design a schema that accurately represents the available products, their attributes, and the operations that clients can perform, such as searching, filtering, and sorting.  You also need to optimize the performance of complex queries that involve joining multiple data sources, such as products, categories, and user preferences. Additionally, you need to implement caching and pagination to improve the performance and scalability of your API.  Finally, you need to ensure that your API is secure and implements appropriate authentication and authorization mechanisms to protect sensitive data and operations. Some challenges like the N+1 problem (when a single query results in multiple nested queries, each of which requires a separate database or API call) can also make the development of GraphQL resolver slow and complex to manage.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution​","type":1,"pageTitle":"Composable GraphQL server","url":"/use-cases/graphql-server#metatypes-solution","content":" Metatype's approach is to focus on schema design solely, and leave the GraphQL resolver implementation to the engine. By providing where the data is stored and how to access it, the queries are optimized by the engine to minimize the number of external API/database calls and to cache the results.  This can be seen as a declarative GraphQL servers, where the server is orchestrated everything for you. Metatype also comes with pre-built functionalities like authentication, authorization, and rate limiting.  Loading... ","version":"Next","tagName":"h2"},{"title":"IAM gateway","type":0,"sectionRef":"#","url":"/use-cases/iam-provider","content":"","keywords":"","version":"Next"},{"title":"Case study​","type":1,"pageTitle":"IAM gateway","url":"/use-cases/iam-provider#case-study","content":"   Suppose a developer is building a social media platform that allows users to post updates and view other users' profiles. The developer wants to ensure that only authenticated users can access the platform's resources, and that each user can only access their own data.  To achieve this, the developer can use OAuth2 for user authentication and access control. OAuth2 allows users to log in using their Google or GitHub credentials, which are verified by Google or GitHub's IAM system. Once the user is authenticated, the social media platform can use OAuth2 to obtain an access token, which is used to authorize the user's access to the platform's resources.  The social media platform can also use IAM to control access to resources based on user roles and permissions. For example, only authenticated users can access the platform's resources, and each user can only access their own data.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution​","type":1,"pageTitle":"IAM gateway","url":"/use-cases/iam-provider#metatypes-solution","content":" Metatype comes with a built-in IAM gateway that can be used to manage user identities and their authorized privileges within a system. It supports any OpenID/OAuth2 providers and includes a list of pre-configured ones like Google, GitHub, Facebook, Twitter or LinkedIn. You can also use your own identity provider and rely on JSON Web Tokens (JWT) for authentication.  Once the user is authenticated, you can use policy access based control (PBAC) to control access to resources based on user identifies and permissions. For example, only authenticated users can access the platform's resources, and each user can only access their own data. Policies can be defined by any function, and run on or off Metatype.  Loading... ","version":"Next","tagName":"h2"},{"title":"Backend for frontend","type":0,"sectionRef":"#","url":"/use-cases/backend-for-frontend","content":"","keywords":"","version":"Next"},{"title":"Case study​","type":1,"pageTitle":"Backend for frontend","url":"/use-cases/backend-for-frontend#case-study","content":"   Imagine you have a web frontend and a mobile app that both consume data from a microservices-based backend. The web frontend requires certain data fields in a given format, and the mobile app requires the same additional fields in another format.  In a traditional architecture, both the web and mobile frontends would have to make separate API calls to the microservices, and then format the data into the appropriate structure themselves. This can lead to duplicated code, increased latency due heavier calls with non-necessary data, and decreased developer efficiency.  With a BFF in place, it handles the formatting of the data based on the specific needs of each client. All frontends can thus make a single API call to the BFF, which then communicates with the microservices, retrieves the data, and formats it into the required structure before returning it to the frontend.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution​","type":1,"pageTitle":"Backend for frontend","url":"/use-cases/backend-for-frontend#metatypes-solution","content":" Metatype can act as a generic BFF component, serving multiple dedicated APIs and handling security, authentication and authorization for you. By encapsulating the logic for communicating with the microservices, Metatype helps to ensure that the frontends are as decoupled as possible from the other services, making it easier to make changes to either the frontend or the backend without affecting the other side.  Loading... ","version":"Next","tagName":"h2"},{"title":"ORM for the edge","type":0,"sectionRef":"#","url":"/use-cases/orm-for-the-edge","content":"","keywords":"","version":"Next"},{"title":"Case study​","type":1,"pageTitle":"ORM for the edge","url":"/use-cases/orm-for-the-edge#case-study","content":"   Suppose you are building a mobile app that allows users to order food from local restaurants. To provide a low-latency user experience, you want to run your server-side logic as close as possible to your users.  You can deploy your functions across multiple locations on distributed edge servers. For database interactions, you may need a lightweight relay API to remains compatible with the platform and offer an efficient interface like an ORM provide.  When a user makes a request to view the menu or place an order, the corresponding function running on the edge will make a request to the lightweight relay API to retrieve or modify the relevant data in the database.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution​","type":1,"pageTitle":"ORM for the edge","url":"/use-cases/orm-for-the-edge#metatypes-solution","content":" Metatype can act out of the box as a lightweight relay API, simplifying database interactions via HTTP/GraphQL requests, and allowing you to query your database through the Prisma runtime. Prisma is a well-known ORM library that provides a convenient interface to interact with PostgreSQL, MySQL, SQLite, SQL Server, MongoDB, CockroachDB databases.  Loading... ","version":"Next","tagName":"h2"},{"title":"Microservices orchestration","type":0,"sectionRef":"#","url":"/use-cases/microservice-orchestration","content":"","keywords":"","version":"Next"},{"title":"Case study​","type":1,"pageTitle":"Microservices orchestration","url":"/use-cases/microservice-orchestration#case-study","content":"   Let's say your company develop a healthcare platform and that one of the microservices is responsible for handling patient records (owned by team A), and another microservice is responsible for handling appointment scheduling (owned by team B).  When a patient schedules an appointment, the appointment scheduling microservice needs access to the patient's records to ensure that the appointment is scheduled with the right provider and that the provider has the necessary information to provide effective care. However, since patient records contain sensitive information, it is important to ensure that only authorized users have access to them.  To achieve this, the healthcare platform must use authentication and authorization on each API, which allows sharing only required information.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution​","type":1,"pageTitle":"Microservices orchestration","url":"/use-cases/microservice-orchestration#metatypes-solution","content":" Metatype can act as a central entry point for all incoming requests and responses between the microservices themselves and external clients. It is responsible for routing requests to the appropriate microservices and handling responses from those microservices, while verifying the authentication and authorization for each request.  Additionally, Metatype gateway can provide other important features such as rate limiting, caching, and request/response transformations. It can even provide an API from another typegraph and delegate the query processing to it.  Loading... ","version":"Next","tagName":"h2"},{"title":"Programmable API gateway","type":0,"sectionRef":"#","url":"/use-cases/programmable-api-gateway","content":"","keywords":"","version":"Next"},{"title":"Case study​","type":1,"pageTitle":"Programmable API gateway","url":"/use-cases/programmable-api-gateway#case-study","content":"   Suppose that your company needs to implement various policies and logic to manage and secure its APIs, such as rate limiting, caching, and request/response transformations.  To achieve this, the company can adopt a programmable API gateway that allows developers to create and deploy custom function to implement additional logic and policies for incoming requests and outgoing responses.  It also provides a platform for the company to manage its API infrastructure more efficiently and flexibly. Developers can leverage existing libraries and frameworks to quickly build and deploy custom logic, reducing the time and effort required to develop and maintain the API gateway.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution​","type":1,"pageTitle":"Programmable API gateway","url":"/use-cases/programmable-api-gateway#metatypes-solution","content":" Metatype provide a Python SDK for developers to create and deploy custom logic and policies, which can later be deployed to the gateway in a single command line. Importers can also be used to import existing API or logic definitions from other sources, such as OpenAPI, GraphQL, and gRPC.  This enables developer to quickly build and deploy any update the API or the business logic without having to worry about the underlying infrastructure.  Loading... ","version":"Next","tagName":"h2"},{"title":"Metatype Basics","type":0,"sectionRef":"#","url":"/docs/tutorials/metatype-basics","content":"","keywords":"","version":"Next"},{"title":"What are you building?​","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#what-are-you-building","content":" For this tutorial, we'll be implementing an API to power a simple feature roadmap/request hybrid as can be seen on Productlane.  Looking through the app we can see that the api should allow:  Unauthenticated users to submit new &quot;ideas&quot; or vote on any of those already listed.Specify or vote on the importance of an &quot;idea&quot; from &quot;medium&quot; to &quot;critical&quot; or even submit text with more description.Admins will be able to move ideas across buckets like &quot;Backlog&quot;, &quot;Planned&quot;, &quot;In Progress&quot;.    ","version":"Next","tagName":"h2"},{"title":"Setup​","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#setup","content":" To setup your Metatype development environment, please follow the installation guide here  ","version":"Next","tagName":"h2"},{"title":"Create a new project​","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#create-a-new-project","content":" Metatype projects are composed of modular bundles of types, logic and policies called typegraphs. We author typegraphs using modern programming languages &amp; environments. Python and Typescript are currently available for use. The meta-cli allows us to create a new project based on pre-existing templates.  Typescript SDK Python SDK Run one the following commands to create a new project under a new directory titled tg_roadmap. # using Node/Bun runtimes meta new --template node tg_roadmap # ^ project name # ^ Use `meta new --help` find out more available templates. # using Deno meta new --template deno tg_roadmap When using Typescript, the @typegraph/sdk package exposes all the necessary functions and types we'll need to describe our typegraph. The templates already specify it as as a dependency so all we need to do now is run the following command to download it: # using Deno deno cache api/example.ts # cache dependencies # using Bun bun install # using pnpm pnpm install # using npm npm install # using yarn yarn install   ","version":"Next","tagName":"h3"},{"title":"Launch typegate​","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#launch-typegate","content":" The typegate is a program that runs and orchestrates our typegraphs. We can run it locally for development purposes. Typegate currently requires the Redis database to function and to make it easy to run both, we'll make use of a linux container runtime for this. The Docker runtime to be specific which has installation guides located here.  We'll also need the Docker Compose orchestrator which usually comes by default with the docker command. Use the following command to check if it is available:  docker compose version # Docker Compose version 2.23.0   ...and if not, the official installation guide can be found here.  If you have your docker runtime installed and running correctly, you will be able to launch the compose.yml file that's bundled in every template. The compose file by default includes the postgres and mongo databases. You can disable the latter by commenting it out or removing it as we'll not be needing it for this tutorial.  To launch the services, navigate your shell to the project directory and run the following command:  docker compose up --detach # ^ detach means it'll run in the background. # Omit to get the all logs in the current terminal   This should download and start typegate and its dependent services.  We can observe their log of typegate or any of the other services with the following command. It has to be run from the same project directory.  docker compose logs typegate --follow # ^ Omit service name to look at the combined logs of all services   ","version":"Next","tagName":"h3"},{"title":"Make sure it's all working​","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#make-sure-its-all-working","content":" Run the following to make sure everything's up and running.  meta doctor   After running the command, you should get a result similar to then one here.  ","version":"Next","tagName":"h3"},{"title":"Building our Models​","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#building-our-models","content":" We will be using the type system from the typegraph SDK to describe the shape of the data that flows through our application. In this case, we'll build our typegraph around types that represent &quot;ideas&quot;, &quot;votes&quot; and &quot;buckets&quot;.  Typescript SDK Python SDK Modify the file at api/example.ts to look something like the following. // we'll need the following imports import { t, typegraph } from &quot;@typegraph/sdk.js&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ^ each typegraph has a name const bucket = t.struct({ // asId and other config items describe the logical properties // of our types beyond just the shape id: t.integer({}, { asId: true }), name: t.string(), }); const idea = t.struct({ // uuid is just a shorthand alias for `t.string({format: &quot;uuid&quot;})` id: t.uuid({ asId: true }), name: t.string(), // another string shorthand authorEmail: t.email(), }); const vote = t.struct({ id: t.uuid(), authorEmail: t.email(), // `enum_` is also a shorthand over `t.string` importance: t.enum_([&quot;medium&quot;, &quot;important&quot;, &quot;critical&quot;]).optional(), // makes it optional desc: t.string().optional(), }); });   The types here are very simple and we haven't yet added any thing that models their relationships but they should do for our purposes.  ","version":"Next","tagName":"h2"},{"title":"Exposing our application​","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#exposing-our-application","content":" Typegraphs expose an API to the external world using Function objects. Functions describe the operation that transform some input type into an output type and we define them in scope of different Runtimes, where the actual logic runs. At this early stage, we can make use of the Random runtime which allows us to generate random test data for our types to get a feel of our API.  Typescript SDK Python SDK // add need the following imports import { Policy } from &quot;@typegraph/sdk/index.js&quot;; import { RandomRuntime } from &quot;@typegraph/sdk/runtimes/random.js&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... // every exposed function requires access control policies // for now, just use the public policy, anyone can access it const pub = Policy.public(); const random = new RandomRuntime({}); g.expose({ // generates a random object in the shape of idea get_idea: random.gen(idea).withPolicy(pub), }); });   At this point, we can push our typegraph to the locally running typegate node and access it. Run the following command in your project root:  # features auto-reload on any changes to your source files meta dev   Typegate has first-class support for consuming the API through a GraphQl interface and it is enabled by default. It also bundles the GrahpiQl API explorer and you should be able to access it at http://localhost:7890/roadmap once meta-cli has successfully pushed your typegraph.  You can go ahead and try out the following graphql on the interface and get a feel for it.  query { get_idea { id name authorEmail } }   Or, you can mess around on the playground below.  Loading...  ","version":"Next","tagName":"h2"},{"title":"The Prisma Runtime​","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#the-prisma-runtime","content":" Now that we have created a simple endpoint that generates random values for our idea model/type, let's add a CRUD support to our app. A runtime most apps will be depend on is the Prisma Runtime which allows us to connect to different databases and peform database operations.  For this tutorial, we'll be making use of the PostgreSQL database. If you made use of the compose.yml to run typegate as outlined in this tutorial, there should be an instance of Postgres already up. You can check if postgres container is currently running by using the meta doctor command.  If a typegraph needs to access a database, it first needs to be made aware of its address. This is done through secrets. In the root of your project directory, you'll find a file titled metatype.yaml. It contains metatype specific configuration for our project such as the top level typegates object which we use to specify the location and credentials of the different typegate nodes we'll be using. Each typegate entry also takes an secrets object where we can specify secret to be passed to our typegraphs.  The keys in the secrets object are the names of the typegraphs and the values are objects mapping secret names to their values/sources.  The metatype.yaml should already have a few sample environment variables. Add an entry like the following to give our typegraph access to the database's address:  typegates: dev: # .. secrets: TG_ROADMAP_POSTGRES: &quot;postgresql://postgres:password@postgres:5432/db&quot;   Meta-cli will auto-reload when it detects changes to metatype.yaml. This is because Meta-cli was run in dev mode(through the meta dev command).  We can add the Prisma runtime to our typegraph now.  Typescript SDK Python SDK // new imports import { PrismaRuntime } from &quot;@typegraph/sdk/providers/prisma.js&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... // the constructor takes the name of the env var directly const db = new PrismaRuntime(&quot;db&quot;, &quot;POSTGRES&quot;); // ... });   One of the features that the Prisma runtime allows us to implement is relationships. Here, we are creating a one to many relationship between bucket and ideas, also another one to many between ideas and vote. We will be specifiying relationships by using the t.list List type and g.ref(method which accepts the name of the model/entity as a parameter) for creating the link. Check the example below for better understanding.  Typescript SDK Python SDK import { PrismaRuntime } from &quot;@typegraph/sdk/providers/prisma.js&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... const db = new PrismaRuntime(&quot;db&quot;, &quot;POSTGRES&quot;); const bucket = t .struct({ id: t.integer( {}, { asId: true, // auto generate ids during creation config: { auto: true }, }, ), name: t.string(), // one-to many relationship ideas: t.list(g.ref(&quot;idea&quot;)), }) // explicitly naming our types makes reference later easier .rename(&quot;bucket&quot;); const idea = t .struct({ id: t.uuid({ asId: true, config: { auto: true } }), name: t.string(), authorEmail: t.email(), // we need to specify the relationships on both types bucket: g.ref(&quot;bucket&quot;), votes: t.list(g.ref(&quot;vote&quot;)), }) .rename(&quot;idea&quot;); const vote = t .struct({ id: t.uuid({ asId: true, config: { auto: true } }), authorEmail: t.email(), importance: t.enum_([&quot;medium&quot;, &quot;important&quot;, &quot;critical&quot;]).optional(), desc: t.string().optional(), idea: g.ref(&quot;idea&quot;), }) .rename(&quot;vote&quot;); // ... });   g.ref declares logical relationships between our types which the Prisma runtime will be able to pick up. If you need more control on what the relationships will look like on the database, you can use the db.link function. More information can be found on the Prisma runtime reference.  When we save our file at this point, the meta dev watcher should automatically create and push the necessary migrations to our database to get it in its intended shape. You should see a new subdirectory in your project called prisma. It's where the generated migrations are contained.  If you mess something up in the migrations and want a clean slate, you can reset everything by recreating the containers like so:  # remove all containers and their volumes docker compose down -v # launch docker compose up --detach # meta dev will auto apply any pending changes to databases meta dev   At this point, we're ready to add functions to expose database queries to create or read data. The Prisma runtime allows us to run raw queries directly on the database but it also provides handy functions we can use for basic CRUD operations. We'll make use of those.  Typescript SDK Python SDK import { PrismaRuntime } from &quot;@typegraph/sdk/providers/prisma.js&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... const pub = Policy.public(); const db = new PrismaRuntime(&quot;db&quot;, &quot;POSTGRES&quot;); // ... g.expose( { get_buckets: db.findMany(bucket), create_bucket: db.create(bucket), get_idea: db.findFirst(idea), create_ideas: db.create(idea), }, pub, // make all functions public by default ); });   We should be able to add a few buckets and ideas now.  Loading...  ","version":"Next","tagName":"h3"},{"title":"Policies​","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#policies","content":" We now have the tools enough to allow coarse CRUD of our data. The next thing we usually add at this point is authorization. A way to control who can read or write what. The primary mechanism typegraphs use for this purpose are policies.  Policies are small functions that get the context of a request as input and return a boolean signaling weather access should be granted.  Metatype currently supports policies based on javascript functions that are run on the Deno runtime.  For this tutorial, we'll be making use of the basic auth extractor. It expects a string in the format &quot;Basic token&quot; to be set in the Authorization http header. The token is expected to be a base64 encoded string in the format username:secret.  Typescript SDK Python SDK import { DenoRuntime } from &quot;@typegraph/sdk/runtimes/deno.js&quot;; import { Auth } from &quot;@typegraph/sdk/params.js&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... const deno = new DenoRuntime(); // The basic extractor only populates the context when // it recognizes the username and the secret matches g.auth(Auth.basic([&quot;andim&quot; /*more users*/])); // the `username` value is only availaible if the basic // extractor was successful const admins = deno.policy( &quot;admins&quot;, ` (_args, { context }) =&gt; !!context.username `, ); g.expose( { // .. // only admins are allowed to create new buckets create_bucket: db.create(bucket).withPolicy(admins), // .. }, pub, ); // ... });   The basic extractors expects the secrets in environment variables named in a specific format. Add the following entries to the metatype.yaml file:  typegates: dev: # .. secrets: roadmap: # your typegraph name # .. # the basic extractor secret format # BASIC_[username] BASIC_ADMIN: hunter2   When you save the files, meta-cli will reload the new additions to your typegraph. create_bucket is now only accessible to requests bearing the right tokens (For the provided example, Basic YW5kaW06aHVudGVyMg== should work). If you are using the GraphiQl interface from earlier, there should be a panel in the bottom left called &quot;Headers&quot; for setting http headers  Loading...  ","version":"Next","tagName":"h2"},{"title":"More Customization for our app​","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#more-customization-for-our-app","content":" ","version":"Next","tagName":"h2"},{"title":"Preventing Unauthorized Creation of Related Objects​","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#preventing-unauthorized-creation-of-related-objects","content":" Reference: Parameter transformations  By default, Prisma generates types that supports the whole suite of usecases one might have on a CRUD operation such as allowing creation of objects of related types in a single operation. We don't always want this and in our case, we want to prevent users from being able to create buckets, which are protected, through the create_idea function which's public. We can use the reduce method to modify the input types of functions.  mutation CIdea { create_idea( data: { # we want to prevent bucket creation through `create_idea` bucket: { create: { name: &quot;Backlog&quot; } } authorEmail: &quot;asdf@as.df&quot; name: &quot;Add support for WASM GC&quot; } ) { id name } }   Even though the reduce method doesn't allow us to change the shape of the type, we can change the types of members and importantly here, hide the ones we don't need.  Typescript SDK Python SDK typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... g.expose( { // .. create_idea: db.create(idea).reduce({ data: { // `g.inherit` specifies that we keep the member // type of the original name: g.inherit(), authorEmail: g.inherit(), votes: g.inherit(), bucket: { connect: g.inherit(), // by omitting the `create` member, we hide it }, }, }), // .. }, pub, ); });   Requests are now only able to connect new ideas with pre-existing buckets and won't be able to create them. If you try to create new bucket through create_idea, the typgate will return this response.  { &quot;errors&quot;: [ { &quot;message&quot;: &quot;Unexpected property 'create' for argument 'data.bucket' of type 'object' ('object_288') at create_idea; valid properties are: connect&quot;, &quot;locations&quot;: [], &quot;path&quot;: [], &quot;extensions&quot;: { &quot;timestamp&quot;: &quot;2024-04-21T09:46:33.177Z&quot; } } ] }   As you will be linking existing buckets when creating ideas, you need to create at least one bucket in your database. To do that you need to execute the following graphql query with admin privileges. You should add Authorization: &quot;Basic YW5kaW06cGFzc3dvcmQ=&quot; in your headers when sending the request.  mutation CBucket { create_bucket(data: { name: &quot;Backlog&quot; }) { id name } }   Now, If you try using this mutation, it will work as expected. You can only specify buckets that are already created.  mutation { create_idea( data: { # we want to prevent bucket creation through `create_idea` bucket: { connect: { id: 1 } } authorEmail: &quot;asdf@as.df&quot; name: &quot;Add support for WASM GC&quot; } ) { id name bucket { id name } } }   Loading...  ","version":"Next","tagName":"h3"},{"title":"Restrict Update Operation on Selected Fields​","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#restrict-update-operation-on-selected-fields","content":" You'll notice that we had set the importance field on votes as optional. This is to allow users to just up-vote an idea from the main list without opening a form. If they want to add importance or a description to their vote at a later point, we want to update their already existing vote. It should be easy to expose a function for this using Prisma's db.update helper and reduce to restrict changes to only those field. But we'll take this opportunity to explore the feature of the Prisma runtime to execute raw queries.  Typescript SDK Python SDK import * as effects from &quot;@typegraph/sdk/effects.js&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... g.expose( { // .. set_vote_importance: db.execute( // query parameters are matched by name from the input type 'UPDATE &quot;vote&quot; SET importance = ${importance} WHERE id = ${vote_id}::uuid', // our input type t.struct({ vote_id: t.uuid(), importance: t.enum_([&quot;medium&quot;, &quot;important&quot;, &quot;critical&quot;]), }), // we use effects to signal what kind of operation we're doing // updates and creates will be exposed as mutations in GraphQl // the boolean signals that the query is idempotent effects.update(true), ), // .. }, pub, ); });   Our query is exposed like any other function in the GraphQl api.  Loading...  ","version":"Next","tagName":"h3"},{"title":"Creating REST endpoints​","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#creating-rest-endpoints","content":" We can easily expose an HTTP API for our typegraph using the g.rest method. It takes a string describe a graphql query to be executed when the http path is requested.  Typescript SDK Python SDK typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... g.rest( ` query get_buckets { get_buckets { id name ideas { id name authorEmail } } } `, ); g.rest( // query parameters present // expects a request of the type `roadmap/rest/get_bucket?id=uuidstr` ` query get_bucket($id: Integer) { get_bucket(where:{ id: $id }) { id name ideas { id name authorEmail } } } `, ); });   The exposed query is served at the path {typegate_url}/{typegraph_name}/rest/{query_name}. Any parameters that the query takes are processed from the search params of the request. You can check this link on your local machine and check the results.  This is it for this tutorial and thanks for following till the end! This was a long one but we hope it gave you an overview to the vast capabilties of Metatype. We ecourage you to keep exploring! ","version":"Next","tagName":"h3"},{"title":"Quick-start","type":0,"sectionRef":"#","url":"/docs/tutorials/quick-start","content":"","keywords":"","version":"Next"},{"title":"1. Meta CLI​","type":1,"pageTitle":"Quick-start","url":"/docs/tutorials/quick-start#1-meta-cli","content":" info Metatype is only supported on macOS and Linux. Windows users should use Linux on Windows with WSL.  You can download the binary from thereleases page, make it executable and add it to your PATH or use the automated method below.  An installer script is also provided for the CLI in our repository. Curl and install in it with the following one-liner. The installer may ask for your password. curl -fsSL https://raw.githubusercontent.com/metatypedev/metatype/main/installer.sh | bash   info For later use, you can run the following command to upgrade Meta CLI to a newer version. If your Meta CLI is up to date, you will get an Already up to date! response. meta upgrade   That's it! You are done installing Meta CLI.  ","version":"Next","tagName":"h2"},{"title":"2. Typegraph SDK​","type":1,"pageTitle":"Quick-start","url":"/docs/tutorials/quick-start#2-typegraph-sdk","content":" Typescript SDK Python SDK Install the @typegraph/sdk package from npm using your preferred package manager and runtime. The SDK requires Node 16+ with Typescript 4.7+, Deno 1.28+ or Bun 1+. pnpm npm jsr deno yarn bun npm install @typegraph/sdk When using Node, make sure to add this to your Typescript configuration: &quot;moduleResolution&quot;: &quot;node16&quot;, // Or &quot;nodenext&quot;   ","version":"Next","tagName":"h2"},{"title":"3. Typegate node​","type":1,"pageTitle":"Quick-start","url":"/docs/tutorials/quick-start#3-typegate-node","content":" ","version":"Next","tagName":"h2"},{"title":"Using Embedded Typegate (Recommended)​","type":1,"pageTitle":"Quick-start","url":"/docs/tutorials/quick-start#using-embedded-typegate-recommended","content":" meta dev   note You can launch the embedded typegate via two subcommands, meta dev and meta typegate. Check the Embedded Typegate for more info.  The typegate instance runs on port 7890 by default. You can check if the typegate node is running by accessing http://localhost:7890 in your browser.   Using docker (Not Recommended) Install Docker and use the following compose.yml to launch a typegate node. For multi-instance production workloads, Redis and an S3 object store provider are required but the typegate will run using in-memory stores if no SYNC_* environment variable is detected. More details can be found here. In practice you might also want to add a database or other systems that the typegate can connect to. services: typegate: image: ghcr.io/metatypedev/typegate:latest ports: - &quot;7890:7890&quot; extra_hosts: - &quot;host.docker.internal:host-gateway&quot; environment: # only for dev, generate secure values for production TG_SECRET: &quot;a4lNi0PbEItlFZbus1oeH/+wyIxi9uH6TpL8AIqIaMBNvp7SESmuUBbfUwC0prxhGhZqHw8vMDYZAGMhSZ4fLw==&quot; TG_ADMIN_PASSWORD: password DEBUG: &quot;true&quot; # launch the containers docker compose up --detach # watch the typegate logs docker compose logs typegate --follow   ","version":"Next","tagName":"h3"},{"title":"4. Verify your installation​","type":1,"pageTitle":"Quick-start","url":"/docs/tutorials/quick-start#4-verify-your-installation","content":" The doctor subcommand will attempt to detect all the components and report any potential issue. Please make sure to run it before opening an issue and include the output in your report.  meta doctor   After Sucessful installation, the above command produces an output somewhat similar to the one below.  user@first-project:~$ meta doctor ——————————————————————————— Global ——————————————————————————— curr. directory /Users/user/Documents/metatype-playground/projects/first-project global config /Users/user/Library/Application Support/dev.metatype.meta/config.json meta-cli version 0.3.6 docker version Docker version 24.0.7, build afdd53b containers bitnami/minio:2022 (Up 3 days), postgres:15 (Up 3 days), bitnami/redis:7.0 (Up 3 days), envoyproxy/envoy:v1.26-latest (Up 3 days), redis:7 (Up 3 days), rabbitmq:3-management (Up 45 hours) —————————————————————————— Project —————————————————————————— metatype file metatype.yaml targets [2] deploy (remote, 3 secrets), dev (local, 3 secrets) typegraphs [0] ————————————————————————— Python SDK ————————————————————————— python version Python 3.11.3 python bin ../../../../../../Library/Caches/pypoetry/virtualenvs/example-paIt3smx-py3.11/bin/python venv folder not found pyproject file pyproject.toml pipfile file not found requirements file not found typegraph version 0.3.6 ——————————————————————— Typescript SDK ——————————————————————— deno version deno 1.39.4 node version v18.16.0 ┌————————————————————————————————————————————————————————————┐ | In case of issue or question, please raise a ticket on: | | https://github.com/metatypedev/metatype/issues | | Or browse the documentation: | | https://metatype.dev/docs | └————————————————————————————————————————————————————————————┘   ","version":"Next","tagName":"h2"},{"title":"Writing your First App​","type":1,"pageTitle":"Quick-start","url":"/docs/tutorials/quick-start#writing-your-first-app","content":" Now you are ready to develop for your first app! You can use meta doctor to check if neccessary components are installed. Let's start by creating a working directory for the project. Open your terminal and run the following commands.  mkdir first-project cd first-project   Now that you have your workspace and development environment setup, let's start building a simple CRUD application.  The SDK used for developing Metatype applications is the Typegraph. Currently, it's available through Typescript and Python.  Typescript SDK Python SDK There are two variations to write your app using Typescript. You can either use node or deno as the TypeScript runtime. For now, you will be using node. To bootstrap a node Metatype project, you can run the following commands. # create startup files meta new --template node # install dependencies npm install This will create the necessary files for development, some of which are: .graphqlrc.yaml: configuration file to define settings and options related to GraphQL.compose.yml: is where the typegate node and similar services are setup.metatype.yaml: is where you configure different variables such as authentication, secrets... used by the backend. The command also creates a directory called api where you will be building much of your applications's business logic. Inside the api directory, you will find a single file called example.ts which defines a simple Typegraph. import { Policy, t, typegraph } from &quot;@typegraph/sdk&quot;; import { DenoRuntime } from &quot;@typegraph/sdk/runtimes/deno&quot;; import { PythonRuntime } from &quot;@typegraph/sdk/runtimes/python&quot;; typegraph(&quot;example&quot;, (g) =&gt; { const pub = Policy.public(); const deno = new DenoRuntime(); const python = new PythonRuntime(); g.expose({ add: python .fromLambda( t.struct({ first: t.float(), second: t.float() }), t.float(), { code: &quot;lambda x: x['first'] + x['second']&quot; } ) .withPolicy(pub), multiply: deno .func(t.struct({ first: t.float(), second: t.float() }), t.float(), { code: ({ first, second }) =&gt; first * second, }) .withPolicy(pub), }); }); Let's break down the above code snippet. The typegraph function is your building block and it encompasses most of the app logic inside. It takes a name and a callback function as an argument. All the magic is done inside the callback function. Metatype uses Policy Based Access Control for accessing resources in your backend and here you have defined a public access. const pub = Policy.public(); There are two runtimes defined namely PythonRuntime and DenoRuntime. You will be using these two runtimes to perform different data operations along with the other runtimes Metatype provides. const deno = new DenoRuntime(); const python = new PythonRuntime(); Now that you have runtimes to process data and you have specified your access control, you need to define endpoints to communicate with your backend. This is where you use the g.expose method to enumerate the endpoints you want in your application. From the starter file, you can see that you have defined two endpoints, add and multiply. g.expose({ add: python .fromLambda(t.struct({ first: t.float(), second: t.float() }), t.float(), { code: &quot;lambda x: x['first'] + x['second']&quot;, }) .withPolicy(pub), multiply: deno .func(t.struct({ first: t.float(), second: t.float() }), t.float(), { code: &quot;({first, second}) =&gt; first * second&quot;, }) .withPolicy(pub), }); Let's dive into what the add endpoint is doing. The add endpoint defines a custom function which does data processing using the PythonRuntime. When you are defining the custom function, you pass the input type, output type and then a function. That's it! You have created your first Metatype app. It's as easy as this. Before you go ahead and test your app, let's add two more endpoints which peform basic Create and Read database operation. In order to exercise database capabilities, you need to build a table schema or a model. The typegraph SDK provides rich Types which you can use to create any database table that fits to your usecase. Let's create a simple Message table which has fields id, title and body. This is what it will look like in code. const message = t.struct( { id: t.integer({}, { asId: true, config: { auto: true } }), // configuring your primary key title: t.string(), body: t.string(), }, { name: &quot;message&quot; }, // the name of your type ); Great! Now you need a runtime which processes database requests. You will be using another runtime that comes out of the box with Metatype. i.e the PrismaRuntime. Let's go ahead and introduce the PrismaRuntime to your app. You can add the following code below the two runtimes that were predefined. ... const python = new PythonRuntime(); const db = new PrismaRuntime(&quot;database&quot;, &quot;POSTGRES_CONN&quot;); Last, you need to expose a Create and Read endpoints to your database table. Let's add these two lines to g.expose. ... g.expose({ ..., // add following to your typegraph create_message: db.create(message).withPolicy(pub), list_messages: db.findMany(message).withPolicy(pub), }); With these three simple steps, you were able to build a basic backend with database capabilities. Finally, this is what your typegraph looks like in example.ts. import { Policy, t, typegraph } from &quot;@typegraph/sdk/index.ts&quot;; import { DenoRuntime } from &quot;@typegraph/sdk/runtimes/deno.ts&quot;; import { PythonRuntime } from &quot;@typegraph/sdk/runtimes/python.ts&quot;; import { PrismaRuntime } from &quot;@typegraph/sdk/providers/prisma.ts&quot;; typegraph( { name: &quot;quick-start-project&quot;, cors: { allowOrigin: [&quot;https://metatype.dev&quot;, &quot;http://localhost:3000&quot;] }, }, (g) =&gt; { // access control const pub = Policy.public(); // runtimes const deno = new DenoRuntime(); const python = new PythonRuntime(); const db = new PrismaRuntime(&quot;database&quot;, &quot;POSTGRES&quot;); // types, database tables const message = t.struct( { id: t.integer({}, { asId: true, config: { auto: true } }), // configuring our primary key title: t.string(), body: t.string(), }, { name: &quot;message&quot; } // the name of our type ); // custom functions const add = deno.func( t.struct({ first: t.float(), second: t.float() }), t.float(), { code: &quot;({first, second}) =&gt; first + second&quot; } ); const hello = python.fromLambda( t.struct({ world: t.string() }), t.string(), { code: `lambda x: f&quot;Hello {x['world']}!&quot;` } ); g.expose( { add, hello, create_message: db.create(message), list_messages: db.findMany(message), }, pub ); } ); You are almost there to test your first Metatype application. You now need to spin a Tyepgate and deploy your typegraph to the instance. You can leverage the embedded typegate that comes with the Meta CLI. To run the embedded typegate, execute the following command from your terminal. meta dev Once you started your typegate instance using one of the available choice, if you open localhost:7890 in your browser, you will get a webpage similar to this one. To deploy your typegraph to the typegate engine, there are two approaces you can follow. You can either use self-deploy which comes with the typegraph SDK or the Meta CLI. For now, you will be deploying your typegraph using the Meta CLI. Execute the command below on your terminal to deploy the typegraph. meta deploy -f api/example.ts --allow-dirty --create-migration --target dev --gate http://localhost:7890 Upon successful deployment of the typegraph, you should recieve a response similar like this. (example-py3.11) user@pc first-project % meta deploy -f api/example.py --allow-dirty --create-migration --target dev --gate http://localhost:7890 [INFO] Loading module &quot;/Users/user/Documents/metatype-playground/projects/first-project/api/example.ts&quot; [INFO] Loaded 1 typegraph from &quot;/Users/user/Documents/metatype-playground/projects/first-project/api/example.ts&quot;: example [INFO] All modules have been loaded. Stopping the loader. [INFO] Pushing typegraph example (from '/Users/user/Documents/metatype-playground/projects/first-project/api/example.ts') [INFO] ✓ Successfully pushed typegraph example. You have deployed your first typegraph. It's time to run and test your backend which is running on the typegate instance. Click here to open a GraphiQL interface and interact with your backend through graphql queries from your browser. You should get a page similar to the one below. Now you can play with your app through the interface. You can try this graphql query as a start. Create a message using the following mutation. mutation { create_message( data: { title: &quot;First typegraph&quot; body: &quot;Congrats on your first typegraph.&quot; } ) { id } } Then, fetch the created message using the query below. query { list_messages } You should get a response from the typegate similar to then one below. You can also try out what you have built so far here on this playground. Loading... ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}