{"searchDocs":[{"title":"Programmable glue for developers","type":0,"sectionRef":"#","url":"/blog/2023/06/18/programmable-glue","content":"","keywords":"","version":null},{"title":"What is Metatype?‚Äã","type":1,"pageTitle":"Programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#what-is-metatype","content":" Metatype is an open platform for developers to declaratively build APIs. It offers a new approach to creating backends, where the developers focus on data modelling and delegate the implementation to the platform.  The intent is to address the following challenges:  developers are often a bottleneck, and may spend less than 50% of their time on tasks that mattermost of the developments needs are similar, yet most of the systems are not interoperableinfrastructure management takes time and slows down the deployment velocity  The platform is composed of the following components:  Typegraph: a multi-language SDK to manage typegraphs - virtual graphs of types - and compose themTypegate: a serverless REST/GraphQL gateway to execute queries over typegraphsMeta CLI: a command-line tool to offer a great developer experience and fast deployment  ","version":null,"tagName":"h2"},{"title":"What are virtual graphs?‚Äã","type":1,"pageTitle":"Programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#what-are-virtual-graphs","content":" Typegraphs are a declarative way to expose all APIs, storage and business logic of your stack as a single graph. They take inspiration from domain-driven design principles and in the idea that the relation between of the data is as important as data itself, even though they might be in different locations or shapes.  Loading...  These elements can then be combined and composed together similarly on how you would compose web components to create an interface in modern frontend practices. This allows developers to build modular and strongly typed APIs using typegraph as a programmable glue.  ","version":null,"tagName":"h2"},{"title":"Where does this belong in the tech landscape?‚Äã","type":1,"pageTitle":"Programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#where-does-this-belong-in-the-tech-landscape","content":" Before Metatype, there was a gap in the technological landscape for a solution that specifically addressed the transactional, short-lived use cases. While there were existing tools for analytical or long-running use cases, such as Trino and Temporal, there was no generic engine for handling transactional, short-lived tasks.  \t‚Üê individual level transactional\tlarge data ‚Üí analytical instantaneous ‚Üë short-lived\tMetatype query engine for data entities in evolving systems\tTrino query engine for large data from multiples sources long-running asynchronous ‚Üì\tTemporal workflow orchestration engine for data operations\tSpark batch/streaming engine for large data processing  ","version":null,"tagName":"h2"},{"title":"Give it a try!‚Äã","type":1,"pageTitle":"Programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#give-it-a-try","content":" Let us know what you think! Metatype is open source and we welcome any feedback or contributions. The community primarily lives on GitHub.  Next steps Build your first typegraph or read more about the concepts behind Metatype. ","version":null,"tagName":"h2"},{"title":"Welcome to the Metatype documentation!","type":0,"sectionRef":"#","url":"/docs","content":"","keywords":"","version":"Next"},{"title":"Get to know Metatype‚Äã","type":1,"pageTitle":"Welcome to the Metatype documentation!","url":"/docs#get-to-know-metatype","content":" Follow the quick-start to install the components and get a taste of Metatype. Or, jump right into practice with a tutorial below.  üìÑÔ∏è Metatype basics Learn 80% of the concept you will need daily. üìÑÔ∏è Build a feature roadmap API Learn how to build a real world API and explore more advanced features.  ","version":"Next","tagName":"h2"},{"title":"Explore and learn more functionalities‚Äã","type":1,"pageTitle":"Welcome to the Metatype documentation!","url":"/docs#explore-and-learn-more-functionalities","content":" The platform provides out of the box support for many use cases:  create/read/update/delete data in your databasestoring files in your cloud storageauthenticate users with different providers or using JWTsconnecting to third-party/internal APIsrunning custom business logic in your preferred languageproviding fine-grained access control to your dataand more...  üìÑÔ∏è All about types üìÑÔ∏è List of support runtimes üìÑÔ∏è Deploy on different environments üìÑÔ∏è Security mechanisms  ","version":"Next","tagName":"h2"},{"title":"Understand Metatype in depth‚Äã","type":1,"pageTitle":"Welcome to the Metatype documentation!","url":"/docs#understand-metatype-in-depth","content":" Once you are familiar with the basics, you can learn more about the motivation behind Metatype and the underlying implementation.  üìÑÔ∏è Mental model üìÑÔ∏è Comparing Metatype üìÑÔ∏è Query engine üìÑÔ∏è Access control ","version":"Next","tagName":"h2"},{"title":"Access control","type":0,"sectionRef":"#","url":"/docs/concepts/access-control","content":"Access control","keywords":"","version":"Next"},{"title":"Architecture","type":0,"sectionRef":"#","url":"/docs/concepts/architecture","content":"Architecture","keywords":"","version":"Next"},{"title":"Adding a typegraph SDK for Node","type":0,"sectionRef":"#","url":"/blog/2023/10/23/index","content":"","keywords":"","version":null},{"title":"Metatype explained to X","type":0,"sectionRef":"#","url":"/docs/concepts/explanations","content":"Metatype explained to X","keywords":"","version":"Next"},{"title":"Comparing Metatype","type":0,"sectionRef":"#","url":"/docs/concepts/comparisons","content":"","keywords":"","version":"Next"},{"title":"App development platforms‚Äã","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#app-development-platforms","content":" FirebaseSupabase  These are great platforms to quickly start a new project. However, they hardly scale in terms of architecture evolution, technology freedom, number of developers on the project, and you will eventually have to move out due to increasing costs or iterations slowness.  When to choose Metatype  You want to build modular APIs by composing pre-defined blocks and import the ones you need from existing systemsYou want to take advantage of developers tooling you are familiar with like version controls or multiple environmentsYou favor interoperability and extensibility over vendor lock-in and follow your future needs with ease  ","version":"Next","tagName":"h2"},{"title":"Headless CMS‚Äã","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#headless-cms","content":" StrapiDirectus  Headless Content Management Systems (CMS) are great tools to manage content and providing great editing experience. However, they are not designed to build complex APIs like a cart checkout or integrate with other systems.  When to choose Metatype  You want an all-in-one APIs development platforms and offer the same editing experience through a user-friendly interfaceYou care about end-user performance and want to use the best underlying technology for each use casesYou are more than one on the project and want to manage your data models using preferred programming language  ","version":"Next","tagName":"h2"},{"title":"APIs over databases‚Äã","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#apis-over-databases","content":" HasuraPostGraphile  These platforms offer great data accessibility, but they are focused on databases and forget about the importance of the business logic glues and the interoperability with other systems.  When to choose Metatype  You want to have more than CRUD operations and get authentication, rate-limiting, and business logic out of the boxYou want to decouple your database from your API and change where the data is stored as the project evolvesYou prefer focusing on what you want to achieve rather than how to achieve it (and get stuck Haskell or Postgres internals)  ","version":"Next","tagName":"h2"},{"title":"GraphQL-based backends‚Äã","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#graphql-based-backends","content":" WunderGraphGrafbase  These great tools leverage GraphQL to build internal APIs using pre-determined queries. They are less API consumer oriented and that disables powerful capabilities like querying between multiple instances owned by different users.  When to choose Metatype  You want to build internal and external APIs, and go beyond what can be described in a GraphQL schemaYou want to optimize your API queries on the fly and let the engine resolve your data in the most efficient wayYou expect a fine-grained permission model and control the data you expose at the level of each model field  ","version":"Next","tagName":"h2"},{"title":"Web frameworks‚Äã","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#web-frameworks","content":" DjangoNestJS  These frameworks are a great way to build web applications. However, they require a lot of boilerplate code to build APIs and are not designed to be deployed in a serverless environment. They also requires a lot of configuration to get a complete solution.  When to choose Metatype  When you want to build declarative APIs and let the engine handle the underlying implementationWhen you want to build APIs in multiple languages, with less code and have a consistent experience across themWhen you expect a lightweight and all-in-one solution with authentication, databases, caching, and more out of the box  ","version":"Next","tagName":"h2"},{"title":"Workflow engines‚Äã","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#workflow-engines","content":" TemporalWindmill  Great tools when it comes at scheduling long-running jobs. However, they are not designed to answer instantaneous API calls and are not optimized for data entities fetching. They are nonetheless the perfect companion to Metatype and some integrations already exists.  When to choose Metatype  When you want to implement modular APIs and backends with instantaneous responsesWhen you want to interact with workflow engines and control over the operations they perform, including pooling and retriesWhen you look for a serverless deployment solution and want to focus on your business logic ","version":"Next","tagName":"h2"},{"title":"Query engine","type":0,"sectionRef":"#","url":"/docs/concepts/query-engine","content":"Query engine","keywords":"","version":"Next"},{"title":"Features overview","type":0,"sectionRef":"#","url":"/docs/concepts/features-overview","content":"","keywords":"","version":"Next"},{"title":"Authentication‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#authentication","content":" ","version":"Next","tagName":"h2"},{"title":"GraphQL and REST queries‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#graphql-and-rest-queries","content":" ","version":"Next","tagName":"h2"},{"title":"Type checking‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#type-checking","content":" ","version":"Next","tagName":"h2"},{"title":"Live reload during development‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#live-reload-during-development","content":" ","version":"Next","tagName":"h2"},{"title":"Built-in CORS and rate-limiting‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#built-in-cors-and-rate-limiting","content":" ","version":"Next","tagName":"h2"},{"title":"Policy-based authorization‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#policy-based-authorization","content":" ","version":"Next","tagName":"h2"},{"title":"Bring your own storage‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#bring-your-own-storage","content":" s3  ","version":"Next","tagName":"h2"},{"title":"Function runner‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#function-runner","content":" python, typescript  ","version":"Next","tagName":"h2"},{"title":"Automatic migration‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#automatic-migration","content":" it offers multiple runtimes [1] with pre-defined operations (e.g. Prisma) and can replace the needs for an ad-hoc backend  when the project grows, you can easily introduce new APIs or break existing ones in smaller parts while keeping the same interface you can write complex business logic directly in Typescript, Python or WebAssembly and run them directly inside the query engine most of the frontend are today built on composable components, this brings a similar approach to backend development third-parties APIs can be easily integrated, providing you visibility and control over them it is interoperable with existing systems, and can be introduced step by step it can be easily self-hosted or customized according to your needs ","version":"Next","tagName":"h2"},{"title":"Run serverless functions","type":0,"sectionRef":"#","url":"/docs/guides/external-functions","content":"","keywords":"","version":"Next"},{"title":"Embedded runner‚Äã","type":1,"pageTitle":"Run serverless functions","url":"/docs/guides/external-functions#embedded-runner","content":" ","version":"Next","tagName":"h2"},{"title":"External runner‚Äã","type":1,"pageTitle":"Run serverless functions","url":"/docs/guides/external-functions#external-runner","content":" ","version":"Next","tagName":"h2"},{"title":"Typegraph‚Äã","type":1,"pageTitle":"Run serverless functions","url":"/docs/guides/external-functions#typegraph","content":"    ","version":"Next","tagName":"h2"},{"title":"External function definition‚Äã","type":1,"pageTitle":"Run serverless functions","url":"/docs/guides/external-functions#external-function-definition","content":" // fib.ts const CACHE = [1, 1]; const MAX_CACHE_SIZE = 1000; export default function fib({ size }: { size: number }) { if (size &gt; MAX_CACHE_SIZE) { throw new Error(`unsupported size ${size} &gt; ${MAX_CACHE_SIZE}`); } let i = CACHE.length; while (i++ &lt; size) { CACHE.push(CACHE[i - 2] + CACHE[i - 3]); } return CACHE.slice(0, size); }  ","version":"Next","tagName":"h2"},{"title":"Mental model","type":0,"sectionRef":"#","url":"/docs/concepts/mental-model","content":"","keywords":"","version":"Next"},{"title":"Why does Metatype exist?‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#why-does-metatype-exist","content":" As products evolve, building APIs becomes a challenging hot spot where initiatives collides and efficiency becomes a struggle. While deploying new features, all developers spend a non-negligible amount of time on low-value added tasks (CRUD generation, data validation, authorization, etc.) and deploying their solutions. This leaves little time under business constraints to design great interfaces and experiment with the best technical solution, eventually increasing the time to delivery and weakening the innovation capabilities.  Metatype's vision is to enable everyone to build modular API with as little effort as possible. By helping developers to re-use existing systems and APIs, it enables teams to focus on what matters: their expert knowledge in business logic, modelling and technologies. Metatype manage the complex layers for them, making them productive and innovation-friendly for the next iterations.  Drawing inspiration from modern frontend development practices, Metatype adopts the pattern of composing components together to solve backend development challenges. In that respect, Metatype is a key element in the composable enterprise trend by:  making system interfaces accessible and easy to understand for everyone (discoverability)embracing iterative approaches and cut time to deployment in half (autonomy)building strong foundations for APIs with type safety and bounded context (modularity)empowering teams to innovate with new technologies and interoperability (orchestration)  ","version":"Next","tagName":"h2"},{"title":"How does Metatype work?‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#how-does-metatype-work","content":" When developing a feature, the classical approach is to define what data will be at play, how to transform them, where the execution shall take place and who should be authorized. Instead, Metatype define an abstraction for each of those steps and put the emphasis on composing pre-defined APIs or defining re-usable ones when there is no existing solution.  \tClassical approach\tMetatype's computing modelWhat (data)\tfixed response defined by the logic\tAPI clients selects what they need from types How (transformations)\tad-hoc code logic\tcomposed data with interchangeable materializers Where (execution)\t1 code base + 1 database\torchestrate the request across multiple runtimes Who (authentication)\thard-coded rules or system\trequest context based and controlled by policies When (event)\trequest arrival\tbased on triggers  This computing model brings numerous advantages:  it offers multiple runtimes with pre-defined operations and can replace the needs for an ad-hoc backendwhen the project grows, you easily introduce new APIs or break existing ones in smaller partsyou write complex business logic directly in Typescript, Python or WebAssembly and run them on-demandthird-parties APIs can be easily integrated, providing you visibility and control over themit is interoperable with existing (legacy) systems, and can be introduced step by stepit can be easily self-hosted in your own infrastructure or customized according to your needs  ","version":"Next","tagName":"h2"},{"title":"What's exactly Metatype?‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#whats-exactly-metatype","content":" Metatype is an open platform for developers to declaratively build APIs. It offers a new approach to creating backends, where the developers focus on data modelling and delegate the implementation to the platform.  The intent is to address the following challenges:  developers are often a bottleneck, and may spend less than 50% of their time on tasks that mattermost of the developments needs are similar, yet most of the systems are not interoperableinfrastructure management takes time and slows down the deployment velocity  The platform is composed of the following components:  Typegraph: a multi-language SDK to manage typegraphs - virtual graphs of types - and compose themTypegate: a serverless REST/GraphQL gateway to execute queries over typegraphsMeta CLI: a command-line tool to offer a great developer experience and fast deployment  ","version":"Next","tagName":"h2"},{"title":"Architectural overview‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#architectural-overview","content":" Metatype is designed for cloud environments and comes with minimal components. The only requirement to scale horizontally is to share some memory between replicas via Redis. You can use Metatype helm chart to directly deploy typegates on your Kubernetes cluster.        Typegraph  Typegraph is a Python package for building virtual graphs of types and managing their metadata. The name also refers to the typegraph specification which is a file format, currently in JSON, describing all elements of a typegraph.  Why Python? Python was historically chosen during Metatype's prototyping phase and remained since then the default way to describe typegraphs. Its great readability and dynamic typing make it a very accessible language for everyone to pick up quickly. In theory, all frameworks and languages can produce typegraphs respecting the specification to become executable by typegates. This opens the door to a wide range of use cases, including generating typegraphs automatically from existing code base and tools.  ","version":"Next","tagName":"h3"},{"title":"Types‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#types","content":" Types are the building block of typegraphs. They define a type system describing all data objects processed in Metatype. They can be easily extended to support new data types according to the needs of the application.  t.struct( { &quot;id&quot;: t.uuid(), &quot;age&quot;: t.integer(), &quot;cars&quot;: t.list( t.struct( { &quot;model&quot;: t.string(), &quot;name&quot;: t.string().optional(), } ) ), } )   Analogy in SQL: types are similar to the Data Definition Language (DDL) with the extended capacity of describing any type of data.  ","version":"Next","tagName":"h2"},{"title":"Materializers‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#materializers","content":" Types can also describe functions and materializers define how the input type gets transformed into the output type. The input and output types are similar to a function signature and a materializer to its implementation, except that it might not always know what the function body is. In such case, the materializer knows at least where and how to access it.  deno = DenoRuntime() deno.func( t.struct({&quot;input&quot;: t.string()}), t.string(), code=&quot;({ input }) =&gt; `hello ${input}`&quot;, # with logic ) http = HttpRuntime(&quot;https://random.org/api&quot;) http.get( &quot;/flip_coin&quot;, t.struct({}), t.enum([&quot;head&quot;, &quot;tail&quot;]), )   Analogy in SQL: a materializer is similar to a join, a function, or an alias.  ","version":"Next","tagName":"h2"},{"title":"Runtimes‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#runtimes","content":" Every type and materializer have a runtime associated to it. This runtime describes where the types or materializers are physically located. It can be another API, a database, or any other services the typegate can connect to. The typegates uses that information to optimize the execution of the queries and minimize the amount of data moved.  In practice, materializers are often not explicitly used and the usage of runtime sugar syntax is preferred.  http = HttpRuntime(&quot;https://random.org/api&quot;) # same func as above http.get( &quot;/flip_coin&quot;, t.struct({}), t.enum([&quot;head&quot;, &quot;tail&quot;]) ) # implicitly attaches runtime to all types   Analogy in SQL: a runtime is similar to a database instance running some requests.  ","version":"Next","tagName":"h2"},{"title":"Policies‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#policies","content":" Policies are a special type of function t.func(t.struct({...}), t.boolean().optional()) attachable to any other type. They are evaluated once per request and determine whether one of the polices authorizes the access or not. They receive the request context (see typegate) as argument allowing you to implement authorization, access control, or any other business logic.  The policy decision can be:  true: the access is authorizedfalse: the access is deniednull: the access in inherited from the parent types     Analogy in SQL: policies are similar to Row Security Policies (RSP) or Row Level Security (RLS) concepts.  ","version":"Next","tagName":"h2"},{"title":"Triggers‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#triggers","content":" Triggers are events launching the execution of one or multiple functions. They fire when a GraphQL request is received for the specific typegraph.     Analogy in SQL: a trigger is similar to receiving a new query. ","version":"Next","tagName":"h2"},{"title":"","type":0,"sectionRef":"#","url":"/docs/guides/contributing","content":"","keywords":"","version":"Next"},{"title":"Table of Contents‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#table-of-contents","content":" Code of ConductI Have a QuestionI Want To ContributeReporting BugsSuggesting EnhancementsYour First Code Contribution  ","version":"Next","tagName":"h2"},{"title":"Code of Conduct‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#code-of-conduct","content":" This project and everyone participating in it is governed by ourCode of Conduct. By participating, you are expected to uphold this code.  ","version":"Next","tagName":"h2"},{"title":"I Have a Question‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#i-have-a-question","content":" If you want to ask a question, we assume that you have read the availabledocumentation.  Before you ask a question, it is best to search for existingIssues that might help you. In case you have found a suitable issue and still need clarification, you can write your question in this issue. It is also advisable to search the internet for answers first.  If you then still feel the need to ask a question and need clarification, we recommend the following:  Open an Issue.Provide as much context as you can about what you're running into.Provide project and platform versions depending on what seems relevant.  ","version":"Next","tagName":"h2"},{"title":"I Want To Contribute‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#i-want-to-contribute","content":" Legal Notice‚Äã When contributing to this project, you must agree that you have authored 100% of the content, that you have the necessary rights to the content and that the content you contribute may be provided under the project license.  ","version":"Next","tagName":"h2"},{"title":"Reporting Bugs‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#reporting-bugs","content":" Before Submitting a Bug Report‚Äã  A good bug report shouldn't leave others needing to chase you up for more information. Therefore, we ask you to investigate carefully, collect information and describe the issue in detail in your report. Please complete the following steps in advance to help us fix any potential bug as fast as possible.  Make sure that you are using the latest version.Determine if your bug is really a bug and not an error on your side e.g. using incompatible environment components/versions (Make sure that you have read thedocumentation. If you are looking for support, you might want to check this section).To see if other users have experienced (and potentially already solved) the same issue you are having, check if there is not already a bug report existing for your bug or error in the bug tracker.Also make sure to search the internet (including Stack Overflow) to see if users outside the GitHub community have discussed the issue.Collect information about the bug:Stack traceOS, Platform and Version (Windows, Linux, macOS, x86, ARM)Version of the interpreter, compiler, SDK, runtime environment, package manager, depending on what seems relevant.Possibly your input and the outputCan you reliably reproduce the issue? And can you also reproduce it with older versions?  How Do I Submit a Good Bug Report?‚Äã  You must never report security related issues, vulnerabilities or bugs including sensitive information to the issue tracker, or elsewhere in public. Instead sensitive bugs must be reported according to theSecurity Policy.  We use GitHub issues to track bugs and errors. If you run into an issue with the project:  Open an Issue. (Since we can't be sure at this point whether it is a bug or not, we ask you not to talk about a bug yet and not to label the issue.)Explain the behavior you would expect and the actual behavior.Please provide as much context as possible and describe the reproduction steps that someone else can follow to recreate the issue on their own. This usually includes your code. For good bug reports you should isolate the problem and create a reduced test case.Provide the information you collected in the previous section.  ","version":"Next","tagName":"h3"},{"title":"Suggesting Enhancements‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#suggesting-enhancements","content":" This section guides you through submitting an enhancement suggestion for Metatype, including completely new features and minor improvements to existing functionality. Following these guidelines will help us and the community to understand your suggestion and find related suggestions.  Before Submitting an Enhancement‚Äã  Make sure that you are using the latest version.Read the documentation carefully and find out if the functionality is already covered, maybe by an individual configuration.Perform a search to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one.Find out whether your idea fits with the scope and aims of the project. It's up to you to make a strong case to convince the project's developers of the merits of this feature. Keep in mind that we want features that will be useful to the majority of our users and not just a small subset. If you're just targeting a minority of users, consider writing an add-on/plugin library.  How Do I Submit a Good Enhancement Suggestion?‚Äã  Enhancement suggestions are tracked asGitHub issues.  Use a clear and descriptive title for the issue to identify the suggestion.Provide a step-by-step description of the suggested enhancement in as many details as possible.Describe the current behavior and explain which behavior you expected to see instead and why. At this point you can also tell which alternatives do not work for you.Explain why this enhancement would be useful to most Metatype users. You may also want to point out the other projects that solved it better and which could serve as inspiration.  ","version":"Next","tagName":"h3"},{"title":"Your First Code Contribution‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#your-first-code-contribution","content":" Metatype is using a mono-repository approach. This means that all code is centralized and requires many different tools to work with. The following sections will guide you through the setup process.  Dependencies‚Äã  Install the following global dependencies:  RustPythonPipxPNPMDenoNode  And then more specific ones for the workspace:  # manage rust dependencies cargo install cargo-edit # task runner cargo install whiz # enforce style and good practice pipx install pre-commit # manange python dependencies pipx install poetry # wasmedge prerequisits brew install llvm sudo apt-get install libclang-dev # grpc prerequisits brew install protobuf sudo apt-get install protobuf-compiler libprotobuf-dev # wasmedge runtime curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash   Running The Project‚Äã  # install git commit hooks pre-commit install # prepare python virtual environment python3 -m venv .venv source .venv/bin/activate # depends on your shell # run the task runner and it will install the remaining dependencies (see whiz.yaml and install step) whiz   Environments And Tests‚Äã  deno run -A dev/env.ts all # or only the envs required (e.g. base prisma s3) cargo test --tests # there is a bug with wasm and doc testings deno run -A dev/test.ts # all tests deno run -A dev/test.ts runtimes/prisma/full_prisma_mapping_test.ts # isolated test deno run -A dev/env.ts # shutdown all envs   There are many more developer scripts in the dev folder, however most of them should only be needed for advanced tasks.  Commit Messages‚Äã  Pre-commit hooks enforce some basic checks, namely that all commit messages follow the conventional commitformat. This is a simple set of rules that makes review easier and help us to generate a changelog.  Faster linking‚Äã  We recommend using mold for Linux targets and macOS new parallel linker for faster linking. You can use them as aliases or configure them in your ~/.cargo/config.toml file.  [target.aarch64-apple-darwin] rustflags = [ &quot;-C&quot;, &quot;link-arg=-fuse-ld=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld&quot;, &quot;-C&quot;, &quot;link-arg=-ld_new&quot; # makes sure the new parallel linker is used ] [target.x86_64-unknown-linux-gnu] rustflags = [ &quot;-C&quot;, &quot;link-arg=-fuse-ld=mold&quot; ]  ","version":"Next","tagName":"h3"},{"title":"Write REST endpoints","type":0,"sectionRef":"#","url":"/docs/guides/rest","content":"","keywords":"","version":"Next"},{"title":"Typegraph‚Äã","type":1,"pageTitle":"Write REST endpoints","url":"/docs/guides/rest#typegraph","content":"   ","version":"Next","tagName":"h2"},{"title":"Secure your requests","type":0,"sectionRef":"#","url":"/docs/guides/securing-requests","content":"","keywords":"","version":"Next"},{"title":"Authentication‚Äã","type":1,"pageTitle":"Secure your requests","url":"/docs/guides/securing-requests#authentication","content":" Metatype supports multiple authentication schemes: Basic authentication, JSON Web Tokens (JWT) and OAuth2. This enables every request to have a context and store some information about the user. You can then use the context to set specific fields with from_context or as you will see next step, to restrict accesses via the policies.  For your app, you will use basic authentication in order to restrict some actions for admin users. In order to do so, adding the following secret to your metatype.yml file: TG_AUTHENTICATION_BASIC_ADMIN=password.  Loading...  ","version":"Next","tagName":"h2"},{"title":"CORS‚Äã","type":1,"pageTitle":"Secure your requests","url":"/docs/guides/securing-requests#cors","content":" ","version":"Next","tagName":"h2"},{"title":"Context‚Äã","type":1,"pageTitle":"Secure your requests","url":"/docs/guides/securing-requests#context","content":" ","version":"Next","tagName":"h2"},{"title":"Policies‚Äã","type":1,"pageTitle":"Secure your requests","url":"/docs/guides/securing-requests#policies","content":"","version":"Next","tagName":"h2"},{"title":"Self-host the Typegate","type":0,"sectionRef":"#","url":"/docs/guides/self-hosting","content":"","keywords":"","version":"Next"},{"title":"Helm‚Äã","type":1,"pageTitle":"Self-host the Typegate","url":"/docs/guides/self-hosting#helm","content":" Helm must be installed to use the charts. Please refer to Helm's documentation to get started. The chart can be accessed on the dedicatedrepository.  Once Helm has been set up correctly, add the repo as follows:  helm repo add metatype https://charts.metatype.dev helm show values metatype/typegate &gt; values.yml # customize values.yaml helm install my-gate --values values.yml metatype/typegate  ","version":"Next","tagName":"h2"},{"title":"Ecosystem","type":0,"sectionRef":"#","url":"/docs/reference/ecosystem","content":"","keywords":"","version":"Next"},{"title":"Metatype‚Äã","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#metatype","content":" Metatype is the principal repository of the Metatype ecosystem. It contains the Meta CLI, the typegate and the typegraph components.  ","version":"Next","tagName":"h2"},{"title":"Whiz‚Äã","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#whiz","content":" Whiz is a modern DAG/tasks runner for multi-platform monorepos. It enables to develop the core components of the ecosystem together and reloading only the necessary tasks on file change.    ","version":"Next","tagName":"h2"},{"title":"Lade‚Äã","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#lade","content":" Lade automatically load secrets from your preferred vault as environment variables, and clear them once your shell command is over. The Meta CLI bundles Lade and use it to load secret seamlessly into your typegates.    ","version":"Next","tagName":"h2"},{"title":"Python WASI reactor‚Äã","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#python-wasi-reactor","content":" Python WASI reactor is one of the runtimes bundled into the typegate. It allows to run Python scripts as WASI modules on the fly. ","version":"Next","tagName":"h2"},{"title":"Configuration file","type":0,"sectionRef":"#","url":"/docs/reference/meta-cli/configuration-file","content":"","keywords":"","version":"Next"},{"title":"metatype.yml Example file‚Äã","type":1,"pageTitle":"Configuration file","url":"/docs/reference/meta-cli/configuration-file#metatypeyml-example-file","content":" typegates: dev: url: http://localhost:7890 username: admin password: password typegraphs: python: include: &quot;**/*.py&quot; materializers: prisma: migrations_path: &quot;migrations&quot;   ","version":"Next","tagName":"h2"},{"title":"Automatic secret loading support‚Äã","type":1,"pageTitle":"Configuration file","url":"/docs/reference/meta-cli/configuration-file#automatic-secret-loading-support","content":" Lade is a secret loading tool that transparently inject environment variables from a variety of sources. It works with Fish, Bash or Zsh and currently supports Doppler, Infisical and 1Password as vault source.  To use Lade with Metatype, you can use the op://, infisical:// or doppler:// prefixes in your configuration file. It will then use the CLI of the vault to securely load the required secrets. For example:  typegates: dev: url: http://localhost:7890 username: op://VAULT_NAME/SECRET_NAME/FIELD_NAME password: infisical://app.infisical.com/PROJECT_NAME/ENV_NAME/SECRET_NAME   More of Lade documentation ","version":"Next","tagName":"h2"},{"title":"Meta CLI","type":0,"sectionRef":"#","url":"/docs/reference/meta-cli","content":"","keywords":"","version":"Next"},{"title":"Development‚Äã","type":1,"pageTitle":"Meta CLI","url":"/docs/reference/meta-cli#development","content":" It watches for changes in your typegraphs and refresh your development typegate node on the fly.  ","version":"Next","tagName":"h2"},{"title":"Deployment‚Äã","type":1,"pageTitle":"Meta CLI","url":"/docs/reference/meta-cli#deployment","content":" It deploy your typegraph to the Metatype Cloud or your self-hosted typegate instances in a single command. ","version":"Next","tagName":"h2"},{"title":"Upload files to cloud storage","type":0,"sectionRef":"#","url":"/docs/guides/files-upload","content":"","keywords":"","version":"Next"},{"title":"Typegraph‚Äã","type":1,"pageTitle":"Upload files to cloud storage","url":"/docs/guides/files-upload#typegraph","content":" TG_RETREND_S3_HOST=http://localhost:9000 TG_RETREND_S3_REGION=local TG_RETREND_S3_ACCESS_KEY=minio TG_RETREND_S3_SECRET_KEY=password TG_RETREND_S3_PATH_STYLE=true   from typegraph import typegraph, Policy, t, Graph from typegraph.providers.aws import S3Runtime @typegraph() def retrend(g: Graph): public = Policy.public() s3 = S3Runtime( &quot;S3_HOST&quot;, &quot;S3_REGION&quot;, &quot;S3_ACCESS_KEY&quot;, &quot;S3_SECRET_KEY&quot;, path_style_secret=&quot;S3_PATH_STYLE&quot;, ) g.expose( listObjects=s3.list(&quot;bucket&quot;), getDownloadUrl=s3.presign_get(&quot;bucket&quot;), signUploadUrl=s3.presign_put(&quot;bucket&quot;), upload=s3.upload( &quot;bucket&quot;, t.file(allow=[&quot;image/png&quot;, &quot;image/jpeg&quot;]) ), uploadMany=s3.upload_all(&quot;bucket&quot;), default_policy=[public], )   ","version":"Next","tagName":"h2"},{"title":"Uploading file using presigned url‚Äã","type":1,"pageTitle":"Upload files to cloud storage","url":"/docs/guides/files-upload#uploading-file-using-presigned-url","content":" const image = await Deno.readFile(&quot;website/static/images/logo.png&quot;); // Get a presigned url const { data: { signUploadUrl: presigned }, } = await fetch(&quot;http://localhost:7891/retrend&quot;, { method: &quot;POST&quot;, body: JSON.stringify({ query: ` query SignUploadUrl($length: Int) { signUploadUrl(length: $length, path: &quot;my-super-image.png&quot;) } `, variables: { length: image.length, }, }), }).then((r) =&gt; r.json()); // Upload the file const upload = await fetch(presigned, { method: &quot;PUT&quot;, body: image, headers: { &quot;content-type&quot;: &quot;image/png&quot;, &quot;content-length&quot;: image.length, }, }); console.log(upload.status);   ","version":"Next","tagName":"h2"},{"title":"Uploading file using GraphQL multipart request‚Äã","type":1,"pageTitle":"Upload files to cloud storage","url":"/docs/guides/files-upload#uploading-file-using-graphql-multipart-request","content":" Metatype supportsGraphQL multipart requestfor uploading files. You may use one of the clients in thislistthat support GraphQL multipart request.  const image = await Deno.readFile(&quot;website/static/images/logo.png&quot;); const formData = new FormData(); formData.append( &quot;operations&quot;, JSON.stringify({ query: ` mutation UploadImage($file: Upload!) { upload(file: $file) { id path size contentType } } `, variables: { file: null, }, }) ); formData.append(&quot;map&quot;, JSON.stringify({ 0: [&quot;variables.file&quot;] })); formData.append(&quot;0&quot;, image, &quot;logo.png&quot;); const upload = await fetch(&quot;http://localhost:7891/retrend&quot;, { method: &quot;POST&quot;, body: formData, }); console.log(await upload.json());  ","version":"Next","tagName":"h2"},{"title":"Policies","type":0,"sectionRef":"#","url":"/docs/reference/policies","content":"","keywords":"","version":"Next"},{"title":"Context‚Äã","type":1,"pageTitle":"Policies","url":"/docs/reference/policies#context","content":" ","version":"Next","tagName":"h2"},{"title":"Generics policies‚Äã","type":1,"pageTitle":"Policies","url":"/docs/reference/policies#generics-policies","content":" ","version":"Next","tagName":"h2"},{"title":"Public‚Äã","type":1,"pageTitle":"Policies","url":"/docs/reference/policies#public","content":"     Policies and materializers  This section also makes use of toy typegraph for the sake of clarity. You will continue the chat-based app on the next one.  ","version":"Next","tagName":"h3"},{"title":"Policy based access control (PBAC)‚Äã","type":1,"pageTitle":"Policies","url":"/docs/reference/policies#policy-based-access-control-pbac","content":" The Deno runtime enable to understand the last abstraction. Policies are a way to verify for each type whether the user is authorized or not to access it. It's a very powerful concept that can be for instance used to guarantee a given type is never accidentally exposed to the outside world.  Metatype comes with some built-in policies, but you can use the Deno runtime to define your own:  policies.public() is an alias for Policy(PureFunMat(&quot;() =&gt; true&quot;)) providing everyone open access.policies.ctx(&quot;role_value&quot;, &quot;role_field&quot;) is a companion policy for the authentication strategy you learned in the previous section. It will verify the context and give adequate access to the user.  Policies are hierarchical in the sense that the request starts with a denial, and the root materializers must explicitly provide an access or not. Once access granted, any further types can either inherit or override the access. Policies evaluate in order in case multiple ones are defined.  Loading...  Enough studied, let's go back to your app and finalize it. ","version":"Next","tagName":"h2"},{"title":"Runtimes","type":0,"sectionRef":"#","url":"/docs/reference/runtimes","content":"Runtimes The status represents the maturity of the runtime implementation: not documented: experiment at your own riskalpha: incomplete or non-stabilized API, most features should work you should expect breaking changes likelybeta: complete and almost-stable API, but still collecting feedbacks and improving usabilitystable: complete and stable API, no breaking changes expected Missing your favorite runtime? Submit your request and vote for your preferred ones here. Runtime\tDescription\tRuntime version\tStatus\tTypegate versionPrisma\tQuery SQL and no-SQL databases with Prisma\t4.17.0\tbeta\t&gt;0.1.0 Deno\tExecute Typescript functions with NPM or deno dependencies\t1.35.0\tbeta\t&gt;0.1.0 HTTP\tMake HTTP requests to (REST) HTTP APIs beta\t&gt;0.1.0 GraphQL\tMake GraphQL requests beta\t&gt;0.1.0 Random\tGenerate random data based on your schema alpha\t&gt;0.1.0 S3\tManipulate S3-compatible storage alpha\t&gt;0.1.0 Temporal\tQuery and trigger workflow orchestrated by Temporal alpha\t&gt;0.1.0 WasmEdge\tExecute WebAssembly functions alpha\t&gt;0.1.0 Python\tExecute Python functions alpha\t&gt;0.1.0","keywords":"","version":"Next"},{"title":"GraphQL","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/graphql","content":"","keywords":"","version":"Next"},{"title":"GraphQL runtime‚Äã","type":1,"pageTitle":"GraphQL","url":"/docs/reference/runtimes/graphql#graphql-runtime","content":" You currently have a single model to describe messages sent in the chat-based app. A reasonable next step is to add a user model and make a link between the two. While you can store users in the same database, it's wiser to avoid data duplication and re-use your service for user management available at GraphQLZero endpoint. Let's introduce the GraphQL runtime that allows remote GraphQL queries.  Update typegraph.py with the highlighted lines below:  Loading...  Again, a few interesting happened here:  No migration has been run. The field user comes from another runtime and doesn't exist in the database. The typegate will orchestrate the query execution in all runtimes and minimize the work done.The from_parent rule automatically fills the input type with the parent field named uid. The g(¬∑) rule allows making named reference to another type and avoid circular reference.  Other type enforcement rules also exists:  from_secret(key) to fill the input type with the secret in the TG_[typegraph name]_[key] formatfrom_context(¬∑) to fill the input type with content from the request context, such as JSON Web Token (JWT), etc.set(x) to fill the input type with content x  You should now start to see the power provided by Metatype and might wonder how to integrate it step by step with your existing systems. Writing all those types by hand is tedious and error-prone. The next section will show you how to generate types from existing sources. ","version":"Next","tagName":"h2"},{"title":"HTTP/REST","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/http","content":"HTTP/REST Example: from typegraph.runtime.http import HTTPRuntime remote = HTTPRuntime('https://dev.to/api') remote.get( '/test', t.struct({}), t.list(t.struct({'a': t.integer()})), ) ","keywords":"","version":"Next"},{"title":"Deno/typescript","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/deno","content":"","keywords":"","version":"Next"},{"title":"Deno runtime‚Äã","type":1,"pageTitle":"Deno/typescript","url":"/docs/reference/runtimes/deno#deno-runtime","content":" While the tutorial covered already interesting runtimes, allowing you to connect to already a lot of systems and different protocols, there is still one powerful that wasn't covered yet: the typescript or Deno runtime.  This enables to run lightweight and short-lived typescript function in a sandboxed environment. Permissions can be customized per typegraph and by default only include some HTTPs domains. It's a great way to implement custom logic and materializers. All typegraphs can lazily spawn a web worker and get an incredible cold-start and continuous performance thanks to the V8 engine powering Deno.  Loading...  Example:  # my_typegraph.py from typegraph import TypeGraph, policies, t from typegraph.runtimes.deno import ModuleMat, PureFunMat with TypeGraph(&quot;deno&quot;) as g: public = policies.public() g.expose( add=t.func( t.struct({&quot;a&quot;: t.number(), &quot;b&quot;: t.number()}), t.number(), ModuleMat(&quot;main.ts&quot;).imp(&quot;doAddition&quot;), ), simple=t.func( t.struct({&quot;a&quot;: t.number(), &quot;b&quot;: t.number()}), t.number(), PureFunMat(&quot;({ a, b }) =&gt; a + b&quot;), ), default_policy=[public], )   // main.ts interface AddInput { a: number; b: number; } export function doAddition({ a, b }: AddInput) { return a + b; }  ","version":"Next","tagName":"h2"},{"title":"","type":0,"sectionRef":"#","url":"/docs/reference/changelog","content":"","keywords":"","version":"Next"},{"title":"[unreleased]‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#unreleased","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes","content":" Fix lock.yml (#459) Fix lock.yml to set WASM_OPT_VERSION in whiz.yaml  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features","content":" Pre-registered public policy (#461) The PolicyId for the public policy was cached in a class variable inPolicy. The cache was not valid in a second typegraph defined in the same module.  ","version":"Next","tagName":"h3"},{"title":"v0.2.3 - 2023-10-19‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v023---2023-10-19","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-1","content":" (gate) Explicit null on query arg (#453) Solves MET-268 + fixes an edgecase for &quot;weak validation&quot;  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-1","content":" (gate,sdk) Update auth interface, better oauth2 (#447)  Remove injected fields from generated types for prisma operations (#448) Injected fields are skipped when generating types for prisma. Additional changes: Enable recursive relationships in where filters.Add disconnect, update, upsert, delete, updateMany,deleteMany on nested reletionships for create/update operations.Fix optional union arg validation.  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks","content":" Upgrade wasm-opt (#456)  ","version":"Next","tagName":"h3"},{"title":"v0.2.2 - 2023-10-11‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v022---2023-10-11","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-2","content":" (gate) Script reload while gate is running (#441)  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-2","content":" (sdk) Change rest queries interface (#444)  Stability fixes (#442)  Wasm + change effect none to read (#443)  ","version":"Next","tagName":"h3"},{"title":"v0.2.1 - 2023-10-05‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v021---2023-10-05","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-3","content":" Update rename logic (#439) Duplicate the store entry instead of referencing.  ","version":"Next","tagName":"h3"},{"title":"Refactor‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#refactor","content":" (typegraph_core) Simplify private rust SDK (#432)  ","version":"Next","tagName":"h3"},{"title":"v0.2.0 - 2023-10-04‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v020---2023-10-04","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-4","content":" (gate) Introspection if func has the same input/output (#431)  (sdk,deno,python) Generate func from frontend + prisma deno frontend (#416)  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-3","content":" (core) Set runtime field in types (#398)  (sdk) Add wasmedge runtime (#397)  (sdk) Random runtime (#396) +runtime_config  (sdk) Implement injection (#403)  (sdk) Rate limiting, cors, etc.. (#411)  (sdk) Add the prisma runtime to the new SDK (#395)  (sdk) Apply syntax (#410)  (sdk) Temporal runtime (#413)  (sdk) Custom query exec for prisma runtime (#419)  Fix nightly (#402)  V0.2.x series + upgrades (#417)  Upgrade jco and prepare sdk build (#420)  Sdk build with wasm (#421)  Add typedef.rename() method (#426)  Release 0.2.0 (#434)  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-1","content":" Migrate all the test typegraphs to the new Python SDK (#418)  Migrate doc typegraphs (#429)  Remove old typegraph sdk (#430)  Check that all interfaces are implemented in both sdk (#435)  Hotfix release flow  Hotfix release  ","version":"Next","tagName":"h3"},{"title":"Refactor‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#refactor-1","content":" Make with_store and with_store_mut private in global_store module (#414)  ","version":"Next","tagName":"h3"},{"title":"v0.1.14 - 2023-08-22‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v0114---2023-08-22","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-5","content":" Fix link to LICENSE.md in README.md (#394)  Test with git (#399)  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-4","content":" (gate) Deno worker should timeout internal functions to avoid infinite loop or similar (#375) Attempt solving MET-120. There seems to be an issue when using setTimeout and setInterval in tests even if they are 'properly' cleared. (some might be cancelled prematurely?) Deno runtime ... should work with async function =&gt; ./typegate/tests/utils/test.ts:148:30 error: Leaking async ops: - 1 async operation to sleep for a duration was started before this test, but was completed during the test. Async operations should not complete in a test if they were not started in that test. This is often caused by not cancelling a `setTimeout` or `setInterval` call. I also tried using an external sleep source like $ sleep 1s but it seems to have similar issues error: Leaking resources: - A child process stdout (rid 158) was opened before the test started, but was closed during the test. Do not close resources in a test that were not created during that test. [Update] Disable sanitizeOps while making sure all resources are closed properly. Meta.test(&quot;test title&quot;, async (t) =&gt; { // test body }, { sanitizeOps: false });   (sdk) Implement all types (#380) Solves MET-213  (sdk) Python wasi runtime (#392) This solves MET-216  (typegraph-next) Add GraphQL runtime support (#388) Solves MET-217.  (typegraph/sdk) Add Http runtime (#391) Solve MET-215.  Replace number with float (#390) Related to #380  Small improvements + meta doctor (#387)  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-2","content":" Release 0.1.14  ","version":"Next","tagName":"h3"},{"title":"Refactor‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#refactor-2","content":" (sdk) Change typegraph definition signature (#389) Replace the expose argument with a g objectUse decorator in python  ","version":"Next","tagName":"h3"},{"title":"v0.1.12 - 2023-08-03‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v0112---2023-08-03","content":" ","version":"Next","tagName":"h2"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-5","content":" More stable run by fixing little bugs + typegraph upgrade (#384)  ","version":"Next","tagName":"h3"},{"title":"v0.1.11 - 2023-08-02‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v0111---2023-08-02","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-6","content":" Ensure hooks logging (#357) Solve MET-174 This PR also makes some refactoring: Register did a lot more than engine registration, so some logic needed to be extracted out, like engine initialization, etc...  Enable introspection on system typegraphs (#373) Solves MET-209  ","version":"Next","tagName":"h3"},{"title":"Documentation‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#documentation","content":" Documentation for types (#348)  Move some examples typegraph into how to guides reference or tests (#374) Solves MET-184  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-6","content":" (Deno) Support deno function defined in multiple files (#345) This implements MET-135  (gate) Generate openapi over rest endpoints (#365) This solves MET-205  (wasi) Add support for python def and python module (#360) This solves MET-176 and MET-177  Improve SDKs and rest support (#350)  Wit component 3 (#366)  Customize the generated prisma schema with the target database (#359)  Improve installer script + release 0.1.11 (#381)  ","version":"Next","tagName":"h3"},{"title":"v0.1.10 - 2023-06-28‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v0110---2023-06-28","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-7","content":" Fix injection for GraphQL runtime (#333) Add selection fields for the dependencies in the remote queryUse computed argument values instead of the original ones (to ensure we have all the injected values)  Fix migrations for target with prefix (#344) Solve MET-198 Use the same migration files for the same typegraph either the target uses a prefix or not.  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-7","content":" Configure S3 in secrets (#336) Solves MET-192.  Add oauth profiler, blog, comparison and small fixes (#338)  New typegraph SDK (#337) Solves MET-178. Typegraph definition in TypeScript/Deno and in Python  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-3","content":" Release 0.1.10 (#347)  ","version":"Next","tagName":"h3"},{"title":"v0.1.10-dev.0 - 2023-05-30‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v0110-dev0---2023-05-30","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-8","content":" Website deployment  Env var  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-8","content":" Remove cookie auth, fix typegraph detection, fix injection, add auth doc, add regression test for doc (#327)  ","version":"Next","tagName":"h3"},{"title":"v0.1.9 - 2023-05-26‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v019---2023-05-26","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-9","content":" All importers (#311) fix field name fix regex pattern, add explicit nullable support patch anyOf, oneOf and unknown schema autogenerate name from method+path fix google discovery use Box _safe_attr() add support union/either fix nullable, deprecated add support url params fix tests fix unsupported operand add missing condition skip unsupported schema  Python typing error happening in example.py file (#319) fix(python): use attr.field directly to please pyright fix(python): add type hint for @with_constraints fix(python): correctly type default_policy in TypeGraph.expose  GitHub(Importer) and validate names (#322) sanitize names throw if name invalid  Add explicit error message (#318) add explicit error message full lowercase change status to 4XX remove content-length requirement add missing Content-Type header for tests fix merge fix tests add test add undefined Content-Type test  ","version":"Next","tagName":"h3"},{"title":"Documentation‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#documentation-1","content":" (tuto) Typo and missing highlight line (#320) doc(tuto): that support for -&gt; supporting in prisma runtime section github: update pr-title-workflow doc(tuto): add missing highlighted line  Introduce typegraph_std (#316) introduce typegraph_std fix typos, update description enable simpler import  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-9","content":" Fine-grained licensing  Change target default for meta dev/deploy (#314) feat: meta dev/deploy can choose the targets fix: pr title fix: pr title  Fixed tmp dir creation and logging, make tests parallel (#313) feat: fixed tmp dir creation and logging feat: simplify launch and env fix: tests feat: parallel tests fix: secret cannot override env vars fix: license file fix: license file fix: license header fix: tests fix: tests  Ignore files without tg (MET-175) + temporal fixes (#315) feat: ignore files without tg (MET-175) feat: fix regex  File upload (#312) wip Request parser for FormData Working file upload Implement file download Update Cargo.lock Add mimeTypes constraint in t.file Pass files in withVars Use aws-sdk from deno Fix http runtime Configurable path_style feat: Multiple file upload Add some comments Update deno.lock Fix pre-commit Remove unnecessary comments Fix codegen feat(workflows/tests): Add minio service  ","version":"Next","tagName":"h3"},{"title":"v0.1.8 - 2023-05-16‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v018---2023-05-16","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-10","content":" Css on mobile  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-10","content":" Rework landing page and small improvements (#303)  Update doc, improve design, some renaming and fix cors issue (#306) feat: review homepage feat: improve doc and fix cors fix: links  ","version":"Next","tagName":"h3"},{"title":"MET-148‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#met-148","content":" Optimized typecheck (#300) Performance review First draft Add tests and fix Restore stack size Remove performance measurement More string format validators Fix tests Implement regex pattern validation Implement enum validation Implement enum variants validation Fix tests Disable enum on optional Fix typo  ","version":"Next","tagName":"h3"},{"title":"v0.1.7 - 2023-05-02‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v017---2023-05-02","content":" ","version":"Next","tagName":"h2"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-11","content":" Rust typegraph sdk poc (#281) feat: rust typegraph sdk poc fix: ci fix: ci feat: add black feat: small fixes feat: test ci fix: debug fix: debug fix: debug fix: debug fix: debug  Add prefix to deploy target (#298) feat: add prefix to deploy target chore: prepare release 0.1.7 chore: update pre-commit  ","version":"Next","tagName":"h3"},{"title":"v0.1.6 - 2023-04-27‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v016---2023-04-27","content":" ","version":"Next","tagName":"h2"},{"title":"MET-163‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#met-163","content":" (prisma) type mismatch on contains for nested relation (#284) add test extend term for nested fix skip nested at root level fix test update test comment groupBy tests doc: update generator list ","version":"Next","tagName":"h3"},{"title":"Python","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/python","content":"Python Example: # my_typegraph.py from typegraph import TypeGraph, policies, t from typegraph.runtimes.python import Python, PyModuleMat with TypeGraph(&quot;example_python&quot;) as g: public = policies.public() python = Python() g.expose( add=t.func( t.struct({&quot;a&quot;: t.integer(), &quot;b&quot;: t.integer()}), t.integer(), python.from_lambda(lambda x: x[&quot;a&quot;] + x[&quot;b&quot;]), ), sayHello=t.func( t.struct({&quot;name&quot;: t.string()}), t.string(), PyModuleMat(&quot;hello.py&quot;).imp(&quot;say_hello&quot;), ), default_policy=[public], ) # hello.py def say_hello(x: any): return f&quot;Hello {x[&quot;name&quot;]}&quot; ","keywords":"","version":"Next"},{"title":"Temporal","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/temporal","content":"Temporal Interacts with Temporal server.","keywords":"","version":"Next"},{"title":"S3","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/s3","content":"S3","keywords":"","version":"Next"},{"title":"Random","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/random","content":"Random","keywords":"","version":"Next"},{"title":"WebAssembly","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/wasmedge","content":"WebAssembly Runs Wasm functions on the WasmEdge runtime.","keywords":"","version":"Next"},{"title":"CORS","type":0,"sectionRef":"#","url":"/docs/reference/typegate/cors","content":"CORS Cross-Origin Resource Sharing (CORS) on the one hand is a mechanism that allows or denies cross-origin requests in the browser. It avoids that other websites use your API without explicitly allowing it. Note that it doesn't protect other servers or a mobile app from using your typegraphs, only browsers implements the CORS mechanism. See this documentation for the details. Loading... If your browser support well CORS, you should see an error and even more if you try to run the interactive demo. By the way, there is a hidden core header in all interactive demos you have met so far: TypeGraph.Cors(allow_origin=[&quot;https://metatype.dev&quot;, &quot;http://localhost:3000&quot;]) ","keywords":"","version":"Next"},{"title":"Typegate","type":0,"sectionRef":"#","url":"/docs/reference/typegate","content":"","keywords":"","version":"Next"},{"title":"With Metatype Cloud‚Äã","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#with-metatype-cloud","content":" This is the easiest way to get started, yet it's not publicly accessible. You can sign up for the private beta below.    ","version":"Next","tagName":"h3"},{"title":"With Docker‚Äã","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#with-docker","content":" Install Docker and use the following compose.yml to launch a typegate node. Redis is the single required dependency, however in practice you will want to add database or other systems that the typegate can connect to.  services: typegate: image: ghcr.io/metatypedev/typegate:latest ports: - &quot;7890:7890&quot; extra_hosts: - &quot;host.docker.internal:host-gateway&quot; environment: # only for dev, generate secure values for production TG_SECRET: &quot;a4lNi0PbEItlFZbus1oeH/+wyIxi9uH6TpL8AIqIaMBNvp7SESmuUBbfUwC0prxhGhZqHw8vMDYZAGMhSZ4fLw==&quot; TG_ADMIN_PASSWORD: password REDIS_URL: redis://:password@redis:6379/0 DEBUG: &quot;true&quot; depends_on: - redis redis: image: redis:7 restart: always command: --requirepass password   # launch the containers docker compose up --detach # watch the typegate logs docker compose logs typegate --follow   ","version":"Next","tagName":"h3"},{"title":"Internal APIs‚Äã","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#internal-apis","content":" Most of the internal APIs are still unstable, and may change without notice. If you still want to experiment with them, you can use the GraphQL introspection to discover them.  /typegate/prisma-migration  The typegate nodes - or typegates - are the central components of the ecosystems. They build and type check typegraphs, and expose them through a HTTP/GraphQL interface. They enforce the type safety of the data flows, connect to all the runtimes and orchestrate the execution of incoming requests.  ","version":"Next","tagName":"h2"},{"title":"Request lifecycle‚Äã","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#request-lifecycle","content":" When a new request fires a trigger, the typegate orchestrates the following stages:  extract the secure request context from custom authentication or JSON Web Token (JWT)retrieve cached execution plan or compute a new one traverse the typegraph to create a DAG of the required typesoptimize the DAG to reduce the number of calls to the runtimespre-compute all structural elements and data resolutions execute the plan type check the argumentsverify lazily policies on the needrun the DAG executionenforce the rate-limitingtype check the response manage metadata of the request  ","version":"Next","tagName":"h2"},{"title":"HTTP/GraphQL interface‚Äã","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#httpgraphql-interface","content":" For now, the typegate nodes are only accessible through HTTP/1.1 and HTTP/2. More protocols could be supported in the future. Typegates expose a GraphQL interface which is the result of a typegraph projected onto corresponding GraphQL types. While this reduces the type safety of the data flowing, it makes more interoperable thanks to the many high-quality and well-known GraphQL tooling already available. The underlying types are also exposed in order for API clients to verify the underlying types.  GraphQL, being a query language, offers a great asset for Metatype's philosophy:  Efficient querying: the client can specify exactly what data it needs, reducing the amount of over- or under-fetchingFlexibility: allows for retrieving multiple resources in a single request, unlike REST, which often requires multiple onesTyping: GraphQL has a built-in type system that allows for better documentation and stronger validation of the requestsImproved tooling: tools and libraries around GraphQL are rapidly growing and great a development experience ","version":"Next","tagName":"h2"},{"title":"Rate limiting","type":0,"sectionRef":"#","url":"/docs/reference/typegate/rate-limiting","content":"Rate limiting The rate limiting algorithm works as follows: each function type can either count the # of calls it gets or the # of results returned rate_calls=Falseeach function type can have a weight rate_weight=1each request is identified by its IP or by one value of its context if set context_identifiera single query can score a maximum of query_limitmultiple queries can sum up to window_limit in a window_sec windowwhen there is multiple typegates (N), you can improve performance by avoiding score synchronizing while the typegate has not reached local_excess: the real maximum score is thus window_limit + min(local_excess, query_limit) * N Loading... Playing with the above should allow you to quickly hit the limits.","keywords":"","version":"Next"},{"title":"Specifications","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/specifications","content":"","keywords":"","version":"Next"},{"title":"Notations‚Äã","type":1,"pageTitle":"Specifications","url":"/docs/reference/typegraph/specifications#notations","content":" t.int() ‚Üí int t.int(as_id=true) ‚Üí int(as_id=true) t.int(...) ‚Üí int(¬∑) t.list(t.int()) ‚Üí [int] t.optional(t.int()) ‚Üí ?int t.either([t.int(), t.float()]) ‚Üí int ‚äï float ‚Üí either int float t.union([t.int(), t.float()]) ‚Üí int | float ‚Üí union int float t.int().compose(t.float()) ‚Üí int &amp; float ‚Üí compose int float t.struct({&quot;a&quot;: t.int(), &quot;b&quot;: t.float()}) ‚Üí struct a: int b: float  ","version":"Next","tagName":"h2"},{"title":"Typegraph","type":0,"sectionRef":"#","url":"/docs/reference/typegraph","content":"","keywords":"","version":"Next"},{"title":"Python‚Äã","type":1,"pageTitle":"Typegraph","url":"/docs/reference/typegraph#python","content":"   Typescript SDKPython SDK Install the @typegraph/sdk package from npm using your preferred package manager and runtime. The SDK requires Node 16+ with Typescript 4.7+, Deno 1.28+ or Bun 1+. # using pnpm pnpm add @typegraph/sdk # using npm npm install @typegraph/sdk # using yarn yarn add @typegraph/sdk # using Deno import { ... } from &quot;npm:@typegraph/sdk/mod.ts&quot;; # using Bun bun add @typegraph/sdk   When using Node, make sure to add this to your Typescript configuration:   &quot;moduleResolution&quot;: &quot;node16&quot;, // Or &quot;nodenext&quot;  ","version":"Next","tagName":"h2"},{"title":"Prisma","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/prisma","content":"","keywords":"","version":"Next"},{"title":"Prisma runtime‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#prisma-runtime","content":" Prisma is a &quot;Next-generation Node.js and Typescript ORM&quot; supporting PostgreSQL, MySQL/MariaDB, SQLite, MongoDB, CockroachDB and Microsoft SQL Server. It is one of the main runtimes provided by Metatype and doesn't require any additional installation.  Go ahead and update typegraph.py with the highlighted lines below:  Loading...  A few things to note on the changes:  You can import runtimes from typegraph.runtime.Y or typegraph.providers.X.runtimes.Y for non-core providers.The config method allows specifying runtime specific attributes. In this case, id shall be automatically set and incremented by the database.Types get generated names unless you manually specify them. You can find the exact names in the playground documentation. Here you want to have a human friendly name as it will also be the name of the table in your database.Runtimes often come with some sugar syntax to generate types and avoid manipulating materializers directly. A corresponding declaration would have looked like this:     In order to use the Prisma runtime, you need to add a new environment variable. Runtimes don't take raw secrets, but instead a secret key used to look up environment variables named under the format TG_[typegraph name]_[key]. You can either add it in your metatype.yml (recommended) or in your compose.yml.  $ cat metatype.yml typegates: dev: # .. env: TG_DATABASE_POSTGRES_CONN: postgresql://postgres:password@postgres:5432/db $ meta dev   And now, you can iteratively continue to improve your interface, running migrations and having data stored inside your database.  ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#usage","content":" with TypeGraph(&quot;prisma-runtime-example&quot;) as g: db = PrismaRuntime(&quot;main_db&quot;, &quot;DB_CONNECTION&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email(), } ) g.expose( createUser=db.create(user).add_policy(public) )   ","version":"Next","tagName":"h2"},{"title":"Raw query‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#raw-query","content":" Generate a raw SQL query operation on the runtime  db = PrismaRuntime(&quot;my-app&quot;, &quot;POSTGRES&quot;) g.expose( countUsers=db.raw_query( &quot;SELECT COUNT(*) as total FROM User&quot;, t.struct({}), t.list(t.struct({&quot;total&quot;: t.integer()})) ) )   Generate a raw SQL query operation without return  db = PrismaRuntime(&quot;my-app&quot;, &quot;POSTGRES&quot;) g.expose( setActive=db.raw_execute( &quot;UPDATE User SET active = TRUE WHERE id=${id}&quot;, t.struct({&quot;id&quot;: t.uuid()}), effect=effects.update() ), )   ","version":"Next","tagName":"h3"},{"title":"Models‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#models","content":" Any t.struct that is passed to a generator of a PrismaRuntimedefines a model. Models must have an ID field specified by the &quot;id&quot; config.  Here is the list of all the available configs for model fields:  Config\tEffectid\tdefines the field ID for the model (a.k.a. primary key) auto\tthe value of this field can be auto generated; supported for t.integer() (auto-increment) and t.uuid() unique\tmake this field unique among all instances of the model  ","version":"Next","tagName":"h2"},{"title":"Relationships‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#relationships","content":" Relationship fields must be defined on both sides of the relationship. A relationship is always defined for t.struct types and t.optional ort.list of t.struct.  Relationships can also be defined implicitly using the link instance method of PrismaRuntime.  runtime = PrismaRuntime(&quot;example&quot;, &quot;POSTGRES&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email().config(&quot;unique&quot;), &quot;posts&quot;: t.list(g(&quot;Post&quot;)), } ).named(&quot;User&quot;) post = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;title&quot;: t.string(), &quot;author&quot;: g(&quot;User&quot;), } ).named(&quot;Post&quot;)   The PrismaRuntime supports two kinds of relationship between models.  ","version":"Next","tagName":"h2"},{"title":"One-to-one relationships‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#one-to-one-relationships","content":" A one-to-one relationship must be in one of these two variants.  Cardinality\tField type in Model1\tField type in Model21..1 ‚Üî 0..1\tg(&quot;Model2&quot;)\tg(&quot;Model1&quot;).optional() 0..1 ‚Üî 0..1\tg(&quot;Model2&quot;).optional()\tg(&quot;Model1&quot;).optional()  For the optional (0..1 ‚Üî 0..1) one-to-one relationship, you need to indicate on which field/model the foreign key will be by:  wrapping the type in a runtime.link(.) with fkey=True:runtime.link(g(&quot;Model2&quot;).optional(), fkey=True); or adding .config(&quot;unique&quot;): g(&quot;Model2&quot;).optional().config(&quot;unique&quot;).  ","version":"Next","tagName":"h3"},{"title":"One-to-many relationships‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#one-to-many-relationships","content":" A one-to-many relationship must be in one of these two variants.  Cardinality\tField type in Model1\tField type in Model21..1 ‚Üî 0..n\tg(&quot;Model2&quot;)\tt.list(g(&quot;Model1&quot;)) 0..1 ‚Üî 0..n\tg(&quot;Model2&quot;).optional()\tt.list(g(&quot;Model1&quot;))  ","version":"Next","tagName":"h3"},{"title":"Many-to-many relationships‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#many-to-many-relationships","content":" Many-to-many relationships must be modelled explicitly using a join model.  ","version":"Next","tagName":"h3"},{"title":"Link‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#link","content":" Explicitly declare a relationship between models. The return value of this function shall be the type of a property of a t.struct that defines a model. If the other end of the relationship is also defined using link, both links must have the same name.  runtime = PrismaRuntime(&quot;example&quot;, &quot;POSTGRES&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email().config(&quot;unique&quot;), &quot;posts&quot;: runtime.link(t.list(g(&quot;Post&quot;)), &quot;postAuthor&quot;), } ).named(&quot;User&quot;) post = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;title&quot;: t.string(), &quot;author&quot;: runtime.link(g(&quot;User&quot;), &quot;postAuthor&quot;), } ).named(&quot;Post&quot;)   ","version":"Next","tagName":"h3"},{"title":"Generators‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#generators","content":" Generators are instance methods of PrismaRuntime that can be used to generate a t.func that represents a specific operation on a specific model of the runtime. They match to the model queries defined for theprisma client API. for the type of the input t.struct and the return type.  Example:  with TypeGraph(&quot;prisma-runtime-example&quot;) as g: db = PrismaRuntime(&quot;main_db&quot;, &quot;DB_CONNECTION&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email(), } ) g.expose( createUser=db.create(user).add_policy(public), findUser=db.find(user).add_policy(public), findManyUsers=db.find_many(user).add_policy(public), )   Here is a list of all available generators:  find_uniquefind_firstfind_manycreateupdateupsertdeletedelete_many ","version":"Next","tagName":"h2"},{"title":"Authentication","type":0,"sectionRef":"#","url":"/docs/reference/typegate/authentication","content":"","keywords":"","version":"Next"},{"title":"Basic authentication‚Äã","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#basic-authentication","content":" Basic authentication is the simplest way to authenticate requests. It is done by sending a base64 encoded string of your username and password in the authorization header. Recall that base64 encoding is not encryption and can be easily reversed, thus the traffic must be encrypted with SSL/TLS when using basic authentication as your password will otherwise be visible.  Components\tValuesSecrets\tTG_[typegraph]_BASIC_[username]=password Header\tAuthorization: Basic base64(username:password) Context\t{ username }  Loading...  ","version":"Next","tagName":"h2"},{"title":"JWT authentication‚Äã","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#jwt-authentication","content":" A more secure way to authenticate requests is to use JSON Web Tokens. The context of a user is signed with a secret key and the typegate will verify the signature to ensure the context has not been tampered with. The JWT is then sent in the authorization header.  The JWT is usually generated by an external identity provider (IdP) such as Keycloak or Auth0 and limited in time. The typegate will check that the exp (expiration time) and nbf (not before) are valid if they exist in the context. The logic of refreshing expired tokens is left to the user or the IdP client library being used.  The typegate supports the most frequently used algorithms for signing the JWT and can be imported as using &quot;jwk&quot;, &quot;raw&quot;, &quot;pkcs8&quot; or &quot;spki&quot; formats (see SubtleCrypto documentation). For instance, an asymmetric key pair can be generated with the following command:  const keys = await crypto.subtle.generateKey( { name: &quot;ECDSA&quot;, namedCurve: &quot;P-384&quot; }, true, [&quot;sign&quot;, &quot;verify&quot;] ); const publicKey = await crypto.subtle.exportKey(&quot;jwk&quot;, keys.publicKey); // save keys.privateKey for later use console.log(JSON.stringify(publicKey)); // in typegraph: Auth.jwt(&quot;keycloak&quot;, &quot;jwk&quot;, {&quot;name&quot;: &quot;ECDSA&quot;, &quot;namedCurve&quot;: &quot;P-384&quot;})   Even though, asymmetric encryption is recommended, HMAC-SHA256 is so commonly used that an alias is provided for it.  Components\tValuesSecrets\tTG_[typegraph]_[authentication]_JWT=secret Header\tAuthorization: Bearer token Context\t{ your_own_content }  Loading...  Note that for the sake of the demo, the token has no expiration time. Tokens should always be shorted lived and refreshed frequently to reduce the risk of unexpected access.  ","version":"Next","tagName":"h2"},{"title":"OAuth2 authorization‚Äã","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#oauth2-authorization","content":" OAuth2 allows a user to grant limited access to their resources on one site, to another site, without having to expose their credentials. It is commonly used when the typegate needed to access restricted information in third-parties such as Google or GitHub.  Most of the time, the OAuth2 is managed by your identity provider and relies on the JWT authentication as explained above. However the typegate provides a simple way to handle the OAuth2 flow without IdP or when the system should be lightweight.  Components\tValuesSecrets\tTG_[typegraph]_[authentication]_CLIENT_ID=client_id, TG_[typegraph]_[authentication]_CLIENT_SECRET=client_secret Header\tAuthorization: Bearer token Context\t{ content_from_your_idp }  ","version":"Next","tagName":"h2"},{"title":"Take flow‚Äã","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#take-flow","content":" Redirect the user to https://[typegate].metatype.cloud/[typegraph]/auth/[authentication]?redirect_uri=https://your-website.com/login and the OAuth2 starts for the user When the user has completed the flow, the typegate will redirect the user to https://your-website.com/login and you can &quot;take&quot; the token from the typegate as follows. This can be only done once and is limited in time:  const take = await fetch( &quot;https://[typegate].metatype.cloud/[typegraph]/auth/take&quot;, { credentials: &quot;include&quot;, } ); const { token } = await take.json();   The token can then be used as JWT in the Authorization header of your requests, and the response of the typegate will contain a header Next-Authorization. When this header is present, the value should be used in follow-up calls (value will be empty if the authentication has expired).    Loading...  ","version":"Next","tagName":"h3"},{"title":"OpenID Connect‚Äã","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#openid-connect","content":" OpenID Connect is an authentication layer on top of OAuth2. It is used to verify the identity of the user and retrieve basic information about them. You can add openid to the OAuth2 scope and you will receive an id_token in the response. The id_token is a JWT that contains the user's information and is signed by the IdP.  ","version":"Next","tagName":"h3"},{"title":"Embedded providers‚Äã","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#embedded-providers","content":" Frequent OAuth2 providers are embedded and can be directly used in the typegraph.  from typegraph.graph.auth import oauth2 oauth2.github(&quot;openid profile email&quot;)   The whole list is available here. ","version":"Next","tagName":"h3"},{"title":"Importers","type":0,"sectionRef":"#","url":"/docs/reference/types/importers","content":"","keywords":"","version":"Next"},{"title":"Google importers‚Äã","type":1,"pageTitle":"Importers","url":"/docs/reference/types/importers#google-importers","content":" The typegraph module comes with some handy importers to avoid having to rewrite manually all types and materializers. Currently, it supports importers for OpenAPI, GraphQL API and Google APIs.  Importers are function call with a boolean re-writing the source code file where they live. As they can generate quite long type definition, the best practice is to separate them into a dedicated file that can be imported into your main typegraph. Let's create google.py and run python google.py to generate the types.  This should generate code similar to this:  And can be imported/customized in your main typegraph file: ","version":"Next","tagName":"h2"},{"title":"Reducers","type":0,"sectionRef":"#","url":"/docs/reference/types/reducers","content":"Reducers","keywords":"","version":"Next"},{"title":"Functions","type":0,"sectionRef":"#","url":"/docs/reference/types/functions","content":"","keywords":"","version":"Next"},{"title":"Effects‚Äã","type":1,"pageTitle":"Functions","url":"/docs/reference/types/functions#effects","content":" Effects are a property of materializers and help categorization what happens to data when it gets transformed. Although they are similar to REST verbs and SQL statements, there is no direct one-to-one mapping.  Effects\tREST verbs\tSQL statementsnone\tGET\tSELECT create\tPOST\tINSERT update\tPUT/PATCH\tUPDATE upsert\tPUT\tINSERT ON CONFLICT delete\tDELETE\tDELETE  They provide hints to the typegates for the query orchestration by splitting the queries and mutations. For example, the create effect is exposed as a mutation. They also allow setting different policies based on them, that's for the next page. ","version":"Next","tagName":"h2"},{"title":"Import your existing APIs","type":0,"sectionRef":"#","url":"/docs/tutorials/import-your-existing-apis","content":"","keywords":"","version":"Next"},{"title":"Google importers‚Äã","type":1,"pageTitle":"Import your existing APIs","url":"/docs/tutorials/import-your-existing-apis#google-importers","content":" The typegraph module comes with some handy importers to avoid having to rewrite manually all types and materializers. Currently, it supports importers for OpenAPI, GraphQL API and Google APIs.  Beta/unstable feature Importers are quite recent and likely to evolve as feedback is received. Your voice and use cases matter a lot, let Metatype community know what suits you the best in this discussion.  Importers are function call with a boolean re-writing the source code file where they live. As they can generate quite long type definition, the best practice is to separate them into a dedicated file that can be imported into your main typegraph. Let's create google.py and run python google.py to generate the types.  This should generate code similar to this:  And can be imported/customized in your main typegraph file:  ","version":"Next","tagName":"h2"},{"title":"Effects‚Äã","type":1,"pageTitle":"Import your existing APIs","url":"/docs/tutorials/import-your-existing-apis#effects","content":" Effects are a property of materializers and help categorization what happens to data when it gets transformed. Although they are similar to REST verbs and SQL statements, there is no direct one-to-one mapping.  Effects\tREST verbs\tSQL statementsnone\tGET\tSELECT create\tPOST\tINSERT update\tPUT/PATCH\tUPDATE upsert\tPUT\tINSERT ON CONFLICT delete\tDELETE\tDELETE  They provide hints to the typegates for the query orchestration by splitting the queries and mutations. For example, the create effect is exposed as a mutation. They also allow setting different policies based on them, that's for the next page.  ","version":"Next","tagName":"h2"},{"title":"Introduction to typegraph_std‚Äã","type":1,"pageTitle":"Import your existing APIs","url":"/docs/tutorials/import-your-existing-apis#introduction-to-typegraph_std","content":" Alternatively, you can use the typegraph_std for the most common APIs. It comes as a separate package so instead of maintening your own importers, you can use typegraph_std.  The package currently includes:  Google APIs (fcm, firebase, youtube, etc.)StripeGithub  As you can see, it works pretty much the same way as importers. ","version":"Next","tagName":"h2"},{"title":"Injections","type":0,"sectionRef":"#","url":"/docs/reference/types/injections","content":"","keywords":"","version":"Next"},{"title":"Raw‚Äã","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#raw","content":" ","version":"Next","tagName":"h2"},{"title":"Parent‚Äã","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#parent","content":" caution Only supported for scalars type inside a struct.  ","version":"Next","tagName":"h2"},{"title":"Context‚Äã","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#context","content":" ","version":"Next","tagName":"h2"},{"title":"Secret‚Äã","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#secret","content":"","version":"Next","tagName":"h2"},{"title":"Types","type":0,"sectionRef":"#","url":"/docs/reference/types","content":"","keywords":"","version":"Next"},{"title":"Overview‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#overview","content":" Types are used to describe the data to be processed. They constrains the range of value that can be accepted as input data or expected as result on each computation running in a runtime.  ","version":"Next","tagName":"h2"},{"title":"Scalar types‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#scalar-types","content":" Type\tGraphQL type\tDescriptiont.integer()\tInt\tRepresents signed 32-bit integers. t.number()\tFloat\tRepresents signed double-precision values as specified by IEEE 754. t.float()\tFloat\tAlias to t.number(). t.boolean()\tBoolean\tRepresents true or false. t.string()\tString\tRepresents textual data as UTF-8 character sequences. t.file()\t‚Äî\tRepresents a file for upload.  The following scalar types are aliases to a t.string() type with a specific format.  t.uuid()t.json()t.email()t.uri()t.hostname()t.ean()t.phone()t.date()t.datetime()  ","version":"Next","tagName":"h3"},{"title":"Non-scalar types‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#non-scalar-types","content":" Type\tGraphQL type\tDescriptiont.optional()\tnullable\tRepresents a value that may be null. t.list()\tlist\tRepresents a list of values. t.struct()\tinterface\tRepresents a structured data value, consisting of fields which map to typed values. t.union()\tunion\tRepresents a value which can be one of a set of specified types. t.either()\tunion\tRepresents a value which can match one and only one of a set of specified types. t.func\t‚Äî\tRepresents an operation that has to be performed on the typegate.  ","version":"Next","tagName":"h3"},{"title":"Type constraints‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#type-constraints","content":" Type constraints define an additional narrowing of the range of values that can be accepted for the type.  Example:The min constraint on the type t.integer()  from typegraph import t # represents integers greater than or equal to `12` t.integer().min(12)   ","version":"Next","tagName":"h3"},{"title":"Names and type references‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#names-and-type-references","content":" ","version":"Next","tagName":"h3"},{"title":"Injection‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#injection","content":" ","version":"Next","tagName":"h3"},{"title":"Types‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#types-1","content":" ","version":"Next","tagName":"h2"},{"title":"t.boolean()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tboolean","content":" from typegraph import t t.boolean()   The t.boolean() type represents boolean values, true or false.  ","version":"Next","tagName":"h3"},{"title":"t.integer()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tinteger","content":" The t.integer() type represents 32-bit integers.  from typegraph import t t.integer()   Constraints‚Äã  Constraint\tDescriptionmin\tThe minimum value of the integer. max\tThe maximum value of the integer. x_min\tThe minimum value of the integer, exclusive. x_max\tThe maximum value of the integer, exclusive. multiple_of\tThe integer must be a multiple of this value.  Examples‚Äã  from typegraph import t # non-negative integer t.integer().min(0) # an integer in the rage [18, 120) adult_age = t.integer().min(18).x_max(120) # an even integer t.integer().multiple_of(2)   ","version":"Next","tagName":"h3"},{"title":"t.number()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tnumber","content":" from typegraph import t t.number()   The t.number() type represents numbers, stored in double precision floating-point format (IEEE 754).  Constraints‚Äã  The t.number() type has the same constraints as t.integer(). See integer constraints.  Aliases‚Äã  The following types are aliases to the t.number() type:  t.float()  ","version":"Next","tagName":"h3"},{"title":"t.string()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tstring","content":" from typegraph import t t.string()   The t.string() type represents textual data represented as UTF-8 character sequences.  Constraints‚Äã  Constraint\tType\tDescriptionmin\tInteger\tMinimum length of the string. max\tInteger\tMaximum length of the string. pattern\tString\tRegular expression pattern that the string must match. format\tString\tJSON schema format that the string must match. See below for the list of supported formats.  Supported formats‚Äã  Here is the list of supported formats:  uuidjsonemailurihostnameeanphonedatedate-time  Examples‚Äã  from typegraph import t # a non-empty string of maximum 64 characters t.string().min(1).max(64) # a email address t.string().format(&quot;email&quot;) # a json data t.string().format(&quot;json&quot;)   Aliases‚Äã  Alias\tEquivalent declarationt.uuid()\tt.string().format(&quot;uuid&quot;) t.email()\tt.string().format(&quot;email&quot;) t.uri()\tt.string().format(&quot;uri&quot;) t.json\tt.string().format(&quot;json&quot;) t.ean()\tt.string().format(&quot;ean&quot;) t.phone()\tt.string().format(&quot;phone&quot;) t.date()\tt.string().format(&quot;date&quot;) t.datetime()\tt.string().format(&quot;date-time&quot;)  ","version":"Next","tagName":"h3"},{"title":"t.file()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tfile","content":" from typegraph import t t.file()   The t.file() represents files for upload.  Type Constraints‚Äã  Constraint\tType\tDescriptionmin\tInteger\tMinimum size of the file in bytes. max\tInteger\tMaximum size of the file in bytes. allow\tArray of strings\tList of allowed content-types  Examples‚Äã  from typegraph import t # A file of a minimum size of 1KB t.file().min(1024) # A JPEG or PNG file less than 2KB t.file().max(2048).allow([&quot;image/jpeg&quot;, &quot;image/png&quot;])   ","version":"Next","tagName":"h3"},{"title":"t.optional()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#toptional","content":" from typegraph import t t.optional(t.string()) t.string().optional() # equivalent syntactic sugar   Default value‚Äã  If the type is used as an input type, the default value can be specified using the .default() method.  from typegraph import t t.string().optional().default(&quot;default value&quot;)   ","version":"Next","tagName":"h3"},{"title":"t.list()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tlist","content":" from typegraph import t t.list(t.string())   The t.list() type represents a sequence of values of the same type.  Constraints‚Äã  Constraint\tType\tDescriptionmin\tInteger\tMinimum number of items. max\tInteger\tMaximum number of items. unique_items\tBoolean\tWhether the items must be unique.  Examples‚Äã  from typegraph import t # A list of strings t.list(t.string()) # A list of unique strings t.list(t.string()).unique_items() # A list of strings with at least 3 items # and at most 10 items t.list(t.string()).min(3).max(10)   ","version":"Next","tagName":"h3"},{"title":"t.struct()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tstruct","content":" from typegraph import t user = t.struct({ &quot;id&quot;: t.uuid().as_id, &quot;email&quot;: t.email(), &quot;username&quot;: t.string().min(3).max(64), })   The t.struct() type represents structured data, consisting of fields which map to typed values.  All the fields are required unless the corresponding type is wrapped int.optional(). In that case, the field is allowed to be missing from the data or be null.  Constraints‚Äã  Constraint\tType\tDescriptionmin\tInteger\tMinimum number of fields. max\tInteger\tMaximum number of fields.  Examples‚Äã  from typegraph import t # A user profile user = t.struct({ &quot;id&quot;: t.uuid().as_id, &quot;email&quot;: t.email(), &quot;username&quot;: t.string().min(3).max(64), }) # A user profile with an optional `name` field user = t.struct({ &quot;id&quot;: t.uuid().as_id, &quot;email&quot;: t.email(), &quot;username&quot;: t.string().min(3).max(64), &quot;name&quot;: t.optional(t.string().min(3).max(64)), })   ","version":"Next","tagName":"h3"},{"title":"t.union() and t.either()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tunion-and-teither","content":" from typegraph import t t.union([t.string(), t.integer()]) t.either([t.string(), t.integer()])   The t.union type represents a value that can be of any of the specified types. The t.either type represents a value that must be of one and only one of the specified types.  ","version":"Next","tagName":"h3"},{"title":"t.func()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tfunc","content":" The t.func() type represents an operation to be performed on the typegate with the specified materializer.  Usually, the functions are not defined explicitly, but rather created with the runtime instance.  Parameters‚Äã  Parameter\tType\tDescriptioninput type\tt.struct()\tThe type of the input data. output type\tany type\tThe type of the output data. materializer\tMaterializer\tThe materializer to use to perform the operation/computation.  Examples‚Äã  from typegraph import t from typegraph.runtimes.deno import FunMat from typegraph.providers.prisma.runtimes import PrismaRuntime with TypeGraph(&quot;math&quot;) as g: add = t.func( t.struct({ &quot;a&quot;: t.integer(), &quot;b&quot;: t.integer(), }), t.integer(), FunMat(&quot;(({a, b}) =&gt; a + b&quot;) ) g.expose(add=add) db = PrismaRuntime(&quot;main-db&quot;, &quot;POSTGRES&quot;) user = t.struct({ &quot;id&quot;: t.uuid().as_id, &quot;email&quot;: t.email(), &quot;username&quot;: t.string().min(3).max(64), }) g.expose(createUser=db.create(user))  ","version":"Next","tagName":"h3"},{"title":"Instant APIs on your database","type":0,"sectionRef":"#","url":"/use-cases/automatic-crud-validation","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"Instant APIs on your database","url":"/use-cases/automatic-crud-validation#case-study","content":"   Let's say you are developing a web application for a retail store that allows customers to place orders online. In this scenario, you would need to use CRUD operations to create, read, update, and delete data related to orders, customers, products, and inventory.  You would have to model each of these entities as a data type, define the operations that can be performed on them and write the code to ensure the correctness of the data processed in the operations.  For example, you would need to define a Customer type with the following fields: id, name, email, and address. You would also need to define the operations that can be performed on the Customer type, such as createCustomer, updateCustomer, and deleteCustomer. You would also need to write the code to validate the data in the createCustomer operation to ensure that the customer's email address is valid and that the customer's address is not empty. Same for the other fields.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"Instant APIs on your database","url":"/use-cases/automatic-crud-validation#metatypes-solution","content":" Metatype simplifies the development of CRUD APIs by providing the Prisma runtime that automates the creation of the API for CRUD operations and corresponding data validation in PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB. It can even validate some advanced types like email which may not be supported by downstream system (databases often store email address into plain string instead of a specialized field). This makes it faster for developers to create scalable CRUD APIs and enable them to focus their expertise where it matters most like checkout or the search capabilities.  Loading... ","version":"Next","tagName":"h2"},{"title":"Quick start","type":0,"sectionRef":"#","url":"/docs/tutorials/quick-start","content":"","keywords":"","version":"Next"},{"title":"1. Meta CLI‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#1-meta-cli","content":" info Metatype is only supported on macOS and Linux. Windows users should use Linux on Windows with WSL.  You can download the binary from thereleases page, make it executable and add it to your PATH or use the automated method below.  # the installer may ask for your password curl -fsSL https://raw.githubusercontent.com/metatypedev/metatype/main/installer.sh | bash # (for later) upgrade to a newer version meta upgrade   ","version":"Next","tagName":"h2"},{"title":"2. Typegraph SDK‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#2-typegraph-sdk","content":" Typescript SDKPython SDK Install the @typegraph/sdk package from npm using your preferred package manager and runtime. The SDK requires Node 16+ with Typescript 4.7+, Deno 1.28+ or Bun 1+. # using pnpm pnpm add @typegraph/sdk # using npm npm install @typegraph/sdk # using yarn yarn add @typegraph/sdk # using Deno import { ... } from &quot;npm:@typegraph/sdk/mod.ts&quot;; # using Bun bun add @typegraph/sdk   When using Node, make sure to add this to your Typescript configuration:   &quot;moduleResolution&quot;: &quot;node16&quot;, // Or &quot;nodenext&quot;   ","version":"Next","tagName":"h2"},{"title":"3. Typegate node‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#3-typegate-node","content":" ","version":"Next","tagName":"h2"},{"title":"With Metatype Cloud‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#with-metatype-cloud","content":" This is the easiest way to get started, yet it's not publicly accessible. You can sign up for the private beta below.    ","version":"Next","tagName":"h3"},{"title":"With Docker‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#with-docker","content":" Install Docker and use the following compose.yml to launch a typegate node. Redis is the single required dependency, however in practice you will want to add database or other systems that the typegate can connect to.  services: typegate: image: ghcr.io/metatypedev/typegate:latest ports: - &quot;7890:7890&quot; extra_hosts: - &quot;host.docker.internal:host-gateway&quot; environment: # only for dev, generate secure values for production TG_SECRET: &quot;a4lNi0PbEItlFZbus1oeH/+wyIxi9uH6TpL8AIqIaMBNvp7SESmuUBbfUwC0prxhGhZqHw8vMDYZAGMhSZ4fLw==&quot; TG_ADMIN_PASSWORD: password REDIS_URL: redis://:password@redis:6379/0 DEBUG: &quot;true&quot; depends_on: - redis redis: image: redis:7 restart: always command: --requirepass password   # launch the containers docker compose up --detach # watch the typegate logs docker compose logs typegate --follow   ","version":"Next","tagName":"h3"},{"title":"4. Verify your installation‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#4-verify-your-installation","content":" The doctor subcommand will attempt to detect all the components and report any potential issue. Please make sure to run it before opening an issue and include the output in your report.  meta doctor  ","version":"Next","tagName":"h2"},{"title":"Cloud function runner","type":0,"sectionRef":"#","url":"/use-cases/faas-runner","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"Cloud function runner","url":"/use-cases/faas-runner#case-study","content":"   For example, imagine you have an e-commerce application that uses FaaS to process orders. When a customer places an order, multiple functions may need to be executed, such as validating the order, processing the payment, and updating the inventory.  Each function may be executed independently by the FaaS platform and may take varying amounts of time to complete. Those functions may also be executed for historical reason on different platforms like AWS Lambda, Google Cloud Functions, or Azure Functions.  To collect the results of all the functions in a timely manner, you need to ensure that each function is executed in the correct order and that you are not waiting for a slow function to complete before moving on to the next function.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"Cloud function runner","url":"/use-cases/faas-runner#metatypes-solution","content":" To solve the use case of executing multiple functions and collecting their results, Metatype provides two key features.  Function composition/chaining: functions can be chained together to form a pipeline. The output of one function can be used as the input of the next function in the pipeline. This allows us to execute multiple functions in a specific order. Embedded runner: you can easily write a function that glues together multiple functions and executes them in a specific order. This allows you to execute multiple functions in a specific order. Currently, both Python and Typescript are supported.  Loading... ","version":"Next","tagName":"h2"},{"title":"Metatype basics","type":0,"sectionRef":"#","url":"/docs/tutorials/metatype-basics","content":"","keywords":"","version":"Next"},{"title":"Zooming on the types‚Äã","type":1,"pageTitle":"Metatype basics","url":"/docs/tutorials/metatype-basics#zooming-on-the-types","content":" There is no &quot;object&quot; or &quot;primitive&quot; type, only 4 main categories of types:  value types: t.integer(), t.string(), t.uuid(), etc.quantifier types: t.optional(¬∑), t.list(¬∑), etc.consolidator types: t.struct(¬∑, ¬∑), t.union(¬∑, ¬∑), etc.function types: t.func(¬∑ ‚Üí ¬∑), t.policy(¬∑ ‚Üí ¬∑), etc.  You can combine them with each other to describe almost any data type you may need. The typegate enforces the data validation when data flows through it. Some syntactic sugar is available to make the type definition shorter:  t.struct( { &quot;name&quot;: t.string(max=200), &quot;age&quot;: t.optional( t.integer() ), # or t.integer().optional() &quot;messages&quot;: t.list( t.struct({&quot;text&quot;: t.string(), &quot;sentAt&quot;: t.datetime()}) ), } ) # the typegate will accept data as follow { &quot;name&quot;: &quot;Alan&quot;, &quot;age&quot;: 28, &quot;messages&quot;: [ {&quot;text&quot;: &quot;Hello!&quot;, &quot;sentAt&quot;: &quot;2022-12-28T01:11:10Z&quot;} ], } # and reject invalid data {&quot;name&quot;: &quot;Turing&quot;, &quot;messages&quot;: [{&quot;sentAt&quot;: 1}]}   ","version":"Next","tagName":"h2"},{"title":"The typegraph package‚Äã","type":1,"pageTitle":"Metatype basics","url":"/docs/tutorials/metatype-basics#the-typegraph-package","content":" The typegraph package is a Python package that allows to describe a full typegraph. It's a thin wrapper around the type system, and provides a few helpers to make the typegraph definition easier. It builds on the type system to provide some more building blocks:  what data types exists ‚Üí value, quantifier, consolidator typeshow these data get transformed ‚Üí function types and materializers that specify the transformationwhere these data and transformations run ‚Üí runtimes that describe materializers operatewho can access them ‚Üí a special case of function types named policies that control accesses  This tutorial will cover these abstractions concept by concept and show how to use them by example.  Code sample are interactive You can interact with most of the typegraph in the documentation. Press command/ctrl + enter to submit the selected query or use the &quot;play&quot; button. Some parts might be voluntarily hidden and full source can be found by clicking on the link.  A complete typegraph definition may look like the following:  Loading...  To start with the chat app design, copy the typegraph into the file named example.py next to your compose.yml file.  ","version":"Next","tagName":"h2"},{"title":"The meta CLI‚Äã","type":1,"pageTitle":"Metatype basics","url":"/docs/tutorials/metatype-basics#the-meta-cli","content":" The meta CLI use a YAML configuration file to source some information and avoid typing the same arguments over and over again. Copy the following into named metatype.yml also next to previous files:  typegates: dev: url: &quot;http://localhost:7890&quot; # default values username: admin password: password typegraphs: python: include: &quot;**/*.py&quot;   At this point, you should have everything ready for your first typegraph. Run the following command in your terminal:  $ ls -1a ./ ../ .venv/ api/ compose.yml metatype.yml pyproject.toml $ ls -1a api ./ ../ example.py $ meta dev Loaded 1 typegraph from ./api/example.py: ‚Üí Pushing typegraph first-typegraph... ‚úì Success!   You can now open http://localhost:7890/first-typegraph in your browser. The CLI will automatically watch for changes in the typegraph and reload the typegraph. You should see a GraphQL playground with a query editor and some auto-generated documentation clicking the top-left menu item. Congrats, you can now to play with your first typegraph!   ","version":"Next","tagName":"h2"},{"title":"Backend for frontend","type":0,"sectionRef":"#","url":"/use-cases/backend-for-frontend","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"Backend for frontend","url":"/use-cases/backend-for-frontend#case-study","content":"   Imagine you have a web frontend and a mobile app that both consume data from a microservices-based backend. The web frontend requires certain data fields in a given format, and the mobile app requires the same additional fields in another format.  In a traditional architecture, both the web and mobile frontends would have to make separate API calls to the microservices, and then format the data into the appropriate structure themselves. This can lead to duplicated code, increased latency due heavier calls with non-necessary data, and decreased developer efficiency.  With a BFF in place, it handles the formatting of the data based on the specific needs of each client. All frontends can thus make a single API call to the BFF, which then communicates with the microservices, retrieves the data, and formats it into the required structure before returning it to the frontend.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"Backend for frontend","url":"/use-cases/backend-for-frontend#metatypes-solution","content":" Metatype can act as a generic BFF component, serving multiple dedicated APIs and handling security, authentication and authorization for you. By encapsulating the logic for communicating with the microservices, Metatype helps to ensure that the frontends are as decoupled as possible from the other services, making it easier to make changes to either the frontend or the backend without affecting the other side.  Loading... ","version":"Next","tagName":"h2"},{"title":"Microservices orchestration","type":0,"sectionRef":"#","url":"/use-cases/microservice-orchestration","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"Microservices orchestration","url":"/use-cases/microservice-orchestration#case-study","content":"   Let's say your company develop a healthcare platform and that one of the microservices is responsible for handling patient records (owned by team A), and another microservice is responsible for handling appointment scheduling (owned by team B).  When a patient schedules an appointment, the appointment scheduling microservice needs access to the patient's records to ensure that the appointment is scheduled with the right provider and that the provider has the necessary information to provide effective care. However, since patient records contain sensitive information, it is important to ensure that only authorized users have access to them.  To achieve this, the healthcare platform must use authentication and authorization on each API, which allows sharing only required information.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"Microservices orchestration","url":"/use-cases/microservice-orchestration#metatypes-solution","content":" Metatype can act as a central entry point for all incoming requests and responses between the microservices themselves and external clients. It is responsible for routing requests to the appropriate microservices and handling responses from those microservices, while verifying the authentication and authorization for each request.  Additionally, Metatype gateway can provide other important features such as rate limiting, caching, and request/response transformations. It can even provide an API from another typegraph and delegate the query processing to it.  Loading... ","version":"Next","tagName":"h2"},{"title":"Composable GraphQL server","type":0,"sectionRef":"#","url":"/use-cases/graphql-server","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"Composable GraphQL server","url":"/use-cases/graphql-server#case-study","content":"   Suppose you are building a subscription platform with a GraphQL API. You need to design a schema that accurately represents the available products, their attributes, and the operations that clients can perform, such as searching, filtering, and sorting.  You also need to optimize the performance of complex queries that involve joining multiple data sources, such as products, categories, and user preferences. Additionally, you need to implement caching and pagination to improve the performance and scalability of your API.  Finally, you need to ensure that your API is secure and implements appropriate authentication and authorization mechanisms to protect sensitive data and operations. Some challenges like the N+1 problem (when a single query results in multiple nested queries, each of which requires a separate database or API call) can also make the development of GraphQL resolver slow and complex to manage.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"Composable GraphQL server","url":"/use-cases/graphql-server#metatypes-solution","content":" Metatype's approach is to focus on schema design solely, and leave the GraphQL resolver implementation to the engine. By providing where the data is stored and how to access it, the queries are optimized by the engine to minimize the number of external API/database calls and to cache the results.  This can be seen as a declarative GraphQL servers, where the server is orchestrated everything for you. Metatype also comes with pre-built functionalities like authentication, authorization, and rate limiting.  Loading... ","version":"Next","tagName":"h2"},{"title":"IAM gateway","type":0,"sectionRef":"#","url":"/use-cases/iam-provider","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"IAM gateway","url":"/use-cases/iam-provider#case-study","content":"   Suppose a developer is building a social media platform that allows users to post updates and view other users' profiles. The developer wants to ensure that only authenticated users can access the platform's resources, and that each user can only access their own data.  To achieve this, the developer can use OAuth2 for user authentication and access control. OAuth2 allows users to log in using their Google or GitHub credentials, which are verified by Google or GitHub's IAM system. Once the user is authenticated, the social media platform can use OAuth2 to obtain an access token, which is used to authorize the user's access to the platform's resources.  The social media platform can also use IAM to control access to resources based on user roles and permissions. For example, only authenticated users can access the platform's resources, and each user can only access their own data.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"IAM gateway","url":"/use-cases/iam-provider#metatypes-solution","content":" Metatype comes with a built-in IAM gateway that can be used to manage user identities and their authorized privileges within a system. It supports any OpenID/OAuth2 providers and includes a list of pre-configured ones like Google, GitHub, Facebook, Twitter or LinkedIn. You can also use your own identity provider and rely on JSON Web Tokens (JWT) for authentication.  Once the user is authenticated, you can use policy access based control (PBAC) to control access to resources based on user identifies and permissions. For example, only authenticated users can access the platform's resources, and each user can only access their own data. Policies can be defined by any function, and run on or off Metatype.  Loading... ","version":"Next","tagName":"h2"},{"title":"ORM for the edge","type":0,"sectionRef":"#","url":"/use-cases/orm-for-the-edge","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"ORM for the edge","url":"/use-cases/orm-for-the-edge#case-study","content":"   Suppose you are building a mobile app that allows users to order food from local restaurants. To provide a low-latency user experience, you want to run your server-side logic as close as possible to your users.  You can deploy your functions across multiple locations on distributed edge servers. For database interactions, you may need a lightweight relay API to remains compatible with the platform and offer an efficient interface like an ORM provide.  When a user makes a request to view the menu or place an order, the corresponding function running on the edge will make a request to the lightweight relay API to retrieve or modify the relevant data in the database.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"ORM for the edge","url":"/use-cases/orm-for-the-edge#metatypes-solution","content":" Metatype can act out of the box as a lightweight relay API, simplifying database interactions via HTTP/GraphQL requests, and allowing you to query your database through the Prisma runtime. Prisma is a well-known ORM library that provides a convenient interface to interact with PostgreSQL, MySQL, SQLite, SQL Server, MongoDB, CockroachDB databases.  Loading... ","version":"Next","tagName":"h2"},{"title":"Programmable API gateway","type":0,"sectionRef":"#","url":"/use-cases/programmable-api-gateway","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"Programmable API gateway","url":"/use-cases/programmable-api-gateway#case-study","content":"   Suppose that your company needs to implement various policies and logic to manage and secure its APIs, such as rate limiting, caching, and request/response transformations.  To achieve this, the company can adopt a programmable API gateway that allows developers to create and deploy custom function to implement additional logic and policies for incoming requests and outgoing responses.  It also provides a platform for the company to manage its API infrastructure more efficiently and flexibly. Developers can leverage existing libraries and frameworks to quickly build and deploy custom logic, reducing the time and effort required to develop and maintain the API gateway.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"Programmable API gateway","url":"/use-cases/programmable-api-gateway#metatypes-solution","content":" Metatype provide a Python SDK for developers to create and deploy custom logic and policies, which can later be deployed to the gateway in a single command line. Importers can also be used to import existing API or logic definitions from other sources, such as OpenAPI, GraphQL, and gRPC.  This enables developer to quickly build and deploy any update the API or the business logic without having to worry about the underlying infrastructure.  Loading... ","version":"Next","tagName":"h2"},{"title":"Build a feature roadmap API","type":0,"sectionRef":"#","url":"/docs/tutorials/building-feature-roadmap-api","content":"","keywords":"","version":"Next"},{"title":"What are you building?‚Äã","type":1,"pageTitle":"Build a feature roadmap API","url":"/docs/tutorials/building-feature-roadmap-api#what-are-you-building","content":" For this tutorial, we'll be implementing an API to power a simple feature roadmap/request hybrid as can be seen on Productlane.  Looking through the app we can see tha the api should allow:  Unauthenticated users to submit new &quot;ideas&quot; or vote on any of those already listed. Specify or vote on the importance of an &quot;idea&quot; from &quot;medium&quot; to &quot;critical&quot; or even submit text with more description. Admins will be able to move ideas across buckets like &quot;Backlog&quot;, &quot;Planned&quot;, &quot;In Progress&quot;.  ","version":"Next","tagName":"h2"},{"title":"Setup‚Äã","type":1,"pageTitle":"Build a feature roadmap API","url":"/docs/tutorials/building-feature-roadmap-api#setup","content":" Before anything, we'll first need to install the tooling required for development and create a new project.  ","version":"Next","tagName":"h2"},{"title":"Install Meta CLI‚Äã","type":1,"pageTitle":"Build a feature roadmap API","url":"/docs/tutorials/building-feature-roadmap-api#install-meta-cli","content":" The meta-cli tool manages and helps you develop your metatype based projects. This include allowing you to run them locally for development, push them to production in the cloud, managing your database migrations and more.  info Metatype is only supported on macOS and Linux. Windows users should use Linux on Windows with WSL.  You can download the binary from thereleases page, make it executable and add it to your PATH or use the automated method below.  # the installer may ask for your password curl -fsSL https://raw.githubusercontent.com/metatypedev/metatype/main/installer.sh | bash # (for later) upgrade to a newer version meta upgrade   ","version":"Next","tagName":"h3"},{"title":"Create a new project‚Äã","type":1,"pageTitle":"Build a feature roadmap API","url":"/docs/tutorials/building-feature-roadmap-api#create-a-new-project","content":" Metatype projects are composed of modular bundles of types, logic and policies called typegraphs. We author typegraphs using modern programming languages &amp; environments. Python and ECMAScript are currently availaible for use. The meta-cli allows us to create a new project based on pre-existing templates.  Typescript SDKPython SDK Run one the following commands to create a new project under a new directory titled tg_roadmap. # using Node/Bun runtimes meta new --template node tg_roadmap # ^ project name # ^ Use `meta new --help` find out more available templates. # using Deno meta new --template deno tg_roadmap When using ECMAScript, the @typegraph/sdk package exposes all the necessary functions and types we'll need to describe our typegraph. The templates already specify it as as a dependency so all we need to do now is run the following command to download it: # using Deno deno cache api/example.ts # cache dependencies # using Bun bun install # using pnpm pnpm install # using npm npm install # using yarn yarn install   ","version":"Next","tagName":"h3"},{"title":"Launch typegate‚Äã","type":1,"pageTitle":"Build a feature roadmap API","url":"/docs/tutorials/building-feature-roadmap-api#launch-typegate","content":" The typegate is a program that runs and orchestrates our typegraphs. We can run it locally for development purposes. Typegate currently requires the Redis database to function and to make it eay to run both, we'll make use of a linux container runtime for this. The Docker runtime to be specific which has installation guides located here.  We'll also need the Docker Compose orchestrator which usually comes by default with the docker command. Use the following command to check if it's available:  docker compose version # Docker Compose version 2.23.0   ...and if not, the official installation guide can be found here.  If you have your docker runtime installed and running correctly, you will be able to launch the compose.yml file that's bundled in every template. The compose file by default includes the postgres and mongo databases. You can disable the latter by commenting it out or removing it as we'll not be needing it for this tutorial.  To launch the services, navigate you shell the the project directory and run the following command:  docker compose up --detach # ^ detach means it'll run in the background. # Omit to get the all logs in the current terminal   This should download and start typegate and it's dependent services.  We can observe their log of typegate or any of the other services with the following command. It has to be run from the same project directory.  docker compose logs typegate --follow # ^ Omit service name to look at the combined logs of all services   ","version":"Next","tagName":"h3"},{"title":"Make sure it's all working‚Äã","type":1,"pageTitle":"Build a feature roadmap API","url":"/docs/tutorials/building-feature-roadmap-api#make-sure-its-all-working","content":" The meta-cli includes the doctor command that checks everything is in working order. You can run the following to make sure everything's up and running.  meta doctor # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Global ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî # curr. directory /home/asdf/tg_roadmap # global config /home/asdf/.config/meta/config.json # meta-cli version 0.2.4 # docker version Docker version 24.0.7, build afdd53b4e3 # containers ghcr.io/metatypedev/typegate:v0.2.4 (Up 7 minutes), redis:7 (Up 7 minutes), postgres:15 (Up 7 minutes) # # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Project ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî # metatype file metatype.yaml # targets [2] deploy (remote, 3 secrets), dev (local, 3 secrets) # typegraphs [1] api/example.ts # # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Python SDK ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî # python version Python 3.11.5 # python bin .venv/bin/python # venv folder .venv # pyproject file pyproject.toml # pipfile file not found # requirements file not found # typegraph version # # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Typescript SDK ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî # deno version deno 1.38.0 # node version v20.9.0 # # ‚îå‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚îê # | Check that all versions match. | # | In case of issue or question, please raise a ticket on: | # | https://github.com/metatypedev/metatype/issues | # | Or browse the documentation: | # | https://metatype.dev/docs/reference | # ‚îî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚îò   ","version":"Next","tagName":"h3"},{"title":"Types‚Äã","type":1,"pageTitle":"Build a feature roadmap API","url":"/docs/tutorials/building-feature-roadmap-api#types","content":" The types of our typegraph describe the shape of the data that flows through it. In this case, we'll build our typegraph around types that represent &quot;ideas&quot;, &quot;votes&quot; and &quot;buckets&quot;.  Typescript SDKPython SDK Modify the file at api/example.ts to look something like the following. // we'll need the following imports import { t, typegraph } from &quot;@typegraph/sdk&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ^ each typegraph has a name const bucket = t.struct({ // asId and other config items describe the logical properties // of our types beyond just the shape &quot;id&quot;: t.integer({}, { asId: true }), &quot;name&quot;: t.string(), }); const idea = t.struct({ // uuid is just a shorthand alias for `t.string({format: &quot;uuid&quot;})` &quot;id&quot;: t.uuid({ asId: true }), &quot;name&quot;: t.string(), // another string shorthand &quot;authorEmail&quot;: t.email(), }); const vote = t.struct({ &quot;id&quot;: t.uuid(), &quot;authorEmail&quot;: t.email(), // `enum_` is also a shorthand over `t.string` &quot;importance&quot;: t.enum_([&quot;medium&quot;, &quot;important&quot;, &quot;critical&quot;]).optional(), // makes it optional &quot;desc&quot;: t.string().optional(), }); });   The types here are very simple and we haven't yet added any thing that models their relationships but they should do for our purposes.  ","version":"Next","tagName":"h2"},{"title":"Materializers‚Äã","type":1,"pageTitle":"Build a feature roadmap API","url":"/docs/tutorials/building-feature-roadmap-api#materializers","content":" Typegraphs expose an API to the external world using Materializer objects. Materializers describe functions that transform some input type into an output type and we define them in scope of different Runtimes, where the actual logic runs. At this early stage, we can make use of the Random runtime which allows us to generate random test data for our types to get a feel of our API.  Typescript SDKPython SDK // add need the following imports import { RandomRuntime } from &quot;@typegraph/sdk/runtimes/random&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... // every exposed materializer requires access control policies // for now, just use the public policy, anyone can access it const pub = Policy.public(); const random = new RandomRuntime({}); g.expose( { // generates a random object in the shape of idea &quot;get_idea&quot;: random.gen(idea).withPolicy(pub), }, ); });   At this point, we can push our typegraph to the locally running typegate node and access it. Run the following command in your project root:  # features auto-reload on any changes to your source files meta dev   Typegate has first-class support for consuming the API through a GraphQl interface and it's enabled by default. It also bundles the GrahpiQl API explorer and you should be able to access it at http://localhost:7890/roadmap once meta-cli has successfully pushed your typegraph.  Loading...  ","version":"Next","tagName":"h2"},{"title":"The Prisma Runtime‚Äã","type":1,"pageTitle":"Build a feature roadmap API","url":"/docs/tutorials/building-feature-roadmap-api#the-prisma-runtime","content":" A runtime most apps will be depend on is the Prisma Runtime. It allows you to persist data and run queries on different kinds of databases and has support for popular SQL and NoSQL databases. We'll use it to add the CRUD (create, read, update, delete) operations our app needs.  For this tutorial, we'll be making use of the PostgreSQL database. If you made use of the compose.yml to run typegate as outlined in this tutorial, there should be an instance of Postgres already up. You can check if postgres container is currently running by using the meta doctor command.  If a typegraph needs to access a database, it first needs to be made aware of its address. This is done through environment variables. In the root of your project directory, you'll find a file titled metatype.yaml. It contains metatype specific configuration for our project such as the top level typegates object which we use to specify the location and credentials of the different typegate nodes we'll be using. Each typegate entry also takes an env object where we can specify environment variables to be passed to our typegraphs. This requires special syntax. If we want for a typegraph called, say FOO, to be able read a variable named BAR, we specify the variable as TG_FOO_BAR: value in our config.  The metatype.yaml should already have a few sample environment variables. Add an entry like the following to give our typegraph access to the database's address:  typegates: dev: # .. env: # values here assume default config TG_ROADMAP_POSTGRES: &quot;postgresql://postgres:password@postgres:5432/db&quot;   Meta-cli will auto-reload when it detects changes to metatype.yaml.  We can add the Prisma runtime to our typegraph now.  Typescript SDKPython SDK // new imports import { PrismaRuntime } from &quot;@typegraph/sdk/providers/prisma&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... // the constructor takes the name of the env var directly const db = new PrismaRuntime(&quot;db&quot;, &quot;POSTGRES&quot;); // ... });   One of the features that the Prisma runtime allows us to implement is relationships.  Typescript SDKPython SDK import { PrismaRuntime } from &quot;@typegraph/sdk/providers/prisma&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... const db = new PrismaRuntime(&quot;db&quot;, &quot;POSTGRES&quot;); const bucket = t.struct({ &quot;id&quot;: t.integer({}, { asId: true, // auto generate ids during creation config: { auto: true } }), &quot;name&quot;: t.string(), // one-to many relationship &quot;ideas&quot;: t.list(g.ref(&quot;idea&quot;)), }) // explicitly naming our types makes reference later easier .rename(&quot;bucket&quot;); const idea = t.struct({ &quot;id&quot;: t.uuid({ asId: true, config: { auto: true } }), &quot;name&quot;: t.string(), &quot;authorEmail&quot;: t.email(), // we need to specify the relationships on both types &quot;bucket&quot;: g.ref(&quot;bucket&quot;), &quot;votes&quot;: t.list(g.ref(&quot;vote&quot;)), }) .rename(&quot;idea&quot;); const vote = t.struct({ &quot;id&quot;: t.uuid({ asId: true, config: { auto: true } }), &quot;authorEmail&quot;: t.email(), &quot;importance&quot;: t.enum_([&quot;medium&quot;, &quot;important&quot;, &quot;critical&quot;]).optional(), &quot;desc&quot;: t.string().optional(), &quot;idea&quot;: g.ref(&quot;idea&quot;) }) .rename(&quot;vote&quot;); // ... });   g.ref declares logical relationships between our types which the Prisma runtime will be able to pick up. If you need more control on what the relationships will look like on the database, you can use the db.link function. More information can be found on the Prisma runtime reference.  When we save our file at this point, the meta dev watcher should automatically create and push the necessary migrations to our database to get it in its intended shape. You should see a new subdirectory in your project called prisma. It's where the generated migrations are contained.  If you mess something up in the migrations and want a clean slate, you can reset everything by recreating the containers like so:  # remove all containers and their volumes docker compose down -v # launch docker compose up --detach # meta dev will auto apply any pending changes to databases meta dev   At this point, we're ready to add materializers to expose database queries to create or read data. The Prisma runtime allows us to run raw queries directly on the database but it also provides handy functions we can use for basic CRUD operations. We'll make use of those.  Typescript SDKPython SDK import { PrismaRuntime } from &quot;@typegraph/sdk/providers/prisma&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... const pub = Policy.public(); const db = new PrismaRuntime(&quot;db&quot;, &quot;POSTGRES&quot;); // ... g.expose( { &quot;get_buckets&quot;: db.findMany(bucket), &quot;create_bucket&quot;: db.create(bucket), &quot;get_idea&quot;: db.findFirst(idea), &quot;create_ideas&quot;: db.create(idea), }, pub // make all materializers public by default ); });   We should be able to add a few buckets and ideas now.  Loading...  ","version":"Next","tagName":"h3"},{"title":"Policies‚Äã","type":1,"pageTitle":"Build a feature roadmap API","url":"/docs/tutorials/building-feature-roadmap-api#policies","content":" We now have the tools enough to allow coarse CRUD of our data. The next thing we usually add at this point is authorization. A way to control who can read or write what. The primary mechanism typegraphs use for this purpose are policies.  Policies are small functions that get the context of a request as input and return a boolean signaling weather access should be granted. There are different kinds of extractors available that primarily work on HTTP request headers including jwt, hmac, basic and oauth2 with support for different providers. We register any extractors we're interested in for the entire typegraph. Any policies running within it can then access their extracted values in the context. Metatype currently supports policies based on javascript functions that are run on the Deno runtime.  For this tutorial, we'll be making use of the basic auth extractor. It expects a string in the format &quot;Basic token&quot; to be set in the Authorization http header. The token is expected to be a base64 encoded string in the format username:secret.  Typescript SDKPython SDK import { DenoRuntime } from &quot;@typegraph/sdk/runtimes/deno&quot;; import { Auth } from &quot;@typegraph/sdk/params&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... const deno = new DenoRuntime(); // The basic extractor only populates the context when // it recognizes the username and the secret matches g.auth(Auth.basic([&quot;andim&quot;, /*more users*/])) // the `username` value is only availaible if the basic // extractor was successful const admins = deno.policy(&quot;admins&quot;, ` (_args, { context }) =&gt; !!context.username `); g.expose( { // .. // only admins are allowed to create new buckets &quot;create_bucket&quot;: db.create(bucket).withPolicy(admins), // .. }, pub ); // ... });   The basic extractors expects the secrets in environment variables named in a specific format. Add the following entries to the metatype.yaml file:  typegates: dev: # .. env: # .. # the basic extractor secret format # TG_[typegraph]_BASIC_[username] TG_ROADMAP_BASIC_ANDIM: hunter2   When you save the files, meta-cli will reload the new additions to your typegraph.create_bucket is now only accessible to requests bearing the right tokens. (For the provided example, Basic YW5kaW06aHVudGVyMg== should work) If you're using the GraphiQl interface from earlier, there should be a panel in the bottom left called &quot;Headers&quot; for setting http headers  Loading...  ","version":"Next","tagName":"h2"},{"title":"More‚Äã","type":1,"pageTitle":"Build a feature roadmap API","url":"/docs/tutorials/building-feature-roadmap-api#more","content":" ","version":"Next","tagName":"h2"},{"title":"reduce‚Äã","type":1,"pageTitle":"Build a feature roadmap API","url":"/docs/tutorials/building-feature-roadmap-api#reduce","content":" We can use the reduce method to modify the input types of functions. This comes especially handy when dealing with generated functions like those from the CRUD helpers from the Prisma runtime. By default, Prisma generates types that supports the whole suite of usecases one might have on a CRUD operation such as allowing creation of objects of related types in a single operation. We don't always want this and in our case, we want to prevent users from being able to create buckets, which are protected, through the create_idea materializer which's public.  mutation CIdea { create_idea( data: { # we want to prevent bucket creation through `create_idea` bucket: { create: {name: &quot;Backlog&quot;} }, authorEmail: &quot;asdf@as.df&quot;, name: &quot;Add support for WASM GC&quot; } ) { id name } }   Even though the reduce method doesn't allow us to change the shape of the type, we can change the types of members and importantly here, hide the ones we don't need.  Typescript SDKPython SDK typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... g.expose( { // .. &quot;create_idea&quot;: db.create(idea).reduce({ &quot;data&quot;: { // `g.inherit` specifies that we keep the member // type of the original &quot;name&quot;: g.inherit(), &quot;authorEmail&quot;: g.inherit(), &quot;votes&quot;: g.inherit(), &quot;bucket&quot;: { &quot;connect&quot;: g.inherit(), // by omitting the `create` member, we hide it } } }), // .. }, pub ); });   Requests are now only able to connect new ideas with pre-existing buckets and won't be able to create them.  Loading...  ","version":"Next","tagName":"h3"},{"title":"execute‚Äã","type":1,"pageTitle":"Build a feature roadmap API","url":"/docs/tutorials/building-feature-roadmap-api#execute","content":" You'll notice that we had set the importance field on votes as optional. This is to allow users to just up-vote an idea from the main list without opening a form. If they want to add importance or a description to their vote at a later point, we want to update their already existing vote. It should be easy to expose a materializer for this using Prisma's db.update helper and reduce to restrict changes to only those field. But we'll take this opportunity to explore the feature of the Prisma runtime to execute raw queries.  Typescript SDKPython SDK import * as effects from &quot;@typegraph/sdk/effects&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... g.expose( { // .. &quot;set_vote_importance&quot;: db.execute( // query parameters are matched by name from the input type 'UPDATE &quot;vote&quot; SET importance = ${importance} WHERE id = ${vote_id}::uuid', // our input type t.struct({ &quot;vote_id&quot;: t.uuid(), &quot;importance&quot;: t.enum_([&quot;medium&quot;, &quot;important&quot;, &quot;critical&quot;]), }), // we use effects to signal what kind of operation we're doing // updates and creates will be exposed as mutations in GraphQl // the boolean signals that the query is idempotent effects.update(true), ) // .. }, pub ); });   Our query is exposed like any other materializer in the GraphQl api.  Loading...  ","version":"Next","tagName":"h3"},{"title":"rest‚Äã","type":1,"pageTitle":"Build a feature roadmap API","url":"/docs/tutorials/building-feature-roadmap-api#rest","content":" We can easily expose an HTTP API for our typegraph using the g.rest method. It takes a string describe a graphql query to be executed when the http path is requested.  Typescript SDKPython SDK typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... g.rest( ` query get_buckets { get_buckets { id name ideas { id name authorEmail } } } ` ) g.rest( // query parameters present // expects a request of the type `roadmap/rest/get_bucket?id=uuidstr` ` query get_bucket($id: Integer) { get_bucket(where:{ id: $id }) { id name ideas { id name authorEmail } } } ` ) });   The exposed query is served at the path {typegate_url}/{typegraph_name}/rest/{query_name}. Any parameters that the query takes are processed from the search params of the request.    ","version":"Next","tagName":"h3"},{"title":"import‚Äã","type":1,"pageTitle":"Build a feature roadmap API","url":"/docs/tutorials/building-feature-roadmap-api#import","content":" So far, the materializers we've looked at have been generated by helpers like the CRUD helpers from the Prisma runtime or the the Random runtime's generate helper. The deno.policy function we used for authoring policies was also based on function objects. All these helpers are shorthands for creating function objects and now we'll look at how to roll a custom function ourselves. We'll be using the Deno runtime to run our code.  Instead of including the code inline through a string, the Deno runtime allows us to import modules from disk. Our modules are allowed to use ESM imports to access libraries on different registries like npm and deno.land. We'll use these features to write a simple materializer that converts markdown to html.  import * as marked from &quot;https://deno.land/x/marked/mod.ts&quot;; export function parse({ raw }: { raw: string }): string { return marked.parse(raw); }   We'll expose our module using the deno runtime.  Typescript SDKPython SDK typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... g.expose( { // .. &quot;parse_markdown&quot;: deno.import( t.struct({&quot;raw&quot;: t.string()}), t.string(), { name: &quot;parse&quot;, // the path is parsed relative to the typegraph file module: &quot;md2html.ts&quot;, } ), // .. }, pub ); });   We can now access our func through the GraphQl api.  Loading...    ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}