[{"title":"Meta CLI","type":0,"sectionRef":"#","url":"/docs/concepts/meta-cli","content":"","keywords":""},{"title":"Developmentâ€‹","type":1,"pageTitle":"Meta CLI","url":"/docs/concepts/meta-cli#development","content":"It watches for changes in your typegraphs and refresh your development typegate node on the fly. "},{"title":"Deploymentâ€‹","type":1,"pageTitle":"Meta CLI","url":"/docs/concepts/meta-cli#deployment","content":"It deploy your typegraph to the Metatype Cloud or your self-hosted typegate instances in a single command. "},{"title":"Overview","type":0,"sectionRef":"#","url":"/docs/concepts/overview","content":"","keywords":""},{"title":"Why does Metatype exist?â€‹","type":1,"pageTitle":"Overview","url":"/docs/concepts/overview#why-does-metatype-exist","content":"As products/projects evolve and grow, the technological stack becomes a challenging hot spot where initiatives collides and efficiency becomes a struggle. While deploying new features, all developer teams spend a non-negligible amount of time on low-value added tasks like CRUD generation, data validation, interoperability with (legacy) systems, authentication or authorization. This leaves little time under business constraints for designing great interfaces and experimenting to find the best technical solution, increasing time to delivery and weakening innovation. Metatype's vision is to enable everyone to compose their data, anywhere. By helping developer the re-use of data and existing systems, it enables teams to focus on what matters: their expert knowledge in business logic, modelling and technologies. Metatype handle the complex layers for them and orchestrate systems into modular API blocks, making it easy to understand and remaining innovative for the next iterations. In short, Metatype promotes standardized and composable solutions to the following challenges: make system interfaces accessible and easy to understand for everyone (discoverability)embrace iterative approaches and cut time to deployment in half (autonomy)build strong foundations for APIs with type safety and bounded context (modularity)empower teams to innovate with new technologies and interoperability (orchestration) "},{"title":"How does Metatype work?â€‹","type":1,"pageTitle":"Overview","url":"/docs/concepts/overview#how-does-metatype-work","content":"When developing a feature, the classical approach is to define what data will be at play, how to transform them, where the execution shall take place and who should be authorized. Instead, Metatype define an abstraction for each of those steps and put the emphasis on composing pre-defined API blocks or defining re-usable ones when there is no existing solution. \tClassical approach\tMetatype's approachWhat (data)\tfixed response defined by the controller\tAPI clients selects what they need from types How (transformations)\tad-hoc code logic\tcompose data with interchangeable materializers Where (execution)\t1 code base + 1 database\torchestrate the request across multiple runtimes Who (authentication)\thard-coded rules or system\trequest context based and controlled by policies When (event)\trequest arrival\tbased on triggers "},{"title":"What's exactly Metatype?â€‹","type":1,"pageTitle":"Overview","url":"/docs/concepts/overview#whats-exactly-metatype","content":"Metatype is a composition ecosystem for developers. It allows to build autonomous, discoverable, and modular API blocks with automatic orchestration. These API blocks are technology-agnostic and enable developers to iterate fast, yet remaining agile and focusing on domain design model as stacks grow. The ecosystem consists of the following components: Typegraph: a package to describe typegraphs - virtual graphs of types - and their compositionsTypegate: a HTTP/GraphQL gateway embedding a scalable and fast query engineMeta CLI: a command-line tool to provide great developer experience and serverless deployments "},{"title":"Architectural overviewâ€‹","type":1,"pageTitle":"Overview","url":"/docs/concepts/overview#architectural-overview","content":"Metatype is designed for cloud environments and comes with minimal components. The only requirement to scale horizontally is to share some memory between replicas via Redis. You can use Metatype helm chart to directly deploy typegates on your Kubernetes cluster.  "},{"title":"Typegate","type":0,"sectionRef":"#","url":"/docs/concepts/typegate","content":"","keywords":""},{"title":"Request lifecycleâ€‹","type":1,"pageTitle":"Typegate","url":"/docs/concepts/typegate#request-lifecycle","content":"When a new request fires a trigger, the typegate orchestrates the following stages: extract the secure request context from custom authentication or JSON Web Token (JWT)retrieve cached execution plan or compute a new one traverse the typegraph to create a DAG of the required typesoptimize the DAG to reduce the number of calls to the runtimespre-compute all structural elements and data resolutions execute the plan type check the argumentsverify lazily policies on the needrun the DAG executionenforce the rate-limitingtype check the response manage metadata of the request "},{"title":"HTTP/GraphQL interfaceâ€‹","type":1,"pageTitle":"Typegate","url":"/docs/concepts/typegate#httpgraphql-interface","content":"For now, the typegate nodes are only accessible through HTTP/1.1 and HTTP/2. More protocols could be supported in the future. Typegates expose a GraphQL interface which is the result of a typegraph projected onto corresponding GraphQL types. While this reduces the type safety of the data flowing, it makes more interoperable thanks to the many high-quality and well-known GraphQL tooling already available. The underlying types are also exposed in order for API clients to verify the underlying types. GraphQL, being a query language, offers a great asset for Metatype's philosophy: Efficient querying: the client can specify exactly what data it needs, reducing the amount of over- or under-fetchingFlexibility: allows for retrieving multiple resources in a single request, unlike REST, which often requires multiple onesTyping: GraphQL has a built-in type system that allows for better documentation and stronger validation of the requestsImproved tooling: tools and libraries around GraphQL are rapidly growing and great a development experience "},{"title":"Typegraph","type":0,"sectionRef":"#","url":"/docs/concepts/typegraph","content":"","keywords":""},{"title":"Typesâ€‹","type":1,"pageTitle":"Typegraph","url":"/docs/concepts/typegraph#types","content":"Types are the building block of typegraphs. They define a type system describing all data objects processed in Metatype. They can be easily extended to support new data types according to the needs of the application. t.struct( { &quot;id&quot;: t.uuid(), &quot;age&quot;: t.integer(), &quot;cars&quot;: t.array( t.struct( { &quot;model&quot;: t.string(), &quot;name&quot;: t.string().optional(), } ) ), } )  Analogy in SQL: types are similar to the Data Definition Language (DDL) with the extended capacity of describing any type of data. "},{"title":"Materializersâ€‹","type":1,"pageTitle":"Typegraph","url":"/docs/concepts/typegraph#materializers","content":"Types can also describe functions and materializers define how the input type gets transformed into the output type. The input and output types are similar to a function signature and a materializer to its implementation, except that it might not always know what the function body is. In such case, the materializer knows at least where and how to access it. t.func( t.struct({&quot;input&quot;: t.string()}), t.string(), PureFunMat(&quot;({ input }) =&gt; `hello ${input}`&quot;), # with logic ) t.func( t.struct({}), t.enum([&quot;head&quot;, &quot;tail&quot;]), RESTMat(http, &quot;GET&quot;, &quot;/flip_coin&quot;, effect=effects.none), # where the logic is )  Analogy in SQL: a materializer is similar to a join, a function, or an alias. "},{"title":"Runtimesâ€‹","type":1,"pageTitle":"Typegraph","url":"/docs/concepts/typegraph#runtimes","content":"Every type and materializer have a runtime associated to it. This runtime describes where the types or materializers are physically located. It can be another API, a database, or any other services the typegate can connect to. The typegates uses that information to optimize the execution of the queries and minimize the amount of data moved. In practice, materializers are often not explicitly used and the usage of runtime sugar syntax is preferred. http = HTTPRuntime(&quot;https://random.org/api&quot;) # same func as above http.get( &quot;/flip_coin&quot;, t.struct({}), t.enum([&quot;head&quot;, &quot;tail&quot;]) ) # implicitly attaches runtime to all types  Analogy in SQL: a runtime is similar to a database instance running some requests. "},{"title":"Policiesâ€‹","type":1,"pageTitle":"Typegraph","url":"/docs/concepts/typegraph#policies","content":"Policies are a special type of function t.func(t.struct({...}), t.boolean().optional()) attachable to any other type. They are evaluated once per request and determine whether one of the polices authorizes the access or not. They receive the request context (see typegate) as argument allowing you to implement authorization, access control, or any other business logic. The policy decision can be: true: the access is authorizedfalse: the access is deniednull: the access in inherited from the parent types public = Policy(PureFunMat(&quot;() =&gt; true&quot;)) team_only = Policy(PureFunMat(&quot;(ctx) =&gt; ctx.user.role === 'admin'&quot;))  Analogy in SQL: policies are similar to Row Security Policies (RSP) or Row Level Security (RLS) concepts. "},{"title":"Triggersâ€‹","type":1,"pageTitle":"Typegraph","url":"/docs/concepts/typegraph#triggers","content":"Triggers are events launching the execution of one or multiple functions. They fire when a GraphQL request is received for the specific typegraph. with TypeGraph(&quot;triggers&quot;) as g: # ... g.expose( flip=http.get(&quot;/flip_coin&quot;, t.struct({}), t.enum([&quot;head&quot;, &quot;tail&quot;])), default_policy=[public], )  Analogy in SQL: a trigger is similar to receiving a new query. "},{"title":"How-to contribute","type":0,"sectionRef":"#","url":"/docs/guides/contribute","content":"","keywords":""},{"title":"Prerequisitesâ€‹","type":1,"pageTitle":"How-to contribute","url":"/docs/guides/contribute#prerequisites","content":"Install: RustPythonpipxPNPMDenoNode "},{"title":"Getting startedâ€‹","type":1,"pageTitle":"How-to contribute","url":"/docs/guides/contribute#getting-started","content":""},{"title":"Essential packages for Linux / WSLâ€‹","type":1,"pageTitle":"How-to contribute","url":"/docs/guides/contribute#essential-packages-for-linux--wsl","content":"sudo apt install build-essential sudo apt install unzip sudo apt install pkg-config libssl-dev  "},{"title":"Toolsetâ€‹","type":1,"pageTitle":"How-to contribute","url":"/docs/guides/contribute#toolset","content":"cargo install cargo-watch cargo install cargo-edit cargo install --git https://github.com/zifeo/whiz --locked apt install -y protobuf-compiler pipx install pre-commit pipx install poetry deno install -Afq -n deno_bindgen https://deno.land/x/deno_bindgen/cli.ts # wasmedge curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash  "},{"title":"Init workspaceâ€‹","type":1,"pageTitle":"How-to contribute","url":"/docs/guides/contribute#init-workspace","content":"pre-commit install python3 -m venv .venv python3 -m venv examples/.venv cd typegraph source ../.venv/bin/activate poetry install deactivate cd .. cd examples poetry install cd .. cd website pnpm install cd .. cd typegate cp .env.sample .env cd .. whiz  "},{"title":"Testsâ€‹","type":1,"pageTitle":"How-to contribute","url":"/docs/guides/contribute#tests","content":"deno run -A dev/env.ts all cargo test deno run -A dev/test.ts cd typegraph &amp;&amp; pytest -s deno run -A dev/env.ts  "},{"title":"How-to upload images to S3","type":0,"sectionRef":"#","url":"/docs/guides/upload-files-s3","content":"","keywords":""},{"title":"Typegraphâ€‹","type":1,"pageTitle":"How-to upload images to S3","url":"/docs/guides/upload-files-s3#typegraph","content":"TG_RETREND_ACCESS_KEY=minio TG_RETREND_SECRET_KEY=password  from typegraph import TypeGraph, policies from typegraph.providers.aws.runtimes.s3 import S3Runtime with TypeGraph( &quot;retrend&quot;, ) as g: public = policies.public() s3 = S3Runtime(&quot;http://localhost:9000&quot;, &quot;local&quot;, &quot;access_key&quot;, &quot;secret_key&quot;) g.expose( presigned=s3.sign(&quot;bucket&quot;, &quot;image/png&quot;).add_policy(public), )  "},{"title":"Usageâ€‹","type":1,"pageTitle":"How-to upload images to S3","url":"/docs/guides/upload-files-s3#usage","content":"const image = await Deno.readFile(&quot;website/static/images/logo.png&quot;); const { data: { presigned }, } = await fetch(&quot;http://localhost:7891/retrend&quot;, { method: &quot;POST&quot;, body: JSON.stringify({ query: ` query sign($length: Int) { presigned(length: $length, path: &quot;my-super-image.png&quot;) } `, variables: { length: image.length, }, }), }).then((r) =&gt; r.json()); const upload = await fetch(presigned, { method: &quot;PUT&quot;, body: image, headers: { &quot;content-type&quot;: &quot;image/png&quot;, &quot;content-length&quot;: image.length, }, }); console.log(upload.status);  "},{"title":"Reference","type":0,"sectionRef":"#","url":"/docs/reference","content":"Reference","keywords":""},{"title":"Configuration file","type":0,"sectionRef":"#","url":"/docs/reference/configuration-file","content":"","keywords":""},{"title":"metatype.yml Example fileâ€‹","type":1,"pageTitle":"Configuration file","url":"/docs/reference/configuration-file#metatypeyml-example-file","content":"typegates: dev: url: http://localhost:7890 username: admin password: password typegraphs: python: include: &quot;**/*.py&quot; materializers: prisma: migrations_path: &quot;migrations&quot;  "},{"title":"Automatic secret loading supportâ€‹","type":1,"pageTitle":"Configuration file","url":"/docs/reference/configuration-file#automatic-secret-loading-support","content":"Lade is a secret loading tool that transparently inject environment variables from a variety of sources. It works with Fish, Bash or Zsh and currently supports Doppler, Infisical and 1Password as vault source. To use Lade with Metatype, you can use the op://, infisical:// or doppler:// prefixes in your configuration file. It will then use the CLI of the vault to securely load the required secrets. For example: typegates: dev: url: http://localhost:7890 username: op://VAULT_NAME/SECRET_NAME/FIELD_NAME password: infisical://app.infisical.com/PROJECT_NAME/ENV_NAME/SECRET_NAME  "},{"title":"Changelog","type":0,"sectionRef":"#","url":"/docs/reference/changelog","content":"","keywords":""},{"title":"v0.1.5 (4/18/2023)â€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v015-4182023","content":""},{"title":"What's Changedâ€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed","content":"New features ðŸŽ‰â€‹ chore: prepare release 0.1.5-dev.0 by @github-actions in #265Fix either schema by @afmika in #262Fix: Unvalidated dynamic method call by @afmika in #269feat: deno coverage and small fixes by @zifeo in #272Improve CLI DX by @Natoandro in #268MET-112: gate better error message for invalid operation type by @afmika in #267feat: new command and for use cases on the website by @zifeo in #273 Full Changelog: v0.1.4...v0.1.5 "},{"title":"v0.1.4 (4/11/2023)â€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v014-4112023","content":""},{"title":"What's Changedâ€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-1","content":"New features ðŸŽ‰â€‹ Improved CLI DX by @Natoandro in #247chore: prepare release 0.1.4-dev.0 by @github-actions in #261feat: doctor, upgrade with version, static materializer and website updates by @zifeo in #263 Full Changelog: v0.1.3...v0.1.4 "},{"title":"v0.1.3 (4/5/2023)â€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v013-452023","content":""},{"title":"What's Changedâ€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-2","content":"New features ðŸŽ‰â€‹ chore: upgrade build dependencies by @zifeo in #255feat: secrets sync by @zifeo in #257Met-101: (copy) fix google service discovery in the tutorial by @afmika in #226feat: add oauth2 providers and upgrade lade for windows by @zifeo in #259MET-128: either should be supported in the introspection by @afmika in #243MET-143: support multi-runtime in all runtimes by @afmika in #258 Full Changelog: v0.1.1...v0.1.3 "},{"title":"v0.1.1 (3/29/2023)â€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v011-3292023","content":""},{"title":"What's Changedâ€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-3","content":"New features ðŸŽ‰â€‹ feat: improve jwt auth, support auth without provider, fix redis bug, fix typos by @zifeo in #244 Full Changelog: v0.1.0...v0.1.1 "},{"title":"v0.1.0 (3/28/2023)â€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v010-3282023","content":""},{"title":"What's Changedâ€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-4","content":"New features ðŸŽ‰â€‹ MET-129: prisma runtime object should only consider same runtime field by @afmika in #228feat: Optional relationships by @Natoandro in #238feat: messenger patterns, refactor and upgrades by @zifeo in #230 Full Changelog: https://github.com/metatypedev/metatype/commits/v0.1.0 "},{"title":"v0.0.3-dev.6 (3/8/2023)â€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v003-dev6-382023","content":""},{"title":"What's Changedâ€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-5","content":"New features ðŸŽ‰â€‹ chore: prepare release 0.0.3-dev.6 by @github-actions in #158fix: disable sentry on worker by @zifeo in #159chore(deps): bump schemars from 0.8.11 to 0.8.12 by @dependabot in #163chore(deps): bump syn from 1.0.108 to 1.0.109 by @dependabot in #162chore(deps): bump tempfile from 3.3.0 to 3.4.0 by @dependabot in #161chore(deps): bump actions/checkout from 2 to 3 by @dependabot in #160chore(deps): bump sentry from 0.29.3 to 0.30.0 by @dependabot in #164MET-118: handle optional and list values in t.union by @afmika in #165chore(deps): bump clap from 4.1.6 to 4.1.8 by @dependabot in #168chore(deps): bump tokio from 1.25.0 to 1.26.0 by @dependabot in #170chore(deps): bump crossbeam-channel from 0.5.6 to 0.5.7 by @dependabot in #167chore(deps-dev): bump ruff from 0.0.245 to 0.0.253 in /typegraph by @dependabot in #169chore(deps): bump temporal-client from 09a2e4f to 6d55691 by @dependabot in #172chore(deps): bump temporal-sdk-core-protos from 09a2e4f to 6d55691 by @dependabot in #171MET-8: http runtime name clash by @afmika in #148MET-67 graph implement full prisma mapping by @afmika in #111MET-73: Make policies configurable per effect by @Natoandro in #147Revert &quot;MET-67 graph implement full prisma mapping (#111)&quot; by @zifeo in #175chore(deps): bump indoc from 2.0.0 to 2.0.1 by @dependabot in #183chore(deps): bump temporal-sdk-core-protos from 6d55691 to 34a2d55 by @dependabot in #182chore(deps): bump thiserror from 1.0.38 to 1.0.39 by @dependabot in #181chore(deps): bump string_cache from 0.8.4 to 0.8.6 by @dependabot in #180chore(deps-dev): bump pytest from 7.2.1 to 7.2.2 in /typegraph by @dependabot in #178chore(deps-dev): bump ruff from 0.0.253 to 0.0.254 in /typegraph by @dependabot in #177chore(deps): bump serde_json from 1.0.93 to 1.0.94 by @dependabot in #179feat: add WasmEdge experiment runtime by @zifeo in #176feat: add lade support by @zifeo in #173feat: internal policy and remove external url by @zifeo in #174chore(deps): bump serde_yaml from 0.9.17 to 0.9.19 by @dependabot in #188chore(deps): bump lade-sdk from 0.2.2 to 0.3.1 by @dependabot in #184chore(deps): bump temporal-client from 34a2d55 to 606c417 by @dependabot in #186chore(deps): bump temporal-sdk-core-protos from 34a2d55 to 606c417 by @dependabot in #187chore(deps): bump async-trait from 0.1.65 to 0.1.66 by @dependabot in #185 Full Changelog: v0.0.3-dev.5...v0.0.3-dev.6 "},{"title":"v0.0.3-dev.5 (2/24/2023)â€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v003-dev5-2242023","content":""},{"title":"What's Changedâ€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-6","content":"New features ðŸŽ‰â€‹ chore(deps): bump temporal-sdk-core-protos from af26dee to 0d7908c by @dependabot in #142feat: add type node either by @msga-mmm in #110chore: prepare release 0.0.3-dev.5 by @github-actions in #146chore(deps): bump temporal-client from 0d7908c to 09a2e4f by @dependabot in #156chore(deps): bump syn from 1.0.107 to 1.0.108 by @dependabot in #155chore(deps): bump swc_ecma_codegen from 0.129.8 to 0.129.10 by @dependabot in #153chore(deps): bump swc_ecma_transforms_typescript from 0.164.10 to 0.164.11 by @dependabot in #154chore(deps): bump python-box from 7.0.0 to 7.0.1 in /typegraph by @dependabot in #151feat: better logging and fix deployment by @zifeo in #150 Full Changelog: v0.0.3-dev.4...v0.0.3-dev.5 "},{"title":"v0.0.3-dev.4 (2/22/2023)â€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v003-dev4-2222023","content":""},{"title":"What's Changedâ€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-7","content":"New features ðŸŽ‰â€‹ chore(meta-cli/codegen): make config file optional by @msga-mmm in #125chore(deps): bump temporal-sdk-core-protos from 17ceab7 to 454cbea by @dependabot in #127chore(deps): bump clap from 4.1.4 to 4.1.6 by @dependabot in #128chore(deps): bump temporal-sdk-core-protos from 454cbea to 00fc0ff by @dependabot in #132chore(deps): bump temporal-client from 454cbea to 00fc0ff by @dependabot in #131chore: prepare release 0.0.3-dev.4 by @github-actions in #130chore: upgrade dependency and unify dependency management by @zifeo in #140chore(deps): bump frozendict from 2.3.4 to 2.3.5 in /typegraph by @dependabot in #137 "},{"title":"New Contributorsâ€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#new-contributors","content":"@github-actions made their first contribution in #130 Full Changelog: v0.0.3-dev.3...v0.0.3-dev.4 "},{"title":"v0.0.3-dev.3 (2/16/2023)â€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v003-dev3-2162023","content":""},{"title":"What's Changedâ€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-8","content":"New features ðŸŽ‰â€‹ chore(deps): bump openssl-src from 111.24.0+1.1.1s to 111.25.0+1.1.1t by @dependabot in #106chore(deps): bump serde_json from 1.0.92 to 1.0.93 by @dependabot in #107chore(deps): bump sentry from 0.29.2 to 0.29.3 by @dependabot in #108chore(deps): bump dprint-plugin-typescript from 0.82.0 to 0.83.0 by @dependabot in #109Docs by @zifeo in #101feat(typegraph): support type union by @msga-mmm in #78chore(deps): bump thehanimo/pr-title-checker from 1.3.6 to 1.3.7 by @dependabot in #112chore(deps): bump self_update from 0.34.0 to 0.35.0 by @dependabot in #113Met 18: New way to use prisma runtime by @Natoandro in #105chore(deps): bump proc-macro2 from 1.0.50 to 1.0.51 by @dependabot in #119chore(deps): bump temporal-sdk-core-protos from 106b09f to 454cbea by @dependabot in #118chore: small fixes by @zifeo in #116Met 75 check all todos fixme in the project by @afmika in #90chore(deps): bump typing-extensions from 4.4.0 to 4.5.0 in /typegraph by @dependabot in #121chore: update Cargo.lock by @msga-mmm in #123 Full Changelog: v0.0.3-dev.2...v0.0.3-dev.3 "},{"title":"v0.0.3-dev.2 (2/7/2023)â€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v003-dev2-272023","content":""},{"title":"What's Changedâ€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-9","content":"New features ðŸŽ‰â€‹ add: system typegraph documentation and change build steps to avoid permission issues by @zifeo in #69refactor : rename allow_all into public by @afmika in #70chore: one more attempt at solving caching issue by @zifeo in #75chore(deps): bump peter-evans/create-pull-request from 3 to 4 by @dependabot in #71chore: one more attempt at solving caching issue by @zifeo in #79chore(deps-dev): bump flake8-docstrings from 1.6.0 to 1.7.0 in /typegraph by @dependabot in #76chore(deps): bump sentry from 0.29.1 to 0.29.2 by @dependabot in #77chore(deps): bump clap from 4.1.2 to 4.1.4 by @dependabot in #72chore(deps): bump temporal-client from feb6258 to a5a1a75 by @dependabot in #81chore(deps): bump temporal-sdk-core-protos from feb6258 to a5a1a75 by @dependabot in #80MET-9 : (http runtime) implement multipart form data by @afmika in #74chore(deps): bump thehanimo/pr-title-checker from 1.3.5 to 1.3.6 by @dependabot in #82chore(deps): bump docker/build-push-action from 3 to 4 by @dependabot in #87MET-72: Replace serial with effect by @Natoandro in #67Feat MET-39: Rewrite importers by @Natoandro in #62Upgrade Deno, refactor cache and add docs typegraph deployment by @zifeo in #89MET-54: branding graphiql by @zoharyAnd in #73chore(deps): bump temporal-sdk-core-protos from a5a1a75 to 106b09f by @dependabot in #91chore(deps): bump notify from 5.0.0 to 5.1.0 by @dependabot in #83chore(deps): bump tokio from 1.24.2 to 1.25.0 by @dependabot in #85fix: deploy by @zifeo in #92chore(deps): bump indoc from 1.0.8 to 2.0.0 by @dependabot in #86chore(deps): bump dprint-plugin-typescript from 0.80.2 to 0.81.1 by @dependabot in #84chore(deps): bump black from 22.12.0 to 23.1.0 in /typegraph by @dependabot in #93chore(deps): bump uuid from 1.2.2 to 1.3.0 by @dependabot in #94chore(deps): bump anyhow from 1.0.68 to 1.0.69 by @dependabot in #99chore(deps): bump serde_json from 1.0.91 to 1.0.92 by @dependabot in #98chore(deps): bump dprint-plugin-typescript from 0.81.1 to 0.82.0 by @dependabot in #97chore(deps): bump proc-macro2 from 1.0.50 to 1.0.51 by @dependabot in #96chore(deps): bump python-box from 6.1.0 to 7.0.0 in /typegraph by @dependabot in #95chore(deps): bump temporal-sdk-core-protos from 106b09f to 17ceab7 by @dependabot in #100Fix introspection by @Natoandro in #102Prepare release: 0.0.3-dev.2 by @Natoandro in #103 "},{"title":"New Contributorsâ€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#new-contributors-1","content":"@zoharyAnd made their first contribution in #73 Full Changelog: v0.0.3-dev.1...v0.0.3-dev.2 "},{"title":"v0.0.3-dev.1 (1/24/2023)â€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v003-dev1-1242023","content":""},{"title":"What's Changedâ€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-10","content":"New features ðŸŽ‰â€‹ Docs follow-up + refactoring by @zifeo in #54Refactor MET-51 handle better ffi crash by @afmika in #52Fix: TypeScript codegen by @Natoandro in #60(CLI) MET-57: Rewrite terminal documentation by @afmika in #61feat(meta-cli): link openssl statically by @msga-mmm in #65MET-86: Fix introspection by @Natoandro in #64feat MET-71: (GRAPH)Add policy.jwt by @afmika in #63Refactor, multiple fixes and add temporal runtime by @zifeo in #66 "},{"title":"New Contributorsâ€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#new-contributors-2","content":"@msga-mmm made their first contribution in #65 Full Changelog: v0.0.3-dev.0...v0.0.3-dev.1 "},{"title":"v0.0.3-dev.0 (1/14/2023)â€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v003-dev0-1142023","content":""},{"title":"What's Changedâ€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-11","content":"New features ðŸŽ‰â€‹ build: add dependabot by @zifeo in #9chore(deps-dev): bump flake8 from 5.0.4 to 6.0.0 in /website by @dependabot in #20chore(deps): bump docker/login-action from 1 to 2 by @dependabot in #13chore(deps): bump actions/checkout from 2 to 3 by @dependabot in #11chore: release improvement by @zifeo in #8chore(deps): bump pnpm/action-setup from 2.2.2 to 2.2.4 by @dependabot in #10chore(deps-dev): bump pytest-asyncio from 0.19.0 to 0.20.3 in /typegraph by @dependabot in #30chore(deps-dev): bump mypy from 0.982 to 0.991 in /typegraph by @dependabot in #26chore(deps): bump httpx from 0.22.0 to 0.23.3 in /typegraph by @dependabot in #25chore(deps): bump base64 from 0.13.1 to 0.20.0 by @dependabot in #29chore: upgrade rust deps by @zifeo in #31chore(deps): bump orjson from 3.8.4 to 3.8.5 in /typegraph by @dependabot in #33Add missing commands by @afmika in #47add changes to the doc by @afmika in #46feat(MET-38): Expose function inputs to the policy by @Natoandro in #4feat MET-12: Generate TypeScript type definitions from jsonschema by @Natoandro in #45Fix workflow for release by @Natoandro in #53 "},{"title":"New Contributorsâ€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#new-contributors-3","content":"@afmika made their first contribution in #47@Natoandro made their first contribution in #4 Full Changelog: v0.0.2-alpha.14...v0.0.3-dev.0 "},{"title":"v0.0.2-alpha.14 (1/7/2023)â€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v002-alpha14-172023","content":""},{"title":"What's Changedâ€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-12","content":"New features ðŸŽ‰â€‹ build: improve pipeline and refactor cache by @zifeo in #5chore(deps): bump tokio from 1.23.0 to 1.23.1 by @dependabot in #6chore: release a14 by @zifeo in #7 "},{"title":"New Contributorsâ€‹","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#new-contributors-4","content":"@zifeo made their first contribution in #5 Full Changelog: v0.0.2-alpha.13...v0.0.2-alpha.14 "},{"title":"Typegraph specification","type":0,"sectionRef":"#","url":"/docs/reference/specification","content":"Typegraph specification v0.0.1","keywords":""},{"title":"Ecosystem repositories","type":0,"sectionRef":"#","url":"/docs/reference/ecosystem","content":"","keywords":""},{"title":"Metatypeâ€‹","type":1,"pageTitle":"Ecosystem repositories","url":"/docs/reference/ecosystem#metatype","content":"Metatype is the principal repository of the Metatype ecosystem. It contains the Meta CLI, the typegate and the typegraph components. "},{"title":"Whizâ€‹","type":1,"pageTitle":"Ecosystem repositories","url":"/docs/reference/ecosystem#whiz","content":"Whiz is a modern DAG/tasks runner for multi-platform monorepos. It enables to develop the core components of the ecosystem together and reloading only the necessary tasks on file change.  "},{"title":"Ladeâ€‹","type":1,"pageTitle":"Ecosystem repositories","url":"/docs/reference/ecosystem#lade","content":"Lade automatically load secrets from your preferred vault as environment variables, and clear them once your shell command is over. The Meta CLI bundles Lade and use it to load secret seamlessly into your typegates.  "},{"title":"Python WASI reactorâ€‹","type":1,"pageTitle":"Ecosystem repositories","url":"/docs/reference/ecosystem#python-wasi-reactor","content":"Python WASI reactor is one of the runtimes bundled into the typegate. It allows to run Python scripts as WASI modules on the fly. "},{"title":"Mutations","type":0,"sectionRef":"#","url":"/docs/reference/typegate/prisma-migration/mutations","content":"","keywords":""},{"title":"applyâ€‹","type":1,"pageTitle":"Mutations","url":"/docs/reference/typegate/prisma-migration/mutations#apply","content":"Type: object_23! apply field Policies: admin_only Arguments Name\tDescriptionresetDatabase Boolean! resetDatabase input field migrations String migrations input field runtime String runtime input field typegraph String! typegraph input field "},{"title":"createâ€‹","type":1,"pageTitle":"Mutations","url":"/docs/reference/typegate/prisma-migration/mutations#create","content":"Type: object_33! create field Policies: admin_only Arguments Name\tDescriptionapply Boolean! apply input field name String! name input field migrations String migrations input field runtime String runtime input field typegraph String! typegraph input field "},{"title":"deployâ€‹","type":1,"pageTitle":"Mutations","url":"/docs/reference/typegate/prisma-migration/mutations#deploy","content":"Type: object_40! deploy field Policies: admin_only Arguments Name\tDescriptionmigrations String! migrations input field runtime String runtime input field typegraph String! typegraph input field "},{"title":"resetâ€‹","type":1,"pageTitle":"Mutations","url":"/docs/reference/typegate/prisma-migration/mutations#reset","content":"Type: Boolean! reset field Policies: admin_only Arguments Name\tDescriptionmigrations String migrations input field runtime String runtime input field typegraph String! typegraph input field "},{"title":"Queries","type":0,"sectionRef":"#","url":"/docs/reference/typegate/prisma-migration/queries","content":"","keywords":""},{"title":"diffâ€‹","type":1,"pageTitle":"Queries","url":"/docs/reference/typegate/prisma-migration/queries#diff","content":"Type: object_16! diff field Policies: admin_only Arguments Name\tDescriptionscript Boolean! script input field runtime String runtime input field typegraph String! typegraph input field "},{"title":"Objects","type":0,"sectionRef":"#","url":"/docs/reference/typegate/prisma-migration/objects","content":"","keywords":""},{"title":"object_16â€‹","type":1,"pageTitle":"Objects","url":"/docs/reference/typegate/prisma-migration/objects#object_16","content":"object_16 type Fields Name\tDescriptionruntimeName String! runtimeName field Policies: inherit diff String diff field Policies: inherit "},{"title":"object_23â€‹","type":1,"pageTitle":"Objects","url":"/docs/reference/typegate/prisma-migration/objects#object_23","content":"object_23 type Fields Name\tDescriptionappliedMigrations [String!]! appliedMigrations field Policies: inherit databaseReset Boolean! databaseReset field Policies: inherit "},{"title":"object_33â€‹","type":1,"pageTitle":"Objects","url":"/docs/reference/typegate/prisma-migration/objects#object_33","content":"object_33 type Fields Name\tDescriptionruntimeName String! runtimeName field Policies: inherit migrations String! migrations field Policies: inherit applyError String applyError field Policies: inherit createdMigrationName String! createdMigrationName field Policies: inherit "},{"title":"object_40â€‹","type":1,"pageTitle":"Objects","url":"/docs/reference/typegate/prisma-migration/objects#object_40","content":"object_40 type Fields Name\tDescriptionappliedMigrations [String!]! appliedMigrations field Policies: inherit migrationCount Int! migrationCount field Policies: inherit "},{"title":"Scalars","type":0,"sectionRef":"#","url":"/docs/reference/typegate/prisma-migration/scalars","content":"","keywords":""},{"title":"Booleanâ€‹","type":1,"pageTitle":"Scalars","url":"/docs/reference/typegate/prisma-migration/scalars#boolean","content":"The Boolean scalar type represents true or false. "},{"title":"Intâ€‹","type":1,"pageTitle":"Scalars","url":"/docs/reference/typegate/prisma-migration/scalars#int","content":"The Int scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. "},{"title":"Stringâ€‹","type":1,"pageTitle":"Scalars","url":"/docs/reference/typegate/prisma-migration/scalars#string","content":"The String scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. "},{"title":"Objects","type":0,"sectionRef":"#","url":"/docs/reference/typegate/typegate/objects","content":"","keywords":""},{"title":"object_13â€‹","type":1,"pageTitle":"Objects","url":"/docs/reference/typegate/typegate/objects#object_13","content":"object_13 type Fields Name\tDescriptionserialized String! serialized field Policies: inherit url String! url field Policies: inherit name String! name field Policies: inherit "},{"title":"object_23â€‹","type":1,"pageTitle":"Objects","url":"/docs/reference/typegate/typegate/objects#object_23","content":"object_23 type Fields Name\tDescriptiontext String! text field Policies: inherit type String! type field Policies: inherit "},{"title":"object_27â€‹","type":1,"pageTitle":"Objects","url":"/docs/reference/typegate/typegate/objects#object_27","content":"object_27 type Fields Name\tDescriptionmigrations String! migrations field Policies: inherit runtime String! runtime field Policies: inherit "},{"title":"object_31â€‹","type":1,"pageTitle":"Objects","url":"/docs/reference/typegate/typegate/objects#object_31","content":"object_31 type Fields Name\tDescriptionresetRequired [String!]! resetRequired field Policies: inherit migrations [object_27!]! migrations field Policies: inherit messages [object_23!]! messages field Policies: inherit name String! name field Policies: inherit "},{"title":"typegraphâ€‹","type":1,"pageTitle":"Objects","url":"/docs/reference/typegate/typegate/objects#typegraph","content":"typegraph type Fields Name\tDescriptionurl String! url field Policies: inherit name String! name field Policies: inherit "},{"title":"Mutations","type":0,"sectionRef":"#","url":"/docs/reference/typegate/typegate/mutations","content":"","keywords":""},{"title":"addTypegraphâ€‹","type":1,"pageTitle":"Mutations","url":"/docs/reference/typegate/typegate/mutations#addtypegraph","content":"Type: object_31! addTypegraph field Policies: admin_only Arguments Name\tDescriptioncliVersion String! cliVersion input field secrets String! secrets input field fromString String! fromString input field "},{"title":"removeTypegraphâ€‹","type":1,"pageTitle":"Mutations","url":"/docs/reference/typegate/typegate/mutations#removetypegraph","content":"Type: Int! removeTypegraph field Policies: admin_only Arguments Name\tDescriptionname String! name input field "},{"title":"Scalars","type":0,"sectionRef":"#","url":"/docs/reference/typegate/typegate/scalars","content":"","keywords":""},{"title":"Booleanâ€‹","type":1,"pageTitle":"Scalars","url":"/docs/reference/typegate/typegate/scalars#boolean","content":"The Boolean scalar type represents true or false. "},{"title":"Intâ€‹","type":1,"pageTitle":"Scalars","url":"/docs/reference/typegate/typegate/scalars#int","content":"The Int scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. "},{"title":"Stringâ€‹","type":1,"pageTitle":"Scalars","url":"/docs/reference/typegate/typegate/scalars#string","content":"The String scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. "},{"title":"Queries","type":0,"sectionRef":"#","url":"/docs/reference/typegate/typegate/queries","content":"","keywords":""},{"title":"typegraphâ€‹","type":1,"pageTitle":"Queries","url":"/docs/reference/typegate/typegate/queries#typegraph","content":"Type: object_13 typegraph field Policies: admin_only Arguments Name\tDescriptionname String! name input field "},{"title":"typegraphsâ€‹","type":1,"pageTitle":"Queries","url":"/docs/reference/typegate/typegate/queries#typegraphs","content":"Type: [typegraph!]! typegraphs field Policies: admin_only "},{"title":"typegraph.graph.typegraph","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/typegraph/graph/typegraph","content":"","keywords":""},{"title":"TypeGraph Objectsâ€‹","type":1,"pageTitle":"typegraph.graph.typegraph","url":"/docs/reference/typegraph/typegraph/graph/typegraph#typegraph-objects","content":"class TypeGraph()  type_by_namesâ€‹ for explicit names "},{"title":"typegraph.graph.models","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/typegraph/graph/models","content":"","keywords":""},{"title":"Auth Objectsâ€‹","type":1,"pageTitle":"typegraph.graph.models","url":"/docs/reference/typegraph/typegraph/graph/models#auth-objects","content":"@define class Auth()  Authentication options oauth2â€‹ @classmethod def oauth2(cls, name: str, authorize_url: str, access_url: str, scopes: str, profile_url: Optional[str] = None) -&gt; &quot;Auth&quot;  OAuth2 authentication jwtâ€‹ @classmethod def jwt(cls, name: str, format: str, algorithm: None) -&gt; &quot;Auth&quot;  Import a JSON Web Token for authentication. Arguments: name str - Name of the authenticationformat str - Format of the key. Can be &quot;jwk&quot;, &quot;raw&quot;, &quot;pkcs8&quot; or &quot;spki&quot;.algorithm Dict[str, str], optional - Arguments for the authentication. Defaults to None. See algorithm parameters in SubtleCrypto.importKey() for more information. Example: Generate a private/public ECDSA key pair using Deno: deno eval ' const keys = await crypto.subtle.generateKey({name: &quot;ECDSA&quot;, namedCurve: &quot;P-384&quot;}, true, [&quot;sign&quot;, &quot;verify&quot;]); const publicKey = await crypto.subtle.exportKey(&quot;jwk&quot;, keys.publicKey); // save keys.privateKey for later use console.log(JSON.stringify(publicKey)); // Auth.jwt(&quot;keycloak&quot;, &quot;jwk&quot;, {&quot;name&quot;: &quot;ECDSA&quot;, &quot;namedCurve&quot;: &quot;P-384&quot;}) ' hmac256â€‹ @classmethod def hmac256(cls, name: str) -&gt; &quot;Auth&quot;  Import a HMAC SHA-256 for authentication. Arguments: name str - Name of the authentication "},{"title":"Cors Objectsâ€‹","type":1,"pageTitle":"typegraph.graph.models","url":"/docs/reference/typegraph/typegraph/graph/models#cors-objects","content":"@define class Cors()  CORS options "},{"title":"Rate Objectsâ€‹","type":1,"pageTitle":"typegraph.graph.models","url":"/docs/reference/typegraph/typegraph/graph/models#rate-objects","content":"@define class Rate()  Rate limiting options "},{"title":"typegraph.importers.openapi","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/typegraph/importers/openapi","content":"","keywords":""},{"title":"OpenApiImporter Objectsâ€‹","type":1,"pageTitle":"typegraph.importers.openapi","url":"/docs/reference/typegraph/typegraph/importers/openapi#openapiimporter-objects","content":"class OpenApiImporter(Importer)  __init__â€‹ def __init__(name: str, *, url: Optional[str] = None, file: Optional[str] = None, base_url: Optional[str] = None, renames: Dict[str, str] = {}, keep_names: List[str] = [])  Requires either only url or file and base_url "},{"title":"Path Objectsâ€‹","type":1,"pageTitle":"typegraph.importers.openapi","url":"/docs/reference/typegraph/typegraph/importers/openapi#path-objects","content":"class Path()  gen_input_typeâ€‹ def gen_input_type(op_spec: Box) -&gt; Tuple[t.typedef, Box]  Returns a tuple of t.typedef and a box of kwargs "},{"title":"typegraph.importers.base.importer","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/typegraph/importers/base/importer","content":"","keywords":""},{"title":"Importer Objectsâ€‹","type":1,"pageTitle":"typegraph.importers.base.importer","url":"/docs/reference/typegraph/typegraph/importers/base/importer#importer-objects","content":"class Importer()  Base importer class headersâ€‹ codegen header lines __init__â€‹ def __init__(name: str, *, renames: Dict[str, str] = {}, keep_names: List[str] = [])  Arguments: name - name of the importerrenames - a dictionary mapping original (imported) names to exposed nameskeep_names - a list of names to keep as the original (imported) "},{"title":"typegraph.providers.prisma.relations","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/typegraph/providers/prisma/relations","content":"","keywords":""},{"title":"RelationshipModel Objectsâ€‹","type":1,"pageTitle":"typegraph.providers.prisma.relations","url":"/docs/reference/typegraph/typegraph/providers/prisma/relations#relationshipmodel-objects","content":"@frozen class RelationshipModel()  fieldâ€‹ field of this model pointing to the other side cardinalityâ€‹ cardinality of the field pointing to the other model "},{"title":"typegraph.providers.prisma.schema","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/typegraph/providers/prisma/schema","content":"","keywords":""},{"title":"SchemaField Objectsâ€‹","type":1,"pageTitle":"typegraph.providers.prisma.schema","url":"/docs/reference/typegraph/typegraph/providers/prisma/schema#schemafield-objects","content":"@frozen class SchemaField()  fkeysâ€‹ foreign keys "},{"title":"typegraph.providers.temporal.runtimes.temporal","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/typegraph/providers/temporal/runtimes/temporal","content":"","keywords":""},{"title":"TemporalRuntime Objectsâ€‹","type":1,"pageTitle":"typegraph.providers.temporal.runtimes.temporal","url":"/docs/reference/typegraph/typegraph/providers/temporal/runtimes/temporal#temporalruntime-objects","content":"@frozen class TemporalRuntime(Runtime)  Interacts with Temporal server. This runtime is experimental state and is subject to change. "},{"title":"typegraph.runtimes.deno","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/typegraph/runtimes/deno","content":"","keywords":""},{"title":"ImportFunMat Objectsâ€‹","type":1,"pageTitle":"typegraph.runtimes.deno","url":"/docs/reference/typegraph/typegraph/runtimes/deno#importfunmat-objects","content":"@frozen class ImportFunMat(Materializer)  runtimeâ€‹ should be the same runtime as mod's "},{"title":"ModuleMat Objectsâ€‹","type":1,"pageTitle":"typegraph.runtimes.deno","url":"/docs/reference/typegraph/typegraph/runtimes/deno#modulemat-objects","content":"@frozen class ModuleMat(Materializer)  runtimeâ€‹ DenoRuntime "},{"title":"typegraph.runtimes.http","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/typegraph/runtimes/http","content":"","keywords":""},{"title":"HTTPRuntime Objectsâ€‹","type":1,"pageTitle":"typegraph.runtimes.http","url":"/docs/reference/typegraph/typegraph/runtimes/http#httpruntime-objects","content":"@frozen class HTTPRuntime(Runtime)  Runs HTTP requests. Example: from typegraph.runtime.http import HTTPRuntime remote = HTTPRuntime('https://dev.to/api') remote.get( '/test', t.struct({}), t.array(t.struct({'a': t.integer()})), )  "},{"title":"typegraph.providers.prisma.runtimes.prisma","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/typegraph/providers/prisma/runtimes/prisma","content":"","keywords":""},{"title":"PrismaRuntime Objectsâ€‹","type":1,"pageTitle":"typegraph.providers.prisma.runtimes.prisma","url":"/docs/reference/typegraph/typegraph/providers/prisma/runtimes/prisma#prismaruntime-objects","content":"@frozen class PrismaRuntime(Runtime)  A database ORM runtime. Attributes: name - Name of prisma runtimeconnection_string_secret - Name of the secret that contains the connection string that will be used to connect to the database Example: with TypeGraph(&quot;prisma-runtime-example&quot;) as g: db = PrismaRuntime(&quot;main_db&quot;, &quot;DB_CONNECTION&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email(), } ) g.expose( createUser=db.create(user).add_policy(public) )  "},{"title":"Modelsâ€‹","type":1,"pageTitle":"typegraph.providers.prisma.runtimes.prisma","url":"/docs/reference/typegraph/typegraph/providers/prisma/runtimes/prisma#models","content":"Any t.struct that is passed to a generator of a PrismaRuntimedefines a model. Models must have an ID field specified by the &quot;id&quot; config. Here is the list of all the available configs for model fields: Config\tEffectid\tdefines the field ID for the model (a.k.a. primary key) auto\tthe value of this field can be auto generated; supported for t.integer() (auto-increment) and t.uuid() unique\tmake this field unique among all instances of the model "},{"title":"Relationshipsâ€‹","type":1,"pageTitle":"typegraph.providers.prisma.runtimes.prisma","url":"/docs/reference/typegraph/typegraph/providers/prisma/runtimes/prisma#relationships","content":"Relationship fields must be defined on both sides of the relationship. A relationship is always defined for t.struct types and t.optional ort.array of t.structs. Relatioships can also be defined implicitly using the link instance method of PrismaRuntime. Example: runtime = PrismaRuntime(&quot;example&quot;, &quot;POSTGRES&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email().config(&quot;unique&quot;), &quot;posts&quot;: t.array(g(&quot;Post&quot;)), } ).named(&quot;User&quot;) post = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;title&quot;: t.string(), &quot;author&quot;: g(&quot;User&quot;), } ).named(&quot;Post&quot;)  The PrismaRuntime supports two kinds of relationship between models. One-to-one relationshipsâ€‹ A one-to-one relationship must be in one of these two variants. Cardinality\tField type in Model1\tField type in Model21..1 â†” 0..1\tg(&quot;Model2&quot;)\tg(&quot;Model1&quot;).optional() 0..1 â†” 0..1\tg(&quot;Model2&quot;).optional()\tg(&quot;Model1&quot;).optional() For the optional (0..1 â†” 0..1) one-to-one relationship, you need to indicate on which field/model the foreign key will be by: wrapping the type in a runtime.link(.) with fkey=True:runtime.link(g(&quot;Model2&quot;).optional(), fkey=True); or adding .config(&quot;unique&quot;): g(&quot;Model2&quot;).optional().config(&quot;unique&quot;). One-to-many relationshipsâ€‹ A one-to-many relationship must be in one of these two variants. Cardinality\tField type in Model1\tField type in Model21..1 â†” 0..n\tg(&quot;Model2&quot;)\tt.array(g(&quot;Model1&quot;)) 0..1 â†” 0..n\tg(&quot;Model2&quot;).optional()\tt.array(g(&quot;Model1&quot;)) Generatorsâ€‹ Generators are instance methods of PrismaRuntime that can be used to generate a t.func that represents a specific operation on a specific model of the runtime. They match to the model queries defined for theprisma client API. for the type of the input t.struct and the return type. Example: with TypeGraph(&quot;prisma-runtime-example&quot;) as g: db = PrismaRuntime(&quot;main_db&quot;, &quot;DB_CONNECTION&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email(), } ) g.expose( createUser=db.create(user).add_policy(public), findUser=db.find_unique(user).add_policy(public), findManyUsers=db.find_many(user).add_policy(public), )  Here is a list of all available generators: find_uniquefind_manycreateupdatedeletedelete_many linkâ€‹ def link(typ: Union[t.TypeNode, str], name: Optional[str] = None, *, field: Optional[str] = None, fkey: Optional[bool] = None) -&gt; t.TypeNode  Explicitly declare a relationship between models. The return value of this function shall be the type of a property of a t.struct that defines a model. If the other end of the relationship is also defined using link, both links must have the same name. Arguments: name - name of the relationshipfield - name of the target field on the target model Example: runtime = PrismaRuntime(&quot;example&quot;, &quot;POSTGRES&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email().config(&quot;unique&quot;), &quot;posts&quot;: runtime.link(t.array(g(&quot;Post&quot;)), &quot;postAuthor&quot;), } ).named(&quot;User&quot;) post = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;title&quot;: t.string(), &quot;author&quot;: runtime.link(g(&quot;User&quot;), &quot;postAuthor&quot;), } ).named(&quot;Post&quot;)  raw_queryâ€‹ def raw_query(query: str, out: t.TypeNode, *, effect: Effect) -&gt; t.func  Generate a raw SQL query operation on the runtime Example: db = PrismaRuntime(&quot;my-app&quot;, &quot;POSTGRES&quot;) g.expose( countUsers=db.raw_query(&quot;SELECT COUNT(*) FROM User&quot;, t.integer()) )  raw_executeâ€‹ def raw_execute(query: str, *, effect: Effect) -&gt; t.func  Generate a raw SQL query operation without return Example: db = PrismaRuntime(&quot;my-app&quot;, &quot;POSTGRES&quot;) g.expose( setActive=db.raw_execute(&quot;UPDATE User SET active = TRUE WHERE id=$1&quot;, effect=effects.update()), )  "},{"title":"typegraph.runtimes.wasmedge","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/typegraph/runtimes/wasmedge","content":"","keywords":""},{"title":"WasmEdgeRuntime Objectsâ€‹","type":1,"pageTitle":"typegraph.runtimes.wasmedge","url":"/docs/reference/typegraph/typegraph/runtimes/wasmedge#wasmedgeruntime-objects","content":"@frozen class WasmEdgeRuntime(Runtime)  Runs Wasm functions on the WasmEdge runtime. Experimental "},{"title":"Adding more runtimes","type":0,"sectionRef":"#","url":"/docs/tutorials/adding-more-runtimes","content":"","keywords":""},{"title":"Prisma runtimeâ€‹","type":1,"pageTitle":"Adding more runtimes","url":"/docs/tutorials/adding-more-runtimes#prisma-runtime","content":"Prisma is a &quot;Next-generation Node.js and Typescript ORM&quot; that support for PostgreSQL, MySQL/MariaDB, SQLite, MongoDB, CockroadDB and Microsoft SQL Server. It is one of the main runtimes provided by Metatype and doesn't require any additional installation. Go ahead and update typegraph.py with the highlighted lines below: Loading... A few things to note on the changes: You can import runtimes from typegraph.runtime.Y or typegraph.providers.X.runtimes.Y for non-core providers.The config method allows to specify runtime specific attributes. In this case, id shall be automatically set and incremented by the database.Types get generated names unless you manually specify them. You can find the exact names in the playground documentation. Here you want to have a human friendly name as it will also be the name of the table in your database.Runtimes often come with some sugar syntax to generate types and avoid manipulating materializers directly. A corresponding declaration would have looked like this: t.func( t.struct( { &quot;data&quot;: t.struct( { # notice to absence of `id` as automatically generated &quot;title&quot;: t.string(), &quot;body&quot;: t.string(), } ) } ), t.array(message), PrismaOperationMat( db, &quot;Message&quot;, &quot;createOne&quot;, effect=effects.create(), ), )  In order to use the Prisma runtime, you need to add a new environment variable to the typegate and restart the docker container. Runtimes don't take raw secrets, but instead a secret key used to look up environment variables named under the format TG_[typegraph name]_[key]. You also need to run a separate command to generate the database migration. cat docker-compose.yml #services: # .. # environment: # TG_DATABASE_POSTGRES_CONN: postgres://postgres:password@postgres:5432/db docker compose down docker compose up -d meta prisma dev database # you need to mention the typegraph name, in this case `database`  And now, you can iteratively continue to improve your interface, running migrations and having data stored inside your database. "},{"title":"GraphQL runtimeâ€‹","type":1,"pageTitle":"Adding more runtimes","url":"/docs/tutorials/adding-more-runtimes#graphql-runtime","content":"You currently have a single model to describe messages sent in the chat-based app. A reasonable next step is to add a user model and make a link between the two. While you can store users in the same database, it's wiser to avoid data duplication and re-use your service for user management available at GraphQLZero endpoint. Lets introduce the GraphQL runtime that allows remote GraphQL queries. Update typegraph.py with the highlighted lines below: Loading... Again, a few interesting happened here: No need to run meta prisma dev [typegraph name] again. The field user comes from another runtime and doesn't exist in the database. The typegate will orchestrate the query execution in all runtimes and minimize the work done.The from_parent rule automatically fills the input type with the parent field named uid. The g(Â·) rule allows to make named reference to another type and avoid circular reference. Other type enforcement rules also exists: from_secret(key) to fill the input type with the secret in the TG_[typegraph name]_[key] formatfrom_context(Â·) to fill the input type with content from the request context, such as JSON Web Token (JWT), etc.set(x) to fill the input type with content x You should now start to see the power provided by Metatype and might wonder how to integrate it step by step with your existing systems. Writing all those types by hand is tedious and error prone. The next section will show you how to generate types from existing sources. "},{"title":"typegraph.types","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/typegraph/types","content":"","keywords":""},{"title":"number Objectsâ€‹","type":1,"pageTitle":"typegraph.types","url":"/docs/reference/typegraph/typegraph/types#number-objects","content":"@with_constraints @frozen class number(typedef)  Represents a generic number. Arguments: _min float, optional - minimum constraint_max float, optional - maximum constraint_x_min float, optional - exclusive minimum constraint_x_max float, optional - exclusive maximum constraint_multiple_of float, optional - number must be a multiple of "},{"title":"integer Objectsâ€‹","type":1,"pageTitle":"typegraph.types","url":"/docs/reference/typegraph/typegraph/types#integer-objects","content":"@frozen class integer(number)  An integer. "},{"title":"union Objectsâ€‹","type":1,"pageTitle":"typegraph.types","url":"/docs/reference/typegraph/typegraph/types#union-objects","content":"@frozen class union(typedef)  A union type represents a general union with the variants provided. The union type is equivalent to the anyOf field in JSON Schema where the given data must be valid against one or more of the given subschemas. "},{"title":"either Objectsâ€‹","type":1,"pageTitle":"typegraph.types","url":"/docs/reference/typegraph/typegraph/types#either-objects","content":"@frozen class either(typedef)  An either type represents a disjoint union with the variants provided. The either type is equivalent to the oneOf field in JSON Schema where the given data must be valid against exactly one of the given subschemas. "},{"title":"Authentication and security","type":0,"sectionRef":"#","url":"/docs/tutorials/authentication-and-security","content":"","keywords":""},{"title":"CORSâ€‹","type":1,"pageTitle":"Authentication and security","url":"/docs/tutorials/authentication-and-security#cors","content":"Cross-Origin Resource Sharing (CORS) on the one hand is a mechanism that allows or denies cross-origin requests in the browser. It avoid that other websites use your API without explicitly allowing it. Note that it doesn't protect other servers or a mobile app from using your typegraphs, only browsers implements the CORS mechanism. See this documentation for the details. Loading... If your browser support well CORS, you should see an error and even more if you try to run the interactive demo. By the way, there is a hidden core header in all interactive demos: TypeGraph.Cors(allow_origin=[&quot;https://metatype.dev&quot;, &quot;http://localhost:3000&quot;])  "},{"title":"Authenticationâ€‹","type":1,"pageTitle":"Authentication and security","url":"/docs/tutorials/authentication-and-security#authentication","content":"Metatype supports multiple authentication schemes like Basic Auth, JSON Web Tokens (JWT) and OAuth2. This enable every request to have a context and store some information about the user. You can then use the context to set specific fields with from_context or as you will see next step, to restrict some accesses via the policies. For Basic Auth, well, it's basic. The context contains a field user with its name. For JWT, it supports parsing from the cookie or the Authorization header and loads the context with the claims. For OAuth2, the typegate provide some helpers to obtain the access token and renew them, either in the cookie - this works only when on the same subdomain due to third-party cookies restrictions - or in the Authorization header. Once setup, you can redirect your users to http://localhost:7890/[typegraph]/auth/[auth name] and the OAuth2 flow will be handled for you. The context will contains the user info of the provider. You can test it by setting up a GitHub OAuth2 App or try with the flow with the demo. Loading... Some OAuth2 providers are already ready to use for you in typegraph.graph.auth.oauth2, no need to gather URL and scopes each time. "},{"title":"Rate limitingâ€‹","type":1,"pageTitle":"Authentication and security","url":"/docs/tutorials/authentication-and-security#rate-limiting","content":"The rate limiting algorithm works as follows: each function type can either count the # of calls it gets or the # of results returned rate_calls=Falseeach function type can have a weight rate_weight=1each request is identified by its IP or by one value of its context if set context_identifiera single query can score a maximum of query_limitmultiple queries can sum up to window_limit in a window_sec windowwhen there is multiple typegates (N), you can improve performance by avoiding score synchronizing while the typegate has not reach local_excess: the real maximum score is thus window_limit + min(local_excess, query_limit) * N Loading... Playing with the above should allow you to quickly hit the limits. "},{"title":"Import your API blocks","type":0,"sectionRef":"#","url":"/docs/tutorials/import-your-api-blocks","content":"","keywords":""},{"title":"Google importersâ€‹","type":1,"pageTitle":"Import your API blocks","url":"/docs/tutorials/import-your-api-blocks#google-importers","content":"The typegraph module comes with some handy importers to avoid having to rewrite manually all types and materializers. Currently, it supports importers for OpenAPI, GraphQL API and Google APIs. Beta/unstable feature Importers are quite recent and likely to evolve as feedback is received. Your voice and use cases matter a lot, let Metatype community know what suits you the best in this discussion. Importers are function call with a boolean re-writing the source code file where they live. As they can generate quite long type definition, the best practice is to separate them into a dedicated file that can be imported into your main typegraph. Lets create google.py and run python google.py to generate the types. from typegraph.importers.google_discovery import GoogleDiscoveryImporter GoogleDiscoveryImporter( &quot;googleapi&quot;, url=&quot;https://fcm.googleapis.com/$discovery/rest?version=v1&quot; ).imp(False)  This should generate code similar to this: # ... def import_googleapi(): # ... types[&quot;MessageOut&quot;] = t.struct( { &quot;apns&quot;: t.proxy(renames[&quot;ApnsConfigOut&quot;]).optional(), &quot;notification&quot;: t.proxy(renames[&quot;NotificationOut&quot;]).optional(), &quot;token&quot;: t.string().optional(), &quot;name&quot;: t.string().optional(), &quot;fcmOptions&quot;: t.proxy(renames[&quot;FcmOptionsOut&quot;]).optional(), &quot;data&quot;: t.struct({&quot;_&quot;: t.string().optional()}).optional(), &quot;android&quot;: t.proxy(renames[&quot;AndroidConfigOut&quot;]).optional(), &quot;condition&quot;: t.string().optional(), &quot;topic&quot;: t.string().optional(), &quot;webpush&quot;: t.proxy(renames[&quot;WebpushConfigOut&quot;]).optional(), &quot;error&quot;: t.proxy(renames[&quot;ErrorResponse&quot;]).optional(), } ).named(renames[&quot;MessageOut&quot;]) # ... return Import( importer=&quot;googleapi&quot;, renames=renames, types=types, functions=functions )  And can be imported/customized in your main typegraph file: Loading... "},{"title":"Effectsâ€‹","type":1,"pageTitle":"Import your API blocks","url":"/docs/tutorials/import-your-api-blocks#effects","content":"Effects are a property of materializers and help categorization what happens to data when it gets transformed. Although they are similar to REST verbs and SQL statements, there is no direct one-to-one mapping. Effects\tREST verbs\tSQL statementsnone\tGET\tSELECT create\tPOST\tINSERT update\tPUT/PATCH\tUPDATE upsert\tPUT\tINSERT ON CONFLICT delete\tDELETE\tDELETE They provide hints to the typegates for the query orchestration by splitting the queries and mutations. For example, the create effect is exposed as a mutation. They also allow to set different policies based on them, that's for the next page. "},{"title":"Policies and materializers","type":0,"sectionRef":"#","url":"/docs/tutorials/policies-and-materializers","content":"","keywords":""},{"title":"Deno runtimeâ€‹","type":1,"pageTitle":"Policies and materializers","url":"/docs/tutorials/policies-and-materializers#deno-runtime","content":"While the tutorial covered already interesting runtimes, allowing you to connect to already a lots of systems and different protocols, there is still one powerful that wasn't covered yet: the typescript or Deno runtime. This enable to run lightweight and short-lived typescript function in a sandboxed environment. Permissions can be customized per typegraph and by default only include some HTTPs domains. It's a great way to implement custom logic and materializers. All typegraphs can lazily spawn a web worker and get an incredible cold-start and continuous performance thanks to the V8 engine powering Deno. Loading... "},{"title":"Policy based access control (PBAC)â€‹","type":1,"pageTitle":"Policies and materializers","url":"/docs/tutorials/policies-and-materializers#policy-based-access-control-pbac","content":"The Deno runtime enable to understand the last abstraction. Policies are a way to verify for each type whether the user is authorized or not to access it. It's a very powerful concept that can be for instance used to guarantee a given type is never accidentally exposed to the outside world. Metatype comes with some built-in policies but you can use the Deno runtime to define your own: policies.public() is an alias for Policy(PureFunMat(&quot;() =&gt; true&quot;)) providing everyone open access.policies.jwt(&quot;role_value&quot;, &quot;role_field&quot;) is a companion policy for the authentication strategy you learnt in the previous section. It will verify the context and give adequate access to the user. Policies are hierarchical in the sense that the request starts with a deny, and the root materializers must explicitly provide an access or not. Once access granted, any further types can either inherit or override the access. Policies evaluate in order in case multiple ones are defined. Loading... Enough studied, lets go back to your app and finalize it. "},{"title":"Getting started","type":0,"sectionRef":"#","url":"/docs/tutorials/getting-started","content":"","keywords":""},{"title":"Introductionâ€‹","type":1,"pageTitle":"Getting started","url":"/docs/tutorials/getting-started#introduction","content":"In this tutorial, you will write your first typegraph and deploy it on a typegate node using the Meta CLI. You will design some API blocks for a chat-based app where users can exchange messages. Running the ecosystem requires Python &gt;=3.8 which should be available on most of the recent OS. Python &gt;=3.8 not yet installed? Follow these steps. Debian-based LinuxMacOSWindows sudo apt-get update sudo apt-get install python3 python3-pip python3-venv Then verify that you have a version higher than 3.8: python --version # or python3 --version &gt; Python 3.8.16  No previous Python knowledge required. While the definition of typegraphs is currently done in Python, it doesn't require previous experience writing Python. The tutorial covers all the basics and doesn't use advanced features of the language. "},{"title":"Quickstart with Metatype Cloudâ€‹","type":1,"pageTitle":"Getting started","url":"/docs/tutorials/getting-started#quickstart-with-metatype-cloud","content":"This is the easiest way to get started, yet it's not publicly accessible. You can sign-up for the private beta below.  "},{"title":"Quickstart with Dockerâ€‹","type":1,"pageTitle":"Getting started","url":"/docs/tutorials/getting-started#quickstart-with-docker","content":"Docker not yet installed? Follow these steps. Debian-based LinuxMacOSWindows curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh  "},{"title":"1. meta CLIâ€‹","type":1,"pageTitle":"Getting started","url":"/docs/tutorials/getting-started#1-meta-cli","content":"You can download the binary executable fromreleases page on GitHub, make it executable and add it to your $PATH or useeget to automate those steps. eget metatypedev/metatype --to $HOME/.local/bin meta --help meta upgrade # to upgrade to the latest version  "},{"title":"2. typegraph packageâ€‹","type":1,"pageTitle":"Getting started","url":"/docs/tutorials/getting-started#2-typegraph-package","content":"Create (and activate) the virtual environment (a local folder where you install the dependency of a project) for your project. Then install the typegraph package from PyPi using pip. python3 -m venv .venv source .venv/bin/activate pip3 install typegraph --upgrade meta doctor # to check version  "},{"title":"3. typegate nodeâ€‹","type":1,"pageTitle":"Getting started","url":"/docs/tutorials/getting-started#3-typegate-node","content":"Finally, download and launch the docker-compose manifest running a typegate node, a Redis instance (this is the sole dependency of the typegate) and a Postgres instance to store the app's messages. meta new your-folder cd your-folder docker compose up --detach curl -X POST http://localhost:7890/typegate \\ -H 'Authorization: Basic YWRtaW46cGFzc3dvcmQ=' \\ # base64 encoded &quot;admin:password&quot; --data '{&quot;query&quot;:&quot;query list { typegraphs { name }}&quot;}'  And go the next section. "},{"title":"Source installationâ€‹","type":1,"pageTitle":"Getting started","url":"/docs/tutorials/getting-started#source-installation","content":"Alternatively, you can install directly the typegraph package and the CLI from the GitHub repository (useful to check out unreleased features). pip3 install --upgrade git+https://github.com/metatypedev/metatype#subdirectory=typegraph cargo install --force meta-cli --git https://github.com/metatypedev/metatype --locked  "},{"title":"Your chat app","type":0,"sectionRef":"#","url":"/docs/tutorials/your-chat-app","content":"","keywords":""},{"title":"Your first typegraph","type":0,"sectionRef":"#","url":"/docs/tutorials/your-first-typegraph","content":"","keywords":""},{"title":"Zooming on the typesâ€‹","type":1,"pageTitle":"Your first typegraph","url":"/docs/tutorials/your-first-typegraph#zooming-on-the-types","content":"There is no &quot;object&quot; or &quot;primitive&quot; type, only 4 main categories of types: value types: t.integer(), t.string(), t.uuid(), etc.quantifier types: t.optional(Â·), t.array(Â·), etc.consolidator types: t.struct(Â·, Â·), t.union(Â·, Â·), etc.function types: t.func(Â· â†’ Â·), t.policy(Â· â†’ Â·), etc. You can combine them with each other to describe almost any data type you may need. The typegate enforces the data validation when data flows through it. Some syntactic sugar is available to make the type definition shorter: t.struct( { &quot;name&quot;: t.string().max(200), &quot;age&quot;: t.optional(t.integer()), # or t.integer().optional() &quot;messages&quot;: t.array(t.struct({&quot;text&quot;: t.string(), &quot;sentAt&quot;: t.datetime()})), } ) # the typegate will accept data as follow { &quot;name&quot;: &quot;Alan&quot;, &quot;age&quot;: 28, &quot;messages&quot;: [{&quot;text&quot;: &quot;Hello!&quot;, &quot;sentAt&quot;: &quot;2022-12-28T01:11:10Z&quot;}], } # and reject invalid data {&quot;name&quot;: &quot;Turing&quot;, &quot;messages&quot;: [{&quot;sentAt&quot;: 1}]}  "},{"title":"The typegraph packageâ€‹","type":1,"pageTitle":"Your first typegraph","url":"/docs/tutorials/your-first-typegraph#the-typegraph-package","content":"The typegraph package is a Python package that allows to describe a full typegraph. It's a thin wrapper around the type system, and provides a few helpers to make the typegraph definition easier. It builds on the type system to provide some more building blocks: what data types exists â†’ value, quantifier, consolidator typeshow these data get transformed â†’ function types and materializers that specify the transformationwhere these data and transformations run â†’ runtimes metadata that describe materializers operatewho can access them â†’ a special case of function types named policies that control accesses This tutorial will cover these abstractions concept by concept and show how to use them by example. Code sample are interactive You can interact with most of the typegraph in the documentation. Some parts might be voluntary hidden and full source can be found on GitHub. Click on &quot;edit this page&quot; to jump there and look into the parent folder. A complete typegraph definition may look like the following: Loading... To start with the chat app design, copy the typegraph into a file named typegraph.py next to your docker-compose.yml file. "},{"title":"The meta CLIâ€‹","type":1,"pageTitle":"Your first typegraph","url":"/docs/tutorials/your-first-typegraph#the-meta-cli","content":"The meta CLI use a YAML configuration file to source some information and avoid typing the same arguments over and over again. Copy the following into named metatype.yml also next to previous files: typegates: dev: url: &quot;http://localhost:7890&quot; # default values username: admin password: password typegraphs: python: include: &quot;**/*.py&quot;  At this point, you should have everything ready for your first typegraph. Run the following command in your terminal: ls -1a # ./ # ../ # .venv/ # docker-compose.yml # metatype.yml # typegraph.py meta dev # Loaded 1 typegraph from ./typegraph.py: # â†’ Pushing typegraph first-typegraph... # âœ“ Success!  You can now open http://localhost:7890/first-typegraph in your browser. The CLI will automatically watch for changes in the typegraph and reload the typegraph. You should see a GraphQL playground with a query editor and some auto-generated documentation clicking the top-left menu item. Congrats, you can now to play with your first typegraph!  "},{"title":"External typescript functionâ€‹","type":1,"pageTitle":"Your chat app","url":"/docs/tutorials/your-chat-app#external-typescript-function","content":"The Deno runtime can register external files for longer functions. You can use the meta CLI to generate the types once the ModuleMat has been defined in your typegraph: meta codegen deno -f typegraph.py. import * as emoji from &quot;https://deno.land/x/emoji@0.2.1/mod.ts&quot;; interface ISend { title: string; } export default async function ( { title }: ISend, { self, context }, ): Promise&lt;boolean&gt; { const text = `New message: ${title} from ${context.user.name} ${ emoji(&quot;coffee&quot;) }`; const message = await fetch( self, { method: &quot;POST&quot;, headers: { accept: &quot;application/json&quot;, &quot;content-type&quot;: &quot;application/json&quot;, &quot;x-metatype-key&quot;: self, // forward internal key }, body: JSON.stringify({ query: ` mutation db($title: String!, $user_id: Int!) { create_message(data: {title: $title, user_id: $user_id}) { } `, variables: { title: text, user_id: context.user.id }, }), }, ).then((r) =&gt; r.json()); console.log(`created message ${message.data.db.create_message.id}`); const notif = await fetch( self, { method: &quot;POST&quot;, headers: { accept: &quot;application/json&quot;, &quot;content-type&quot;: &quot;application/json&quot;, &quot;x-typegate-key&quot;: self, }, body: JSON.stringify({ query: ` mutation fcm { send_notification } `, variables: {}, }), }, ).then((r) =&gt; r.json()); console.log(`created notif ${notif.data.fcm.send_notification}`); return true; }  "},{"title":"Connecting the pieces togetherâ€‹","type":1,"pageTitle":"Your chat app","url":"/docs/tutorials/your-chat-app#connecting-the-pieces-together","content":"Take the learning of the last sections and use at your advantage the internal policies allowing to made calls within the Deno runtime and keeping the same context. Loading... That's it, you just developed chat-based API block for your app - naive for sure, but covering most of the feature of Metatype. "},{"title":"Backend for frontend","type":0,"sectionRef":"#","url":"/use-cases/backend-for-frontend","content":"","keywords":""},{"title":"Case studyâ€‹","type":1,"pageTitle":"Backend for frontend","url":"/use-cases/backend-for-frontend#case-study","content":" Imagine you have a web frontend and a mobile app that both consume data from a (micro)services-based backend. The web frontend requires certain data fields in a format B, and the mobile app requires the same field plus additional ones in format B. In a traditional architecture, both the web and mobile frontends would have to make separate API calls to the (micro)services, and then format the data into the appropriate structure themselves. This can lead to duplicated code, increased latency due heavier calls with non-necessary data, and decreased developer efficiency. With a BFF in place, it handles the formatting of the data based on the specific needs of each client. All frontends can thus make a single API call to the BFF, which then communicates with the (micro)services, retrieves the data, and formats it into the required structure before returning it to the frontend. "},{"title":"Metatype's solutionâ€‹","type":1,"pageTitle":"Backend for frontend","url":"/use-cases/backend-for-frontend#metatypes-solution","content":"Metatype can act as a generic BFF component, serving multiple dedicated APIs and handling security, authentication and authorization for you. By encapsulating the logic for communicating with the (micro)services, Metatype helps to ensure that the frontends are as decoupled as possible from the other services, making it easier to make changes to either the frontend or the backend without affecting the other side. Loading... "},{"title":"Automatic CRUD & validation","type":0,"sectionRef":"#","url":"/use-cases/automatic-crud-validation","content":"","keywords":""},{"title":"Case studyâ€‹","type":1,"pageTitle":"Automatic CRUD & validation","url":"/use-cases/automatic-crud-validation#case-study","content":" Let's say you are developing a web application for a retail store that allows customers to place orders online. In this scenario, you would need to use CRUD operations to create, read, update, and delete data related to orders, customers, products, and inventory. You would have to model each of these entities as a data type, define the operations that can be performed on them and write the code to ensure the correctness of the data processed in the operations. For example, you would need to define a Customer type with the following fields: id, name, email, and address. You would also need to define the operations that can be performed on the Customer type, such as createCustomer, updateCustomer, and deleteCustomer. You would also need to write the code to validate the data in the createCustomer operation to ensure that the customer's email address is valid and that the customer's address is not empty. Same for the other fields. "},{"title":"Metatype's solutionâ€‹","type":1,"pageTitle":"Automatic CRUD & validation","url":"/use-cases/automatic-crud-validation#metatypes-solution","content":"Metatype simplifies the development of CRUD APIs by providing the Prisma runtime that automates the creation of the API for CRUD operations and corresponding data validation. It can even validate some advanced types like email which may not be supported by downstream system (like database that often store email address into plain string field). This makes it faster for developers to create scalable CRUD APIs and enable them to focus their expertise where it matters most like checkout or search capabilities. Loading... "},{"title":"Function-as-a-service runner","type":0,"sectionRef":"#","url":"/use-cases/faas-runner","content":"","keywords":""},{"title":"Case studyâ€‹","type":1,"pageTitle":"Function-as-a-service runner","url":"/use-cases/faas-runner#case-study","content":" For example, imagine we have an e-commerce application that uses FaaS to process orders. When a customer places an order, multiple functions may need to be executed, such as validating the order, processing the payment, and updating the inventory. Each function may be executed independently by the FaaS platform and may take varying amounts of time to complete. Those functions may also be executed for historical reason on different platforms like AWS Lambda, Google Cloud Functions, or Azure Functions. To collect the results of all the functions in a timely manner, we need to ensure that each function is executed in the correct order and that we are not waiting for a slow function to complete before moving on to the next function. "},{"title":"Metatype's solutionâ€‹","type":1,"pageTitle":"Function-as-a-service runner","url":"/use-cases/faas-runner#metatypes-solution","content":"To solve the use case of executing multiple functions and collecting their results, Metatype provides two key features. Function composition/chaining: functions can be chained together to form a pipeline. The output of one function can be used as the input of the next function in the pipeline. This allows us to execute multiple functions in a specific order. Embedded runner: you can easily write a function that glues together multiple functions and executes them in a specific order. This allows you to execute multiple functions in a specific order. Currently, both Python and Typescript are supported. Loading... "},{"title":"IAM provider","type":0,"sectionRef":"#","url":"/use-cases/iam-provider","content":"","keywords":""},{"title":"Case studyâ€‹","type":1,"pageTitle":"IAM provider","url":"/use-cases/iam-provider#case-study","content":" Suppose a developer is building a social media platform that allows users to post updates and view other users' profiles. The developer wants to ensure that only authenticated users can access the platform's resources, and that each user can only access their own data. To achieve this, the developer can use OAuth2 for user authentication and access control. OAuth2 allows users to log in using their Google or GitHub credentials, which are verified by Google or GitHub's IAM system. Once the user is authenticated, the social media platform can use OAuth2 to obtain an access token, which is used to authorize the user's access to the platform's resources. The social media platform can also use IAM to control access to resources based on user roles and permissions. For example, only authenticated users can access the platform's resources, and each user can only access their own data. "},{"title":"Metatype's solutionâ€‹","type":1,"pageTitle":"IAM provider","url":"/use-cases/iam-provider#metatypes-solution","content":"Metatype comes with a built-in IAM provider that can be used to manage user identities and their authorized privileges within a system. It supports any OpenID/OAuth2 provider and includes a list of pre-configured ones like Google, GitHub, Facebook, Twitter or LinkedIn. You can also use your own identity provider and rely on JSON Web Tokens (JWT) for authentication. Once the user is authenticated, you can use policy access based control (PBAC) to control access to resources based on user identifies and permissions. For example, only authenticated users can access the platform's resources, and each user can only access their own data. Policies can be defined by any function, and run on or off Metatype. Loading... "},{"title":"All-in-one GraphQL server","type":0,"sectionRef":"#","url":"/use-cases/graphql-server","content":"","keywords":""},{"title":"Case studyâ€‹","type":1,"pageTitle":"All-in-one GraphQL server","url":"/use-cases/graphql-server#case-study","content":" Suppose you are building a subscription platform with a GraphQL API. You need to design a schema that accurately represents the available products, their attributes, and the operations that clients can perform, such as searching, filtering, and sorting. You also need to optimize the performance of complex queries that involve joining multiple data sources, such as products, categories, and user preferences. Additionally, you need to implement caching and pagination to improve the performance and scalability of your API. Finally, you need to ensure that your API is secure and implements appropriate authentication and authorization mechanisms to protect sensitive data and operations. Some challenges like the N+1 problem (when a single query results in multiple nested queries, each of which requires a separate database or API call) can also make the development of GraphQL resolver slow and complex to manage. "},{"title":"Metatype's solutionâ€‹","type":1,"pageTitle":"All-in-one GraphQL server","url":"/use-cases/graphql-server#metatypes-solution","content":"Metatype's approach is to focus on schema design solely, and leave the GraphQL resolver implementation to the engine. By providing where the data is stored and how to access it, the queries are optimized by the engine to minimize the number of external API/database calls and to cache the results. This can be seen as a declarative GraphQL servers, where the server is orchestrated everything for you. Metatype also comes with pre-built functionalities like authentication, authorization, and rate limiting. Loading... "},{"title":"(Micro)services orchestration","type":0,"sectionRef":"#","url":"/use-cases/microservice-orchestration","content":"","keywords":""},{"title":"Case studyâ€‹","type":1,"pageTitle":"(Micro)services orchestration","url":"/use-cases/microservice-orchestration#case-study","content":" Let's say your company develop a healthcare platform and that one of the microservices is responsible for handling patient records (owned by team A), and another microservice is responsible for handling appointment scheduling (owned by team B). When a patient schedules an appointment, the appointment scheduling microservice needs access to the patient's records to ensure that the appointment is scheduled with the right provider and that the provider has the necessary information to provide effective care. However, since patient records contain sensitive information, it is important to ensure that only authorized users have access to them. To achieve this, the healthcare platform must use authentication and authorization on each API, which allows sharing only required information. "},{"title":"Metatype's solutionâ€‹","type":1,"pageTitle":"(Micro)services orchestration","url":"/use-cases/microservice-orchestration#metatypes-solution","content":"Metatype can act as a central entry point for all incoming requests and responses between the microservices themselves and external clients. It is responsible for routing requests to the appropriate microservices and handling responses from those microservices, while verifying the authentication and authorization for each request. Additionally, Metatype gateway can provide other important features such as rate limiting, caching, and request/response transformations. It can even provide an API from another typegraph and delegate the query processing to it. Loading... "},{"title":"ORM for the edge","type":0,"sectionRef":"#","url":"/use-cases/orm-for-the-edge","content":"","keywords":""},{"title":"Case studyâ€‹","type":1,"pageTitle":"ORM for the edge","url":"/use-cases/orm-for-the-edge#case-study","content":" Suppose you are building a mobile app that allows users to order food from local restaurants. To provide a low-latency user experience, you want to run your server-side logic as close as possible to your users. You can deploy your functions across multiple locations on distributed edge servers. For database interactions, you may need a lightweight relay API to remains compatible with the platform and offer an efficient interface like an ORM provide. When a user makes a request to view the menu or place an order, the corresponding function running on the edge will make a request to the lightweight relay API to retrieve or modify the relevant data in the database. "},{"title":"Metatype's solutionâ€‹","type":1,"pageTitle":"ORM for the edge","url":"/use-cases/orm-for-the-edge#metatypes-solution","content":"Metatype can act out of the box as a lightweight relay API, simplifying database interactions via HTTP/GraphQL requests, and allowing you to query your database through the Prisma runtime. Prisma is a well-known ORM library that provides a convenient interface to interact with PostgreSQL, MySQL, SQLite, SQL Server, MongoDB, CockroachDB databases. Loading... "},{"title":"Programmable API gateway","type":0,"sectionRef":"#","url":"/use-cases/programmable-api-gateway","content":"","keywords":""},{"title":"Case studyâ€‹","type":1,"pageTitle":"Programmable API gateway","url":"/use-cases/programmable-api-gateway#case-study","content":" Suppose that your company needs to implement various policies and logic to manage and secure its APIs, such as rate limiting, caching, and request/response transformations. To achieve this, the company can adopt a programmable API gateway that allows developers to create and deploy custom function to implement additional logic and policies for incoming requests and outgoing responses. It also provides a platform for the company to manage its API infrastructure more efficiently and flexibly. Developers can leverage existing libraries and frameworks to quickly build and deploy custom logic, reducing the time and effort required to develop and maintain the API gateway. "},{"title":"Metatype's solutionâ€‹","type":1,"pageTitle":"Programmable API gateway","url":"/use-cases/programmable-api-gateway#metatypes-solution","content":"Metatype provide a Python SDK for developers to create and deploy custom logic and policies, which can later be deployed to the gateway in a single command line. Importers can also be used to import existing API or logic definitions from other sources, such as OpenAPI, GraphQL, and gRPC. This enables developer to quickly build and deploy any update the API or the business logic without having to worry about the underlying infrastructure. Loading... "}]