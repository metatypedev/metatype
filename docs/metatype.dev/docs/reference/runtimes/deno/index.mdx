# Deno/typescript

import CodeBlock from "@theme/CodeBlock";
import TGExample from "@site/src/components/TGExample";

## Deno runtime

The DenoRuntime allows you to run lightweight and short-lived typescript function in a sandboxed environment. Permissions can be customized per typegraph and by default only include some HTTPs domains. It's a great way to implement custom logic and functions. All typegraphs can lazily spawn a web worker and get an incredible cold-start and continuous performance thanks to the V8 engine powering Deno.

<TGExample
  typegraph="deno"
  typescript={require("!!code-loader!../../../../../../examples/typegraphs/deno.ts")}
  python={require("!!code-loader!../../../../../../examples/typegraphs/deno.py")}
  query={require("./deno.graphql")}
/>

Instead of providing the typescript code inline, we can also point to a file on disk:

```python
# my_typegraph.py

from typegraph import typegraph, Policy, t, Graph
from typegraph.runtimes.deno import DenoRuntime, DenoModule

@typegraph()
def deno(g: Graph):
    public = Policy.public()
    deno = DenoRuntime()

    g.expose(
        public,
        add=deno.import_(
            t.struct({"a": t.integer(), "b": t.integer()}),
            t.integer(),
            module="main.ts", # path to ts file
            name="doAddition", # function export from ts file to use
            deps=[] # path to dependencies
        ),
    )

    # We can also use the following method for reusability

    module = DenoModule(
        path="main.ts",
        deps=["deps.ts"],
    )

    g.expose(
        public,
        add_alt=deno.import_(
            t.struct({"a": t.integer(), "b": t.integer()}),
            t.integer(),
            module=module.import_("doAddition") # name of the function to use
        ),
    )
```

Where main.ts looks like:

```typescript
// main.ts

interface AddInput {
  a: number;
  b: number;
}
export function doAddition({ a, b }: AddInput) {
  return a + b;
}
```
