# Running Python code with WebAssembly

Language runtimes are nice, but integrating one is an entire story. Let's discover how we managed to integrate the Python runtime within the Metatype ecosystem.

## Why?

You have probably heard of "Function as a Service" or FaaS. In simple terms, FaaS enables anyone to run code in response to events without the hassle of managing the underlying infrastructure needed for microservices.

This capability was initially added into Metatype through Deno workers, which provided ways to execute functions authored in Typescript with ease.

On the other hand, people might also want to write functions in Python, which, as you may know, is very popular, and its standard library can be quite resourceful for this type of use case.

However, integrating a Python runtime isn't as straightforward as integrating Deno.

## What are the constraints?

There are few constraints that had to be met:

1. **Security**: functions should have limited access to the execution evironment
2. **Speed**: functions should run with low latency
3. **User-friendliness**: writing a function in one language should be as near identical as writing one in another

## Choosing an approach...

Let's start simple, we want to run Python code, so what do we need?

- A Python runtime

What limitations should be lifted for Python?

- **Interoperability**: Typegate is written in Rust and TypeScript, which made the [Deno Runtime](/docs/reference/runtimes/deno) easier to implement. However, Python presents unique challenges due to its significant differences.
- **Security**: Python does not have built-in features for limiting resource access out of the box unlike Deno.

The interoperability issue can be addressed using solutions like **PyO3**. With PyO3, it is possible to programmatically execute Python code within various contexts in Rust. But also has its own sets of constraints, like needing read access to the File System.

We do not want to be platform-dependent, but how can we achieve that?

- Docker
- WebAssembly

At a higher level, Docker and WebAssembly all share the same idea: package an application into one build and make it platform independent.

## The WebAssembly System Interface (WASI)

This is basically WebAssembly but with more capabilities such as file system access and networking.

Just like x86, or Wasm, WASI is a compilation target.
The **build** can then be executed in a sandboxed environment within a WASI-compliant runtime (WasmEdge, Wasmtime, Wasmer).

This fits very well to our use case, and as opposed to Docker, we can instantiate, manage and expose ressources programmatically with ease.

And luckily for us at the time, some [community work](https://github.com/vmware-labs/webassembly-language-runtimes) has already been done on enabling the use of Python into WASI.

To complicate things a bit, the WASI spec itself is a work in progress.
The one that is supported the most is the [preview1](https://github.com/WebAssembly/WASI/blob/main/legacy/preview1/docs.md).

### File system access

Since we relied on PyO3's abi3-py311 for running Python script in rust, it required libpython to be available at runtime.

```toml
pyo3 = { version = "0.19.1", features = ["abi3-py311"] }
```

In short, we had to find a way to expose a **script folder** and also **libpython** to the WASI build.

Our first solution was to use [wasi-vfs](https://github.com/kateinoigakukun/wasi-vfs), here was our first architectural design:

<img src="/images/wasi_vfs_python_and_rust.svg" alt="FIRST SOLUTION" />

This approach turned out to be quite hacky.

After encountering several issues, we ultimately decided to use **preopens**, which provided the features we needed for our situation.

```rust
fn init_Python_vm() -> Result<Vm> {
  let preopens = vec![
    // User script will be uploaded at ./src/Python which is virtually seen as /app
    // Each script has access only to /app
    "/app:./src/Python:readonly".to_owned()
  ];

  // This follow the same idea as above, but for clarity's sake we decided to separate it
  let pylib = PathBuf::from("./vendor/libpython/usr/local/lib");

  // This is our WASI module reponsible for running Python scripts at runtime
  // It assumes /app and libpython to be available in its world
  let wasi_mod = PathBuf::from("./build/Python-wasi-reactor.wasm");

  // Now we can instantiate the WASI module with all the configurations above
  let vm = wasi_vm::init_reactor_vm(preopens, pylib, wasi_mod)?;
  vm.run_func(None, "init_Python", params!())?;

  // ..

  Ok(vm)
}
```
