// Copyright Metatype OÃœ, licensed under the Mozilla Public License Version 2.0.
// SPDX-License-Identifier: MPL-2.0

mod node_metas;
mod selections;

use core::fmt::Write;

use fdk_ts::types::{TsType, TsTypesPage};
use node_metas::TsNodeMeta;
use selections::TsSelectionManifestPage;
use shared::manifest::ManifestPage;
use shared::node_metas::MetasPageBuilder;
use tg_schema::EffectType;
use typegraph::{ExpansionConfig, TypeNodeExt as _};

use crate::interlude::*;
use crate::utils::processed_write;
use crate::*;

use crate::fdk_ts::utils;
use crate::shared::client::*;

#[derive(Serialize, Deserialize, Debug, garde::Validate)]
pub struct ClienTsGenConfig {
    #[serde(flatten)]
    #[garde(dive)]
    pub base: crate::config::FdkGeneratorConfigBase,
}

impl ClienTsGenConfig {
    pub fn from_json(json: serde_json::Value, workspace_path: &Path) -> anyhow::Result<Self> {
        let mut config: ClienTsGenConfig = serde_json::from_value(json)?;
        config.base.path = workspace_path.join(config.base.path);
        config.base.typegraph_path = config
            .base
            .typegraph_path
            .as_ref()
            .map(|path| workspace_path.join(path));
        Ok(config)
    }
}

struct Maps {
    types: Arc<IndexMap<TypeKey, String>>,
    node_metas: IndexMap<TypeKey, String>,
    selections: IndexMap<TypeKey, String>,
}

pub struct TsClientManifest {
    tg: Arc<Typegraph>,
    pub types: ManifestPage<TsType>,
    node_metas: ManifestPage<TsNodeMeta>,
    selections: TsSelectionManifestPage,
    maps: Maps,
}

impl TsClientManifest {
    pub fn new(tg: Arc<Typegraph>, fdk: bool) -> Result<TsClientManifest> {
        let types = TsTypesPage::new(&tg, fdk);
        types.cache_references();
        let types_memo = Arc::new(types.get_cached_refs());

        let node_metas = MetasPageBuilder::new(tg.clone())?.build();
        node_metas.cache_references();
        let node_metas_memo = node_metas.get_cached_refs();

        let selections = selections::manifest_page(&tg, types_memo.clone());
        selections.cache_references();
        let selections_memo = selections.get_cached_refs();

        Ok(Self {
            tg,
            types,
            node_metas,
            selections,
            maps: Maps {
                types: types_memo,
                node_metas: node_metas_memo,
                selections: selections_memo,
            },
        })
    }
}

pub struct Generator {
    config: ClienTsGenConfig,
}

impl Generator {
    pub const INPUT_TG: &'static str = "tg_name";
    pub fn new(config: ClienTsGenConfig) -> Result<Self, garde::Report> {
        use garde::Validate;
        config.validate()?;
        Ok(Self { config })
    }
}

impl crate::Plugin for Generator {
    fn bill_of_inputs(&self) -> IndexMap<String, GeneratorInputOrder> {
        [(
            Self::INPUT_TG.to_string(),
            if let Some(tg_name) = &self.config.base.typegraph_name {
                GeneratorInputOrder::TypegraphFromTypegate {
                    name: tg_name.clone(),
                }
            } else if let Some(tg_path) = &self.config.base.typegraph_path {
                GeneratorInputOrder::TypegraphFromPath {
                    path: tg_path.clone(),
                    name: self.config.base.typegraph_name.clone(),
                }
            } else {
                unreachable!()
            },
        )]
        .into_iter()
        .collect()
    }

    fn generate(
        &self,
        inputs: IndexMap<String, GeneratorInputResolved>,
    ) -> anyhow::Result<GeneratorOutput> {
        let tg = match inputs
            .get(Self::INPUT_TG)
            .context("missing generator input")?
        {
            GeneratorInputResolved::TypegraphFromTypegate { raw } => raw.clone(),
            GeneratorInputResolved::TypegraphFromPath { raw } => raw.clone(),
            _ => bail!("unexpected input type"),
        };

        let tg = ExpansionConfig::with_default_engines().expand(tg)?;
        let mut out = IndexMap::new();
        info!("building render manifest");
        let manif = TsClientManifest::new(tg.clone(), false)?;
        let mut buf = String::new();
        info!("rendering...");
        manif.render(&mut buf)?;
        info!("rendering successful");
        out.insert(
            self.config.base.path.join("client.ts"),
            GeneratedFile {
                contents: buf,
                overwrite: true,
            },
        );

        Ok(GeneratorOutput(out))
    }
}

pub struct GenClientTsOpts {
    pub hostcall: bool,
}

impl TsClientManifest {
    fn render(&self, dest: &mut impl Write) -> anyhow::Result<()> {
        writeln!(
            dest,
            "// This file was @generated by metagen and is intended"
        )?;
        writeln!(dest, "// to be generated again on subsequent metagen runs.")?;
        writeln!(dest)?;
        self.render_client(dest, &GenClientTsOpts { hostcall: false })?;
        writeln!(dest)?;
        Ok(())
    }

    pub fn render_client(
        &self,
        dest: &mut impl Write,
        opts: &GenClientTsOpts,
    ) -> anyhow::Result<()> {
        // Render the common sections like the transports
        let static_ts = include_str!("static/mod.ts");
        processed_write(
            dest,
            static_ts,
            &[("HOSTCALL".to_string(), opts.hostcall)]
                .into_iter()
                .collect(),
        )?;

        let mut types_buffer = String::new();
        self.types.render_all(&mut types_buffer)?;

        Self::render_node_metas(dest, self.node_metas.render_all_buffered()?)?;

        dest.write_str(&types_buffer)?;
        let _ = types_buffer;

        self.selections.render_all(dest)?;

        self.render_query_graph(dest)?;

        Ok(())
    }

    fn render_node_metas(dest: &mut impl Write, raw: String) -> std::fmt::Result {
        write!(
            dest,
            r#"
const nodeMetas = {{
  scalar() {{
    return {{}};
  }},
  {raw}
}};
"#
        )
    }

    fn render_query_graph(&self, out: &mut impl Write) -> anyhow::Result<()> {
        let gql_types = get_gql_types(&self.tg);

        write!(
            out,
            r#"
export class QueryGraph extends _QueryGraphBase {{
  constructor() {{
    super({{"#
        )?;
        for (key, gql_ty) in gql_types.into_iter() {
            let ty_name = self.tg.find_type(key).unwrap().name();
            write!(
                out,
                r#"
      "{ty_name}": "{gql_ty}","#
            )?;
        }
        write!(
            out,
            r#"
    }});
  }}
            "#
        )?;

        self.render_meta_functions(out)?;

        writeln!(
            out,
            "
}}"
        )?;

        Ok(())
    }

    fn render_meta_functions(&self, out: &mut impl Write) -> anyhow::Result<()> {
        for func in self.tg.root_functions() {
            let (path, ty) = func?;
            use heck::ToLowerCamelCase;

            let node_name = path.join("_");
            let method_name = node_name.to_lower_camel_case();
            let out_ty_name = self.maps.types.get(&ty.output().key()).unwrap();

            let arg_ty = ty
                .non_empty_input()
                .and_then(|ty| self.maps.types.get(&ty.key()));
            let select_ty = self.maps.selections.get(&ty.output().key());

            let args_row = match (arg_ty, select_ty) {
                (Some(arg_ty), Some(select_ty)) => {
                    format!("args: {arg_ty} | PlaceholderArgs<{arg_ty}>, select: {select_ty}")
                }
                // functions that return scalars don't need selections
                (Some(arg_ty), None) => format!("args: {arg_ty} | PlaceholderArgs<{arg_ty}>"),
                // not all functions have args (empty struct arg)
                (None, Some(select_ty)) => format!("select: {select_ty}"),
                (None, None) => "".into(),
            };

            let args_selection = match (ty.non_empty_input(), select_ty) {
                (Some(_), Some(_)) => "[args, select]",
                (Some(_), None) => "args",
                (None, Some(_)) => "select",
                (None, None) => "true",
            };

            let meta_method = self
                .maps
                .node_metas
                .get(&ty.key())
                .map(|str| &str[..])
                .unwrap_or_else(|| "scalar");

            let node_type = match ty.effect() {
                EffectType::Read => "QueryNode",
                EffectType::Update | EffectType::Delete | EffectType::Create => "MutationNode",
            };

            write!(
                out,
                r#"
  {method_name}({args_row}): {node_type}<{out_ty_name}> {{
    const inner = _selectionToNodeSet(
      {{ "{node_name}": {args_selection} }},
      [["{node_name}", nodeMetas.{meta_method}]],
      "$q",
    )[0];
    return new {node_type}(inner);
  }}"#
            )?;
        }

        Ok(())
    }
}

#[test]
fn e2e() -> anyhow::Result<()> {
    use crate::tests::*;

    let tg_name = "gen-test";
    let config = config::Config {
        targets: [(
            "default".to_string(),
            config::Target(
                [GeneratorConfig {
                    generator_name: "client_ts".to_string(),
                    other: serde_json::to_value(client_ts::ClienTsGenConfig {
                        base: config::FdkGeneratorConfigBase {
                            typegraph_name: Some(tg_name.into()),
                            typegraph_path: None,
                            // NOTE: root will map to the test's tempdir
                            path: "./".into(),
                            template_dir: None,
                        },
                    })?,
                }]
                .into_iter()
                .collect(),
            ),
        )]
        .into_iter()
        .collect(),
    };
    tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .thread_stack_size(16 * 1024 * 1024)
        .build()?
        .block_on(async {
            let tg = test_typegraph_3().await?;
            e2e_test(vec![E2eTestCase {
                typegraphs: [(tg_name.to_string(), tg)].into_iter().collect(),
                target: "default".into(),
                config,
                build_fn: |args| {
                    Box::pin(async move {
                        let status = tokio::process::Command::new("deno")
                            .args("check client.ts".split(' ').collect::<Vec<_>>())
                            .current_dir(&args.path)
                            .kill_on_drop(true)
                            .spawn()?
                            .wait()
                            .await?;
                        if !status.success() {
                            let code = std::fs::read_to_string(args.path.join("client.ts"))?;
                            for line in code.lines().enumerate() {
                                eprintln!("{:04}: {}", line.0, line.1);
                            }
                            anyhow::bail!("error checking generated crate");
                        }
                        let status = tokio::process::Command::new("deno")
                            .args("lint client.ts".split(' ').collect::<Vec<_>>())
                            .current_dir(&args.path)
                            .kill_on_drop(true)
                            .spawn()?
                            .wait()
                            .await?;
                        if !status.success() {
                            anyhow::bail!("error lint generated crate");
                        }
                        Ok(())
                    })
                },
                target_dir: Some("./fixtures/client_ts/".into()),
            }])
            .await
        })?;
    Ok(())
}
