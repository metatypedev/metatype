(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8598],{77162:(e,n,i)=>{"use strict";i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>c,toc:()=>d});var o=i(86070),t=i(25710),s=(i(7871),i(65671));const r={sidebar_position:3},a="Policies",c={id:"reference/policies/index",title:"Policies",description:"Typegraphs allow you to specify granular access control when exposing your functions. This can be done at the function or the type field level. This section also makes use of toy typegraph for the sake of clarity.",source:"@site/docs/reference/policies/index.mdx",sourceDirName:"reference/policies",slug:"/reference/policies/",permalink:"/docs/reference/policies/",draft:!1,unlisted:!1,editUrl:"https://github.com/metatypedev/metatype/tree/main/docs/metatype.dev/docs/reference/policies/index.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docs",previous:{title:"Wasm",permalink:"/docs/reference/runtimes/wasm/"},next:{title:"Ecosystem",permalink:"/docs/reference/ecosystem/"}},l={},d=[{value:"Policy based access control (PBAC)",id:"policy-based-access-control-pbac",level:2},{value:"Composition rules",id:"composition-rules",level:2},{value:"Traversal order",id:"traversal-order",level:3},{value:"Chaining policies",id:"chaining-policies",level:3}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"policies",children:"Policies"}),"\n","\n",(0,o.jsx)(n.h1,{id:"policies-and-functions",children:"Policies and functions"}),"\n",(0,o.jsx)(n.p,{children:"Typegraphs allow you to specify granular access control when exposing your functions. This can be done at the function or the type field level. This section also makes use of toy typegraph for the sake of clarity."}),"\n",(0,o.jsx)(n.h2,{id:"policy-based-access-control-pbac",children:"Policy based access control (PBAC)"}),"\n",(0,o.jsx)(n.p,{children:"The Deno runtime enable to understand the last abstraction. Policies are a way to verify for each type whether the user is authorized or not to access it. It's a very powerful concept that can be for instance used to guarantee a given type is never accidentally exposed to the outside world."}),"\n",(0,o.jsx)(n.p,{children:"Metatype comes with some built-in policies, but you can use the Deno runtime to define your own:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"policies.public()"})," is an alias for ",(0,o.jsx)(n.code,{children:'deno.policy("public", "() => \'PASS\'")'})," providing everyone open access while still allowing field level custom access."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:'Policy.context("role_value", "role_field")'})," is a companion policy for the authentication strategy you learned in the previous section. It will verify the context and give adequate access to the user."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Policies are hierarchical in the sense that the request starts with a denial, and the root functions must explicitly provide an access or not. Once access granted, any further types can either inherit or override the access. Policies evaluate in order in case multiple ones are defined."}),"\n",(0,o.jsx)(s.A,{typegraph:"policies",python:i(85775),typescript:i(22481),query:i(6931)}),"\n",(0,o.jsx)(n.h2,{id:"composition-rules",children:"Composition rules"}),"\n",(0,o.jsx)(n.h3,{id:"traversal-order",children:"Traversal order"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"ALLOW"}),": Allows access to the parent and all its descendants, disregarding inner policies."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"DENY"}),": Denies access to the parent and all its descendants, disregarding inner policies."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"PASS"}),": Allows access to the parent, each descendant will still be evaluated individually (equivalent to having no policies set)."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"chaining-policies",children:"Chaining policies"}),"\n",(0,o.jsxs)(n.p,{children:["If you have ",(0,o.jsx)(n.code,{children:"foo.with_policy(A, B).with_policy(C)"})," for example, it will evaluated in batch as ",(0,o.jsx)(n.code,{children:"[A, B, C]"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["If one or more policies fail (",(0,o.jsx)(n.code,{children:"DENY"}),"), the type will be inaccessible."]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},6931:e=>{var n={kind:"Document",definitions:[{kind:"OperationDefinition",operation:"query",name:{kind:"Name",value:"A"},variableDefinitions:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"public"},arguments:[],directives:[]}]}},{kind:"OperationDefinition",operation:"query",name:{kind:"Name",value:"B"},variableDefinitions:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"admin_only"},arguments:[],directives:[]}]}},{kind:"OperationDefinition",operation:"query",name:{kind:"Name",value:"C"},variableDefinitions:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"user_only"},arguments:[],directives:[]}]}},{kind:"OperationDefinition",operation:"query",name:{kind:"Name",value:"D"},variableDefinitions:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"both"},arguments:[],directives:[]}]}}],loc:{start:0,end:92}};n.loc.source={body:"query A {\n  public\n}\n\nquery B {\n  admin_only\n}\n\nquery C {\n  user_only\n}\n\nquery D {\n  both\n}\n",name:"GraphQL request",locationOffset:{line:1,column:1}};function i(e,n){if("FragmentSpread"===e.kind)n.add(e.name.value);else if("VariableDefinition"===e.kind){var o=e.type;"NamedType"===o.kind&&n.add(o.name.value)}e.selectionSet&&e.selectionSet.selections.forEach((function(e){i(e,n)})),e.variableDefinitions&&e.variableDefinitions.forEach((function(e){i(e,n)})),e.definitions&&e.definitions.forEach((function(e){i(e,n)}))}var o={};function t(e,n){for(var i=0;i<e.definitions.length;i++){var o=e.definitions[i];if(o.name&&o.name.value==n)return o}}function s(e,n){var i={kind:e.kind,definitions:[t(e,n)]};e.hasOwnProperty("loc")&&(i.loc=e.loc);var s=o[n]||new Set,r=new Set,a=new Set;for(s.forEach((function(e){a.add(e)}));a.size>0;){var c=a;a=new Set,c.forEach((function(e){r.has(e)||(r.add(e),(o[e]||new Set).forEach((function(e){a.add(e)})))}))}return r.forEach((function(n){var o=t(e,n);o&&i.definitions.push(o)})),i}n.definitions.forEach((function(e){if(e.name){var n=new Set;i(e,n),o[e.name.value]=n}})),e.exports=n,e.exports.A=s(n,"A"),e.exports.B=s(n,"B"),e.exports.C=s(n,"C"),e.exports.D=s(n,"D")},85775:e=>{e.exports={content:'deno = DenoRuntime()\nrandom = RandomRuntime(seed=0, reset=None)\n\n# `public` is sugar for to `(_args, _ctx) => "PASS"`\npublic = Policy.public()\n\nadmin_only = deno.policy(\n  "admin_only",\n  # note: policies either return "ALLOW" | "DENY" | "PASS"\n  "(args, { context }) => context?.username === \'admin\' ? \'ALLOW\' : \'DENY\'",\n)\nuser_only = deno.policy(\n  "user_only",\n  "(args, { context }) => context?.username === \'user\' ? \'PASS\' : \'DENY\'",\n)\n\ng.auth(Auth.basic(["admin", "user"]))\n\ng.expose(\n  # set default policy for the exposed functions\n  Policy.public(),\n  public=random.gen(t.string()).with_policy(public),\n  admin_only=random.gen(t.string()).with_policy(admin_only),\n  user_only=random.gen(t.string()).with_policy(user_only),\n  # if both policies return null, access is denied\n  both=random.gen(t.string()).with_policy(user_only, admin_only),\n)',path:"../examples/typegraphs/policies.py"}},22481:e=>{e.exports={content:'const deno = new DenoRuntime();\nconst random = new RandomRuntime({ seed: 0 });\n// `public` is sugar for `(_args, _ctx) => "PASS"`\nconst pub = Policy.public();\n\nconst admin_only = deno.policy(\n  "admin_only",\n  // note: policies either return "ALLOW" | "DENY" | "PASS"\n  "(args, { context }) => context?.username === \'admin\' ? \'ALLOW\' : \'DENY\'",\n);\nconst user_only = deno.policy(\n  "user_only",\n  "(args, { context }) => context?.username === \'user\' ? \'PASS\' : \'DENY\'",\n);\n\ng.auth(Auth.basic(["admin", "user"]));\n\ng.expose(\n  {\n    public: random.gen(t.string()).withPolicy(pub),\n    admin_only: random.gen(t.string()).withPolicy(admin_only),\n    user_only: random.gen(t.string()).withPolicy(user_only),\n    // if both attached policies return null, access is denied\n    both: random.gen(t.string()).withPolicy([user_only, admin_only]),\n    // set default policy for the exposed functions\n  },\n  pub,\n);',path:"../examples/typegraphs/policies.ts"}}}]);