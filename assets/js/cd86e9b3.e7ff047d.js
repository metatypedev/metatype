(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4947],{98143:(n,e,t)=>{"use strict";t.r(e),t.d(e,{assets:()=>p,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>d,toc:()=>c});var r=t(86070),s=t(25710),a=t(65671),i=t(7871);const o={},l=void 0,d={id:"reference/metagen/index",title:"index",description:"/typegrap/typegraphh---",source:"@site/docs/reference/metagen/index.mdx",sourceDirName:"reference/metagen",slug:"/reference/metagen/",permalink:"/docs/reference/metagen/",draft:!1,unlisted:!1,editUrl:"https://github.com/metatypedev/metatype/tree/main/docs/metatype.dev/docs/reference/metagen/index.mdx",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Changelog",permalink:"/docs/reference/changelog"},next:{title:"Features overview",permalink:"/docs/concepts/features-overview/"}},p={},c=[{value:"Access through CLI",id:"access-through-cli",level:2},{value:"Access through SDK",id:"access-through-sdk",level:2},{value:"Generators",id:"generators",level:2},{value:"<code>client_ts</code>",id:"client_ts",level:3},{value:"<code>client_py</code>",id:"client_py",level:3},{value:"<code>client_rs</code>",id:"client_rs",level:3},{value:"<code>fdk_ts</code>",id:"fdk_ts",level:3},{value:"<code>fdk_py</code>",id:"fdk_py",level:3},{value:"<code>fdk_rs</code>",id:"fdk_rs",level:3}];function u(n){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...n.components},{Details:o}=e;return o||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:"/typegrap/typegraphh---\nsidebar_position: 50"}),"\n",(0,r.jsx)(e.hr,{}),"\n","\n",(0,r.jsx)(e.h1,{id:"metagen",children:"Metagen"}),"\n",(0,r.jsx)(e.admonition,{title:"Beta",type:"warning",children:(0,r.jsx)(e.p,{children:"The following feature is not yet stable."})}),"\n",(0,r.jsx)(e.p,{children:"Metagen is a code-generator suite that contains implementations that help with development on the Metatype platform. Today, this means a set of generators to:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Generate code-first, typesafe clients for your typegraph"}),"\n",(0,r.jsxs)(e.li,{children:["Help with ",(0,r.jsx)(e.a,{href:"/docs/guides/external-functions",children:"custom functions"})," by generating types, serializers and bindings."]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["It's availaible bundled within the ",(0,r.jsx)(e.a,{href:"/docs/reference/meta-cli",children:"meta CLI"})," and the ",(0,r.jsx)(e.a,{href:"/docs/reference/typegraph#sdks",children:"typegraph SDKs"}),"."]}),"\n",(0,r.jsx)(e.h2,{id:"access-through-cli",children:"Access through CLI"}),"\n",(0,r.jsxs)(e.p,{children:["The meta-cli has a dedicated ",(0,r.jsx)(e.code,{children:"gen"})," command for interacting with metagen. We configure the generators through the ",(0,r.jsx)(e.a,{href:"/docs/reference/meta-cli/configuration-file",children:"standard configuration file"})," under the metagen key."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-yaml",children:'typegates:\n  # bla bla\n\ntypegraphs:\n  # bla bla\n\nmetagen:\n  targets:\n    main:\n      # generator to use\n      - generator: fdk_rs\n        # path to generate to\n        path: ./bff/\n        # typegraph path to use\n        typegraph_path: ./typegraphs/svc-bff.ts\n        # we can have multiple generators per target\n      - generator: fdk_rs\n        path: ./telemetry/\n        typegraph_path: ./typegraphs/svc-telemetry.ts\n        # generators might have custom keys\n        stubbed_runtimes: ["wasm_wire", "deno"]\n    # more than one targets avail if you need them\n    iter:\n      - generator: client_ts\n        path: ./next_app/\n        # name of typegraph to read from typegate\n        typegraph: svc_bff\n'})}),"\n",(0,r.jsx)(e.p,{children:"This allows us to invoke the targets from the CLI."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-sh",children:"meta cli gen main\n"})}),"\n",(0,r.jsxs)(e.p,{children:["This will resolve the requisite typegraphs, serialize as needed and put the resulting files at the appropriate locations. If no target name is provied, the CLI will look for a target under the key ",(0,r.jsx)(e.code,{children:"main"})," and invoke it instead."]}),"\n",(0,r.jsx)(e.h2,{id:"access-through-sdk",children:"Access through SDK"}),"\n",(0,r.jsx)(e.p,{children:"Metagen is availaible through the SDK for programmatic access needs and can be helpful when writing tests or when relying on the CLI is not an option."}),"\n",(0,r.jsx)(a.A,{python:t(7797),typescript:t(19507),disablePlayground:!0}),"\n",(0,r.jsx)(e.h2,{id:"generators",children:"Generators"}),"\n",(0,r.jsxs)(e.admonition,{title:"Chicken or the egg?",type:"info",children:[(0,r.jsx)(e.p,{children:"As most of the generators are intended for types to be used by custom functions, they'll require that you declare the custom functions in your typegraph first. This begs the question, how does one declare custom functions that depend on artifacts that are yet to be generated? Typegraphs error out when referenced artifacts aren't found, how does it work in this scenario?"}),(0,r.jsxs)(e.p,{children:["To resolve this concern, the SDKs support a serialization mode that skips resolution of artifacts. This mode is activated when serialization is done for codegen purposes. What this means is that, ",(0,r.jsx)(e.strong,{children:"you can declare non-existent files in your typegraph and codegen should work"}),". Some generators are even smart enough to work around your expected files. Of course, if the files aren't present when you're trying to deply to the typegate, it'll raise an error."]})]}),"\n",(0,r.jsx)(e.h3,{id:"client_ts",children:(0,r.jsx)(e.code,{children:"client_ts"})}),"\n",(0,r.jsx)(e.p,{children:"This generator supports:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Types and query builders based on your typegraph"}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API",children:(0,r.jsx)(e.code,{children:"fetch"})})," based ",(0,r.jsx)(e.code,{children:"GraphQlTransport"})," implementation","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Requires Node.js version ",(0,r.jsx)(e.code,{children:"v17.5.0"})," and ",(0,r.jsx)(e.a,{href:"https://nodejs.org/dist/latest-v18.x/docs/api/globals.html#fetch",children:"up"}),"."]}),"\n",(0,r.jsxs)(e.li,{children:["Requires using ",(0,r.jsx)(e.code,{children:"--experimental-fetch"})," flag if on Node.js version below v18.0.0"]}),"\n",(0,r.jsx)(e.li,{children:"Provides async queries"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.li,{children:"Prepared requests and aliases"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["Refer to the ",(0,r.jsx)(e.a,{href:"/docs/reference/typegraph/client/",children:"client reference"})," for usage guidelines and examples."]}),"\n",(0,r.jsx)(e.h3,{id:"client_py",children:(0,r.jsx)(e.code,{children:"client_py"})}),"\n",(0,r.jsx)(e.p,{children:"This generator supports:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Types and query builders based on your typegraph"}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"urlib"})," based ",(0,r.jsx)(e.code,{children:"GraphQlTransport"})," implementation.","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Provides sync and async queries"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.li,{children:"Prepared requests and aliases"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["Refer to the ",(0,r.jsx)(e.a,{href:"/docs/reference/typegraph/client/",children:"client reference"})," for usage guidelines and examples."]}),"\n",(0,r.jsx)(e.h3,{id:"client_rs",children:(0,r.jsx)(e.code,{children:"client_rs"})}),"\n",(0,r.jsx)(e.p,{children:"This generator supports:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Types and query builders based on your typegraph"}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://lib.rs/crates/reqwest",children:(0,r.jsx)(e.code,{children:"reqwest"})})," based ",(0,r.jsx)(e.code,{children:"GraphQlTransport"})," implementation","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Provides sync and async queries"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.li,{children:"Prepared requests and aliases"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["Refer to the ",(0,r.jsx)(e.a,{href:"/docs/reference/typegraph/client/",children:"client reference"})," for usage guidelines and examples."]}),"\n",(0,r.jsx)(e.p,{children:"It supports the following extra configuration keys."}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Key"}),(0,r.jsx)(e.th,{children:"Type"}),(0,r.jsx)(e.th,{children:"Default"}),(0,r.jsx)(e.th,{children:"Description"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"crate_name"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"string"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"${typegraphName}_fdk"})}),(0,r.jsxs)(e.td,{children:["Name to assign to crate when generating ",(0,r.jsx)(e.code,{children:"Cargo.toml"}),"."]})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"skip_cargo_toml"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"boolean"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"false"})}),(0,r.jsxs)(e.td,{children:["Do not generate ",(0,r.jsx)(e.code,{children:"Cargo.toml"}),"."]})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"skip_lib_rs"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"boolean"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"false"})}),(0,r.jsxs)(e.td,{children:["Do not generate ",(0,r.jsx)(e.code,{children:"lib.rs"}),", the sample entrypoint."]})]})]})]}),"\n",(0,r.jsx)(e.h3,{id:"fdk_ts",children:(0,r.jsx)(e.code,{children:"fdk_ts"})}),"\n",(0,r.jsx)(e.p,{children:"This generator supports:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Typescript types that map to typegraph types"}),"\n",(0,r.jsxs)(e.li,{children:["Stub function types for custom functions implementors that adhere to typegraph functions.","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["By default, all function types from the ",(0,r.jsx)(e.code,{children:"DenoRuntime"})," get stub types."]}),"\n",(0,r.jsxs)(e.li,{children:["Use ",(0,r.jsx)(e.code,{children:"stubbed_runtimes"})," to select which runtimes get stubs."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"#client_ts",children:(0,r.jsx)(e.code,{children:"client_ts"})})," based typegraph client","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Special ",(0,r.jsx)(e.code,{children:"HostcallTransport"})," implementation"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"The following example showcases the generator."}),"\n",(0,r.jsx)(e.p,{children:"Typegraph:"}),"\n",(0,r.jsx)(a.A,{python:t(14037),typescript:t(14037),disablePlayground:!0}),"\n",(0,r.jsx)(e.p,{children:"Custom function:"}),"\n",(0,r.jsx)(a.A,{typescript:t(13246),disablePlayground:!0}),"\n",(0,r.jsxs)(o,{children:[(0,r.jsx)("summary",{children:(0,r.jsx)(e.p,{children:"Code generation sample."})}),(0,r.jsx)(a.A,{typescript:t(96280),disablePlayground:!0})]}),"\n",(0,r.jsx)(e.p,{children:"It supports the following extra configuration keys."}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Key"}),(0,r.jsx)(e.th,{children:"Type"}),(0,r.jsx)(e.th,{children:"Default"}),(0,r.jsx)(e.th,{children:"Description"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"stubbed_runtimes"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"string[]"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:'["deno"]'})}),(0,r.jsx)(e.td,{children:"Runtimes for which to generate stub types."})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"exclude_client"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"boolean"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"false"})}),(0,r.jsxs)(e.td,{children:["Do not include the typegraph client from ",(0,r.jsx)(e.a,{href:"#client_ts",children:(0,r.jsx)(e.code,{children:"client_ts"})}),"."]})]})]})]}),"\n",(0,r.jsx)(e.h3,{id:"fdk_py",children:(0,r.jsx)(e.code,{children:"fdk_py"})}),"\n",(0,r.jsx)(e.p,{children:"This generator supports:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Python classes that map to typegraph types"}),"\n",(0,r.jsxs)(e.li,{children:["Decorators for custom functions implementors that require adherance to typegraph function types.","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["By default, all functions from the ",(0,r.jsx)(e.code,{children:"PythonRuntime"})," get stub types."]}),"\n",(0,r.jsxs)(e.li,{children:["Use ",(0,r.jsx)(e.code,{children:"stubbed_runtimes"})," to select which runtimes get stubs."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"#client_py",children:(0,r.jsx)(e.code,{children:"client_py"})})," based typegraph client","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Special ",(0,r.jsx)(e.code,{children:"HostcallTransport"})," implementation"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"If the referenced module for the custom function is not found, the generator will also output stub implementation (in addition to the types) at the given type. It will not replace our code on a second run."}),"\n",(0,r.jsx)(e.p,{children:"The following example showcases the generator."}),"\n",(0,r.jsx)(e.p,{children:"Typegraph:"}),"\n",(0,r.jsx)(a.A,{typescript:t(62292),disablePlayground:!0}),"\n",(0,r.jsx)(e.p,{children:"Custom function:"}),"\n",(0,r.jsx)(a.A,{python:t(28434),disablePlayground:!0}),"\n",(0,r.jsxs)(o,{children:[(0,r.jsx)("summary",{children:(0,r.jsx)(e.p,{children:"Code generation sample."})}),(0,r.jsx)(a.A,{python:t(95836),disablePlayground:!0})]}),"\n",(0,r.jsx)(e.p,{children:"It supports the following extra configuration keys."}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Key"}),(0,r.jsx)(e.th,{children:"Type"}),(0,r.jsx)(e.th,{children:"Default"}),(0,r.jsx)(e.th,{children:"Description"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"stubbed_runtimes"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"string[]"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:'["deno"]'})}),(0,r.jsx)(e.td,{children:"Runtimes for which to generate stub types."})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"exclude_client"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"boolean"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"false"})}),(0,r.jsxs)(e.td,{children:["Do not include the typegraph client from ",(0,r.jsx)(e.a,{href:"#client_py",children:(0,r.jsx)(e.code,{children:"client_py"})}),"."]})]})]})]}),"\n",(0,r.jsx)(e.h3,{id:"fdk_rs",children:(0,r.jsx)(e.code,{children:"fdk_rs"})}),"\n",(0,r.jsx)(e.p,{children:"This generator generates types, serializers and bindings needed to implement custom functions in Rust. Rust implementations will need to be compiled to wasm components to be executed on the metatype platform and the generator assumes such usage."}),"\n",(0,r.jsx)(e.p,{children:"To be more specific, it supports:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Rust types that map to typegraph defined types","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Serialization is handled out of sight through ",(0,r.jsx)(e.a,{href:"https://lib.rs/serde_json",children:(0,r.jsx)(e.code,{children:"serde_json"})})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["Stub traits for custom functions implementors that adhere to typegraph functions.","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["By default, all functions from the ",(0,r.jsx)(e.code,{children:"WasmRuntime"})," get stub types."]}),"\n",(0,r.jsxs)(e.li,{children:["The generator assumes the ",(0,r.jsx)(e.code,{children:"wire"})," based wasm interface is being targetted."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"stubbed_runtimes"})," key can be used to configure stub generation from additional runtimes."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"#client_rs",children:(0,r.jsx)(e.code,{children:"client_rs"})})," based typegraph client","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Special ",(0,r.jsx)(e.code,{children:"HostcallTransport"})," implementation."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["Glue code for setting up the wasm component to be run within the ",(0,r.jsx)(e.code,{children:"WasmRuntime"}),"."]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"By default the generator will also output a library crate entrypoint and a functional Cargo.toml with all the required dependencies. These additional files wlil not be overwritten on a second run. The generator can also be configured to avoid generating them even if not present."}),"\n",(0,r.jsx)(e.p,{children:"The following example showcases the generator."}),"\n",(0,r.jsx)(e.p,{children:"Typegraph:"}),"\n",(0,r.jsx)(a.A,{python:t(28054),typescript:t(86016),disablePlayground:!0}),"\n",(0,r.jsx)(e.p,{children:"Custom function:"}),"\n",(0,r.jsx)(i.A,{language:"rust",children:t(39028).content}),"\n",(0,r.jsxs)(o,{children:[(0,r.jsx)("summary",{children:"Code generation sample."}),(0,r.jsx)(i.A,{language:"rust",children:t(86496).content})]}),"\n",(0,r.jsx)(e.p,{children:"It supports the following extra configuration keys."}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Key"}),(0,r.jsx)(e.th,{children:"Type"}),(0,r.jsx)(e.th,{children:"Default"}),(0,r.jsx)(e.th,{children:"Description"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"stubbed_runtimes"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"string[]"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:'["wasm_wire"]'})}),(0,r.jsx)(e.td,{children:"Runtimes for which to generate stub types."})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"crate_name"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"string"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"${typegraphName}_fdk"})}),(0,r.jsxs)(e.td,{children:["Name to assign to crate when generating ",(0,r.jsx)(e.code,{children:"Cargo.toml"}),"."]})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"skip_cargo_toml"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"boolean"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"false"})}),(0,r.jsxs)(e.td,{children:["Do not generate ",(0,r.jsx)(e.code,{children:"Cargo.toml"}),"."]})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"skip_lib_rs"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"boolean"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"false"})}),(0,r.jsxs)(e.td,{children:["Do not generate ",(0,r.jsx)(e.code,{children:"lib.rs"}),", the sample entrypoint."]})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"exclude_client"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"boolean"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"false"})}),(0,r.jsxs)(e.td,{children:["Do not include the typegraph client from ",(0,r.jsx)(e.a,{href:"#client_rs",children:(0,r.jsx)(e.code,{children:"client_rs"})}),"."]})]})]})]})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(u,{...n})}):u(n)}},14037:n=>{n.exports={content:'@typegraph(\n)\ndef metagen_deno(g: Graph):\n  idv3 = t.struct(\n    {\n      "title": t.string(),\n      "artist": t.string(),\n      "releaseTime": t.datetime(),\n      "mp3Url": t.uri(),\n      # explicit type names help when generating code\n    }\n  ).rename("idv3")\n  deno = DenoRuntime()\n\n  g.expose(\n    Policy.public(),\n    remix=deno.import_(\n      idv3,\n      idv3,\n      module="./metagen/ts/remix.ts",\n      deps=["./metagen/ts/fdk.ts"],\n      name="remix_track",\n    ).rename("remix_track"),  # explicit names help\n  )',path:"../examples/typegraphs/metagen-deno.py"}},62292:n=>{n.exports={content:'await typegraph(\n  {\n    name: "metagen-py",\n  },\n  (g) => {\n    const idv3 = t\n      .struct({\n        title: t.string(),\n        artist: t.string(),\n        releaseTime: t.datetime(),\n        mp3Url: t.uri(),\n        // explicit type names help when generating code\n      })\n      .rename("idv3");\n\n    const python = new PythonRuntime();\n\n    g.expose(\n      {\n        remix: python\n          .import(idv3, idv3, {\n            module: "./metagen/py/remix.py",\n            deps: ["./metagen/py/fdk.py"],\n            name: "remix_track",\n          })\n          .rename("remix_track"), // explicit names help\n      },\n      Policy.public(),\n    );\n  },\n);',path:"../examples/typegraphs/metagen-py.ts"}},28054:n=>{n.exports={content:'@typegraph(\n)\ndef metagen_rs(g: Graph):\n  idv3 = t.struct(\n    {\n      "title": t.string(),\n      "artist": t.string(),\n      "releaseTime": t.datetime(),\n      "mp3Url": t.uri(),\n      # explicit type names help when generating code\n    }\n  ).rename("idv3")\n\n  # the wire flavour is availible through a static\n  # constructor\n  wasm = WasmRuntime.wire("metagen/rust.wasm")\n\n  g.expose(\n    Policy.public(),\n    remix=wasm.handler(\n      idv3,\n      idv3,\n      name="remix_track",\n    ).rename("remix_track"),  # explicit names help\n  )',path:"../examples/typegraphs/metagen-rs.py"}},86016:n=>{n.exports={content:'await typegraph(\n  {\n    name: "metagen-rs",\n  },\n  (g) => {\n    const idv3 = t\n      .struct({\n        title: t.string(),\n        artist: t.string(),\n        releaseTime: t.datetime(),\n        mp3Url: t.uri(),\n        // explicit type names help when generating code\n      })\n      .rename("idv3");\n\n    // the wire flavour is availible through a static\n    // constructor\n    const wasm = WasmRuntime.wire("metagen/rust.wasm");\n\n    g.expose(\n      {\n        remix: wasm\n          .handler(\n            idv3,\n            idv3,\n            {\n              name: "remix_track",\n            },\n            // the traits will map to the name of the materializer\n            // and also the the name of the handler mentioned above\n          )\n          .rename("remix_track"),\n      },\n      Policy.public(),\n    );\n  },\n);',path:"../examples/typegraphs/metagen-rs.ts"}},7797:n=>{n.exports={content:'import os\nfrom typegraph.graph.metagen import Metagen\n\n\n@typegraph(\n)\ndef metagen_sdk(g: Graph):\n  idv3 = t.struct(\n    {\n      "title": t.string(),\n      "artist": t.string(),\n      "releaseTime": t.datetime(),\n      "mp3Url": t.uri(),\n    }\n  ).rename("idv3")\n  deno = DenoRuntime()\n\n  g.expose(\n    Policy.public(),\n    remix=deno.import_(\n      idv3,\n      idv3,\n      module="./metagen/ts/remix.ts",\n      deps=["./metagen/ts/fdk.ts"],\n      name="remix_track",\n    ).rename("remix_track"),\n  )\n\n\nif __name__ == "__main__" and False:\n  metagen = Metagen(\n    # the workspace root that our config is relative to\n    os.path.dirname(os.path.abspath(__file__)),\n    # the rest is pretty similar to the CLI config\n    {\n      "targets": {\n        "main": [\n          {\n            "generator": "fdk_ts",\n            "typegraph_path": __file__,\n            "path": "funcs/",\n          },\n        ],\n      },\n    },\n  )\n  tg = metagen_sdk()\n  # dry_run doesn\'t write to disk\n  items = metagen.dry_run(tg, "main", None)',path:"../examples/typegraphs/metagen-sdk.py"}},19507:n=>{n.exports={content:'// Copyright Metatype O\xdc, licensed under the Mozilla Public License Version 2.0.\n// SPDX-License-Identifier: MPL-2.0\n\nimport { Metagen } from "@typegraph/sdk/metagen";\n\n// get typegraph desc here\nconst tg = await typegraph(\n  {\n    name: "metagen-sdk",\n  },\n  (g) => {\n    const idv3 = t\n      .struct({\n        title: t.string(),\n        artist: t.string(),\n        releaseTime: t.datetime(),\n        mp3Url: t.uri(),\n      })\n      .rename("idv3");\n\n    const deno = new DenoRuntime();\n\n    g.expose(\n      {\n        remix: deno\n          .import(idv3, idv3, {\n            module: "./metagen/ts/remix.ts",\n            deps: ["./metagen/ts/fdk.ts"],\n            name: "remix_track",\n          })\n          .rename("remix_track"),\n      },\n      Policy.public(),\n    );\n  },\n);\n\n// deno-lint-ignore no-constant-condition\nif (false) {\n  const myPath = import.meta.url.replace("file://", "");\n  const metagen = new Metagen(\n    // the workspace root that our config is relative to\n    myPath + "/..",\n    // this rest of the config is similmilar to the CLI config\n    {\n      targets: {\n        main: [\n          {\n            generator: "fdk_ts",\n            typegraph_path: myPath,\n            path: "funcs/",\n          },\n        ],\n      },\n    },\n  );\n  // dry_run doesn\'t write to disk\n  metagen.dryRun(tg, "main");\n}',path:"../examples/typegraphs/metagen-sdk.ts"}},95836:n=>{n.exports={content:'# This file was @generated by metagen and is intended\n# to be generated again on subsequent metagen runs.\n\nimport typing\nimport dataclasses as dc\nimport http.client as http_c\nimport io\nimport json\nimport mimetypes\nimport re\nimport urllib\nimport urllib.error\nimport urllib.request as request\nimport uuid\nfrom abc import ABC, abstractmethod\n\n\nclass Ctx:\n  def __init__(\n    self,\n    binding: "HostcallBinding",\n    qg: "QueryGraph",\n    host: "HostcallTransport",\n  ):\n    self.__binding = binding\n    self.qg = qg\n    self.host = host\n\n  def gql(self, query: str, variables: typing.Mapping):\n    return self.__binding(query, dict(variables))\n\n\ndef selection_to_nodes(\n  selection: "SelectionErased",\n  metas: typing.Dict[str, "NodeMetaFn"],\n  parent_path: str,\n) -> typing.List["SelectNode[typing.Any]"]:\n  out = []\n  sub_flags = selection.get("_")\n  if sub_flags is not None and not isinstance(sub_flags, SelectionFlags):\n    raise Exception(\n      f"selection field \'_\' should be of type SelectionFlags but found {type(sub_flags)}"\n    )\n  select_all = bool(sub_flags and sub_flags.select_all)\n  found_nodes = set(selection.keys())\n  for node_name, meta_fn in metas.items():\n    found_nodes.discard(node_name)\n\n    node_selection = selection.get(node_name)\n    if node_selection is False or (node_selection is None and not select_all):\n      # this node was not selected\n      continue\n\n    meta = meta_fn()\n\n    # we splat out any aliasing of nodes here\n    node_instances = (\n      [(key, val) for key, val in node_selection.items.items()]\n      if isinstance(node_selection, Alias)\n      else [(node_name, node_selection)]\n    )\n\n    for instance_name, instance_selection in node_instances:\n      # print(parent_path, instance_selection, meta.sub_nodes, instance_selection, flags)\n      if instance_selection is False or (\n        instance_selection is None and not select_all\n      ):\n        # this instance was not selected\n        continue\n      if isinstance(instance_selection, Alias):\n        raise Exception(\n          f"nested Alias node discovered at {parent_path}.{instance_name}"\n        )\n\n      instance_args: typing.Optional[NodeArgs] = None\n      if meta.arg_types is not None:\n        arg = instance_selection\n\n        if isinstance(arg, tuple):\n          arg = arg[0]\n\n        # arg types are always TypedDicts\n        if not isinstance(arg, dict):\n          raise Exception(\n            f"node at {parent_path}.{instance_name} is a node that "\n            + "requires arguments "\n            + f"but detected argument is typeof {type(arg)}"\n          )\n\n        # convert arg dict to NodeArgs\n        expected_args = {key: val for key, val in meta.arg_types.items()}\n        instance_args = {}\n        for key, val in arg.items():\n          ty_name = expected_args.pop(key)\n          if ty_name is None:\n            raise Exception(\n              f"unexpected argument ${key} at {parent_path}.{instance_name}"\n            )\n          instance_args[key] = NodeArgValue(ty_name, val)\n\n      sub_nodes: SubNodes = None\n      if meta.sub_nodes is not None or meta.variants is not None:\n        sub_selections = instance_selection\n\n        # if node requires both selection and arg, it must be\n        # a CompositeSelectArgs which is a tuple selection\n        if meta.arg_types is not None:\n          if not isinstance(sub_selections, tuple):\n            raise Exception(\n              f"node at {parent_path}.{instance_name} is a composite "\n              + "that requires an argument object "\n              + f"but selection is typeof {type(sub_selections)}"\n            )\n          sub_selections = sub_selections[1]\n\n        # we got a tuple selection when this shouldn\'t be the case\n        elif isinstance(sub_selections, tuple):\n          raise Exception(\n            f"node at {parent_path}.{instance_name} "\n            + "is a composite that takes no arguments "\n            + f"but selection is typeof {type(instance_selection)}",\n          )\n\n        # flags are recursive for any subnode that\'s not specified\n        if sub_selections is None:\n          sub_selections = {"_": sub_flags}\n\n        # selection types are always TypedDicts as well\n        if not isinstance(sub_selections, dict):\n          raise Exception(\n            f"node at {parent_path}.{instance_name} "\n            + "is a no argument composite but first element of "\n            + f"selection is typeof {type(instance_selection)}",\n          )\n\n        if meta.sub_nodes is not None:\n          if meta.variants is not None:\n            raise Exception(\n              "unreachable: union/either NodeMetas can\'t have subnodes"\n            )\n\n          # skip non explicit composite selection when using select_all\n          sub_flags = sub_selections.get("_")\n\n          if (\n            isinstance(sub_flags, SelectionFlags)\n            and sub_flags.select_all\n            and instance_selection is None\n          ):\n            continue\n\n          sub_nodes = selection_to_nodes(\n            typing.cast("SelectionErased", sub_selections),\n            meta.sub_nodes,\n            f"{parent_path}.{instance_name}",\n          )\n        else:\n          assert meta.variants is not None\n          union_selections: typing.Dict[str, typing.List[SelectNode]] = {}\n          for variant_ty, variant_meta in meta.variants.items():\n            variant_meta = variant_meta()\n\n            # this union member is a scalar\n            if variant_meta.sub_nodes is None:\n              continue\n\n            variant_select = sub_selections.pop(variant_ty, None)\n            nodes = (\n              selection_to_nodes(\n                typing.cast("SelectionErased", variant_select),\n                variant_meta.sub_nodes,\n                f"{parent_path}.{instance_name}.variant({variant_ty})",\n              )\n              if variant_select is not None\n              else []\n            )\n\n            # we select __typename for each variant\n            # even if the user is not interested in the variant\n            nodes.append(\n              SelectNode(\n                node_name="__typename",\n                instance_name="__typename",\n                args=None,\n                sub_nodes=None,\n                files=None,\n              )\n            )\n\n            union_selections[variant_ty] = nodes\n\n          if len(sub_selections) > 0:\n            raise Exception(\n              f"node at {parent_path}.{instance_name} "\n              + "has none of the variants called "\n              + str(sub_selections.keys()),\n            )\n          sub_nodes = union_selections\n\n      node = SelectNode(\n        node_name, instance_name, instance_args, sub_nodes, meta.input_files\n      )\n      out.append(node)\n\n  found_nodes.discard("_")\n  if len(found_nodes) > 0:\n    raise Exception(\n      f"unexpected nodes found in selection set at {parent_path}: {found_nodes}",\n    )\n  return out\n\n\n#\n# --- --- Util types --- --- #\n#\n\nOut = typing.TypeVar("Out", covariant=True)\nPreparedOut = typing.TypeVar("PreparedOut", covariant=True)\n\nT = typing.TypeVar("T")\n\nArgT = typing.TypeVar("ArgT", bound=typing.Mapping[str, typing.Any])\nSelectionT = typing.TypeVar("SelectionT")\n\n\nclass File:\n  def __init__(\n    self, content: bytes, name: str, mimetype: typing.Optional[str] = None\n  ):\n    self.content = content\n    self.name = name\n    self.mimetype = mimetype\n\n\n#\n# --- --- Graph node types --- --- #\n#\n\n\nSubNodes = typing.Union[\n  None,\n  # atomic composite\n  typing.List["SelectNode"],\n  # union/either selection\n  typing.Dict[str, typing.List["SelectNode"]],\n]\n\nTypePath = typing.List[typing.Union[typing.Literal["?"], typing.Literal["[]"], str]]\nValuePath = typing.List[typing.Union[typing.Literal[""], str]]\n\n\n@dc.dataclass\nclass SelectNode(typing.Generic[Out]):\n  node_name: str\n  instance_name: str\n  args: typing.Optional["NodeArgs"]\n  sub_nodes: SubNodes\n  files: typing.Optional[typing.List[TypePath]]\n\n\n@dc.dataclass\nclass QueryNode(SelectNode[Out]):\n  pass\n\n\n@dc.dataclass\nclass MutationNode(SelectNode[Out]):\n  pass\n\n\nNodeMetaFn = typing.Callable[[], "NodeMeta"]\n\n\n@dc.dataclass\nclass NodeMeta:\n  sub_nodes: typing.Optional[typing.Dict[str, NodeMetaFn]] = None\n  variants: typing.Optional[typing.Dict[str, NodeMetaFn]] = None\n  arg_types: typing.Optional[typing.Dict[str, str]] = None\n  input_files: typing.Optional[typing.List[TypePath]] = None\n\n\nclass FileExtractor:\n  def __init__(self):\n    self.path: TypePath = []\n    self.current_path: ValuePath = []\n    self.result: typing.Dict[str, File] = {}\n\n  def extract_from_value(self, value: typing.Any):\n    next_segment = self.path[len(self.current_path)]\n\n    if next_segment == "?":\n      if value is None:\n        return\n      self.current_path.append("")\n      self.extract_from_value(value)\n      self.current_path.pop()\n      return\n\n    if next_segment == "[]":\n      if not isinstance(value, list):\n        raise Exception(f"Expected array at {self.format_path()}")\n\n      for idx in range(len(value)):\n        self.current_path.append(f"[{idx}]")\n        self.extract_from_array(value, idx)\n        self.current_path.pop()\n      return\n\n    if next_segment.startswith("."):\n      if not isinstance(value, dict):\n        raise Exception(f"Expected dictionary at {self.format_path()}")\n\n      self.current_path.append(next_segment)\n      self.extract_from_object(value, next_segment[1:])\n      self.current_path.pop()\n      return\n\n  def extract_from_array(self, parent: typing.List[typing.Any], idx: int):\n    value = parent[idx]\n\n    if len(self.current_path) == len(self.path):\n      if isinstance(value, File):\n        self.result[self.format_path()] = value\n        parent[idx] = None\n        return\n\n      raise Exception(f"Expected File at {self.format_path()}")\n\n    self.extract_from_value(value)\n\n  def extract_from_object(self, parent: typing.Dict[str, typing.Any], key: str):\n    value = parent.get(key)\n\n    if len(self.current_path) == len(self.path):\n      if isinstance(value, File):\n        self.result[self.format_path()] = value\n        parent[key] = None\n        return\n\n      raise Exception(f"Expected File at {self.format_path()}")\n\n    self.extract_from_value(value)\n\n  def format_path(self):\n    res = ""\n\n    for path in self.current_path:\n      res += f".{path[1:-1]}" if path.startswith("[") else path\n\n    return res\n\n\ndef extract_files(\n  key: str, obj: typing.Dict[str, typing.Any], paths: typing.List[TypePath]\n):\n  extractor = FileExtractor()\n\n  for path in paths:\n    if path[0] and path[0].startswith("." + key):\n      extractor.current_path = []\n      extractor.path = path\n      extractor.extract_from_value(obj)\n\n  return extractor.result\n\n\n#\n# --- --- Argument types --- --- #\n#\n\n\n@dc.dataclass\nclass NodeArgValue:\n  type_name: str\n  value: typing.Any\n\n\nNodeArgs = typing.Dict[str, NodeArgValue]\n\n\nclass PlaceholderValue(typing.Generic[T]):\n  def __init__(self, key: str):\n    self.key = key\n\n\nPlaceholderArgs = typing.Dict[str, PlaceholderValue]\n\n\nclass PreparedArgs:\n  def get(self, key: str) -> PlaceholderValue:\n    return PlaceholderValue(key)\n\n\n#\n# --- --- Selection types --- --- #\n#\n\n\nclass Alias(typing.Generic[SelectionT]):\n  """\n  Request multiple instances of a single node under different\n  aliases.\n  """\n\n  def __init__(self, **aliases: SelectionT):\n    self.items = aliases\n\n\nScalarSelectNoArgs = typing.Union[bool, Alias[typing.Literal[True]], None]\nScalarSelectArgs = typing.Union[\n  ArgT,\n  PlaceholderArgs,\n  Alias[typing.Union[ArgT, PlaceholderArgs]],\n  typing.Literal[False],\n  None,\n]\nCompositeSelectNoArgs = typing.Union[\n  SelectionT, Alias[SelectionT], typing.Literal[False], None\n]\nCompositeSelectArgs = typing.Union[\n  typing.Tuple[typing.Union[ArgT, PlaceholderArgs], SelectionT],\n  Alias[typing.Tuple[typing.Union[ArgT, PlaceholderArgs], SelectionT]],\n  typing.Literal[False],\n  None,\n]\n\n\n# FIXME: ideally this would be a TypedDict\n# to allow full dict based queries but\n# we need to reliably identify SelectionFlags at runtime\n# but TypedDicts don\'t allow instanceof\n@dc.dataclass\nclass SelectionFlags:\n  select_all: typing.Union[bool, None] = None\n\n\nclass Selection(typing.TypedDict, total=False):\n  _: SelectionFlags\n\n\nSelectionErased = typing.Mapping[\n  str,\n  typing.Union[\n    SelectionFlags,\n    ScalarSelectNoArgs,\n    ScalarSelectArgs[typing.Mapping[str, typing.Any]],\n    CompositeSelectNoArgs["SelectionErased"],\n    # FIXME: should be possible to make SelectionT here `SelectionErased` recursively\n    # but something breaks\n    CompositeSelectArgs[typing.Mapping[str, typing.Any], typing.Any],\n  ],\n]\n\n#\n# --- --- GraphQL types --- --- #\n#\n\n\n@dc.dataclass\nclass GraphQLTransportOptions:\n  headers: typing.Dict[str, str]\n\n\n@dc.dataclass\nclass GraphQLRequest:\n  addr: str\n  method: str\n  headers: typing.Dict[str, str]\n  body: bytes\n\n\n@dc.dataclass\nclass GraphQLResponse:\n  req: GraphQLRequest\n  status: int\n  headers: typing.Dict[str, str]\n  body: bytes\n\n\ndef convert_query_node_gql(\n  ty_to_gql_ty_map: typing.Dict[str, str],\n  node: SelectNode,\n  variables: typing.Dict[str, NodeArgValue],\n  files: typing.Dict[str, File],\n):\n  out = (\n    f"{node.instance_name}: {node.node_name}"\n    if node.instance_name != node.node_name\n    else node.node_name\n  )\n  if node.args is not None:\n    arg_row = ""\n    for key, val in node.args.items():\n      name = f"in{len(variables)}"\n      obj = {key: val.value}\n\n      if node.files is not None and len(node.files) > 0:\n        extracted_files = extract_files(key, obj, node.files)\n\n        for path, file in extracted_files.items():\n          path_in_variables = re.sub(r"^\\.[^.\\[]+", f".{name}", path)\n          files[path_in_variables] = file\n\n      val.value = obj[key]\n      variables[name] = val\n      arg_row += f"{key}: ${name}, "\n    if len(arg_row):\n      out += f"({arg_row[:-2]})"\n\n  # if it\'s a dict, it\'ll be a union selection\n  if isinstance(node.sub_nodes, dict):\n    sub_node_list = ""\n    for variant_ty, sub_nodes in node.sub_nodes.items():\n      # fetch the gql variant name so we can do\n      # type assertions\n      gql_ty = ty_to_gql_ty_map[variant_ty]\n      if gql_ty is None:\n        raise Exception(\n          f"unreachable: no graphql type found for variant {variant_ty}"\n        )\n      gql_ty = gql_ty.strip("!")\n\n      sub_node_list += f"... on {gql_ty} {{ "\n      for node in sub_nodes:\n        sub_node_list += f"{convert_query_node_gql(ty_to_gql_ty_map, node, variables, files)} "\n      sub_node_list += "}"\n    out += f" {{ {sub_node_list}}}"\n  elif isinstance(node.sub_nodes, list):\n    sub_node_list = ""\n    for sub_node in node.sub_nodes:\n      sub_node_list += f"{convert_query_node_gql(ty_to_gql_ty_map, sub_node, variables, files)} "\n    out += f" {{ {sub_node_list}}}"\n  return out\n\n\nclass MultiPartForm:\n  def __init__(self):\n    self.form_fields: typing.List[typing.Tuple[str, str]] = []\n    self.files: typing.List[typing.Tuple[str, File]] = []\n    self.boundary = uuid.uuid4().hex.encode("utf-8")\n\n  def add_field(self, name: str, value: str):\n    self.form_fields.append((name, value))\n\n  def add_file(self, key, file: File):\n    self.files.append((key, file))\n\n  def get_content_type(self):\n    return f"multipart/form-data; boundary={self.boundary.decode(\'utf-8\')}"\n\n  def _form_data(self, name):\n    return f\'Content-Disposition: form-data; name="{name}"\\r\\n\'.encode("utf-8")\n\n  def _attached_file(self, name, filename):\n    return f\'Content-Disposition: file; name="{name}"; filename="{filename}"\\r\\n\'.encode(\n      "utf-8"\n    )\n\n  def _content_type(self, ct):\n    return f"Content-Type: {ct}\\r\\n".encode("utf-8")\n\n  def __bytes__(self):\n    buffer = io.BytesIO()\n    boundary = b"--" + self.boundary + b"\\r\\n"\n\n    for name, value in self.form_fields:\n      buffer.write(boundary)\n      buffer.write(self._form_data(name))\n      buffer.write(b"\\r\\n")\n      buffer.write(value.encode("utf-8"))\n      buffer.write(b"\\r\\n")\n\n    for key, file in self.files:\n      mimetype = (\n        file.mimetype\n        or mimetypes.guess_type(file.name)[0]\n        or "application/octet-stream"\n      )\n\n      buffer.write(boundary)\n      buffer.write(self._attached_file(key, file.name))\n      buffer.write(self._content_type(mimetype))\n      buffer.write(b"\\r\\n")\n      buffer.write(file.content)\n      buffer.write(b"\\r\\n")\n\n    buffer.write(b"--" + self.boundary + b"--\\r\\n")\n\n    return buffer.getvalue()\n\n\nclass GraphQLTransportBase(ABC):\n  def __init__(\n    self,\n    addr: str,\n    opts: GraphQLTransportOptions,\n    ty_to_gql_ty_map: typing.Dict[str, str],\n  ):\n    self.addr = addr\n    self.opts = opts\n    self.ty_to_gql_ty_map = ty_to_gql_ty_map\n\n  def build_gql(\n    self,\n    query: typing.Mapping[str, SelectNode],\n    ty: typing.Union[typing.Literal["query"], typing.Literal["mutation"]],\n    name: str = "",\n  ):\n    variables: typing.Dict[str, NodeArgValue] = {}\n    files: typing.Dict[str, File] = {}\n    root_nodes = ""\n    for key, node in query.items():\n      fixed_node = SelectNode(\n        node.node_name, key, node.args, node.sub_nodes, node.files\n      )\n      root_nodes += f"  {convert_query_node_gql(self.ty_to_gql_ty_map, fixed_node, variables, files)}\\n"\n    args_row = ""\n    for key, val in variables.items():\n      args_row += f"${key}: {self.ty_to_gql_ty_map[val.type_name]}, "\n\n    if len(args_row):\n      args_row = f"({args_row[:-2]})"\n\n    doc = f"{ty} {name}{args_row} {{\\n{root_nodes}}}"\n    variables = {key: val.value for key, val in variables.items()}\n    # print(doc, variables)\n    return (doc, variables, files)\n\n  def build_req(\n    self,\n    doc: str,\n    variables: typing.Dict[str, typing.Any],\n    opts: typing.Optional[GraphQLTransportOptions] = None,\n    files: typing.Optional[typing.Dict[str, File]] = None,\n  ):\n    if files is None:\n      files = {}\n    headers = {}\n    headers.update(self.opts.headers)\n    if opts:\n      headers.update(opts.headers)\n    headers.update({"accept": "application/json"})\n\n    body = json.dumps({"query": doc, "variables": variables})\n\n    if len(files) > 0:\n      form_data = MultiPartForm()\n      form_data.add_field("operations", body)\n      file_map = {}\n      map = {}\n\n      for path, file in files.items():\n        array = file_map.get(file)\n        variable = "variables" + path\n        if array is not None:\n          array.append(variable)\n        else:\n          file_map[file] = [variable]\n\n      for idx, (file, variables) in enumerate(file_map.items()):\n        key = str(idx)\n        map[key] = variables\n        form_data.add_file(key, file)\n\n      form_data.add_field("map", json.dumps(map))\n      headers.update({"Content-type": form_data.get_content_type()})\n      body = bytes(form_data)\n    else:\n      headers.update({"Content-type": "application/json"})\n      body = body.encode("utf-8")\n\n    return GraphQLRequest(\n      addr=self.addr,\n      method="POST",\n      headers=headers,\n      body=body,\n    )\n\n  def handle_response(self, res: GraphQLResponse):\n    if res.status != 200:\n      raise Exception(f"graphql request failed with status {res.status}", res)\n    if res.headers.get("content-type") != "application/json":\n      raise Exception("unexpected content-type in graphql response", res)\n    parsed = json.loads(res.body)\n    if parsed.get("errors"):\n      raise Exception("graphql errors in response", parsed)\n    return parsed["data"]\n\n  @abstractmethod\n  def fetch(\n    self,\n    doc: str,\n    variables: typing.Dict[str, typing.Any],\n    opts: typing.Optional[GraphQLTransportOptions],\n    files: typing.Optional[typing.Dict[str, File]] = None,\n  ) -> typing.Any: ...\n\n  @typing.overload\n  def query(\n    self,\n    inp: QueryNode[Out],\n    opts: typing.Optional[GraphQLTransportOptions] = None,\n    name: str = "",\n  ) -> Out: ...\n\n  @typing.overload\n  def query(\n    self,\n    inp: typing.Dict[str, QueryNode[Out]],\n    opts: typing.Optional[GraphQLTransportOptions] = None,\n    name: str = "",\n  ) -> typing.Dict[str, Out]: ...\n\n  def query(\n    self,\n    inp: typing.Union[QueryNode[Out], typing.Dict[str, QueryNode[Out]]],\n    opts: typing.Optional[GraphQLTransportOptions] = None,\n    name: str = "",\n  ) -> typing.Union[Out, typing.Dict[str, Out]]:\n    query = {"value": inp} if isinstance(inp, QueryNode) else inp\n    doc, variables, _ = self.build_gql(query, "query", name)\n    result = self.fetch(doc, variables, opts)\n    return result["value"] if isinstance(inp, QueryNode) else result\n\n  @typing.overload\n  def mutation(\n    self,\n    inp: MutationNode[Out],\n    opts: typing.Optional[GraphQLTransportOptions] = None,\n    name: str = "",\n  ) -> Out: ...\n\n  @typing.overload\n  def mutation(\n    self,\n    inp: typing.Dict[str, MutationNode[Out]],\n    opts: typing.Optional[GraphQLTransportOptions] = None,\n    name: str = "",\n  ) -> typing.Dict[str, Out]: ...\n\n  def mutation(\n    self,\n    inp: typing.Union[MutationNode[Out], typing.Dict[str, MutationNode[Out]]],\n    opts: typing.Optional[GraphQLTransportOptions] = None,\n    name: str = "",\n  ) -> typing.Union[Out, typing.Dict[str, Out]]:\n    mutation = {"value": inp} if isinstance(inp, MutationNode) else inp\n    doc, variables, files = self.build_gql(mutation, "mutation", name)\n    result = self.fetch(doc, variables, opts, files)\n    return result["value"] if isinstance(inp, MutationNode) else result\n\n\nclass GraphQLTransportUrlib(GraphQLTransportBase):\n  def fetch(\n    self,\n    doc: str,\n    variables: typing.Dict[str, typing.Any],\n    opts: typing.Optional[GraphQLTransportOptions],\n    files: typing.Optional[typing.Dict[str, File]] = None,\n  ):\n    if files is None:\n      files = {}\n    req = self.build_req(doc, variables, opts, files)\n    try:\n      with request.urlopen(\n        request.Request(\n          url=req.addr, method=req.method, headers=req.headers, data=req.body\n        )\n      ) as res:\n        http_res: http_c.HTTPResponse = res\n        return self.handle_response(\n          GraphQLResponse(\n            req,\n            status=http_res.status,\n            body=http_res.read(),\n            headers={key: val for key, val in http_res.headers.items()},\n          )\n        )\n    except request.HTTPError as res:\n      return self.handle_response(\n        GraphQLResponse(\n          req,\n          status=res.status or 599,\n          body=res.read(),\n          headers={key: val for key, val in res.headers.items()},\n        )\n      )\n    except urllib.error.URLError as err:\n      raise Exception(f"URL error: {err.reason}") from err\n\n  @typing.overload\n  def prepare_query(\n    self,\n    fun: typing.Callable[[PreparedArgs], QueryNode[Out]],\n    name: str = "",\n  ) -> "PreparedRequest[Out, Out]": ...\n\n  @typing.overload\n  def prepare_query(\n    self,\n    fun: typing.Callable[[PreparedArgs], typing.Dict[str, QueryNode[Out]]],\n    name: str = "",\n  ) -> "PreparedRequest[Out, typing.Dict[str, Out]]": ...\n\n  def prepare_query(\n    self,\n    fun: typing.Callable[\n      [PreparedArgs],\n      typing.Union[QueryNode[Out], typing.Dict[str, QueryNode[Out]]],\n    ],\n    name: str = "",\n  ) -> typing.Union[\n    "PreparedRequest[Out, Out]",\n    "PreparedRequest[Out, typing.Dict[str, Out]]",\n  ]:\n    return PreparedRequest(self, fun, "query", name)\n\n  @typing.overload\n  def prepare_mutation(\n    self,\n    fun: typing.Callable[[PreparedArgs], MutationNode[Out]],\n    name: str = "",\n  ) -> "PreparedRequest[Out, Out]": ...\n\n  @typing.overload\n  def prepare_mutation(\n    self,\n    fun: typing.Callable[[PreparedArgs], typing.Dict[str, MutationNode[Out]]],\n    name: str = "",\n  ) -> "PreparedRequest[Out, typing.Dict[str, Out]]": ...\n\n  def prepare_mutation(\n    self,\n    fun: typing.Callable[\n      [PreparedArgs],\n      typing.Union[MutationNode[Out], typing.Dict[str, MutationNode[Out]]],\n    ],\n    name: str = "",\n  ) -> typing.Union[\n    "PreparedRequest[Out, Out]",\n    "PreparedRequest[Out, typing.Dict[str, Out]]",\n  ]:\n    return PreparedRequest(self, fun, "mutation", name)\n\n\nHostcallBinding = typing.Callable[\n  [str, typing.Dict[str, typing.Any]], typing.Dict[str, typing.Any]\n]\n\n\nclass HostcallTransport(GraphQLTransportBase):\n  def __init__(\n    self,\n    gql_fn: HostcallBinding,\n    opts: GraphQLTransportOptions,\n    ty_to_gql_ty_map: typing.Dict[str, str],\n  ):\n    self.gql_fn = gql_fn\n    self.opts = opts\n    self.ty_to_gql_ty_map = ty_to_gql_ty_map\n\n  def fetch(\n    self,\n    doc: str,\n    variables: typing.Dict[str, typing.Any],\n    opts: typing.Optional[GraphQLTransportOptions],\n    files: typing.Optional[typing.Dict[str, File]] = None,\n  ):\n    _ = opts\n\n    if files is None:\n      files = {}\n\n    if len(files) > 0:\n      raise Exception("no support for file upload on HostcallTransport")\n\n    res = self.gql_fn(doc, variables)\n    if res.get("errors"):\n      raise Exception("graphql errors in response", res)\n    return res["data"]\n\n  @typing.overload\n  def prepare_query(\n    self,\n    fun: typing.Callable[[PreparedArgs], QueryNode[Out]],\n    name: str = "",\n  ) -> "PreparedRequest[Out, Out]": ...\n\n  @typing.overload\n  def prepare_query(\n    self,\n    fun: typing.Callable[[PreparedArgs], typing.Dict[str, QueryNode[Out]]],\n    name: str = "",\n  ) -> "PreparedRequest[Out, typing.Dict[str, Out]]": ...\n\n  def prepare_query(\n    self,\n    fun: typing.Callable[\n      [PreparedArgs],\n      typing.Union[QueryNode[Out], typing.Dict[str, QueryNode[Out]]],\n    ],\n    name: str = "",\n  ) -> typing.Union[\n    "PreparedRequest[Out, Out]",\n    "PreparedRequest[Out, typing.Dict[str, Out]]",\n  ]:\n    return PreparedRequest(self, fun, "query", name)\n\n  @typing.overload\n  def prepare_mutation(\n    self,\n    fun: typing.Callable[[PreparedArgs], MutationNode[Out]],\n    name: str = "",\n  ) -> "PreparedRequest[Out, Out]": ...\n\n  @typing.overload\n  def prepare_mutation(\n    self,\n    fun: typing.Callable[[PreparedArgs], typing.Dict[str, MutationNode[Out]]],\n    name: str = "",\n  ) -> "PreparedRequest[Out, typing.Dict[str, Out]]": ...\n\n  def prepare_mutation(\n    self,\n    fun: typing.Callable[\n      [PreparedArgs],\n      typing.Union[MutationNode[Out], typing.Dict[str, MutationNode[Out]]],\n    ],\n    name: str = "",\n  ) -> typing.Union[\n    "PreparedRequest[Out, Out]",\n    "PreparedRequest[Out, typing.Dict[str, Out]]",\n  ]:\n    return PreparedRequest(self, fun, "mutation", name)\n\n\nclass PreparedRequest(typing.Generic[Out, PreparedOut]):\n  def __init__(\n    self,\n    transport: GraphQLTransportBase,\n    fun: typing.Callable[\n      [PreparedArgs],\n      typing.Union[SelectNode[Out], typing.Mapping[str, SelectNode[Out]]],\n    ],\n    ty: typing.Union[typing.Literal["query"], typing.Literal["mutation"]],\n    name: str = "",\n  ):\n    dry_run_node = fun(PreparedArgs())\n    query = (\n      {"value": dry_run_node}\n      if isinstance(dry_run_node, SelectNode)\n      else dry_run_node\n    )\n    doc, variables, files = transport.build_gql(query, ty, name)\n    self.single_node = isinstance(dry_run_node, SelectNode)\n    self.doc = doc\n    self._mapping = variables\n    self.transport = transport\n    self.files = files\n\n  def resolve_vars(\n    self,\n    args: typing.Mapping[str, typing.Any],\n    mappings: typing.Dict[str, typing.Any],\n  ):\n    resolved: typing.Dict[str, typing.Any] = {}\n    for key, val in mappings.items():\n      if isinstance(val, PlaceholderValue):\n        resolved[key] = args[val.key]\n      elif isinstance(val, dict):\n        self.resolve_vars(args, val)\n      else:\n        resolved[key] = val\n    return resolved\n\n  def perform(\n    self,\n    args: typing.Mapping[str, typing.Any],\n    opts: typing.Optional[GraphQLTransportOptions] = None,\n  ) -> PreparedOut:\n    resolved_vars = self.resolve_vars(args, self._mapping)\n    result = self.transport.fetch(self.doc, resolved_vars, opts)\n    if self.single_node:\n      return result["value"]\n    else:\n      return result\n\n\n#\n# --- --- QueryGraph types --- --- #\n#\n\n\nclass QueryGraphBase:\n  def __init__(self, ty_to_gql_ty_map: typing.Dict[str, str]):\n    self.ty_to_gql_ty_map = ty_to_gql_ty_map\n\n\nclass Transports:\n  @staticmethod\n  def graphql_sync(\n    qg: QueryGraphBase,\n    addr: str,\n    opts: typing.Optional[GraphQLTransportOptions] = None,\n  ):\n    return GraphQLTransportUrlib(\n      addr, opts or GraphQLTransportOptions({}), qg.ty_to_gql_ty_map\n    )\n\n  @staticmethod\n  def hostcall(\n    qg: QueryGraphBase,\n    binding: HostcallBinding,\n  ):\n    return HostcallTransport(\n      binding, GraphQLTransportOptions({}), qg.ty_to_gql_ty_map\n    )\n\n\n#\n# --- --- Typegraph types --- --- #\n#\n\n\nclass NodeDescs:\n  @staticmethod\n  def scalar():\n    return NodeMeta()\n\n  @staticmethod\n  def Idv3():\n    return NodeMeta(\n      sub_nodes={\n        "title": NodeDescs.scalar,\n        "artist": NodeDescs.scalar,\n        "releaseTime": NodeDescs.scalar,\n        "mp3Url": NodeDescs.scalar,\n      },\n    )\n\n  @staticmethod\n  def RemixTrack():\n    return_node = NodeDescs.Idv3()\n    return NodeMeta(\n      sub_nodes=return_node.sub_nodes,\n      variants=return_node.variants,\n      arg_types={\n        "title": "Idv3TitleString",\n        "artist": "Idv3TitleString",\n        "releaseTime": "Idv3ReleaseTimeStringDatetime",\n        "mp3Url": "Idv3Mp3UrlStringUri",\n      },\n    )\n\n\nIdv3TitleString = str\n\nIdv3ReleaseTimeStringDatetime = str\n\nIdv3Mp3UrlStringUri = str\n\nIdv3 = typing.TypedDict(\n  "Idv3",\n  {\n    "title": Idv3TitleString,\n    "artist": Idv3TitleString,\n    "release_time": Idv3ReleaseTimeStringDatetime,\n    "mp3_url": Idv3Mp3UrlStringUri,\n  },\n  total=False,\n)\n\n\nIdv3Selections = typing.TypedDict(\n  "Idv3Selections",\n  {\n    "_": SelectionFlags,\n    "title": ScalarSelectNoArgs,\n    "artist": ScalarSelectNoArgs,\n    "release_time": ScalarSelectNoArgs,\n    "mp3_url": ScalarSelectNoArgs,\n  },\n  total=False,\n)\n\n\nclass QueryGraph(QueryGraphBase):\n  def __init__(self):\n    super().__init__(\n      {\n        "Idv3TitleString": "String!",\n        "Idv3ReleaseTimeStringDatetime": "String!",\n        "Idv3Mp3UrlStringUri": "String!",\n      }\n    )\n\n  def remix(\n    self, args: typing.Union[Idv3, PlaceholderArgs], select: Idv3Selections\n  ) -> QueryNode[Idv3]:\n    node = selection_to_nodes(\n      {"remix": (args, select)}, {"remix": NodeDescs.RemixTrack}, "$q"\n    )[0]\n    return QueryNode(\n      node.node_name, node.instance_name, node.args, node.sub_nodes, node.files\n    )\n\n\ndef handler_remix_track(user_fn: typing.Callable[[Idv3, Ctx], Idv3]):\n  def wrapper(raw_inp, gql_fn):\n    qg = QueryGraph()\n    host = Transports.hostcall(qg, gql_fn)\n    cx = Ctx(gql_fn, qg, host)\n    return user_fn(raw_inp, cx)\n\n  return wrapper',path:"../examples/typegraphs/metagen/py/fdk.py"}},28434:n=>{n.exports={content:'from .fdk import handler_remix_track, Idv3, Ctx\n\n\n# the following decorator makes sure your function\n# adheres to the function types from the typegraph\n@handler_remix_track\ndef remix_track(inp: Idv3, _cx: Ctx) -> Idv3:\n  return {\n    "title": f"{inp[\'title\']} (Remix)",\n    "artist": f"{inp[\'artist\']} + DJ Cloud",\n    "release_time": inp["release_time"],\n    "mp3_url": "https://mp3.url/remix1",\n  }',path:"../examples/typegraphs/metagen/py/remix.py"}},86496:n=>{n.exports={content:'// This file was @generated by metagen and is intended\n// to be generated again on subsequent metagen runs.\n#![cfg_attr(rustfmt, rustfmt_skip)]\n\n// gen-static-start\n#![allow(dead_code)]\n\npub mod wit {\n    wit_bindgen::generate!({\n        pub_export_macro: true,\n        \n\n        inline: "package metatype:wit-wire;\n\ninterface typegate-wire {\n  hostcall: func(op-name: string, json: string) -> result<string, string>;\n}\n\ninterface mat-wire {\n  type json-str = string;\n\n  record mat-info {\n    op-name: string,\n    mat-title: string,\n    mat-hash: string,\n    mat-data-json: string,\n  }\n\n  record init-args {\n    metatype-version: string,\n    expected-ops: list<mat-info>\n  }\n\n  record init-response {\n    ok: bool\n  }\n\n  variant init-error {\n    version-mismatch(string),\n    unexpected-mat(mat-info),\n    other(string)\n  }\n\n  init: func(args: init-args) -> result<init-response, init-error>;\n\n  record handle-req {\n    op-name: string,\n    in-json: json-str,\n  }\n\n  variant handle-err {\n    no-handler,\n    in-json-err(string),\n    handler-err(string),\n  }\n\n  handle: func(req: handle-req) -> result<json-str, handle-err>;\n}\n\nworld wit-wire {\n  import typegate-wire;\n\n  export mat-wire;\n}\n"\n    });\n}\n\nuse std::cell::RefCell;\nuse std::collections::HashMap;\n\nuse wit::exports::metatype::wit_wire::mat_wire::*;\nuse wit::metatype::wit_wire::typegate_wire::hostcall;\n\npub type HandlerFn = Box<dyn Fn(&str, Ctx) -> Result<String, HandleErr>>;\n\npub struct ErasedHandler {\n    mat_id: String,\n    mat_trait: String,\n    mat_title: String,\n    handler_fn: HandlerFn,\n}\n\npub struct MatBuilder {\n    handlers: HashMap<String, ErasedHandler>,\n}\n\nimpl Default for MatBuilder {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl MatBuilder {\n    pub fn new() -> Self {\n        Self {\n            handlers: Default::default(),\n        }\n    }\n\n    pub fn register_handler(mut self, handler: ErasedHandler) -> Self {\n        self.handlers.insert(handler.mat_trait.clone(), handler);\n        self\n    }\n}\n\npub struct Router {\n    handlers: HashMap<String, ErasedHandler>,\n}\n\nimpl Router {\n    pub fn from_builder(builder: MatBuilder) -> Self {\n        Self {\n            handlers: builder.handlers,\n        }\n    }\n\n    pub fn init(&self, args: InitArgs) -> Result<InitResponse, InitError> {\n        static MT_VERSION: &str = "0.5.1-rc.2";\n        if args.metatype_version != MT_VERSION {\n            return Err(InitError::VersionMismatch(MT_VERSION.into()));\n        }\n        for info in args.expected_ops {\n            let mat_trait = stubs::op_to_trait_name(&info.op_name);\n            if !self.handlers.contains_key(mat_trait) {\n                return Err(InitError::UnexpectedMat(info));\n            }\n        }\n        Ok(InitResponse { ok: true })\n    }\n\n    pub fn handle(&self, req: HandleReq) -> Result<String, HandleErr> {\n        let mat_trait = stubs::op_to_trait_name(&req.op_name);\n        let Some(handler) = self.handlers.get(mat_trait) else {\n            return Err(HandleErr::NoHandler);\n        };\n        let qg = query_graph();\n        let cx = Ctx {\n            host: transports::hostcall(&qg),\n            qg,\n        };\n        (handler.handler_fn)(&req.in_json, cx)\n    }\n}\n\npub type InitCallback = fn() -> anyhow::Result<MatBuilder>;\n\nthread_local! {\n    pub static MAT_STATE: RefCell<Router> = panic!("MAT_STATE has not been initialized");\n}\n\n\npub struct Ctx {\n    pub qg: QueryGraph,\n    pub host: metagen_client::hostcall::HostcallTransport,\n}\n\nimpl Ctx {\n    pub fn gql<O>(\n        &self,\n        query: &str,\n        variables: impl Into<serde_json::Value>,\n    ) -> Result<O, GraphqlRunError>\n    where\n        O: serde::de::DeserializeOwned,\n    {\n        match hostcall(\n            "gql",\n            &serde_json::to_string(&serde_json::json!({\n                "query": query,\n                "variables": variables.into(),\n            }))?,\n        ) {\n            Ok(json) => Ok(serde_json::from_str(&json[..])?),\n            Err(json) => Err(GraphqlRunError::HostError(serde_json::from_str(&json)?)),\n        }\n    }\n}\n\n#[derive(Debug)]\npub enum GraphqlRunError {\n    JsonError(serde_json::Error),\n    HostError(serde_json::Value),\n}\n\nimpl std::error::Error for GraphqlRunError {}\n\nimpl From<serde_json::Error> for GraphqlRunError {\n    fn from(value: serde_json::Error) -> Self {\n        Self::JsonError(value)\n    }\n}\n\nimpl std::fmt::Display for GraphqlRunError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<\'_>) -> std::fmt::Result {\n        match self {\n            GraphqlRunError::JsonError(msg) => write!(f, "json error: {msg}"),\n            GraphqlRunError::HostError(serde_json::Value::Object(map))\n                if map.contains_key("message") =>\n            {\n                write!(f, "host error: {}", map["message"])\n            }\n            GraphqlRunError::HostError(val) => write!(f, "host error: {val:?}"),\n        }\n    }\n}\n\n#[macro_export]\nmacro_rules! init_mat {\n    (hook: $init_hook:expr) => {\n        struct MatWireGuest;\n        use wit::exports::metatype::wit_wire::mat_wire::*;\n        wit::export!(MatWireGuest with_types_in wit);\n\n        #[allow(unused)]\n        impl Guest for MatWireGuest {\n            fn handle(req: HandleReq) -> Result<String, HandleErr> {\n                MAT_STATE.with(|router| {\n                    let router = router.borrow();\n                    router.handle(req)\n                })\n            }\n\n            fn init(args: InitArgs) -> Result<InitResponse, InitError> {\n                let hook = $init_hook;\n                let router = Router::from_builder(hook());\n                let resp = router.init(args)?;\n                MAT_STATE.set(router);\n                Ok(resp)\n            }\n        }\n    };\n}\n// gen-static-end\nuse core::marker::PhantomData;\nuse metagen_client::prelude::*;\n\n/// Contains constructors for the different transports supported\n/// by the typegate. Namely:\n/// - GraphQl transports ([sync](transports::graphql)/[async](transports::graphql_sync)): reqwest\n///   based transports that talk to the typegate using GraphQl over HTTP.\n/// - [Hostcall transport](transports::hostcall): used by custom functions running in the typegate to access typegraphs.\npub mod transports {\n    use super::*;\n\n\n\n    pub fn hostcall(qg: &QueryGraph) -> metagen_client::hostcall::HostcallTransport {\n        metagen_client::hostcall::HostcallTransport::new(\n            std::sync::Arc::new(super::hostcall),\n            qg.ty_to_gql_ty_map.clone(),\n        )\n    }\n}\n\n//\n// --- --- QueryGraph types --- --- //\n//\n\n#[derive(Clone)]\npub struct QueryGraph {\n    ty_to_gql_ty_map: TyToGqlTyMap,\n}\n\n//\n// --- --- Typegraph types --- --- //\n//\n\n#[allow(non_snake_case)]\nmod node_metas {\n    use super::*;\n    pub fn scalar() -> NodeMeta {\n        NodeMeta {\n            arg_types: None,\n            sub_nodes: None,\n            variants: None,\n            input_files: None,\n        }\n    }    \n    pub fn RemixTrack() -> NodeMeta {\n        NodeMeta {\n            arg_types: Some(\n                [\n                    ("artist".into(), "idv3_title_string".into()),\n                    ("mp3Url".into(), "idv3_mp3Url_string_uri".into()),\n                    ("releaseTime".into(), "idv3_releaseTime_string_datetime".into()),\n                    ("title".into(), "idv3_title_string".into()),\n                ].into()\n            ),\n            ..Idv3()\n        }\n    }\n    pub fn Idv3() -> NodeMeta {\n        NodeMeta {\n            arg_types: None,\n            variants: None,\n            sub_nodes: Some(\n                [\n                    ("title".into(), scalar as NodeMetaFn),\n                    ("artist".into(), scalar as NodeMetaFn),\n                    ("releaseTime".into(), scalar as NodeMetaFn),\n                    ("mp3Url".into(), scalar as NodeMetaFn),\n                ].into()\n            ),\n            input_files: None,\n        }\n    }\n\n}\nuse types::*;\n#[allow(unused)]\npub mod types {\n    // input types\n    #[derive(Debug, serde::Serialize, serde::Deserialize)]\n    pub struct Idv3 {\n        pub title: Idv3TitleString,\n        pub artist: Idv3TitleString,\n        #[serde(rename = "releaseTime")]\n        pub release_time: Idv3ReleaseTimeStringDatetime,\n        #[serde(rename = "mp3Url")]\n        pub mp3_url: Idv3Mp3UrlStringUri,\n    }\n    pub type Idv3TitleString = String;\n    pub type Idv3ReleaseTimeStringDatetime = String;\n    pub type Idv3Mp3UrlStringUri = String;\n    // partial output types\n    #[derive(Debug, serde::Serialize, serde::Deserialize)]\n    pub struct Idv3Partial {\n        pub title: Option<Idv3TitleString>,\n        pub artist: Option<Idv3TitleString>,\n        #[serde(rename = "releaseTime")]\n        pub release_time: Option<Idv3ReleaseTimeStringDatetime>,\n        #[serde(rename = "mp3Url")]\n        pub mp3_url: Option<Idv3Mp3UrlStringUri>,\n    }\n    // output types\n}\n#[derive(Default, Debug)]\npub struct Idv3Selections<ATy = NoAlias> {\n    pub title: ScalarSelect<ATy>,\n    pub artist: ScalarSelect<ATy>,\n    pub release_time: ScalarSelect<ATy>,\n    pub mp3_url: ScalarSelect<ATy>,\n}\nimpl_selection_traits!(Idv3Selections, title, artist, release_time, mp3_url);\n\npub fn query_graph() -> QueryGraph {\n    QueryGraph {\n        ty_to_gql_ty_map: std::sync::Arc::new([\n            ("idv3_title_string".into(), "String!".into()),\n            ("idv3_releaseTime_string_datetime".into(), "String!".into()),\n            ("idv3_mp3Url_string_uri".into(), "String!".into()),\n        ].into()),\n    }\n}\n    impl QueryGraph{\n\n    pub fn remix(\n        &self,\n        args: impl Into<NodeArgs<Idv3>>\n    ) -> UnselectedNode<Idv3Selections, Idv3Selections<HasAlias>, QueryMarker, Idv3Partial>\n    {\n        UnselectedNode {\n            root_name: "remix".into(),\n            root_meta: node_metas::RemixTrack,\n            args: args.into().into(),\n            _marker: PhantomData,\n        }\n    }\n}\npub mod stubs {\n    use super::*;\n    pub trait RemixTrack: Sized + \'static {\n        fn erased(self) -> ErasedHandler {\n            ErasedHandler {\n                mat_id: "remix_track".into(),\n                mat_title: "remix_track".into(),\n                mat_trait: "RemixTrack".into(),\n                handler_fn: Box::new(move |req, cx| {\n                    let req = serde_json::from_str(req)\n                        .map_err(|err| HandleErr::InJsonErr(format!("{err}")))?;\n                    let res = self\n                        .handle(req, cx)\n                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))?;\n                    serde_json::to_string(&res)\n                        .map_err(|err| HandleErr::HandlerErr(format!("{err}")))\n                }),\n            }\n        }\n\n        fn handle(&self, input: Idv3, cx: Ctx) -> anyhow::Result<Idv3>;\n    }\n    pub fn op_to_trait_name(op_name: &str) -> &\'static str {\n        match op_name {\n            "remix_track" => "RemixTrack",\n            _ => panic!("unrecognized op_name: {op_name}"),\n        }\n    }\n}',path:"../examples/typegraphs/metagen/rs/fdk.rs"}},39028:n=>{n.exports={content:'mod fdk;\npub use fdk::*;\n\n// the macro sets up all the glue\ninit_mat! {\n    // the hook is expected to return a MatBuilder instance\n    hook: || {\n        // initialize global stuff here if you need it\n        MatBuilder::new()\n            // register function handlers here\n            // each trait will map to the name of the\n            // handler found in the typegraph\n            .register_handler(stubs::RemixTrack::erased(MyMat))\n    }\n}\n\nstruct MyMat;\n\nimpl stubs::RemixTrack for MyMat {\n    fn handle(&self, input: types::Idv3, _cx: Ctx) -> anyhow::Result<types::Idv3> {\n        Ok(types::Idv3 {\n            title: format!("{} (Remix)", input.title),\n            artist: format!("{} + DJ Cloud", input.artist),\n            release_time: input.release_time,\n            mp3_url: "https://mp3.url/shumba2".to_string(),\n        })\n    }\n}',path:"../examples/typegraphs/metagen/rs/lib.rs"}},96280:n=>{n.exports={content:'// This file was @generated by metagen and is intended\n// to be generated again on subsequent metagen runs.\n\nexport type Ctx = {\n  parent?: Record<string, unknown>;\n  /**\n   * Request context extracted by auth extractors.\n   */\n  context?: Record<string, unknown>;\n  secrets: Record<string, string>;\n  effect: "create" | "update" | "delete" | "read" | undefined | null;\n  meta: {\n    url: string;\n    token: string;\n  };\n  headers: Record<string, string>;\n};\n\n/**\n * Access features on your typegraph deployment.\n */\nexport type Deployment = {\n  gql: (query: readonly string[], ...args: unknown[]) => {\n    run: (\n      variables: Record<string, unknown>,\n    ) => Promise<Record<string, unknown>>;\n  };\n};\n\nexport type Handler<In, Out> = (\n  input: In,\n  ctx: Ctx,\n  tg: Deployment,\n) => Out | Promise<Out>;\n\nfunction _selectionToNodeSet(\n  selection: Selection,\n  metas: [string, () => NodeMeta][],\n  parentPath: string,\n): SelectNode<unknown>[] {\n  const out = [] as SelectNode[];\n  const selectAll = selection._ == "selectAll";\n  // set of the user specified nodes to do sanity\n  // check at the end\n  const foundNodes = new Set(Object.keys(selection));\n\n  for (const [nodeName, metaFn] of metas) {\n    foundNodes.delete(nodeName);\n\n    const nodeSelection = selection[nodeName];\n    if (!nodeSelection && !selectAll) {\n      // this node was not selected\n      continue;\n    }\n\n    const { argumentTypes, subNodes, variants, inputFiles } = metaFn();\n\n    const nodeInstances = nodeSelection instanceof Alias\n      ? nodeSelection.aliases()\n      : { [nodeName]: nodeSelection };\n\n    for (\n      const [instanceName, instanceSelection] of Object.entries(\n        nodeInstances,\n      )\n    ) {\n      if (!instanceSelection && !selectAll) {\n        continue;\n      }\n      if (instanceSelection instanceof Alias) {\n        throw new Error(\n          `nested Alias discovered at ${parentPath}.${instanceName}`,\n        );\n      }\n      const node: SelectNode = { instanceName, nodeName, files: inputFiles };\n\n      if (argumentTypes) {\n        // make sure the arg is of the expected form\n        let arg = instanceSelection;\n        if (Array.isArray(arg)) {\n          arg = arg[0];\n        }\n        // TODO: consider bringing in Zod (after hoisting impl into common lib)\n        if (typeof arg != "object" || arg === null) {\n          throw new Error(\n            `node at ${parentPath}.${instanceName} is a node ` +\n              `that requires arguments object but detected argument ` +\n              `is typeof ${typeof arg}`,\n          );\n        }\n\n        const expectedArguments = new Map(Object.entries(argumentTypes));\n        node.args = {};\n        for (const [key, value] of Object.entries(arg)) {\n          const typeName = expectedArguments.get(key);\n          // TODO: consider logging a warning if `_` is detected incase user passes\n          // Selection as arg\n          if (!typeName) {\n            throw new Error(\n              `unexpected argument ${key} at ${parentPath}.${instanceName}`,\n            );\n          }\n          expectedArguments.delete(key);\n          node.args[key] = { typeName, value };\n        }\n      }\n\n      if (subNodes || variants) {\n        // sanity check selection object\n        let subSelections = instanceSelection;\n        if (argumentTypes) {\n          if (!Array.isArray(subSelections)) {\n            throw new Error(\n              `node at ${parentPath}.${instanceName} ` +\n                `is a composite that takes an argument ` +\n                `but selection is typeof ${typeof subSelections}`,\n            );\n          }\n          subSelections = subSelections[1];\n        } else if (Array.isArray(subSelections)) {\n          throw new Error(\n            `node at ${parentPath}.${instanceName} ` +\n              `is a composite that takes no arguments ` +\n              `but selection is typeof ${typeof subSelections}`,\n          );\n        }\n        if (subSelections == undefined) {\n          subSelections = {\n            _: selection._,\n          };\n        }\n        if (typeof subSelections != "object") {\n          throw new Error(\n            `node at ${parentPath}.${nodeName} ` +\n              `is a no argument composite but first element of ` +\n              `selection is typeof ${typeof nodeSelection}`,\n          );\n        }\n\n        if (subNodes) {\n          if (variants) {\n            throw new Error(\n              "unreachable: union/either NodeMetas can\'t have subnodes",\n            );\n          }\n\n          // skip non explicit composite selection when using selectAll\n          if (subSelections?._ === "selectAll" && !instanceSelection) {\n            continue;\n          }\n\n          node.subNodes = _selectionToNodeSet(\n            // assume it\'s a Selection. If it\'s an argument\n            // object, mismatch between the node desc should hopefully\n            // catch it\n            subSelections as Selection,\n            subNodes,\n            `${parentPath}.${instanceName}`,\n          );\n        } else {\n          const unionSelections = {} as Record<string, SelectNode[]>;\n          const foundVariants = new Set([...Object.keys(subSelections)]);\n          for (const [variantTy, variant_meta_fn] of variants!) {\n            const variant_meta = variant_meta_fn();\n            // this union member is a scalar\n            if (!variant_meta.subNodes) {\n              continue;\n            }\n            foundVariants.delete(variantTy);\n            const variant_select = subSelections[variantTy];\n            const nodes = variant_select\n              ? _selectionToNodeSet(\n                variant_select as Selection,\n                variant_meta.subNodes,\n                `${parentPath}.${instanceName}.variant(${variantTy})`,\n              )\n              : [];\n            nodes.push({\n              nodeName: "__typename",\n              instanceName: "__typename",\n            });\n            unionSelections[variantTy] = nodes;\n          }\n          if (foundVariants.size > 0) {\n            throw new Error(\n              `node at ${parentPath}.${instanceName} ` +\n                "has none of the variants called " +\n                [...foundVariants.keys()],\n            );\n          }\n          node.subNodes = unionSelections;\n        }\n      }\n\n      out.push(node);\n    }\n  }\n  foundNodes.delete("_");\n  if (foundNodes.size > 0) {\n    throw new Error(\n      `unexpected nodes found in selection set at ${parentPath}: ${[\n        ...foundNodes,\n      ]}`,\n    );\n  }\n  return out;\n}\n\n/* Query node types section */\n\ntype SubNodes = undefined | SelectNode[] | Record<string, SelectNode[]>;\n\ntype SelectNode<_Out = unknown> = {\n  nodeName: string;\n  instanceName: string;\n  args?: NodeArgs;\n  subNodes?: SubNodes;\n  files?: TypePath[];\n};\n\nexport class QueryNode<Out> {\n  #inner: SelectNode<Out>;\n  constructor(inner: SelectNode<Out>) {\n    this.#inner = inner;\n  }\n\n  inner() {\n    return this.#inner;\n  }\n}\n\nexport class MutationNode<Out> {\n  #inner: SelectNode<Out>;\n  constructor(inner: SelectNode<Out>) {\n    this.#inner = inner;\n  }\n\n  inner() {\n    return this.#inner;\n  }\n}\n\ntype SelectNodeOut<T> = T extends QueryNode<infer O> | MutationNode<infer O> ? O\n  : never;\ntype QueryOut<T> = T extends\n  Record<string, QueryNode<unknown> | MutationNode<unknown>> ? {\n    [K in keyof T]: SelectNodeOut<T[K]>;\n  }\n  : T extends QueryNode<unknown> | MutationNode<unknown> ? SelectNodeOut<T>\n  : never;\n\ntype TypePath = ("?" | "[]" | `.${string}`)[];\ntype ValuePath = ("" | `[${number}]` | `.${string}`)[];\n\nclass FileExtractor {\n  #path: TypePath = [];\n  #currentPath: ValuePath = [];\n  #files: Map<string, File> = new Map();\n\n  static extractFrom(key: string, object: unknown, paths: TypePath[]) {\n    const extractor = new FileExtractor();\n    if (!object || typeof object !== "object") {\n      throw new Error("expected object");\n    }\n    for (const path of paths) {\n      if (path[0] && path[0].startsWith("." + key)) {\n        extractor.#currentPath = [];\n        extractor.#path = path;\n        extractor.#extractFromValue(object);\n      }\n    }\n    return extractor.#files;\n  }\n\n  #extractFromValue(value: unknown) {\n    const nextSegment = this.#path[this.#currentPath.length];\n    if (nextSegment === "?") {\n      if (value === null || value === undefined) {\n        return;\n      }\n      this.#currentPath.push("");\n      this.#extractFromValue(value);\n      this.#currentPath.pop();\n      return;\n    }\n\n    if (nextSegment === "[]") {\n      if (!Array.isArray(value)) {\n        throw new Error(`Expected array at ${this.#formatPath()}`);\n      }\n      for (let i = 0; i < value.length; i++) {\n        this.#currentPath.push(`[${i}]`);\n        this.#extractFromArray(value, i);\n        this.#currentPath.pop();\n      }\n      return;\n    }\n\n    if (nextSegment.startsWith(".")) {\n      if (typeof value !== "object" || value === null) {\n        throw new Error(`Expected non-null object at ${this.#formatPath()}`);\n      }\n      this.#currentPath.push(nextSegment);\n      this.#extractFromObject(\n        value as Record<string, unknown>,\n        nextSegment.slice(1),\n      );\n      this.#currentPath.pop();\n      return;\n    }\n  }\n\n  #extractFromObject(parent: Record<string, unknown>, key: string) {\n    const value = parent[key];\n    if (this.#currentPath.length == this.#path.length) {\n      if (value instanceof File) {\n        this.#files.set(this.#formatPath(), value);\n        parent[key] = null;\n        return;\n      }\n      throw new Error(`Expected File at ${this.#formatPath()}`);\n    }\n\n    this.#extractFromValue(value);\n  }\n\n  #extractFromArray(parent: unknown[], idx: number) {\n    const value = parent[idx];\n    if (this.#currentPath.length == this.#path.length) {\n      if (value instanceof File) {\n        this.#files.set(this.#formatPath(), value);\n        parent[idx] = null;\n        return;\n      }\n      throw new Error(`Expected File at ${this.#formatPath()}`);\n    }\n\n    this.#extractFromValue(value);\n  }\n\n  #formatPath() {\n    return this.#currentPath\n      .map((seg) => {\n        if (seg.startsWith("[")) {\n          return `.${seg.slice(1, -1)}`;\n        }\n        return seg;\n      })\n      .join("");\n  }\n}\n\ntype NodeMeta = {\n  subNodes?: [string, () => NodeMeta][];\n  variants?: [string, () => NodeMeta][];\n  argumentTypes?: { [name: string]: string };\n  inputFiles?: TypePath[];\n};\n\n/* Selection types section */\n\ntype SelectionFlags = "selectAll";\n\ntype Selection = {\n  _?: SelectionFlags;\n  [key: string]:\n    | SelectionFlags\n    | ScalarSelectNoArgs\n    | ScalarSelectArgs<Record<string, unknown>>\n    | CompositeSelectNoArgs<Selection | undefined>\n    | CompositeSelectArgs<Record<string, unknown>, Selection>\n    | Selection;\n};\n\ntype ScalarSelectNoArgs = boolean | Alias<true> | null | undefined;\n\ntype ScalarSelectArgs<ArgT extends Record<string, unknown>> =\n  | ArgT\n  | PlaceholderArgs<ArgT>\n  | Alias<ArgT | PlaceholderArgs<ArgT>>\n  | false\n  | null\n  | undefined;\n\ntype CompositeSelectNoArgs<SelectionT> =\n  | SelectionT\n  | Alias<SelectionT>\n  | false\n  | null\n  | undefined;\n\ntype CompositeSelectArgs<ArgT extends Record<string, unknown>, SelectionT> =\n  | [ArgT | PlaceholderArgs<ArgT>, SelectionT]\n  | Alias<[ArgT | PlaceholderArgs<ArgT>, SelectionT]>\n  | false\n  | undefined\n  | null;\n\n/**\n * Request multiple instances of a single node under different\n * aliases. Look at {@link alias} for a functional way of instantiating\n * this class.\n */\nexport class Alias<T> {\n  #aliases: Record<string, T>;\n  constructor(aliases: Record<string, T>) {\n    this.#aliases = aliases;\n  }\n  aliases() {\n    return this.#aliases;\n  }\n}\n\n/**\n * Request multiple instances of a single node under different\n * aliases.\n */\nexport function alias<T>(aliases: Record<string, T>): Alias<T> {\n  return new Alias(aliases);\n}\n\n/* Argument types section */\n\ntype NodeArgValue = {\n  typeName: string;\n  value: unknown;\n};\n\ntype NodeArgs = {\n  [name: string]: NodeArgValue;\n};\n\n/**\n * This object is passed to closures used for preparing requests\n * ahead of time for {@link PreparedRequest}s. It allows one to\n * get {@link PlaceholderValue}s that can be used in place of node\n * arguments. At request time, the {@link PreparedRequest} then\n * takes an object that adheres to `T` that can then be used\n * to replace the placeholders.\n */\nexport class PreparedArgs<T extends Record<string, unknown>> {\n  get(key: OnlyStringKeys<T>): PlaceholderValue<T[typeof key]> {\n    return new PlaceholderValue(key);\n  }\n}\n\n/**\n * Placeholder values for use by {@link PreparedRequest}\n */\nexport class PlaceholderValue<_T> {\n  #key: string;\n  constructor(key: string) {\n    this.#key = key;\n  }\n\n  key() {\n    return this.#key;\n  }\n}\n\nexport type PlaceholderArgs<T extends Record<string, unknown>> = {\n  [K in keyof T]: PlaceholderValue<T[K]>;\n};\n\n/* GraphQL section */\n\n/**\n * Options to be used for requests performed by {@link GraphQLTransport}.\n */\nexport type GraphQlTransportOptions = Omit<RequestInit, "body"> & {\n  /**\n   * {@link fetch} implementaiton to use. Defaults to the one found in the environment\n   */\n  fetch?: typeof fetch;\n};\n\nfunction convertQueryNodeGql(\n  typeToGqlTypeMap: Record<string, string>,\n  node: SelectNode,\n  variables: Map<string, NodeArgValue>,\n  files: Map<string, File>,\n) {\n  let out = node.nodeName == node.instanceName\n    ? node.nodeName\n    : `${node.instanceName}: ${node.nodeName}`;\n\n  const args = node.args;\n  if (args && Object.keys(args).length > 0) {\n    const argsRow = [];\n\n    for (const [key, val] of Object.entries(args)) {\n      const name = `in${variables.size}`;\n      const obj = { [key]: val.value };\n\n      if (node.files && node.files.length > 0) {\n        const extractedFiles = FileExtractor.extractFrom(key, obj, node.files);\n\n        for (const [path, file] of extractedFiles) {\n          const pathInVariables = path.replace(/^\\.[^\\.\\[]+/, `.${name}`);\n          files.set(pathInVariables, file);\n        }\n      }\n\n      val.value = obj[key];\n      variables.set(name, val);\n      argsRow.push(`${key}: $${name}`);\n    }\n\n    out = `${out} (${argsRow.join(", ")})`;\n  }\n\n  const subNodes = node.subNodes;\n  if (subNodes) {\n    if (Array.isArray(subNodes)) {\n      out = `${out} { ${\n        subNodes\n          .map((node) =>\n            convertQueryNodeGql(typeToGqlTypeMap, node, variables, files)\n          )\n          .join(" ")\n      } }`;\n    } else {\n      out = `${out} { ${\n        Object.entries(subNodes)\n          .map(([variantTy, subNodes]) => {\n            let gqlTy = typeToGqlTypeMap[variantTy];\n            if (!gqlTy) {\n              throw new Error(\n                `unreachable: no graphql type found for variant ${variantTy}`,\n              );\n            }\n            gqlTy = gqlTy.replace(/[!]+$/, "");\n\n            return `... on ${gqlTy} {${\n              subNodes\n                .map((node) =>\n                  convertQueryNodeGql(typeToGqlTypeMap, node, variables, files)\n                )\n                .join(" ")\n            }}`;\n          })\n          .join(" ")\n      } }`;\n    }\n  }\n  return out;\n}\n\nfunction buildGql(\n  typeToGqlTypeMap: Record<string, string>,\n  query: Record<string, SelectNode>,\n  ty: "query" | "mutation",\n  // deno-lint-ignore no-inferrable-types\n  name: string = "",\n) {\n  const variables = new Map<string, NodeArgValue>();\n  const files = new Map<string, File>();\n\n  const rootNodes = Object.entries(query)\n    .map(([key, node]) => {\n      const fixedNode = { ...node, instanceName: key };\n      return convertQueryNodeGql(typeToGqlTypeMap, fixedNode, variables, files);\n    })\n    .join("\\n  ");\n\n  let argsRow = [...variables.entries()]\n    .map(([key, val]) => `$${key}: ${typeToGqlTypeMap[val.typeName]} `)\n    .join(", ");\n  if (argsRow.length > 0) {\n    // graphql doesn\'t like empty parentheses so we only\n    // add them if there are args\n    argsRow = `(${argsRow})`;\n  }\n\n  const doc = `${ty} ${name}${argsRow} {\n  ${rootNodes}\n      } `;\n  return {\n    doc,\n    variables: Object.fromEntries(\n      [...variables.entries()].map(([key, val]) => [key, val.value]),\n    ),\n    files,\n  };\n}\n\nasync function fetchGql(\n  addr: URL,\n  doc: string,\n  variables: Record<string, unknown>,\n  options: GraphQlTransportOptions,\n  files?: Map<string, File>,\n) {\n  let body: FormData | string = JSON.stringify({\n    query: doc,\n    variables,\n  });\n\n  const additionalHeaders: HeadersInit = {};\n\n  if (files && files.size > 0) {\n    const data = new FormData();\n    const fileMap = new Map<File, string[]>();\n    const map: Record<string, string[]> = {};\n\n    for (const [path, file] of files) {\n      const array = fileMap.get(file);\n      const variable = "variables" + path;\n      if (array) {\n        array.push(variable);\n      } else {\n        fileMap.set(file, [variable]);\n      }\n    }\n\n    let index = 0;\n    for (const [file, variables] of fileMap) {\n      const key = index.toString();\n      map[key] = variables;\n      data.set(key, file);\n      index += 1;\n    }\n\n    data.set("operations", body);\n    data.set("map", JSON.stringify(map));\n\n    body = data;\n  } else {\n    additionalHeaders["content-type"] = "application/json";\n  }\n\n  const fetchImpl = options.fetch ?? fetch;\n  const res = await fetchImpl(addr, {\n    ...options,\n    method: "POST",\n    headers: {\n      accept: "application/json",\n      ...additionalHeaders,\n      ...(options.headers ?? {}),\n    },\n    body,\n  });\n\n  if (!res.ok) {\n    const body = await res.text().catch((err) => `error reading body: ${err} `);\n    throw new (Error as ErrorPolyfill)(\n      `graphql request to ${addr} failed with status ${res.status}: ${body} `,\n      {\n        cause: {\n          response: res,\n          body,\n        },\n      },\n    );\n  }\n  if (res.headers.get("content-type") != "application/json") {\n    throw new (Error as ErrorPolyfill)("unexpected content type in response", {\n      cause: {\n        response: res,\n        body: await res.text().catch((err) => `error reading body: ${err} `),\n      },\n    });\n  }\n  return (await res.json()) as { data: unknown; errors?: object[] };\n}\n\n/**\n * Access the typegraph over it\'s exposed GraphQL API.\n */\nexport class GraphQLTransport {\n  constructor(\n    public address: URL,\n    public options: GraphQlTransportOptions,\n    private typeToGqlTypeMap: Record<string, string>,\n  ) {}\n\n  protected async request(\n    doc: string,\n    variables: Record<string, unknown>,\n    options: GraphQlTransportOptions,\n    files?: Map<string, File>,\n  ) {\n    const res = await fetchGql(\n      this.address,\n      doc,\n      variables,\n      { ...this.options, ...options },\n      files,\n    );\n    if ("errors" in res) {\n      throw new (Error as ErrorPolyfill)("graphql errors on response", {\n        cause: res.errors,\n      });\n    }\n    return res.data;\n  }\n\n  /**\n   * Make a query request to the typegraph.\n   */\n  async query<\n    Q extends QueryNode<unknown> | Record<string, QueryNode<unknown>>,\n  >(\n    query: Q,\n    {\n      options,\n      name = "",\n    }: {\n      options?: GraphQlTransportOptions;\n      name?: string;\n    } = {},\n  ): Promise<QueryOut<Q>> {\n    const isNode = query instanceof QueryNode;\n    const { variables, doc } = buildGql(\n      this.typeToGqlTypeMap,\n      isNode ? { value: query.inner() } : Object.fromEntries(\n        Object.entries(query).map(([key, val]) => [\n          key,\n          (val as QueryNode<unknown>).inner(),\n        ]),\n      ),\n      "query",\n      name,\n    );\n    let result = await this.request(doc, variables, options ?? {});\n\n    if (isNode) {\n      result = (result as { value: SelectNodeOut<Q> }).value;\n    }\n\n    return result as QueryOut<Q>;\n  }\n\n  /**\n   * Make a mutation request to the typegraph.\n   */\n  async mutation<\n    Q extends MutationNode<unknown> | Record<string, MutationNode<unknown>>,\n  >(\n    query: Q,\n    {\n      options,\n      name = "",\n    }: {\n      options?: GraphQlTransportOptions;\n      name?: string;\n    } = {},\n  ): Promise<QueryOut<Q>> {\n    const isNode = query instanceof MutationNode;\n    const { variables, doc, files } = buildGql(\n      this.typeToGqlTypeMap,\n      isNode ? { value: query.inner() } : Object.fromEntries(\n        Object.entries(query).map(([key, val]) => [\n          key,\n          (val as MutationNode<unknown>).inner(),\n        ]),\n      ),\n      "mutation",\n      name,\n    );\n    let result = await this.request(doc, variables, options ?? {}, files);\n\n    if (isNode) {\n      result = (result as { value: SelectNodeOut<Q> }).value;\n    }\n\n    return result as QueryOut<Q>;\n  }\n\n  /**\n   * Prepare an ahead of time query {@link PreparedRequest}.\n   */\n  prepareQuery<\n    T extends JsonObject,\n    Q extends QueryNode<unknown> | Record<string, QueryNode<unknown>>,\n  >(\n    fun: (args: PreparedArgs<T>) => Q,\n    { name = "" }: { name?: string } = {},\n  ): PreparedRequest<T, Q> {\n    return new PreparedRequest(\n      (doc, vars, opts) => this.request(doc, vars, opts),\n      this.typeToGqlTypeMap,\n      fun,\n      "query",\n      name,\n    );\n  }\n\n  /**\n   * Prepare an ahead of time mutation {@link PreparedRequest}.\n   */\n  prepareMutation<\n    T extends JsonObject,\n    Q extends MutationNode<unknown> | Record<string, MutationNode<unknown>>,\n  >(\n    fun: (args: PreparedArgs<T>) => Q,\n    { name = "" }: { name?: string } = {},\n  ): PreparedRequest<T, Q> {\n    return new PreparedRequest(\n      (doc, vars, opts) => this.request(doc, vars, opts),\n      this.typeToGqlTypeMap,\n      fun,\n      "mutation",\n      name,\n    );\n  }\n}\n\nexport class HostcallTransport extends GraphQLTransport {\n  constructor(\n    private gqlFn: (\n      doc: string,\n      variables: Record<string, unknown>,\n    ) => Promise<Record<string, unknown>>,\n    options: GraphQlTransportOptions,\n    typeToGqlTypeMap: Record<string, string>,\n  ) {\n    super(\n      new URL("hostcall://this_url_will_never_be_used"),\n      options,\n      typeToGqlTypeMap,\n    );\n  }\n\n  protected async request(\n    doc: string,\n    variables: Record<string, unknown>,\n    _options: GraphQlTransportOptions,\n    files?: Map<string, File>,\n  ) {\n    if (files && files.size > 0) {\n      throw new Error("no support for file upload on HostcallTransport");\n    }\n    const res = await this.gqlFn(doc, variables);\n    if ("errors" in res) {\n      throw new (Error as ErrorPolyfill)("graphql errors on response", {\n        cause: res.errors,\n      });\n    }\n    return res.data;\n  }\n}\n\n/**\n * Prepares the GraphQL string ahead of time and allows re-use\n * avoid the compute and garbage overhead of re-building it for\n * repeat queries.\n */\nexport class PreparedRequest<\n  T extends JsonObject,\n  Q extends\n    | QueryNode<unknown>\n    | MutationNode<unknown>\n    | Record<string, QueryNode<unknown> | MutationNode<unknown>>,\n> {\n  public doc: string;\n  #mappings: Record<string, unknown>;\n  private singleNode: boolean;\n\n  constructor(\n    // private address: URL,\n    // private options: GraphQlTransportOptions,\n    private gqlFn: (\n      doc: string,\n      variables: Record<string, unknown>,\n      opts: GraphQlTransportOptions,\n    ) => Promise<unknown>,\n    typeToGqlTypeMap: Record<string, string>,\n    fun: (args: PreparedArgs<T>) => Q,\n    ty: "query" | "mutation",\n    name: string = "",\n  ) {\n    const args = new PreparedArgs<T>();\n    const dryRunNode = fun(args);\n    const isSingleNode = dryRunNode instanceof QueryNode ||\n      dryRunNode instanceof MutationNode;\n    // FIXME: file support for prepared requets\n    const { doc, variables } = buildGql(\n      typeToGqlTypeMap,\n      isSingleNode ? { value: dryRunNode.inner() } : Object.fromEntries(\n        Object.entries(dryRunNode).map(([key, val]) => [\n          key,\n          (val as MutationNode<unknown>).inner(),\n        ]),\n      ),\n      ty,\n      name,\n    );\n    this.doc = doc;\n    this.#mappings = variables;\n    this.singleNode = isSingleNode;\n  }\n\n  resolveVariables(args: T, mappings: Record<string, unknown>) {\n    const resolvedVariables = {} as Record<string, unknown>;\n    for (const [key, val] of Object.entries(mappings)) {\n      if (val instanceof PlaceholderValue) {\n        resolvedVariables[key] = args[val.key()];\n      } else if (typeof val == "object" && val != null) {\n        this.resolveVariables(args, val as JsonObject);\n      } else {\n        resolvedVariables[key] = val;\n      }\n    }\n    return resolvedVariables;\n  }\n\n  /**\n   * Execute the prepared request.\n   */\n  async perform(args: T, opts?: GraphQlTransportOptions): Promise<QueryOut<Q>> {\n    const resolvedVariables = this.resolveVariables(args, this.#mappings);\n    // console.log(this.doc, {\n    //   resolvedVariables,\n    //   mapping: this.#mappings,\n    // });\n    let result = await this.gqlFn(this.doc, resolvedVariables, {\n      ...opts,\n    });\n    if (this.singleNode) {\n      result = (result as { value: SelectNodeOut<Q> }).value;\n    }\n    return result as QueryOut<Q>;\n  }\n}\n\n/* Util types section */\n\ntype OnlyStringKeys<T extends Record<string, unknown>> = {\n  [K in keyof T]: K extends string ? K : never;\n}[keyof T];\n\ntype JsonLiteral = string | number | boolean | null;\ntype JsonObject = { [key: string]: Json };\ntype JsonArray = Json[];\ntype Json = JsonLiteral | JsonObject | JsonArray;\n\ntype ErrorPolyfill = new (msg: string, payload: unknown) => Error;\n\n/* QueryGraph section */\n\nexport class Transports {\n  /**\n   * Get the {@link GraphQLTransport} for the typegraph.\n   */\n  static graphql(\n    qg: _QueryGraphBase,\n    addr: URL | string,\n    options?: GraphQlTransportOptions,\n  ) {\n    return new GraphQLTransport(\n      new URL(addr),\n      options ?? {},\n      qg.typeNameMapGql,\n    );\n  }\n\n  static hostcall(\n    qg: _QueryGraphBase,\n    tg: Deployment,\n    options?: Pick<GraphQlTransportOptions, "headers">,\n  ) {\n    return new HostcallTransport(\n      (doc, vars) => tg.gql([doc]).run(vars),\n      options ?? {},\n      qg.typeNameMapGql,\n    );\n  }\n}\n\nclass _QueryGraphBase {\n  constructor(public typeNameMapGql: Record<string, string>) {}\n}\n\n// -------------------------------------------------- //\n\nconst nodeMetas = {\n  scalar() {\n    return {};\n  },\n  \n  Idv3(): NodeMeta {\n    return {\n      subNodes: [\n        ["title", nodeMetas.scalar],\n        ["artist", nodeMetas.scalar],\n        ["releaseTime", nodeMetas.scalar],\n        ["mp3Url", nodeMetas.scalar],\n      ],\n    };\n  },\n  RemixTrack(): NodeMeta {\n    return {\n      ...nodeMetas.Idv3(),\n      argumentTypes: {\n        title: "Idv3TitleString",\n        artist: "Idv3TitleString",\n        releaseTime: "Idv3ReleaseTimeStringDatetime",\n        mp3Url: "Idv3Mp3UrlStringUri",\n      },\n    };\n  },\n};\nexport type Idv3TitleString = string;\nexport type Idv3ReleaseTimeStringDatetime = string;\nexport type Idv3Mp3UrlStringUri = string;\nexport type Idv3 = {\n  title: Idv3TitleString;\n  artist: Idv3TitleString;\n  releaseTime: Idv3ReleaseTimeStringDatetime;\n  mp3Url: Idv3Mp3UrlStringUri;\n};\n\nexport type Idv3Selections = {\n  _?: SelectionFlags;\n  title?: ScalarSelectNoArgs;\n  artist?: ScalarSelectNoArgs;\n  releaseTime?: ScalarSelectNoArgs;\n  mp3Url?: ScalarSelectNoArgs;\n};\n\nexport class QueryGraph extends _QueryGraphBase {\n  constructor() {\n    super({\n      "Idv3TitleString": "String!",\n      "Idv3ReleaseTimeStringDatetime": "String!",\n      "Idv3Mp3UrlStringUri": "String!",\n    });\n  }\n    \n  remix(args: Idv3 | PlaceholderArgs<Idv3>, select: Idv3Selections): QueryNode<Idv3> {\n    const inner = _selectionToNodeSet(\n      { "remix": [args, select] },\n      [["remix", nodeMetas.RemixTrack]],\n      "$q",\n    )[0];\n    return new QueryNode(inner);\n  }\n}\n\nexport type RemixTrackHandler = Handler<Idv3, Idv3>;',path:"../examples/typegraphs/metagen/ts/fdk.ts"}},13246:n=>{n.exports={content:'import type { Ctx, Idv3, RemixTrackHandler } from "./fdk.ts";\n\n// the name of the export must match the one referred int he typegraph\nexport const remix_track: RemixTrackHandler = (inp, cx: Ctx) => {\n  const out: Idv3 = {\n    title: `${inp.title} (Remix)`,\n    artist: `${inp.artist} + DJ Cloud`,\n    releaseTime: new Date().toISOString(),\n    // S3Runtime could be used to really provide this service\n    mp3Url: `${cx.meta.url}/get_mp3`,\n  };\n  return out;\n};',path:"../examples/typegraphs/metagen/ts/remix.ts"}}}]);