"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2903],{68962:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>a,toc:()=>u});var s=t(86070),r=t(25710),i=t(65671);const l={sidebar_position:50},o="Client",a={id:"reference/typegraph/client/index",title:"Client",description:"The following feature isn't yet stable.",source:"@site/docs/reference/typegraph/client/index.mdx",sourceDirName:"reference/typegraph/client",slug:"/reference/typegraph/client/",permalink:"/docs/reference/typegraph/client/",draft:!1,unlisted:!1,editUrl:"https://github.com/metatypedev/metatype/tree/main/docs/metatype.dev/docs/reference/typegraph/client/index.mdx",tags:[],version:"current",sidebarPosition:50,frontMatter:{sidebar_position:50},sidebar:"docs",previous:{title:"Typegraph",permalink:"/docs/reference/typegraph/"},next:{title:"Typegate",permalink:"/docs/reference/typegate/"}},c={},u=[{value:"Guide",id:"guide",level:2},{value:"<code>QueryGraph</code>",id:"querygraph",level:3},{value:"Transports",id:"transports",level:3},{value:"<code>GraphQLTransport</code>",id:"graphqltransport",level:4},{value:"<code>HostcallTransport</code>",id:"hostcalltransport",level:4},{value:"Requests",id:"requests",level:3},{value:"Nested arguments",id:"nested-arguments",level:3},{value:"Selecting fields",id:"selecting-fields",level:3},{value:"Preparing requests",id:"preparing-requests",level:3},{value:"Aliases",id:"aliases",level:3},{value:"Unions",id:"unions",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"client",children:"Client"}),"\n",(0,s.jsx)(n.admonition,{title:"Beta",type:"warning",children:(0,s.jsx)(n.p,{children:"The following feature isn't yet stable."})}),"\n",(0,s.jsxs)(n.p,{children:["The typegraph client provides a code-first alternative for querying typegraphs.\nIt contains types generated from typegraph definitions to ensure type safety.\nThe ",(0,s.jsx)(n.a,{href:"/docs/reference/metagen",children:"metagen"})," suite provides the client code-generators under the following names:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"client_ts"}),": client code-generator for Typescript for use in browsers and other Javascript runtimes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"client_py"}),": client code-generator for Python"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"client_rs"}),": client code-generator for Rust."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Refer to the metagen documentation on how to access the generators."}),"\n",(0,s.jsx)(n.h2,{id:"guide",children:"Guide"}),"\n",(0,s.jsx)(n.p,{children:"Even though there are minor differences across language implementations, the generated clients adhere to a common design that contains the following elements."}),"\n",(0,s.jsx)(n.h3,{id:"querygraph",children:(0,s.jsx)(n.code,{children:"QueryGraph"})}),"\n",(0,s.jsx)(n.p,{children:"The root type generated for the client, it includes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Query builders for all the root functions"}),"\n",(0,s.jsx)(n.li,{children:"Transport constructors for all the transports exposed by the typegraph"}),"\n"]}),"\n",(0,s.jsx)(i.A,{python:{content:"\nfrom client import QueryGraph\n\nqg = new QueryGraph();"},typescript:{content:'import { QueryGraph } from "./client.ts" ;\n\nconst qg = new QueryGraph();'},rust:{content:'use client::*;\n\nlet api1 = QueryGraph::new(format!("http://localhost:7890/sample").parse()?);'},disablePlayground:!0}),"\n",(0,s.jsx)(n.h3,{id:"transports",children:"Transports"}),"\n",(0,s.jsxs)(n.p,{children:["Different transport implementations are used to send the requests to the typegate for different use cases.\nThe ",(0,s.jsx)(n.code,{children:"QueryGraph"})," will sport methods to construct transports supported by the typegraph (see examples below).\nNot all transports have the same feature sets."]}),"\n",(0,s.jsx)(n.h4,{id:"graphqltransport",children:(0,s.jsx)(n.code,{children:"GraphQLTransport"})}),"\n",(0,s.jsx)(n.p,{children:"This transport converts to equivalent GraphQL query strings that get sent over http.\nIt includes the following features for all implementations:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sync or async queries and mutations"}),"\n",(0,s.jsx)(n.li,{children:"Multiple queries or mutations in one request"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"hostcalltransport",children:(0,s.jsx)(n.code,{children:"HostcallTransport"})}),"\n",(0,s.jsx)(n.p,{children:"This transport uses host functions exposed by the typegate for use with custom functions."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sync queries and mutations"}),"\n",(0,s.jsx)(n.li,{children:"Multiple queries or mutations in one request"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"requests",children:"Requests"}),"\n",(0,s.jsx)(n.p,{children:"Requests consist of two parts:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Describe the operations using methods on ",(0,s.jsx)(n.code,{children:"QueryGraph"}),".","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Methods are typesafe according to each typegraph root functions."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Transport methods that take the query description and perform request to the typegate.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Mutations and queries use separate methods and types."}),"\n",(0,s.jsxs)(n.li,{children:["Some transports like the ",(0,s.jsx)(n.code,{children:"GraphQLTransport"})," support multiple operations in one request"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.A,{python:{content:'qg = QueryGraph()\ngql_client = qg.graphql_sync("http://localhost:7890/sample")\n\n# describe the query\n\n# there\'s a different method available for mutations\n\nout = gql_client.query(\n{\n"user": qg.get_user( # the function takes arguments\nUserArgs(id="1234"),\nUserSelections( # choose which fields get included\nid=True,\nemail=True,\n),\n), # add a second query in the request # this one doesn\'t take arguments so only # selections are provided\n"posts": qg.get_posts({ # both arguments and selections are TypedDicts # allowing use of dicts instead of the classes\n"slug": True,\n"title": True,\n}),\n}\n)\n\nuser = out["user"];\nposts = out["posts"]'},typescript:{content:'const api1 = new QueryGraph();\nconst gqlClient = api1.graphql("http://localhost:7890/sample");\n\n// describe the query\n// there\'s a different method available for mutations\nconst out = await gqlClient.query({\nuser: api1.getUser(\n// the function takes arguments\n{ id: "1234" },\n{\n// choose which fields get included\nid: true,\nemail: true,\n}),\n// add a second query in the request\n// this one doesn\'t take arguments so only\n// selections are provided\nposts: api1.getPosts(\n{ title: true, slug: true }\n),\n});\nconst user = out.user;\nconst posts = out.posts;'},rust:{content:'let api1 = QueryGraph::new("http://localhost:7890/sample".parse()?);\nlet gql_sync = api1.graphql_sync();\n\n// describe the query\n// there\'s a different method available for mutations\nlet out = gql_sync.query((\n// the function takes arguments\napi1.get_user(UserArgs { id: "1234".into() })\n.select(UserSelections {\n// choose which fields get included\n// in rust, selection functions are\n// used instead of booleans.\nid: get(),\nslug: get(),\n}),\n// add a second query in the request\n// note: rust uses tuples for multi-requests\n// this one doesn\'t take arguments\napi1.get_posts()\n.select(PostSelections {\nid: get(),\nslug: get(),\ntitle: get(),\n}),\n)).unwrap();\n\nlet (user, posts) = out;'},disablePlayground:!0}),"\n",(0,s.jsx)(n.h3,{id:"nested-arguments",children:"Nested arguments"}),"\n",(0,s.jsx)(n.p,{children:"Some fields are themselves composite types that have fields that also require selection.\nAnd functions are used to resolve certain fields which require arguments."}),"\n",(0,s.jsx)(i.A,{python:{content:'\nout = gql_client.query(\n    {\n        "user": qg.get_user(\n            UserArgs(id="1234"),\n            UserSelections(\n                id=True,\n                email=True,\n                # the posts field takes an argument\n                # and is also a composite\n                # selection and arguments are combined\n                # with tuples in such cases\n                posts=(\n                  PostArgs(filter="top"), \n                  PostSelections(\n                    slug=True, \n                    title=True\n                  )\n                ),\n                # this nested composite doesn\'t\n                # take arguments so no tuple\n                comments=CommentSelections(\n                  body=True\n                )\n            ),\n        ),\n    }\n)\n'},typescript:{content:'\nconst { user } = await gqlClient.query({\n  user: api1.getUser(\n    { id: "1234" }, \n    {\n      // posts field takes an argument\n      // and is also a composite\n      // selection and arguments are combined\n      // with array tuples in such cases\n      posts: [\n        { filter: "top" }, \n        { title: true, slug: true }\n      ],\n      // this nested composite doesn\'t\n      // take arguments so no tuple\n      // required\n      comments: { body: true }\n    }\n  ),\n});\n  '},rust:{content:'let user = gql_sync.query(\n    api1.get_user(UserArgs { id: "1234".into() })\n      .select(UserSelections {\n          id: get(),\n          slug: get(),\n          // posts nested field takes an argument\n          // and is also a composite type\n          // requiring the arg_select select function\n          posts: arg_select(\n              PostArgs { filter: "top".into() },\n              PostSelections {\n                id: get(),\n                slug: get(),\n                title: get(),\n              }\n          ),\n          // this nested composite doesn\'t\n          // take arguments so the select function\n          // is used instead\n          comments: select(CommentSelections {\n            body: get()\n          }),\n      }),\n).unwrap();\n'},disablePlayground:!0}),"\n",(0,s.jsx)(n.h3,{id:"selecting-fields",children:"Selecting fields"}),"\n",(0,s.jsx)(n.p,{children:"Booleans indicate interest when selecting fields on an object.\nBy default a field isn't included if it's null, or unspecified.\nSelections can include selection flags to flip the default so that all unspecified fields get included.\nThis won't apply if the field requires an argument explicitly requiring them for inclusion."}),"\n",(0,s.jsxs)(n.p,{children:["Note that these patterns are different in the ",(0,s.jsx)(n.code,{children:"client_rs"})," implementations as demonstrated below:"]}),"\n",(0,s.jsx)(i.A,{python:{content:'\nout = gql_client.query(\n    {\n        "user": qg.get_user(\n            UserArgs(id="1234"),\n            UserSelections(\n                # seletion flags are set on the underscore\n                # field. The select_all flg flips the\n                # semantics for unspecified fields\n                _=SelectionFlags(select_all=True),\n                # False excludes fields explicitly\n                id=False,\n                # the posts field takes an argument\n                # so the select_all flag doesn\'t apply\n                # it still must be provided\n                # if intending to include it\n                posts=(\n                  PostArgs(filter="top"), \n                  # TypedDict form\n                  {"_": SelectionFlags(select_all=True)},\n                ),\n                # comments is a nested composite but\n                # doesn\'t take args so select_all flag applies\n                # comments=CommentSelections(\n                #  body=True\n                # )\n            ),\n        ),\n    }\n)\n'},typescript:{content:'\nconst { user } = await gqlClient.query({\n  user: api1.getUser(\n    { id: "1234" }, \n    {\n      // posts field takes an argument\n      // and is also a composite\n      // selection and arguments are combined\n      // with array tuples in such cases\n      posts: [\n        { filter: "top" }, \n        { title: true, slug: true }\n      ],\n      // this nested composite doesn\'t\n      // take arguments so no tuple\n      // required\n    }\n  ),\n});\nconst { user  } = await gqlClient.query({\n  user: api1.getUser(\n    { id: "1234" }, \n    {\n      // seletion flags are set on the underscore\n      // field. The selectAll flg flips the\n      // semantics for unspecified fields\n      _:  "selectAll",\n      // false excludes fields explicitly \n      id: false,\n      // post field takes an argument\n      // so the selectAll flag doesn\'t apply\n      // it still must be provided\n      // if intending to include it\n      posts: [\n        { filter: "top" }, \n        { _: "selectAll" }\n      ],\n      // comments is a nested composite but\n      // doesnt\'t take args so selectAll flag applies\n      // comments: { body: true }\n    }\n  ),\n});\n  '},rust:{content:'let user = gql_sync.query(\n    api1.get_user(UserArgs { id: "1234".into() })\n      .select(UserSelections {\n          // skip excludes fields explicitly \n          id: skip(),\n\n          // post field takes an argument\n          // so the all() down below still\n          // won\'t include it\n          // it must be provided explicitly\n          // if intending to include it\n          posts: arg_select(\n              PostArgs { filter: "top".into() },\n              // we use all top\n              all()\n          ),\n\n          // comments is a nested composite but\n          // doesnt\'t take args so the all() down\n          // below includes it\n          // comments: select(CommentSelections::all())\n\n          // filling the missing fields with the results\n          // of all() using the struct update syntax\n          // ensures they\'re all get()\n          // use default() to get a selection that is full\n          // of skip()\n          ..all()\n      }),\n\n).unwrap();\n'},disablePlayground:!0}),"\n",(0,s.jsx)(n.p,{children:"Note that this only applies to scalar fields and those that require arguments or are structs must still be explicitly included."}),"\n",(0,s.jsx)(n.h3,{id:"preparing-requests",children:"Preparing requests"}),"\n",(0,s.jsxs)(n.p,{children:["Some transports like the ",(0,s.jsx)(n.code,{children:"GraphQLTransport"})," allows one to prepare requests before hand and reuse them.\nThis isn't immediately useful but will be critical when persisted queries are available in Metatype."]}),"\n",(0,s.jsx)(i.A,{python:{content:'\nprepared = gql_client.prepare_query(\n    # the args object will contain placholder value of the arguments\n    # the lambda will then return a request description as\n    # usual\n    lambda args: {\n        "user": qg.get_user(\n            # use only values from args for arguments\n            # no branching should be done\n            { "id": args.get("userId") },\n            {\n                "id": True,\n                "email": True,\n                "posts": (\n                  { "filter": args.get("postFilter") }, \n                  { "_": SelectionFlags(select_all=True) },\n                ),\n            },\n        ),\n    },\n)\n\n# execute the actual query\n\n# the input here must contain every key\n\n# used from the lambda arg above\n\nout = prepared.perform({\n"userId": "1234",\n"postFilter": "top",\n})\nout2 = prepared.perform({\n"userId": "5678",\n"postFilter": "hot",\n})\n'},typescript:{content:'\nconst prepared = gqlClient.prepareQuery(\n// the args object will contain placholder value of the arguments\n// the closure will then return a request description as\n// usual\n(\n// types can be provided as hints\nargs: PreparedArgs<{\nuserId: string;\npostFilter: string;\n}>,\n) => ({\n\n    user: api1.getUser(\n      // use only values from args for arguments\n      // no branching should be done\n      { id: args.userId },\n      {\n        id: true,\n        email: true,\n        posts: [\n          { filter: args.postFilter },\n          { title: true, slug: true }\n        ],\n      }),\n\n})\n);\n\n// execute the actual query\n// the input here must contain every key\n// used from the closure arg above\nconst { posts } = await prepared.perform({\nuserId: "1234"\npostFilter: "top"\n});\nconst { posts: posts2 } = await prepared.perform({\nuserId: "5678"\npostFilter: "hot"\n});\n'},rust:{content:'\nlet prepared_m = gql_sync.prepare_mutation(\n// the args object will contain placholder value of the arguments\n// the closure will then return a request description as\n// usual\n|args| {\n(\n// for each placholder value, we provide a closure that returns\n// argument structs according to the value\n// this closure will be used for each use of the prepared\n// request\napi1.scalar_args(args.get("userId", |id: String| UserArgs { id })),\n.select(UserSelections {\nid: get(),\nslug: get(),\nposts: arg_select(\n// the placholder closures can take any parameter\n// that implements serde::DeserializeOwned\n// the closure here does no transformation\nargs.get("postFilter", |val: PostArgs| val)\nPostSelections {\nid: get(),\nslug: get(),\ntitle: get(),\n}\n),\n}),\n)\n}\n);\n\n// execute the actual query\n// the input here must contain every key\n// used from the closure arg above\nlet user1 = prepared_clone.perform([\n(\n"userId",\n// perform takes an Into<HashMap> parameter,\n// requiring use of json values to\n// allow heterogeneous values in a single map\nserde_json::json!("1234"),\n),\n(\n"postFilter",\nserde_json::json!(PostArgs{\nfilter: "hot".into(),\n}),\n),\n])?;\nlet user1 = prepared_clone.perform([\n(\n"userId",\nserde_json::json!("1234"),\n),\n(\n"postFilter",\n// we can provide PostArgs in json form alternatively\n// but this is less typesafe\nserde_json::json!({\n"filter": "top"\n}),\n),\n])?;\n\n'},disablePlayground:!0}),"\n",(0,s.jsx)(n.admonition,{title:"Caution",type:"warning",children:(0,s.jsx)(n.p,{children:"Note that in all three implementations, the closures are only invoked once and it's critical that there are no branching logic present in them."})}),"\n",(0,s.jsx)(n.h3,{id:"aliases",children:"Aliases"}),"\n",(0,s.jsxs)(n.p,{children:["Aliasing allows the querying of a node multiple times under different names.\nThis is very similar to the ",(0,s.jsx)(n.a,{href:"https://graphql.org/learn/queries/#aliases",children:"GraphQL aliases"})," and uses them under the hood when using the GraphQLTransport.\nNote that not all ",(0,s.jsx)(n.code,{children:"Runtimes"})," support aliasing so make sure your target does before using this feature."]}),"\n",(0,s.jsx)(i.A,{python:{content:'\nout = gql_client.query(\n    {\n        "user": qg.get_user(\n            UserSelections(\n                _=SelectionFlags(select_all=True),\n                # all selections accept Aliases in their stead\n                # including scalars\n                posts=Alias(\n                    # posts is a composie with arguments so the \n                    # tuple form is expected\n                    post1=(\n                      PostArgs(filter="top"), \n                      PostSelections(\n                          id=True,\n                          slug=True,\n                          title=True,\n                      ),\n                    )\n                    # a second aliasing\n                    post2=(\n                      PostArgs(filter="hot"), \n                      PostSelections(\n                          _=SelectionFlags(select_all=True),\n                          id=False,\n                      ),\n                    )\n                ),\n            ),\n        ),\n    }\n)\n# note that when using aliases, the TypedDict are no longer\n# valid\nposts1 = out["user"]["post1"];\nposts2 = out["user"].["post2"];\n'},typescript:{content:'\nconst { user } = await gqlClient.query({\n  user: api1.getUser({\n    _: "selectAll",\n    // all selections accept alias() in their stead\n    // including scalars\n    posts: alias({\n      // posts is a composie with arguments so the \n      // tuple form is expected\n      post1: [\n        { filter: "top" }, \n        { _: "selectAll" }\n      ],\n      // a second aliasing\n      post2: [\n        { filter: "top" }, \n        { _: "selectAll" }\n      ],\n    }),\n  }),\n});\n\n// when using aliases, the original types\n// provided are no longer accurate\nconst posts1 = user.post1\nconst posts2 = user.post1\n'},rust:{content:'\n// user here is a serde_json::Value type\n// since we opted into aliases by using\n// select_aliased\nlet (user,) = gql_sync.query((\napi1.get_user()\n// alias() selections are only available under root select_aliased\n// selections. Even if the alias() is nested deep, the root\n// must be select_aliased\n.select_aliased(UserSelections {\n// all selections accept alias() in their stead\n// including scalars\nposts: alias([\n(\n"post1",\n// posts is a composie with arguments so the\n// arg_select form is expected\nposts: arg_select(\nPostArgs { filter: "top".into() },\nPostSelections {\n..all()\n}\n),\n),\n// a second aliasing\n("post2", arg_select(PostArgs { filter: "hot".into() }, all())),\n]),\n..all()\n}),\n))?;\n// aliases force use of json to bypass the generated types\nlet posts1 = user["post1"];\nlet posts2 = user["post2"];\n'},disablePlayground:!0}),"\n",(0,s.jsx)(n.h3,{id:"unions",children:"Unions"}),"\n",(0,s.jsx)(n.p,{children:"Union and either types that have composite variants require special forms when querying them.\nThe generated selection types will have fields for selecting composite variants.\nIf the value from the API wasn't of a selected variant, an empty object will be returned.\nScalar variants are always selected."}),"\n",(0,s.jsx)(i.A,{python:{content:'\nres5 = gql_client.query(\n    {\n        # this case is only interested in post values\n        "postOnly": qg.composite_union(\n            {\n                "userId": "1234"\n            },\n            {\n              "post": {"_": SelectionFlags(select_all=True)}\n            },\n        ),\n        "userOnly": qg.composite_union(\n            {\n                "userId": "1234"\n            },\n            {\n              "user": { "_": SelectionFlags(select_all=True) }\n            },\n        ),\n        "both": qg.composite_union(\n            {\n                "userId": "1234"\n            },\n            {\n                # add selections for both variants to ensure\n                # that a value is present no matter the type\n                "post": {"_": SelectionFlags(select_all=True)},\n                "user": {"_": SelectionFlags(select_all=True)},\n            },\n        ),\n    }\n)\n'},typescript:{content:'\nconst out = await gqlClient.query({\n  // this case is only interested in post values\n  postOnly: api1.compositeUnion(\n    { id: "1234" }, \n    {\n      post: { "_": "selectAll" },\n    }\n  ),\n  userOnly: api1.compositeUnion(\n    { id: "1234" }, \n    {\n      user: { "_": "selectAll" },\n    }\n  ),\n  both: api1.compositeUnion(\n    { id: "1234" }, \n    {\n      // add selections for both variants to ensure\n      // that a value is present no matter the type\n      user: { "_": "selectAll" },\n      post: { "_": "selectAll" },\n    }\n  ),\n});\n  '},rust:{content:'\nlet out = gql\n  .query((\n      // this case is only interested in post values\n      api1\n        .composite_union(MyArgs { id: "1234".into(), })\n        .select(UnionSelections {\n            post: select(all()),\n            ..default()\n        }),\n      api1\n        .composite_union(MyArgs { id: "1234".into(), })\n        .select(UnionSelections {\n            user: select(all()),\n            ..default()\n        }),\n      api1\n        .composite_union(MyArgs { id: "1234".into(), })\n        .select(UnionSelections {\n            // add selections for both variants to ensure\n            // that a value is present no matter the type\n            post: select(all()),\n            user: select(all()),\n        }),\n  ))\n  .await?;\n'},disablePlayground:!0})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},65671:(e,n,t)=>{t.d(n,{A:()=>i});var s=t(98302),r=(t(30758),t(86070));function i(e){let{python:n,typescript:t,rust:i,...l}=e;const o=[n&&{content:n.content,codeLanguage:"python",codeFileUrl:n.path},t&&{content:t.content,codeLanguage:"typescript",codeFileUrl:t.path},i&&{content:i.content,codeLanguage:"rust",codeFileUrl:i.path}].filter((e=>!!e));return(0,r.jsx)(s.A,{code:0==o.length?void 0:o,...l})}}}]);