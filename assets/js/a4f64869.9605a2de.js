"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1723],{33454:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>c,toc:()=>h});var s=t(86070),i=t(25710),r=t(65480),a=t(27676);const l={},o="Substantial",c={id:"reference/runtimes/substantial/index",title:"Substantial",description:"Substantial runtime",source:"@site/docs/reference/runtimes/substantial/index.mdx",sourceDirName:"reference/runtimes/substantial",slug:"/reference/runtimes/substantial/",permalink:"/docs/reference/runtimes/substantial/",draft:!1,unlisted:!1,editUrl:"https://github.com/metatypedev/metatype/tree/main/docs/metatype.dev/docs/reference/runtimes/substantial/index.mdx",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"S3",permalink:"/docs/reference/runtimes/s3/"},next:{title:"Temporal",permalink:"/docs/reference/runtimes/temporal/"}},d={},h=[{value:"Substantial runtime",id:"substantial-runtime",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Backend",id:"backend",level:3},{value:"Workflows",id:"workflows",level:3},{value:"Persistence and Lifecycle",id:"persistence-and-lifecycle",level:4},{value:"Run",id:"run",level:3},{value:"Debugging your workflow",id:"debugging-your-workflow",level:3},{value:"Logging",id:"logging",level:4},{value:"Debugging",id:"debugging",level:4},{value:"Advanced Filters",id:"advanced-filters",level:3},{value:"Child workflows",id:"child-workflows",level:2},{value:"Versioning",id:"versioning",level:2},{value:"Method 1: Abort or wait on all ongoing workflows, then start new ones",id:"method-1-abort-or-wait-on-all-ongoing-workflows-then-start-new-ones",level:3},{value:"Method 2: Create a new workflow under a new name",id:"method-2-create-a-new-workflow-under-a-new-name",level:3},{value:"Method 3: Add conditional logic for new behavior",id:"method-3-add-conditional-logic-for-new-behavior",level:3},{value:"Method 4: Add conditional logic with an external trigger",id:"method-4-add-conditional-logic-with-an-external-trigger",level:3}];function u(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"substantial",children:"Substantial"}),"\n",(0,s.jsx)(n.h2,{id:"substantial-runtime",children:"Substantial runtime"}),"\n",(0,s.jsx)(n.p,{children:"The Substantial runtime enables the execution of durable workflows in one or across multiple typegates."}),"\n",(0,s.jsx)(n.p,{children:"Why use it?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:'Long-running "processes"'}),": Durable tasks that need to run over extended periods (days, weeks or months), handling ",(0,s.jsx)(n.strong,{children:"retries"})," and ",(0,s.jsx)(n.strong,{children:"restarts"})," seamlessly."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fault-tolerant execution"}),": Ensure reliable execution of tasks, even upon failures, by maintaining a durable state of the latest run."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Task orchestration"}),": Coordinate complex sequences of workflows (analogous to microservice interactions)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For example, the workflow below will continue running until a ",(0,s.jsx)(n.code,{children:"confirmation"})," event is sent to the ",(0,s.jsx)(n.strong,{children:"associated run"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'export async function sendEmail(ctx: Context) {\n  // 1. A workflow can receive parameters whose type is defined on the typegraph\n  const { to } = ctx.kwargs;\n\n  // 2. When a function call produces effects, we can make it durable\n  const info = await ctx.save(() => sendSubscriptionEmail(to));\n  const timeSent = await ctx.save(() => new Date().toJSON());\n\n  const confirmation = ctx.receive<boolean>("confirmation");\n  if (!confirmation) {\n    throw new Error(`${to} has denied the subscription sent at ${timeSent}`);\n  }\n\n  return `${to} confirmed (${info})`;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Additionally, if we were to shut down the Typegate node executing it and then restart it, the state ",(0,s.jsx)(n.strong,{children:"will be preserved"}),". This means that if the subscription email was already sent, upon relaunch, it will not be sent again, same thing for the value of ",(0,s.jsx)(n.code,{children:"timeSent"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"backend",children:"Backend"}),"\n",(0,s.jsxs)(n.p,{children:["This abstraction implements a set of atomic operations that allows Typegate to persist and recover the workflow state. Currently, we have the ",(0,s.jsx)(n.strong,{children:"Redis"})," backend available, along with others like ",(0,s.jsx)(n.strong,{children:"fs"})," and ",(0,s.jsx)(n.strong,{children:"memory"}),", which are primarily intended for development or testing purposes."]}),"\n",(0,s.jsx)(n.h3,{id:"workflows",children:"Workflows"}),"\n",(0,s.jsxs)(n.p,{children:["A special type of function with ",(0,s.jsx)(n.strong,{children:"durable state"})," and an execution mechanism directly tied to time. A workflow can also trigger other workflows (child workflows)."]}),"\n",(0,s.jsx)(n.h4,{id:"persistence-and-lifecycle",children:"Persistence and Lifecycle"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Context"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The context object contains the workflow input (namely ",(0,s.jsx)(n.code,{children:"kwargs"})," as seen in the example above), but it can also be thought as a namespace that contains all of the core functions used for durableness."]}),"\n",(0,s.jsx)(n.p,{children:"It is recreated at every replay."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Interrupts"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["A special state of the program that is produced by any function that can trigger a workflow ",(0,s.jsx)(n.strong,{children:"replay"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"An interrupt will pause the program at the line it was emitted then queue it back to execute later."}),"\n",(0,s.jsx)(n.p,{children:"One simple example of such function is when you want to wait for a given amount of time, Substantial will save the current time and the end time, interrupts the workflow then requeue it to execute later."}),"\n",(0,s.jsxs)(n.p,{children:["Any agent (Typegate node) that picks the workflow, will ",(0,s.jsx)(n.strong,{children:"replay"})," it, the cycle repeats until the actual current time is greater or equal to the end time."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"ctx.sleep(24 * 3600 * 1000); // 1 day\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Save"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"A save is one of the main building blocks of a workflow, many functions available on the context object rely on it."}),"\n",(0,s.jsxs)(n.p,{children:["This is mainly because a save call converts any function into a ",(0,s.jsx)(n.strong,{children:"durable"})," one: the function output is saved and persisted in the backend. On subsequent executions, the saved value is retrieved from the backend instead of re-executing the function."]}),"\n",(0,s.jsx)(n.p,{children:"This ensures that when a workflow is resumed (after a Typegate reboot for example) or replayed (after interrupts), the saved function will not be executed again."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// For example, if the output was 7 then after replay,\n// save will not execute the function inside but directly return already persisted value, which was 7.\nconst rand = await ctx.save(() => Math.floor(10 * Math.random()));\n\n// If you keep in mind that the workflow can be replayed many times\n// A save call should make more sense!\nconst now = await ctx.save(() => Date.now());\n\n// And even more for functions that can produce external side-effects\nconst result = await ctx.save(() => sendEmail());\n"})}),"\n",(0,s.jsxs)(n.admonition,{title:"Notes",type:"info",children:[(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Only JSON-serializable values can be persisted. The execution will throw otherwise."}),"\n",(0,s.jsx)(n.li,{children:"Make sure to not rely on changing outside references inside a save call, best is to always expect a replay."}),"\n"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'let value = 5;\nconst afterSave = await save(() => {\n  value *= 2;\n  return save; // 10 will be stored on the Backend\n});\n\nconsole.log(value); // 10 on the first replay, 5 on the next replay (save call function was skipped)\nconsole.log(afterSave); // always 10\n\n// Ideally, what you want is to reuse the saved value if the effect was desired\n// especially when you branch\nif (afterSave == 10) {\n  console.log("All good"); // branch path is now durable even after replays!\n} else {\n  throw new Error("Unreachable code");\n}\n'})})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Send/Receive"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["You can send events to a workflow through GraphQL, any receive call on the workflow will await for it and will ",(0,s.jsx)(n.strong,{children:"interrupt"})," the workflow if it hasn't been received yet."]}),"\n",(0,s.jsxs)(r.Ay,{children:[(0,s.jsx)(a.A,{value:"python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"g.expose(\n  # ..\n  send=sub.send(t.integer())\n)\n"})})}),(0,s.jsx)(a.A,{value:"typescript",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"g.expose({\n  // ..\n  send: sub.send(t.integer()),\n});\n"})})})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'# Client\nquery {\n  send(run_id: "<workflow_run_id>", event: { name: "myEvent", payload: 1234 })\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'// Workflow\nconst value = ctx.receive<number>("myEvent"); // 1234\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Ensure"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["It's a function that takes a predicate, and will ",(0,s.jsx)(n.strong,{children:"interrupt"})," the workflow so that it will be replayed later if the returned value is false."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'const secret = ctx.receive<string>("secret");\nawait ctx.ensure(() => secret == "top_secret");\n//\n// continue execution\n'})}),"\n",(0,s.jsx)(n.h3,{id:"run",children:"Run"}),"\n",(0,s.jsxs)(n.p,{children:["When a workflow is started, a run is created and Substantial will provide you a ",(0,s.jsx)(n.code,{children:"run_id"})," to uniquely identify it."]}),"\n",(0,s.jsxs)(n.p,{children:["You can send an event or abort an ongoing run from its ",(0,s.jsx)(n.code,{children:"run_id"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"debugging-your-workflow",children:"Debugging your workflow"}),"\n",(0,s.jsx)(n.h4,{id:"logging",children:"Logging"}),"\n",(0,s.jsxs)(n.p,{children:["Under the context object, there is a ",(0,s.jsx)(n.code,{children:"logger"})," namespace that you can use to emit event logs."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'ctx.logger.info("Will start a sleep");\nconst startTime = await ctx.save(() => Date.now());\n\nctx.logger.warn("Started at", new Date());\nctx.sleep(5000);\nctx.logger.warn("Ended at", new Date());\n\nconst diff = await ctx.save(() => Date.now() - startTime);\nif (diff < 0) {\n  // Always make sure that branches are deterministic accross replays\n  ctx.logger.error("Time went backwards");\n  throw new Error("Time travel");\n}\n'})}),"\n",(0,s.jsxs)(n.admonition,{title:"Notes",type:"info",children:[(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Logger arguments must be JSON-serializable."}),"\n",(0,s.jsx)(n.li,{children:"Similarly to save calls, any path leading to a logger function call must be deterministic."}),"\n"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// BAD\nif (Math.random() < 0.5) {\n  // Path is not deterministic\n  ctx.logger.info("Lucky!");\n}\n\n// GOOD\n// The solution is to save any non-deterministic value first\nconst isLucky = await ctx.save(() => Math.random() < 0.5);\nif (isLucky) {\n  ctx.logger.info("Lucky!");\n}\n'})})]}),"\n",(0,s.jsx)(n.h4,{id:"debugging",children:"Debugging"}),"\n",(0,s.jsx)(n.p,{children:"Substantial comes with a few utility functions that you can expose on your typegraph."}),"\n",(0,s.jsx)(n.p,{children:"You can check in real time the state of your workflows."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'query AwesomeStatusDebugger($worlflow: String!)\n  results_raw(name: $workflow) {\n    ongoing {\n      count\n      runs {\n        run_id\n        logs {\n          timestamp  # Time at which the log event was emitted\n          level  # One of "Info", "Warn" or "Error"\n          value  # A json string of an array of JSON objects\n        }\n      }\n    }\n\n    completed {\n      count\n      runs {\n        run_id\n        result {\n          status  # One of "COMPLETED", "COMPLETED_WITH_ERROR"\n          value  # Returned value or error by the workflow\n        }\n        logs {\n          timestamp\n          level\n          value\n        }\n      }\n    }\n  }\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This endpoint can be exposed with ",(0,s.jsx)(n.code,{children:"queryResultsRaw"})," or ",(0,s.jsx)(n.code,{children:"queryResults"})," (if you want to enforce the return type shape)."]}),"\n",(0,s.jsxs)(r.Ay,{children:[(0,s.jsx)(a.A,{value:"python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'g.expose(\n  # ..\n  results=sub.query_results( # if you want to enforce the return type\n      t.either([t.integer(), t.string()]).rename("ResultOrError")\n  ),\n  results_raw=sub.query_results_raw(), # if you do not care about the return type\n)\n'})})}),(0,s.jsx)(a.A,{value:"typescript",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'g.expose({\n  // ..\n  results = sub.queryResults(\n    // if you want to enforce the return type\n    t.either([t.integer(), t.string()]).rename("ResultOrError"),\n  ),\n  results_raw = sub.queryResultsRaw(), // if you do not care about the return type\n});\n'})})})]}),"\n",(0,s.jsx)(n.h3,{id:"advanced-filters",children:"Advanced Filters"}),"\n",(0,s.jsx)(n.p,{children:"In practice, you will have many workflows that have been executed, each run can be in different states. Substantial provides a way to filter the runs."}),"\n",(0,s.jsxs)(r.Ay,{children:[(0,s.jsx)(a.A,{value:"python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"g.expose(\n  # ..\n  search=sub.advanced_filters()\n)\n"})})}),(0,s.jsx)(a.A,{value:"typescript",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"g.expose({\n  // ..\n  search: sub.advancedFilters(),\n});\n"})})})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'# Client\nquery {\n  search(\n    name: "sendEmail"\n    filter: {\n      and: [\n        { status: { contains: "\\"COMPLETED\\"" } }\n        { not: { started_at: { lt: "\\"2025-01-15T00:00:00Z\\"" } } }\n        { not: { eq: "null" } }\n      ]\n    }\n  ) {\n    run_id\n    started_at\n    ended_at\n    status\n    value\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Specification and syntax"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The specification itself is very close to Prisma queries.\nYou can also refer to your GraphQL playground for guiding you into expressing your query."}),"\n",(0,s.jsx)(n.p,{children:"Base specification:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"val           ::=  json_string\n\nterm          ::=  { eq: val }\n                | { lt: val } | { lte: val }\n                | { gt: val } |  { gte: val }\n                | { in: val } | { contains: val }\n\nspecial_term  ::=  { started_at: term }\n                | { ended_at: term }\n                | { status: term }\n\nnot           ::=  { not: expr }\nor            ::=  { or: [expr] }\nand           ::=  { and: [expr] }\n\nexpr          ::=  not | or | and | term | special_term\n"})}),"\n",(0,s.jsxs)(n.admonition,{title:"Notes",type:"info",children:[(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"contains"}),": Check if the workflow output is a list that contains the given value or if the given value is a substring of it."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"in"}),": Check if the workflow output is within a list or is a substring of the given value."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"status"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Can be one of ",(0,s.jsx)(n.code,{children:'"COMPLETED"'}),", ",(0,s.jsx)(n.code,{children:'"COMPLETED_WITH_ERROR"'}),", ",(0,s.jsx)(n.code,{children:'"ONGOING"'})," or ",(0,s.jsx)(n.code,{children:'"UNKNOWN"'}),"."]}),"\n"]}),"\n"]}),"\n"]}),(0,s.jsx)(n.p,{children:"For example, the term"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'{ status: { contains: "\\"COMPLETED\\"" } }\n'})}),(0,s.jsxs)(n.p,{children:["..should cover ",(0,s.jsx)(n.code,{children:'"COMPLETED"'})," and ",(0,s.jsx)(n.code,{children:'"COMPLETED_WITH_ERROR"'}),"."]})]}),"\n",(0,s.jsx)(n.h2,{id:"child-workflows",children:"Child workflows"}),"\n",(0,s.jsx)(n.p,{children:"Child workflows are like any other workflows, they are just run by another workflow (parent)."}),"\n",(0,s.jsx)(n.p,{children:"If a workflow parent is explicitly stopped or aborted, all of its descendants will also be aborted."}),"\n",(0,s.jsx)(n.p,{children:"For example, suppose you want to write a workflow that sends a subscription request to a list of emails and then receive a notification for each confirmation or denial, but only during your work hours."}),"\n",(0,s.jsx)(n.p,{children:"You can easily translate that logic as if you were writing generic sequential code using Substantial workflows."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import {\n  nextTimeWhenAdminIsAvailable,\n  sendSubscriptionEmail,\n  notifyAdmin,\n} from "./utils.ts";\n\nexport async function sendEmail(ctx: Context) {\n  // 1. A workflow can receive parameters whose type is defined on the typegraph\n  const { to } = ctx.kwargs;\n\n  // 2. When a function call produces effects, we can make it durable\n  const info = await ctx.save(() => sendSubscriptionEmail(to));\n  const timeSent = await ctx.save(() => new Date());\n\n  const confirmation = ctx.receive<boolean>("confirmation");\n  if (!confirmation) {\n    throw new Error(`${to} has denied the subscription sent at ${timeSent}`);\n  }\n\n  // 3. In this scenario, we use a durable sleep to wait until the admin\n  // is available\n  const duration = await ctx.save(() =>\n    nextTimeWhenAdminIsAvailable(new Date()),\n  );\n  ctx.sleep(duration);\n\n  const _ = await ctx.save(() => notifyAdmin(info), {\n    retry: {\n      minBackoffMs: 1000,\n      maxBackoffMs: 5000,\n      maxRetries: 4,\n    },\n  });\n\n  return `${to} confirmed`;\n}\n\nexport async function sendMultipleEmails(ctx: Context) {\n  const { emails } = ctx.kwargs;\n\n  // 1. Persist the state of the child workflows\n  const handlersDef = await ctx.save(async () => {\n    const handlersDef = [];\n    for (const email of emails) {\n      const handleDef = await ctx.startChildWorkflow(sendEmail, {\n        to: email,\n      });\n      handlersDef.push(handleDef);\n    }\n\n    return handlersDef;\n  });\n\n  // 2. Create handles for your child workflows\n  const handles = handlersDef.map((def) => ctx.createWorkflowHandle(def));\n\n  // 3. In this example, we wait on all child workflows to complete\n  await ctx.ensure(async () => {\n    for (const handle of handles) {\n      if (!(await handle.hasStopped())) {\n        return false;\n      }\n    }\n    return true;\n  });\n\n  const ret = await ctx.save(async () => {\n    const ret = [];\n    for (const handle of handles) {\n      const childResult = await handle.result<string>();\n      ret.push(childResult);\n    }\n\n    return ret;\n  });\n\n  return ret;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"In your typegraph, you will have:"}),"\n",(0,s.jsxs)(r.Ay,{children:[(0,s.jsx)(a.A,{value:"python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from typegraph import typegraph, t, Graph\nfrom typegraph.policy import Policy\nfrom typegraph.runtimes.substantial import SubstantialRuntime, WorkflowFile\nfrom typegraph.runtimes.substantial import Backend\n\n\n@typegraph()\ndef substantial_example(g: Graph):\n    pub = Policy.public()\n\n    backend = Backend.redis("REDIS_SECRET")\n    file = (\n        WorkflowFile.deno(file="my_workflow.ts", deps=["shared/types.ts"])\n        .import_(["sendEmail", "sendMultipleEmails"])\n        .build()\n    )\n\n    sub = SubstantialRuntime(backend, [file])\n\n    g.expose(\n        pub,\n        stop=sub.stop(),\n        send_multiple_emails=sub.start(t.struct({ "emails": t.list(t.email()) })).reduce(\n            { "name": "sendMultipleEmails"}\n        ),\n        send_single_email=sub.start(t.struct({"to": t.email()})).reduce(\n            {"name": "sendEmail"}\n        ),\n        send_confirmation=sub.send(t.boolean()).reduce(\n            {"event": {"name": "confirmation", "payload": g.inherit()}}\n        ),\n        results_raw=sub.query_results_raw(),\n        workers=sub.query_resources(),\n        **sub.internals(), # Required for child workflows\n    )\n\n'})})}),(0,s.jsx)(a.A,{value:"typescript",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import { Policy, t, typegraph } from "@typegraph/sdk/index.ts";\nimport {\n  SubstantialRuntime,\n  Backend,\n  WorkflowFile,\n} from "@typegraph/sdk/runtimes/substantial.ts";\n\ntypegraph(\n  {\n    name: "substantial-example",\n  },\n  (g) => {\n    const pub = Policy.public();\n    const backend = Backend.redis("REDIS_SECRET");\n    const file = WorkflowFile.deno("my_workflow.ts", [])\n      .import(["sendEmail", "sendMultipleEmails"])\n      .build();\n\n    const sub = new SubstantialRuntime(backend, [file]);\n\n    g.expose(\n      {\n        stop: sub.stop(),\n        send_multiple_emails: sub\n          .start(t.struct({ emails: t.list(t.email()) }))\n          .reduce({ name: "sendMultipleEmails" }),\n        send_single_email: sub\n          .start(t.struct({ to: t.email() }))\n          .reduce({ name: "sendEmail" }),\n        results_raw: sub.queryResultsRaw(),\n        workers: sub.queryResources(),\n        ...sub.internals(), // Required for child workflows\n      },\n      pub,\n    );\n  },\n);\n'})})})]}),"\n",(0,s.jsx)(n.h2,{id:"versioning",children:"Versioning"}),"\n",(0,s.jsx)(n.p,{children:"There is no dedicated versioning scheme in Substantial. However, you can still manage versioning using existing features when applying incremental changes to a workflow."}),"\n",(0,s.jsx)(n.p,{children:"Assume the following workflow:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import { checkStatus, getAmountById, sendEmail, pay } from "./payroll.ts";\n\nexport function payEmployee(ctx: Context) {\n  const { id } = ctx.kwargs;\n\n  let period = 0;\n  while (true) {\n    const isStillEmployed = await ctx.save(() => checkStatus(id));\n    if (!isStillEmployed) {\n      break;\n    }\n\n    const amount = await ctx.save(() => getAmountById(id));\n    await ctx.save(() => pay(id, amount));\n    await ctx.save(() => sendEmail(id));\n    period += 1;\n\n    ctx.logger.info(`Period ${period}: paid ${amount}`);\n    ctx.sleep(30 /*days*/ * 24 * 3600 * 1000);\n  }\n\n  ctx.logger.info(`Workflow terminated for Employee #${id}`);\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Now, suppose you want to change the sleep interval from 30 days to 15 days for future runs.\nReconciling this change with already-running workflows can be challenging."}),"\n",(0,s.jsx)(n.h3,{id:"method-1-abort-or-wait-on-all-ongoing-workflows-then-start-new-ones",children:"Method 1: Abort or wait on all ongoing workflows, then start new ones"}),"\n",(0,s.jsx)(n.p,{children:"This works if your infrastructure lets you safely abort a workflow and restart it, or if your domain logic allows this approach."}),"\n",(0,s.jsx)(n.p,{children:"In our example, this strategy is feasible only if all employees are paid in sync. Otherwise, you'd need to ensure you only abort at the end of a payroll cycle."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-diff",children:"-    ctx.sleep(30/*days*/ * 24 * 3600 * 1000);\n+    ctx.sleep(15/*days*/ * 24 * 3600 * 1000);\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u2705 Simple, but requires coordination."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"method-2-create-a-new-workflow-under-a-new-name",children:"Method 2: Create a new workflow under a new name"}),"\n",(0,s.jsx)(n.p,{children:"Instead of modifying the existing workflow, keep it as-is and introduce a new one with the updated logic."}),"\n",(0,s.jsx)(n.p,{children:"Then, switch over to the new workflow in your orchestration layer. Optionally, you can abort old ones after they finish."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export function payEmployee(ctx: Context) {\n  // old logic\n}\n\nexport function payEmployee15Days(ctx: Context) {\n  // new logic\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u2705 Clean separation, allows for drastically different logic."}),"\n",(0,s.jsx)(n.li,{children:"\u26a0\ufe0f You may need to update callers or orchestration logic."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"method-3-add-conditional-logic-for-new-behavior",children:"Method 3: Add conditional logic for new behavior"}),"\n",(0,s.jsxs)(n.p,{children:["This approach lets you keep the same workflow name but use branching logic based on a versioning flag (e.g., an optional ",(0,s.jsx)(n.code,{children:"cycle"})," in ",(0,s.jsx)(n.code,{children:"ctx.kwargs"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"It's especially useful when you have many interconnected workflows and don't want to change references or workflow names."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export function payEmployee(ctx: Context) {\n  const { id, cycle } = ctx.kwargs; // 'cycle' is new\n  // ..\n  while (true) {\n    // ..\n\n    if (!cycle) {\n      ctx.sleep(30 * 24 * 3600 * 1000); // legacy default\n    } else {\n      ctx.sleep(cycle * 24 * 3600 * 1000); // new logic\n    }\n  }\n  // ..\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You can start new workflows with ",(0,s.jsx)(n.code,{children:"cycle"})," set to ",(0,s.jsx)(n.code,{children:"15"}),", while old ones follow the legacy path."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u2705 Backwards-compatible and centralized logic."}),"\n",(0,s.jsx)(n.li,{children:"\u26a0\ufe0f Still requires external coordination to eventually abort the old instances."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"method-4-add-conditional-logic-with-an-external-trigger",children:"Method 4: Add conditional logic with an external trigger"}),"\n",(0,s.jsx)(n.p,{children:"This is very similar to the previous method, the key difference being the source of the flag that decides the branch to pick."}),"\n",(0,s.jsx)(n.p,{children:"In this setup, you control the code path from an external trigger."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'export function payEmployee(ctx: Context) {\n  // ..\n  while (true) {\n    // ..\n\n    // Function that calls an external service\n    const version = await ctx.save(() => getVersion());\n    switch (version) {\n      case "15-days-patch-v1":\n        ctx.sleep(15 /*days*/ * 24 * 3600 * 1000);\n        break;\n\n      // You can add new conditions incrementally\n      // with potentially drastically different logic\n      // ..\n\n      default:\n        ctx.sleep(30 /*days*/ * 24 * 3600 * 1000);\n    }\n  }\n  // ..\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This is especially useful because the workflow will simply use the new delay on the next cycle, automatically, without any need to migrate, and without breaking the event log."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u2705 All benefits from the previous methods, resilient to incremental changes."}),"\n",(0,s.jsx)(n.li,{children:"\u26a0\ufe0f The approach of needing an external service to inform the workflow itself, can get messy when the workflow complexifies."}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},65480:(e,n,t)=>{t.d(n,{Ay:()=>a,gc:()=>l});t(30758);var s=t(3733),i=t(56315),r=t(86070);function a(e){let{children:n}=e;const[t,a]=(0,s.e)();return(0,r.jsx)(i.mS,{choices:{typescript:"Typescript SDK",python:"Python SDK"},choice:t,onChange:a,children:n})}function l(e){let{children:n}=e;const[t]=(0,s.e)();return(0,r.jsx)(i.q9,{choices:{typescript:"Typescript SDK",python:"Python SDK"},choice:t,children:n})}}}]);