"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9835],{38544:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>l});var r=n(86070),i=n(25710);const c={sidebar_position:3},a="Architecture",s={id:"concepts/architecture/index",title:"Architecture",description:"Artifacts",source:"@site/docs/concepts/architecture/index.mdx",sourceDirName:"concepts/architecture",slug:"/concepts/architecture/",permalink:"/docs/concepts/architecture/",draft:!1,unlisted:!1,editUrl:"https://github.com/metatypedev/metatype/tree/main/website/docs/concepts/architecture/index.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docs",previous:{title:"Mental model",permalink:"/docs/concepts/mental-model/"},next:{title:"Comparing Metatype",permalink:"/docs/concepts/comparisons/"}},o={},l=[{value:"Artifacts",id:"artifacts",level:2},{value:"Reference counting",id:"reference-counting",level:3},{value:"Rationale",id:"rationale",level:4},{value:"Artifact removal",id:"artifact-removal",level:3},{value:"GC: Garbage collection",id:"gc-garbage-collection",level:4},{value:"Full GC",id:"full-gc",level:4}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"architecture",children:"Architecture"}),"\n",(0,r.jsx)(t.h2,{id:"artifacts",children:"Artifacts"}),"\n",(0,r.jsxs)(t.p,{children:["While developing and building an application using ",(0,r.jsx)(t.em,{children:"Metatype"}),", different types of artifacts can be used in different parts of the application. An artifact is an external file that your application uses as a dependency to execute tasks."]}),"\n",(0,r.jsxs)(t.p,{children:["For instance, while working with ",(0,r.jsx)(t.a,{href:"/docs/reference/runtimes/python",children:"PythonRuntime"}),", we import an external Python script ",(0,r.jsx)(t.code,{children:"artifacts/hasher.py"})," which has some hashing functionality. The script which we imported will be marked as an artifact and run inside the ",(0,r.jsx)(t.code,{children:"PythonRuntime"}),". There can be numerous artifacts which can be used by different ",(0,r.jsx)(t.a,{href:"/docs/reference/runtimes",children:"Runtimes"})," inside Metatype."]}),"\n",(0,r.jsxs)(t.p,{children:["The way ",(0,r.jsx)(t.em,{children:"Metatype"})," tracks depends on the mode in which the typegate is running."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["In the ",(0,r.jsx)(t.em,{children:"single-replica"})," mode ",(0,r.jsx)(t.em,{children:"(default)"}),", the artifacts are stored in only in the filesystem of the ",(0,r.jsx)(t.a,{href:"/docs/reference/typegate",children:"Typegate"})," node."]}),"\n",(0,r.jsxs)(t.li,{children:["In the ",(0,r.jsxs)(t.a,{href:"/docs/reference/typegate/synchronization",children:[(0,r.jsx)(t.em,{children:"Synchronized"})," mode"]}),", they are stored in a shared S3-compatible object store."]}),"\n"]}),"\n",(0,r.jsx)("div",{className:"text-center md:float-right p-8",children:(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Artifact upload protocol",src:n(59489).A+"",title:"Artifact upload protocol"})})}),"\n",(0,r.jsx)(t.h3,{id:"reference-counting",children:"Reference counting"}),"\n",(0,r.jsx)(t.p,{children:"Artifacts are tracked using reference counts. After a successful upload, each artifact is assigned a zero reference count."}),"\n",(0,r.jsx)(t.p,{children:"When a typegraph is deployed for the first time, the reference counts associated to each of its artifacts are incremented."}),"\n",(0,r.jsx)(t.p,{children:"When a typegraph is updated, reference counts are updated according to the diff of the artifact list between new and old versions of the typegraph (list of artifact hashes): removal \u2192 decrementation, addition \u2192 incrementation, no change \u2192 no change."}),"\n",(0,r.jsx)(t.p,{children:"When a typegraph is undeployed, the reference count of each artifact associated to the typegraph is decremented."}),"\n",(0,r.jsx)(t.h4,{id:"rationale",children:"Rationale"}),"\n",(0,r.jsx)(t.p,{children:"Why do we use reference counts instead of removing unused artifacts after each typegraph update/undeployment?"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Artifacts are shared between typegraphs: multiple typegraphs from a single projects might share the same artifacts."}),"\n",(0,r.jsx)(t.li,{children:"We might have orphaned artifacts due to uncompleted typegraph process."}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"artifact-removal",children:"Artifact removal"}),"\n",(0,r.jsx)(t.h4,{id:"gc-garbage-collection",children:"GC: Garbage collection"}),"\n",(0,r.jsx)(t.p,{children:"Artifacts that have a zero reference count are removed."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Triggers:"})," The GC is triggerred at the end of each typegraph deployment/undeployment process."]}),"\n",(0,r.jsx)(t.h4,{id:"full-gc",children:"Full GC"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.em,{children:"Not implemented"})})}),"\n",(0,r.jsxs)(t.p,{children:["A full GC can be triggered manually with the ",(0,r.jsx)(t.em,{children:"Meta CLI"})," or on the console."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Remove orphaned artifacts from uncompleted typegraph deployment process or uncompleted GC."}),"\n",(0,r.jsx)(t.li,{children:"Recompute all the reference counts, then run the GC. It might be necessary as the reference count might get wrong due to lack of a proper transaction support for the typegraph deployment/undeployment process."}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},59489:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/artifact_upload_protocol.drawio-15859794500be20efb4f9a80d1c08d22.svg"}}]);