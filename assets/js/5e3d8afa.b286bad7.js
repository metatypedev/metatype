(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3862],{75627:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>d,toc:()=>c});var i=t(86070),s=t(25710),r=t(65671);const a={sidebar_position:50},l="GraphQL",d={id:"reference/graphql/index",title:"GraphQL",description:"GraphQL is the primary means of querying your typegraph.",source:"@site/docs/reference/graphql/index.mdx",sourceDirName:"reference/graphql",slug:"/reference/graphql/",permalink:"/docs/reference/graphql/",draft:!1,unlisted:!1,editUrl:"https://github.com/metatypedev/metatype/tree/main/docs/metatype.dev/docs/reference/graphql/index.mdx",tags:[],version:"current",sidebarPosition:50,frontMatter:{sidebar_position:50},sidebar:"docs",previous:{title:"Embedded Typegate",permalink:"/docs/reference/meta-cli/embedded-typegate/"},next:{title:"Changelog",permalink:"/docs/reference/changelog"}},o={},c=[{value:"<code>Query</code> and <code>Mutation</code>",id:"query-and-mutation",level:2},{value:"Variables",id:"variables",level:2},{value:"Types",id:"types",level:2},{value:"Scalars",id:"scalars",level:3},{value:"Files",id:"files",level:3},{value:"Structs",id:"structs",level:3},{value:"Lists",id:"lists",level:3},{value:"Functions",id:"functions",level:3},{value:"Unions and Eithers",id:"unions-and-eithers",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"graphql",children:"GraphQL"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://graphql.org/",children:"GraphQL"})," is the primary means of querying your typegraph.\nThis page documents all the semantics of how your typegraph translates into a GraphQL schema."]}),"\n",(0,i.jsxs)(n.h2,{id:"query-and-mutation",children:[(0,i.jsx)(n.code,{children:"Query"})," and ",(0,i.jsx)(n.code,{children:"Mutation"})]}),"\n",(0,i.jsxs)(n.p,{children:["The root functions passed to the ",(0,i.jsx)(n.code,{children:"expose"})," function will be added as fields to the ",(0,i.jsxs)(n.a,{href:"https://graphql.org/learn/schema/#the-query-and-mutation-types",children:["special ",(0,i.jsx)(n.code,{children:"query"})," and ",(0,i.jsx)(n.code,{children:"mutation"})]})," GraphQL objects.\nUnder which object a function is assigned depends on it's ",(0,i.jsx)(n.a,{href:"/docs/reference/types/functions",children:"effect"}),".\nNote that this assignment still holds for deeply nested functions so be sure to avoid including functions that have mutating effects under query responses or vice versa."]}),"\n",(0,i.jsx)(n.h2,{id:"variables",children:"Variables"}),"\n",(0,i.jsxs)(n.p,{children:["While ",(0,i.jsx)(n.a,{href:"https://graphql.org/learn/queries/#variables",children:"GraphQL Variables"})," work as expected for the most part, the typegate currently does not do type validation of variables for the provided query documents."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'query ($varRight: String!, $varWrong: Int!) {\n  foo1: foo(in: $varRight)\n  foo2: foo(in: $varWrong)\n}\n{\n  "varRight": "string",\n  # request will work as long as varWrong is string\n  # even if variable above was annotated as Int\n  "varWrong": "AlsoString",\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"types",children:"Types"}),"\n",(0,i.jsx)(n.h3,{id:"scalars",children:"Scalars"}),"\n",(0,i.jsxs)(n.p,{children:["The simple primitive typegraph types translate directly to their ",(0,i.jsx)(n.a,{href:"https://graphql.org/learn/schema/#scalar-types",children:"GraphQL equivalent"}),".\nThis includes standard scalar variants like ",(0,i.jsx)(n.code,{children:"t.uuid"})," or any user declared aliases with custom configurations.\nNo custom GraphQL scalars are generated for such types."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"GraphQL type"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"t.integer()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int"})}),(0,i.jsx)(n.td,{children:"Represents signed 32-bit integers."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"t.float()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Float"})}),(0,i.jsxs)(n.td,{children:["Represents signed double-precision values as specified by ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/IEEE_754",children:"IEEE 754"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"t.boolean()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Boolean"})}),(0,i.jsxs)(n.td,{children:["Represents ",(0,i.jsx)(n.code,{children:"true"})," or ",(0,i.jsx)(n.code,{children:"false"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"t.string()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"String"})}),(0,i.jsx)(n.td,{children:"Represents textual data as UTF-8 character sequences."})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"files",children:"Files"}),"\n",(0,i.jsxs)(n.p,{children:["File types, primarily used through the ",(0,i.jsx)(n.a,{href:"/docs/reference/runtimes/s3",children:(0,i.jsx)(n.code,{children:"S3Runtime"})}),", translate to a custom scalar called ",(0,i.jsx)(n.code,{children:"File"})," in the GraphQL schema.\nThe ",(0,i.jsx)(n.code,{children:"S3Runtime"})," provides a set of helpers for all your file needs including support for ",(0,i.jsx)(n.a,{href:"/docs/guides/files-upload",children:"multipart HTTP requests"})," for file upload."]}),"\n",(0,i.jsx)(n.h3,{id:"structs",children:"Structs"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"t.structs"})," types translate to:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://graphql.org/learn/schema/#input-types",children:"GraphQL input types"})," when used as inputs to functions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://graphql.org/learn/schema/#object-types-and-fields",children:"GraphQL object types"})," in any other place."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"lists",children:"Lists"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"t.list"})," types simply convert to ",(0,i.jsx)(n.a,{href:"https://graphql.org/learn/schema/#lists-and-non-null",children:"GraphQL list types"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"functions",children:"Functions"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"t.func"})," types are represented by their output type in the GraphQL schema.\nIf their input struct has fields present, these are converted to ",(0,i.jsx)(n.a,{href:"https://graphql.org/learn/schema/#arguments",children:"arguments"})," for the field."]}),"\n",(0,i.jsx)(n.h3,{id:"unions-and-eithers",children:"Unions and Eithers"}),"\n",(0,i.jsx)(n.p,{children:"Unions and either translate to a number of different forms depending on their usage in the graph and their composition."}),"\n",(0,i.jsx)(n.p,{children:"When used as a field in an input struct, unions/eithers are converted to custom scalars since the GraphQL spec doesn't allow GraphQL unions on input types.\nThese scalars expect the standard JSON representation of your value and that is all."}),"\n",(0,i.jsxs)(n.p,{children:["When querying union/either values, there are a few more details.\nFor struct variants, the standard GraphQL rules apply and ",(0,i.jsx)(n.a,{href:"https://graphql.org/learn/queries/#inline-fragments",children:"inline fragments"})," must be used.\nCurrently, all struct variants must have inline fragments present even if the user is not interested in them.\nAnd as per GraphQL spec, common field querying is not supported and any fields must be part of the inline fragment.\nUnlike the GraphQL spec, this includes the ",(0,i.jsx)(n.code,{children:"__typename"})," field which must be included in the fragments instead."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"# introspection schema\nunion MyUnion = Struct1 | Struct2\n\ntype Struct1 {\n  foo: String!\n  bar: String!\n}\n\ntype Struct2 {\n  foo: String!\n  baz: String!\n}\n\n# introspection expected query (THIS IS WRONG)\nquery {\n  myUnion {\n    # common fields are not supported\n    __typename\n    foo\n    ... on Struct1 {\n      bar\n    }\n    ... on Struct2 {\n      baz\n    }\n  }\n}\n\n# actual expected query (THIS IS RIGHT)\nquery {\n  myUnion {\n    ... on Struct1 {\n      # common fields must be included each time\n      __typename\n      foo\n      bar\n    }\n    ... on Struct2 {\n      __typename\n      foo\n      baz\n    }\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For scalar variant, the introspected GraphQL schema will include a ",(0,i.jsx)(n.code,{children:"_NameOfScalar"})," variant in the introspection schema ",(0,i.jsx)(n.strong,{children:"but"})," the value is returned at the field level as a simple scalar.\nThat is, GraphQL API explorers will show union ",(0,i.jsx)(n.strong,{children:"object"})," members that include the scalar values and they'll prompt you to use ",(0,i.jsx)(n.a,{href:"https://graphql.org/learn/queries/#inline-fragments",children:"inline fragments"})," for querying the scalar members.\nBut the typegate will reject these kind of queries in preference to simple fields.\nLook at the following example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# introspection schema\nunion MyUnion = _String | _Integer\n\ntype _String {\n  string: String!\n}\n\ntype _Integer {\n  integer: Int!\n}\n\n# introspection expected query (THIS IS WRONG)\nquery {\n  myUnion {\n    ... on _String {\n      string\n    }\n    ... on _Integer {\n      integer\n    }\n  }\n}\n\n# actual expected query (THIS IS RIGHT)\nquery {\n  # no subfield selection at all required\n  # since all members are scalars\n  myUnion\n}\n\n# received json\n{\n  "myUnion": "string"\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"List members act accordingly to their wrapped times.\nLists of scalars are treated as scalars and lists of composites as a standard GraphQL composites list."}),"\n",(0,i.jsx)(n.p,{children:"The following playground shows all the different types of unions/eithers:"}),"\n",(0,i.jsx)(r.A,{typegraph:"union-either",typescript:t(67548),python:t(51626),query:t(82481)})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},82481:e=>{var n={kind:"Document",definitions:[{kind:"OperationDefinition",operation:"query",variableDefinitions:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"outer"},arguments:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"unionList"},arguments:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"InlineFragment",typeCondition:{kind:"NamedType",name:{kind:"Name",value:"comp_1"}},directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"field1"},arguments:[],directives:[]}]}},{kind:"InlineFragment",typeCondition:{kind:"NamedType",name:{kind:"Name",value:"comp_2"}},directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"field2"},arguments:[],directives:[]}]}}]}},{kind:"Field",name:{kind:"Name",value:"union"},arguments:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"InlineFragment",typeCondition:{kind:"NamedType",name:{kind:"Name",value:"comp_1"}},directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"field1"},arguments:[],directives:[]}]}},{kind:"InlineFragment",typeCondition:{kind:"NamedType",name:{kind:"Name",value:"comp_2"}},directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"field2"},arguments:[],directives:[]}]}}]}},{kind:"Field",name:{kind:"Name",value:"either"},arguments:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"InlineFragment",typeCondition:{kind:"NamedType",name:{kind:"Name",value:"comp_1"}},directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"field1"},arguments:[],directives:[]}]}},{kind:"InlineFragment",typeCondition:{kind:"NamedType",name:{kind:"Name",value:"comp_2"}},directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"field2"},arguments:[],directives:[]}]}}]}}]}}]}}],loc:{start:0,end:532}};n.loc.source={body:"{\n  outer {\n    # scalar 1 and 2 don't need\n    # type inline fragments\n    unionList {\n      ... on comp_1 {\n        field1\n      }\n      ... on comp_2 {\n        field2\n      }\n    }\n    # we must include fragments\n    # for all composites or it will fail\n    union {\n      ... on comp_1 {\n        field1\n      }\n      ... on comp_2 {\n        field2\n      }\n    }\n    # rules are the same between unions and eithers\n    either {\n      ... on comp_1 {\n        field1\n      }\n      ... on comp_2 {\n        field2\n      }\n    }\n  }\n}\n",name:"GraphQL request",locationOffset:{line:1,column:1}};function t(e,n){if("FragmentSpread"===e.kind)n.add(e.name.value);else if("VariableDefinition"===e.kind){var i=e.type;"NamedType"===i.kind&&n.add(i.name.value)}e.selectionSet&&e.selectionSet.selections.forEach((function(e){t(e,n)})),e.variableDefinitions&&e.variableDefinitions.forEach((function(e){t(e,n)})),e.definitions&&e.definitions.forEach((function(e){t(e,n)}))}var i={};n.definitions.forEach((function(e){if(e.name){var n=new Set;t(e,n),i[e.name.value]=n}})),e.exports=n},51626:e=>{e.exports={content:'@typegraph(\n)\ndef union_either(g: Graph):\n  deno = DenoRuntime()\n  members = [\n    t.string().rename("scalar_1"),\n    t.integer().rename("scalar_2"),\n    t.struct(\n      {\n        "field1": t.string(),\n      }\n    ).rename("comp_1"),\n    t.struct(\n      {\n        "field2": t.string(),\n      }\n    ).rename("comp_2"),\n    t.list(t.string()).rename("scalar_list"),\n    # # FIXME: list of composites is broken\n    # t.list(\n    #   t.struct(\n    #     {\n    #       "listField": t.string(),\n    #     }\n    #   ),\n    # ),\n  ]\n  g.expose(\n    Policy.public(),\n    outer=deno.func(\n      t.struct(),\n      t.struct(\n        {\n          "union": t.union(members),\n          "either": t.either(members),\n          "unionList": t.list(t.union(members)),\n        }\n      ),\n      code="""() => ({\n        either: {\n          field1: "1",\n        },\n        union: {\n          field2: "2",\n        },\n        unionList: [\n          "scalar",\n          2,\n          {\n            field1: "1",\n          },\n          {\n            field2: "2",\n          },\n          ["scalar_1", "scalar_2"],\n        ],\n      })""",\n    ),\n  )',path:"../examples/typegraphs/union-either.py"}},67548:e=>{e.exports={content:'typegraph(\n  {\n    name: "union-either",\n  },\n  (g) => {\n    const deno = new DenoRuntime();\n    const members = [\n      t.string().rename("scalar_1"),\n      t.integer().rename("scalar_2"),\n      t.struct({\n        field1: t.string(),\n      }).rename("comp_1"),\n      t.struct({\n        field2: t.string(),\n      }).rename("comp_2"),\n      t.list(t.string()).rename("scalar_list"),\n      /* FIXME: list of composites is broken\n        t.list(\n          t.struct({\n            listField: t.string(),\n          }),\n        ), */\n    ];\n    g.expose({\n      outer: deno.func(\n        // input\n        t.struct({}),\n        // output\n        t.struct({\n          union: t.union(members),\n          either: t.either(members),\n          unionList: t.list(t.union(members)),\n        }),\n        {\n          code: () => ({\n            either: {\n              field1: "1",\n            },\n            union: {\n              field2: "2",\n            },\n            unionList: [\n              "scalar",\n              2,\n              {\n                field1: "1",\n              },\n              {\n                field2: "2",\n              },\n              ["scalar_1", "scalar_2"],\n            ],\n          }),\n        },\n      ),\n    }, Policy.public());\n  },\n);',path:"../examples/typegraphs/union-either.ts"}}}]);