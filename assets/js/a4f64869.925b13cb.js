"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1723],{33454:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>c,toc:()=>h});var s=t(86070),i=t(25710),r=t(65480),a=t(27676);const l={},o="Substantial",c={id:"reference/runtimes/substantial/index",title:"Substantial",description:"Substantial runtime",source:"@site/docs/reference/runtimes/substantial/index.mdx",sourceDirName:"reference/runtimes/substantial",slug:"/reference/runtimes/substantial/",permalink:"/docs/reference/runtimes/substantial/",draft:!1,unlisted:!1,editUrl:"https://github.com/metatypedev/metatype/tree/main/docs/metatype.dev/docs/reference/runtimes/substantial/index.mdx",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"S3",permalink:"/docs/reference/runtimes/s3/"},next:{title:"Temporal",permalink:"/docs/reference/runtimes/temporal/"}},d={},h=[{value:"Substantial runtime",id:"substantial-runtime",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Backend",id:"backend",level:3},{value:"Workflows",id:"workflows",level:3},{value:"Persistence and Lifecycle",id:"persistence-and-lifecycle",level:4},{value:"Run",id:"run",level:3},{value:"Advanced Filters",id:"advanced-filters",level:3},{value:"Child workflows",id:"child-workflows",level:2}];function u(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"substantial",children:"Substantial"}),"\n",(0,s.jsx)(n.h2,{id:"substantial-runtime",children:"Substantial runtime"}),"\n",(0,s.jsx)(n.p,{children:"The Substantial runtime enables the execution of durable workflows in one or across multiple typegates."}),"\n",(0,s.jsx)(n.p,{children:"Why use it?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:'Long-running "processes"'}),": Durable tasks that need to run over extended periods (days, weeks or months), handling ",(0,s.jsx)(n.strong,{children:"retries"})," and ",(0,s.jsx)(n.strong,{children:"restarts"})," seamlessly."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fault-tolerant execution"}),": Ensure reliable execution of tasks, even upon failures, by maintaining a durable state of the latest run."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Task orchestration"}),": Coordinate complex sequences of workflows (analogous to microservice interactions)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For example, the workflow below will continue running until a ",(0,s.jsx)(n.code,{children:"confirmation"})," event is sent to the ",(0,s.jsx)(n.strong,{children:"associated run"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'export async function sendEmail(ctx: Context) {\n  // 1. A workflow can receive parameters whose type is defined on the typegraph\n  const { to } = ctx.kwargs;\n\n  // 2. When a function call produces effects, we can make it durable\n  const info = await ctx.save(() => sendSubscriptionEmail(to));\n  const timeSent = await ctx.save(() => new Date().toJSON());\n\n  const confirmation = ctx.receive<boolean>("confirmation");\n  if (!confirmation) {\n    throw new Error(`${to} has denied the subscription sent at ${timeSent}`);\n  }\n\n  return `${to} confirmed (${info})`;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Additionally, if we were to shut down the Typegate node executing it and then restart it, the state ",(0,s.jsx)(n.strong,{children:"will be preserved"}),". This means that if the subscription email was already sent, upon relaunch, it will not be sent again, same thing for the value of ",(0,s.jsx)(n.code,{children:"timeSent"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"backend",children:"Backend"}),"\n",(0,s.jsxs)(n.p,{children:["This abstraction implements a set of atomic operations that allows Typegate to persist and recover the workflow state. Currently, we have the ",(0,s.jsx)(n.strong,{children:"Redis"})," backend available, along with others like ",(0,s.jsx)(n.strong,{children:"fs"})," and ",(0,s.jsx)(n.strong,{children:"memory"}),", which are primarily intended for development or testing purposes."]}),"\n",(0,s.jsx)(n.h3,{id:"workflows",children:"Workflows"}),"\n",(0,s.jsxs)(n.p,{children:["A special type of function with ",(0,s.jsx)(n.strong,{children:"durable state"})," and an execution mechanism directly tied to time. A workflow can also trigger other workflows (child workflows)."]}),"\n",(0,s.jsx)(n.h4,{id:"persistence-and-lifecycle",children:"Persistence and Lifecycle"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Context"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The context object contains the workflow input (namely ",(0,s.jsx)(n.code,{children:"kwargs"})," as seen in the example above), but it can also be thought as a namespace that contains all of the core functions used for durableness."]}),"\n",(0,s.jsx)(n.p,{children:"It is recreated at every replay."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Interrupts"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["A special state of the program that is produced by any function that can trigger a workflow ",(0,s.jsx)(n.strong,{children:"replay"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"An interrupt will pause the program at the line it was emitted then queue it back to execute later."}),"\n",(0,s.jsx)(n.p,{children:"One simple example of such function is when you want to wait for a given amount of time, Substantial will save the current time and the end time, interrupts the workflow then requeue it to execute later."}),"\n",(0,s.jsxs)(n.p,{children:["Any agent (Typegate node) that picks the workflow, will ",(0,s.jsx)(n.strong,{children:"replay"})," it, the cycle repeats until the actual current time is greater or equal to the end time."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"await ctx.sleep(24 * 3600 * 1000); // 1 day\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Save"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"A save is one of the main building blocks of a workflow, many functions available on the context object rely on it."}),"\n",(0,s.jsxs)(n.p,{children:["This is mainly because a save call converts any function into a ",(0,s.jsx)(n.strong,{children:"durable"})," one: the function output is saved and persisted in the backend. On subsequent executions, the saved value is retrieved from the backend instead of re-executing the function."]}),"\n",(0,s.jsx)(n.p,{children:"This ensures that when a workflow is resumed (after a Typegate reboot for example) or replayed (after interrupts), the saved function will not be executed again."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// For example, if the output was 7 then after replay,\n// save will not execute the function inside but directly return already persisted value, which was 7.\nconst rand = await ctx.save(() => Math.floor(10 * Math.random()));\n\n// If you keep in mind that the workflow can be replayed many times\n// A save call should make more sense!\nconst now = await ctx.save(() => Date.now());\n\n// And even more for functions that can produce external side-effects\nconst result = await ctx.save(() => sendEmail());\n"})}),"\n",(0,s.jsxs)(n.admonition,{title:"Notes",type:"info",children:[(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Only JSON-compliant values can be persisted. The execution will throw otherwise."}),"\n",(0,s.jsx)(n.li,{children:"Make sure to not rely on changing outside references inside a save call, best is to always expect a replay."}),"\n"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'let value = 5;\nconst afterSave = await save(() => {\n  value *= 2;\n  return save; // 10 will be stored on the Backend\n});\n\nconsole.log(value); // 10 on the first replay, 5 on the next replay (save call function was skipped)\nconsole.log(afterSave); // always 10\n\n// Ideally, what you want is to reuse the saved value if the effect was desired\n// especially when you branch\nif (afterSave == 10) {\n  console.log("All good"); // branch path is now durable even after replays!\n} else {\n  throw new Error("Unreachable code");\n}\n'})})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Send/Receive"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["You can send events to a workflow through GraphQL, any receive call on the workflow will await for it and will ",(0,s.jsx)(n.strong,{children:"interrupt"})," the workflow if it hasn't been received yet."]}),"\n",(0,s.jsxs)(r.Ay,{children:[(0,s.jsx)(a.A,{value:"python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"g.expose(\n  # ..\n  send=sub.send(t.integer())\n)\n"})})}),(0,s.jsx)(a.A,{value:"typescript",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"g.expose({\n  // ..\n  send: sub.send(t.integer()),\n});\n"})})})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'# Client\nquery {\n  send(run_id: "<workflow_run_id>", event: { name: "myEvent", payload: 1234 })\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'// Workflow\nconst value = ctx.receive<number>("myEvent"); // 1234\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Ensure"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["It's a function that takes a predicate, and will ",(0,s.jsx)(n.strong,{children:"interrupt"})," the workflow so that it will be replayed later if the returned value is false."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'const secret = ctx.receive<string>("secret");\nawait ctx.ensure(() => secret == "top_secret");\n//\n// continue execution\n'})}),"\n",(0,s.jsx)(n.h3,{id:"run",children:"Run"}),"\n",(0,s.jsxs)(n.p,{children:["When a workflow is started, a run is created and Substantial will provide you a ",(0,s.jsx)(n.code,{children:"run_id"})," to uniquely identify it."]}),"\n",(0,s.jsxs)(n.p,{children:["You can send an event or abort an ongoing run from its ",(0,s.jsx)(n.code,{children:"run_id"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"advanced-filters",children:"Advanced Filters"}),"\n",(0,s.jsx)(n.p,{children:"In practice, you will have many workflows that have been executed, each run can be in different states. Substantial provides a way to filter the runs."}),"\n",(0,s.jsxs)(r.Ay,{children:[(0,s.jsx)(a.A,{value:"python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"g.expose(\n  # ..\n  search=sub.advanced_filters()\n)\n"})})}),(0,s.jsx)(a.A,{value:"typescript",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"g.expose({\n  // ..\n  search: sub.advancedFilters(),\n});\n"})})})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'# Client\nquery {\n  search(\n    name: "sendEmail"\n    filter: {\n      and: [\n        { status: { contains: "\\"COMPLETED\\"" } }\n        { not: { started_at: { lt: "\\"2025-01-15T00:00:00Z\\"" } } }\n        { not: { eq: "null" } }\n      ]\n    }\n  ) {\n    run_id\n    started_at\n    ended_at\n    status\n    value\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Specification and syntax"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The specification itself is very close to Prisma queries.\nYou can also refer to your GraphQL playground for guiding you into expressing your query."}),"\n",(0,s.jsx)(n.p,{children:"Base specification:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"val           ::=  json_string\n\nterm          ::=  { eq: val }\n                | { lt: val } | { lte: val }\n                | { gt: val } |  { gte: val }\n                | { in: val } | { contains: val }\n\nspecial_term  ::=  { started_at: term }\n                | { ended_at: term }\n                | { status: term }\n\nnot           ::=  { not: expr }\nor            ::=  { or: [expr] }\nand           ::=  { and: [expr] }\n\nexpr          ::=  not | or | and | term | special_term\n"})}),"\n",(0,s.jsxs)(n.admonition,{title:"Notes",type:"info",children:[(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"contains"}),": Check if the workflow output is a list that contains the given value or if the given value is a substring of it."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"in"}),": Check if the workflow output is within a list or is a substring of the given value."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"status"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Can be one of ",(0,s.jsx)(n.code,{children:'"COMPLETED"'}),", ",(0,s.jsx)(n.code,{children:'"COMPLETED_WITH_ERROR"'}),", ",(0,s.jsx)(n.code,{children:'"ONGOING"'})," or ",(0,s.jsx)(n.code,{children:'"UNKNOWN"'}),"."]}),"\n"]}),"\n"]}),"\n"]}),(0,s.jsx)(n.p,{children:"For example, the term"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'{ status: { contains: "\\"COMPLETED\\"" } }\n'})}),(0,s.jsxs)(n.p,{children:["..should cover ",(0,s.jsx)(n.code,{children:'"COMPLETED"'})," and ",(0,s.jsx)(n.code,{children:'"COMPLETED_WITH_ERROR"'}),"."]})]}),"\n",(0,s.jsx)(n.h2,{id:"child-workflows",children:"Child workflows"}),"\n",(0,s.jsx)(n.p,{children:"Child workflows are like any other workflows, they are just run by another workflow (parent)."}),"\n",(0,s.jsx)(n.p,{children:"If a workflow parent is explicitly stopped or aborted, all of its descendants will also be aborted."}),"\n",(0,s.jsx)(n.p,{children:"For example, suppose you want to write a workflow that sends a subscription request to a list of emails and then receive a notification for each confirmation or denial, but only during your work hours."}),"\n",(0,s.jsx)(n.p,{children:"You can easily translate that logic as if you were writing generic sequential code using Substantial workflows."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import {\n  nextTimeWhenAdminIsAvailable,\n  sendSubscriptionEmail,\n  notifyAdmin,\n} from "./utils.ts";\n\nexport async function sendEmail(ctx: Context) {\n  // 1. A workflow can receive parameters whose type is defined on the typegraph\n  const { to } = ctx.kwargs;\n\n  // 2. When a function call produces effects, we can make it durable\n  const info = await ctx.save(() => sendSubscriptionEmail(to));\n  const timeSent = await ctx.save(() => new Date());\n\n  const confirmation = ctx.receive<boolean>("confirmation");\n  if (!confirmation) {\n    throw new Error(`${to} has denied the subscription sent at ${timeSent}`);\n  }\n\n  // 3. In this scenario, we use a durable sleep to wait until the admin\n  // is available\n  const duration = await ctx.save(() =>\n    nextTimeWhenAdminIsAvailable(new Date()),\n  );\n  ctx.sleep(duration);\n\n  const _ = await ctx.save(() => notifyAdmin(info), {\n    retry: {\n      minBackoffMs: 1000,\n      maxBackoffMs: 5000,\n      maxRetries: 4,\n    },\n  });\n\n  return `${to} confirmed`;\n}\n\nexport async function sendMultipleEmails(ctx: Context) {\n  const { emails } = ctx.kwargs;\n\n  // 1. Persist the state of the child workflows\n  const handlersDef = await ctx.save(async () => {\n    const handlersDef = [];\n    for (const email of emails) {\n      const handleDef = await ctx.startChildWorkflow(sendEmail, {\n        to: email,\n      });\n      handlersDef.push(handleDef);\n    }\n\n    return handlersDef;\n  });\n\n  // 2. Create handles for your child workflows\n  const handles = handlersDef.map((def) => ctx.createWorkflowHandle(def));\n\n  // 3. In this example, we wait on all child workflows to complete\n  await ctx.ensure(async () => {\n    for (const handle of handles) {\n      if (!(await handle.hasStopped())) {\n        return false;\n      }\n    }\n    return true;\n  });\n\n  const ret = await ctx.save(async () => {\n    const ret = [];\n    for (const handle of handles) {\n      const childResult = await handle.result<string>();\n      ret.push(childResult);\n    }\n\n    return ret;\n  });\n\n  return ret;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"In your typegraph, you will have:"}),"\n",(0,s.jsxs)(r.Ay,{children:[(0,s.jsx)(a.A,{value:"python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from typegraph import typegraph, t, Graph\nfrom typegraph.policy import Policy\nfrom typegraph.runtimes.substantial import SubstantialRuntime, WorkflowFile\nfrom typegraph.runtimes.substantial import Backend\n\n\n@typegraph()\ndef substantial_example(g: Graph):\n    pub = Policy.public()\n\n    backend = Backend.redis("REDIS_SECRET")\n    file = (\n        WorkflowFile.deno(file="my_workflow.ts", deps=["shared/types.ts"])\n        .import_(["sendEmail", "sendMultipleEmails"])\n        .build()\n    )\n\n    sub = SubstantialRuntime(backend, [file])\n\n    g.expose(\n        pub,\n        stop=sub.stop(),\n        send_multiple_emails=sub.start(t.struct({ "emails": t.list(t.email()) })).reduce(\n            { "name": "sendMultipleEmails"}\n        ),\n        send_single_email=sub.start(t.struct({"to": t.email()})).reduce(\n            {"name": "sendEmail"}\n        ),\n        send_confirmation=sub.send(t.boolean()).reduce(\n            {"event": {"name": "confirmation", "payload": g.inherit()}}\n        ),\n        results_raw=sub.query_results_raw(),\n        workers=sub.query_resources(),\n        **sub.internals(), # Required for child workflows\n    )\n\n'})})}),(0,s.jsx)(a.A,{value:"typescript",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import { Policy, t, typegraph } from "@typegraph/sdk/index.ts";\nimport {\n  SubstantialRuntime,\n  Backend,\n  WorkflowFile,\n} from "@typegraph/sdk/runtimes/substantial.ts";\n\ntypegraph(\n  {\n    name: "substantial-example",\n  },\n  (g) => {\n    const pub = Policy.public();\n    const backend = Backend.redis("REDIS_SECRET");\n    const file = WorkflowFile.deno("my_workflow.ts", [])\n      .import(["sendEmail", "sendMultipleEmails"])\n      .build();\n\n    const sub = new SubstantialRuntime(backend, [file]);\n\n    g.expose(\n      {\n        stop: sub.stop(),\n        send_multiple_emails: sub\n          .start(t.struct({ emails: t.list(t.email()) }))\n          .reduce({ name: "sendMultipleEmails" }),\n        send_single_email: sub\n          .start(t.struct({ to: t.email() }))\n          .reduce({ name: "sendEmail" }),\n        results_raw: sub.queryResultsRaw(),\n        workers: sub.queryResources(),\n        ...sub.internals(), // Required for child workflows\n      },\n      pub,\n    );\n  },\n);\n'})})})]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},65480:(e,n,t)=>{t.d(n,{Ay:()=>a,gc:()=>l});t(30758);var s=t(3733),i=t(56315),r=t(86070);function a(e){let{children:n}=e;const[t,a]=(0,s.e)();return(0,r.jsx)(i.mS,{choices:{typescript:"Typescript SDK",python:"Python SDK"},choice:t,onChange:a,children:n})}function l(e){let{children:n}=e;const[t]=(0,s.e)();return(0,r.jsx)(i.q9,{choices:{typescript:"Typescript SDK",python:"Python SDK"},choice:t,children:n})}}}]);