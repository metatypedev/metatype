(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4404],{43053:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var i=t(86070),r=t(25710),a=t(65671);const o={sidebar_position:50},s="Custom functions",l={id:"guides/external-functions/index",title:"Custom functions",description:"Custom functions can be used to run custom code at different points of a typegraph. These constructs fall under functions which are, concretly, operations associated to a specific runtime. For some common tasks, like simple operations on database tables for example, runtime implementations provide function generators to minimize boilerplate. For cases not expressible by generators, runtimes like the DenoRuntime allow us to write more powerful custom functions.",source:"@site/docs/guides/external-functions/index.mdx",sourceDirName:"guides/external-functions",slug:"/guides/external-functions/",permalink:"/docs/guides/external-functions/",draft:!1,unlisted:!1,editUrl:"https://github.com/metatypedev/metatype/tree/main/docs/metatype.dev/docs/guides/external-functions/index.mdx",tags:[],version:"current",sidebarPosition:50,frontMatter:{sidebar_position:50},sidebar:"docs",previous:{title:"Metatype Basics",permalink:"/docs/tutorials/metatype-basics/"},next:{title:"Upload files to cloud storage",permalink:"/docs/guides/files-upload/"}},c={},d=[{value:"Accessing function context",id:"accessing-function-context",level:2},{value:"Accessing the typegraph",id:"accessing-the-typegraph",level:2},{value:"Generating types",id:"generating-types",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components},{Details:o}=n;return o||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"custom-functions",children:"Custom functions"}),"\n",(0,i.jsxs)(n.p,{children:["Custom functions can be used to run custom code at different points of a typegraph. These constructs fall under ",(0,i.jsx)(n.a,{href:"/docs/concepts/mental-model#functions",children:"functions"})," which are, concretly, operations associated to a specific runtime. For some common tasks, like simple operations on database tables for example, runtime implementations provide function ",(0,i.jsx)(n.a,{href:"/docs/reference/runtimes/prisma#generators",children:"generators"})," to minimize boilerplate. For cases not expressible by generators, runtimes like the ",(0,i.jsx)(n.code,{children:"DenoRuntime"})," allow us to write more powerful custom functions."]}),"\n",(0,i.jsx)(n.p,{children:"Custom functions are commonly used for:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Specialized business logic to respond directly to incoming requests"}),"\n",(0,i.jsx)(n.li,{children:"Authentication policy logic"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The following example uses the ",(0,i.jsx)(n.code,{children:"DenoRuntime"})," to respond to requests and define a policy."]}),"\n",(0,i.jsx)(a.A,{typegraph:"math",typescript:t(41929),python:t(32535),query:t(34348)}),"\n",(0,i.jsxs)(n.p,{children:["Note that for the ",(0,i.jsx)(n.code,{children:"fib"})," root function, we're using a typescript module in an external file. Here's what ",(0,i.jsx)(n.code,{children:"scripts/fib.ts"})," looks like:"]}),"\n",(0,i.jsx)(a.A,{typescript:t(39409),disablePlayground:!0}),"\n",(0,i.jsx)(n.p,{children:"The following runtimes can be used to run custom functions:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/reference/runtimes/deno/",children:(0,i.jsx)(n.code,{children:"DenoRuntime"})})," through typescript code."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/reference/runtimes/python/",children:(0,i.jsx)(n.code,{children:"PythonRuntime"})})," through python code."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/reference/runtimes/wasm/",children:(0,i.jsx)(n.code,{children:"WasmRuntime"})})," through wasm modules."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/reference/runtimes/prisma/",children:(0,i.jsx)(n.code,{children:"PrismaRuntime"})})," throw raw SQL queries."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"accessing-function-context",children:"Accessing function context"}),"\n",(0,i.jsx)(n.admonition,{title:"Beta",type:"warning",children:(0,i.jsxs)(n.p,{children:["The following feature is currently only implemented for the ",(0,i.jsx)(n.code,{children:"DenoRuntime"}),"."]})}),"\n",(0,i.jsx)(n.p,{children:"On some runtimes, custom functions are passed to the context object along with the function inputs. This object provides access to all kinds of information about the context in which the function is running. The following example illustrates availaible fields:"}),"\n",(0,i.jsx)(a.A,{typegraph:"func-ctx",typescript:t(46165),python:t(58379),query:t(90939)}),"\n",(0,i.jsxs)(n.p,{children:["Note, the typescript version of the sample uses a closure instead of a string snippet to define the function. This is a simple syntax sugar availaible when using ",(0,i.jsx)(n.code,{children:"DenoRuntime"})," through the typescript sdk or the ",(0,i.jsx)(n.code,{children:"PythonRuntime"})," the python one. Consult the reference for each runtime to look at what's availaible."]}),"\n",(0,i.jsx)(n.h2,{id:"accessing-the-typegraph",children:"Accessing the typegraph"}),"\n",(0,i.jsx)(n.admonition,{title:"Beta",type:"warning",children:(0,i.jsxs)(n.p,{children:["The following feature is currently only implemented for the ",(0,i.jsx)(n.code,{children:"DenoRuntime"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["To do anything meaningful with custom functions, you'll want to access the rest of functionality implemented on your typegraph. The primary way of doing this is by sending GraphqQl queries from within your function. On the ",(0,i.jsx)(n.code,{children:"DenoRuntime"}),", to make this easier, there's a ",(0,i.jsx)(n.code,{children:"gql"})," object passed to all functions. The following exapmle illustrates how it functions:"]}),"\n",(0,i.jsx)(a.A,{typegraph:"func-gql",typescript:t(95856),python:t(63014),query:t(30360)}),"\n",(0,i.jsxs)(n.p,{children:["And ",(0,i.jsx)(n.code,{children:"scripts/createVote.ts"})," looks like:"]}),"\n",(0,i.jsx)(a.A,{typescript:t(97778),disablePlayground:!0}),"\n",(0,i.jsx)(n.h2,{id:"generating-types",children:"Generating types"}),"\n",(0,i.jsx)(n.admonition,{title:"Beta",type:"warning",children:(0,i.jsx)(n.p,{children:"The following feature is not yet stable."})}),"\n",(0,i.jsxs)(n.p,{children:["Custom functions can be made smoother to develop or more robust to changes by using the ",(0,i.jsx)(n.a,{href:"/docs/reference/metagen",children:"metagen"})," to generate code for them. By using the generated types along with static analysis tools in your workflow, this allows you to avoid many cases of drift between your custom functions and your typegraph. Not to mention improving the development experience of writing custom functions. The code generated for Python and Rust targets also includes the serialization boilerplate and utilities that you'd need for those to even get started in those languages."]}),"\n",(0,i.jsxs)(n.p,{children:["The metagen library is availaible within the ",(0,i.jsx)(n.a,{href:"/docs/reference/meta-cli",children:"meta CLI"})," or the ",(0,i.jsx)(n.a,{href:"/docs/reference/typegraph#sdks",children:"typegraph SDK"}),". In the following example we'll use the CLI to generate typescript code for a simple typegraph."]}),"\n",(0,i.jsx)(a.A,{typegraph:"metagen-deno",typescript:t(86099),python:t(14037),query:t(29711)}),"\n",(0,i.jsxs)(n.p,{children:["We'll need to configure metagen through the ",(0,i.jsx)(n.code,{children:"metatype.yaml"})," file. We add a new target to the metagen section that does what we need."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"metagen:\n  targets:\n    # named targets to configure a bunch of generators together\n    metagen_deno:\n      - generator: fdk_ts # generator to use\n        # path to generate to\n        path: ./metagen/ts/\n        # point to the typegraph location\n        # or name of typegraph on a typegate somehwere\n        typegraph_path: ./metagen-deno.ts\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We can configure multiple target in our config file. Each target can have mutiple generator configurations. Metagen currently ",(0,i.jsx)(n.a,{href:"/docs/reference/metagen",children:"implements"})," for the Typescript, Python and Rust targets."]}),"\n",(0,i.jsx)(n.p,{children:"We can then invoke the target using the following command:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"meta gen metagen_deno\n"})}),"\n",(0,i.jsx)(n.p,{children:"This results in the following files."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"\u276f lsd --tree metagen\n\uf115 metagen\n\u2514\u2500\u2500 \ue628 ts\n    \u2514\u2500\u2500 \ue628 fdk.ts\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Within ",(0,i.jsx)(n.code,{children:"fdk.ts"})," and the types and helpers, all the types from your typegraph should be there. Something like:"]}),"\n",(0,i.jsxs)(o,{children:[(0,i.jsx)("summary",{children:"Code generation sample. Collapsed for aesthetic reasons."}),(0,i.jsx)(a.A,{typescript:t(96280),disablePlayground:!0})]}),"\n",(0,i.jsxs)(n.p,{children:["Note, this also include typescript function types for specific typegraph functions. By default, the ",(0,i.jsx)(n.code,{children:"fdk_ts"})," generator will only include stub function types for those defined on the ",(0,i.jsx)(n.code,{children:"DenoRuntime"})," but this is ",(0,i.jsx)(n.a,{href:"/docs/reference/metagen#fdk_ts",children:"configurable"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["We can then use these types in the following manner. Add the following snippet into ",(0,i.jsx)(n.code,{children:"metagen/ts/remix.ts"}),"."]}),"\n",(0,i.jsx)(a.A,{typescript:t(13246),disablePlayground:!0}),"\n",(0,i.jsx)(n.p,{children:"Ofcourse, we'll need to include both our implementation and the generated code when defining our typegraph functions."})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},90939:e=>{var n={kind:"Document",definitions:[{kind:"OperationDefinition",operation:"query",variableDefinitions:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"ctx"},arguments:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"parent"},arguments:[],directives:[]},{kind:"Field",name:{kind:"Name",value:"context"},arguments:[],directives:[]},{kind:"Field",name:{kind:"Name",value:"effect"},arguments:[],directives:[]},{kind:"Field",name:{kind:"Name",value:"meta"},arguments:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"url"},arguments:[],directives:[]},{kind:"Field",name:{kind:"Name",value:"token"},arguments:[],directives:[]}]}},{kind:"Field",name:{kind:"Name",value:"secrets"},arguments:[],directives:[]},{kind:"Field",name:{kind:"Name",value:"headers"},arguments:[],directives:[]}]}}]}}],loc:{start:0,end:119}};n.loc.source={body:"query {\n  ctx {\n    parent\n    context\n    effect\n    meta {\n      url\n      token\n    }\n    secrets\n    headers\n  }\n}\n",name:"GraphQL request",locationOffset:{line:1,column:1}};function t(e,n){if("FragmentSpread"===e.kind)n.add(e.name.value);else if("VariableDefinition"===e.kind){var i=e.type;"NamedType"===i.kind&&n.add(i.name.value)}e.selectionSet&&e.selectionSet.selections.forEach((function(e){t(e,n)})),e.variableDefinitions&&e.variableDefinitions.forEach((function(e){t(e,n)})),e.definitions&&e.definitions.forEach((function(e){t(e,n)}))}var i={};n.definitions.forEach((function(e){if(e.name){var n=new Set;t(e,n),i[e.name.value]=n}})),e.exports=n},30360:e=>{var n={kind:"Document",definitions:[{kind:"OperationDefinition",operation:"mutation",name:{kind:"Name",value:"createIdea"},variableDefinitions:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"createIdea"},arguments:[{kind:"Argument",name:{kind:"Name",value:"data"},value:{kind:"ObjectValue",fields:[{kind:"ObjectField",name:{kind:"Name",value:"id"},value:{kind:"StringValue",value:"c0ebb212-c94e-4fa5-a6ed-ae910d6cd9f5",block:!1}},{kind:"ObjectField",name:{kind:"Name",value:"name"},value:{kind:"StringValue",value:"PATENT #12343",block:!1}},{kind:"ObjectField",name:{kind:"Name",value:"authorEmail"},value:{kind:"StringValue",value:"corp@abc.xyz",block:!1}},{kind:"ObjectField",name:{kind:"Name",value:"desc"},value:{kind:"StringValue",value:"Well, you can't use it so why do you care?",block:!1}}]}}],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"id"},arguments:[],directives:[]},{kind:"Field",name:{kind:"Name",value:"authorEmail"},arguments:[],directives:[]}]}}]}},{kind:"OperationDefinition",operation:"mutation",name:{kind:"Name",value:"createVote"},variableDefinitions:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"createVote"},arguments:[{kind:"Argument",name:{kind:"Name",value:"authorEmail"},value:{kind:"StringValue",value:"corp@abc.xyz",block:!1}},{kind:"Argument",name:{kind:"Name",value:"ideaId"},value:{kind:"StringValue",value:"c0ebb212-c94e-4fa5-a6ed-ae910d6cd9f5",block:!1}}],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"vote"},arguments:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"id"},arguments:[],directives:[]},{kind:"Field",name:{kind:"Name",value:"authorEmail"},arguments:[],directives:[]}]}}]}}]}}],loc:{start:0,end:488}};n.loc.source={body:'# create idea first\nmutation createIdea {\n  createIdea(\n    data: {\n      id: "c0ebb212-c94e-4fa5-a6ed-ae910d6cd9f5"\n      name: "PATENT #12343"\n      authorEmail: "corp@abc.xyz"\n      desc: "Well, you can\'t use it so why do you care?"\n    }\n  ) {\n    id\n    authorEmail\n  }\n}\n\n# now try to vote using same email\nmutation createVote {\n  createVote(\n    authorEmail: "corp@abc.xyz"\n    ideaId: "c0ebb212-c94e-4fa5-a6ed-ae910d6cd9f5"\n  ) {\n    vote {\n      id\n      authorEmail\n    }\n  }\n}\n',name:"GraphQL request",locationOffset:{line:1,column:1}};function t(e,n){if("FragmentSpread"===e.kind)n.add(e.name.value);else if("VariableDefinition"===e.kind){var i=e.type;"NamedType"===i.kind&&n.add(i.name.value)}e.selectionSet&&e.selectionSet.selections.forEach((function(e){t(e,n)})),e.variableDefinitions&&e.variableDefinitions.forEach((function(e){t(e,n)})),e.definitions&&e.definitions.forEach((function(e){t(e,n)}))}var i={};function r(e,n){for(var t=0;t<e.definitions.length;t++){var i=e.definitions[t];if(i.name&&i.name.value==n)return i}}function a(e,n){var t={kind:e.kind,definitions:[r(e,n)]};e.hasOwnProperty("loc")&&(t.loc=e.loc);var a=i[n]||new Set,o=new Set,s=new Set;for(a.forEach((function(e){s.add(e)}));s.size>0;){var l=s;s=new Set,l.forEach((function(e){o.has(e)||(o.add(e),(i[e]||new Set).forEach((function(e){s.add(e)})))}))}return o.forEach((function(n){var i=r(e,n);i&&t.definitions.push(i)})),t}n.definitions.forEach((function(e){if(e.name){var n=new Set;t(e,n),i[e.name.value]=n}})),e.exports=n,e.exports.createIdea=a(n,"createIdea"),e.exports.createVote=a(n,"createVote")},34348:e=>{var n={kind:"Document",definitions:[{kind:"OperationDefinition",operation:"query",variableDefinitions:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"fib"},arguments:[{kind:"Argument",name:{kind:"Name",value:"size"},value:{kind:"IntValue",value:"50"}}],directives:[]},{kind:"Field",name:{kind:"Name",value:"random"},arguments:[],directives:[]},{kind:"Field",name:{kind:"Name",value:"randomItem"},arguments:[{kind:"Argument",name:{kind:"Name",value:"items"},value:{kind:"ListValue",values:[{kind:"StringValue",value:"ice",block:!1},{kind:"StringValue",value:"advice",block:!1},{kind:"StringValue",value:"gold",block:!1},{kind:"StringValue",value:"flowers",block:!1},{kind:"StringValue",value:"dirt",block:!1}]}}],directives:[]}]}}],loc:{start:0,end:95}};n.loc.source={body:'{\n  fib(size: 50)\n  random\n  randomItem(items: ["ice", "advice", "gold", "flowers", "dirt"])\n}\n',name:"GraphQL request",locationOffset:{line:1,column:1}};function t(e,n){if("FragmentSpread"===e.kind)n.add(e.name.value);else if("VariableDefinition"===e.kind){var i=e.type;"NamedType"===i.kind&&n.add(i.name.value)}e.selectionSet&&e.selectionSet.selections.forEach((function(e){t(e,n)})),e.variableDefinitions&&e.variableDefinitions.forEach((function(e){t(e,n)})),e.definitions&&e.definitions.forEach((function(e){t(e,n)}))}var i={};n.definitions.forEach((function(e){if(e.name){var n=new Set;t(e,n),i[e.name.value]=n}})),e.exports=n},29711:e=>{var n={kind:"Document",definitions:[{kind:"OperationDefinition",operation:"query",variableDefinitions:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"remix"},arguments:[{kind:"Argument",name:{kind:"Name",value:"title"},value:{kind:"StringValue",value:"Lovefool",block:!1}},{kind:"Argument",name:{kind:"Name",value:"artist"},value:{kind:"StringValue",value:"The Cardigans",block:!1}},{kind:"Argument",name:{kind:"Name",value:"releaseTime"},value:{kind:"StringValue",value:"1996-06-29T10:30:40.340Z",block:!1}},{kind:"Argument",name:{kind:"Name",value:"mp3Url"},value:{kind:"StringValue",value:"https://mus.ic/lovefool.mp3",block:!1}}],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"title"},arguments:[],directives:[]},{kind:"Field",name:{kind:"Name",value:"artist"},arguments:[],directives:[]},{kind:"Field",name:{kind:"Name",value:"releaseTime"},arguments:[],directives:[]},{kind:"Field",name:{kind:"Name",value:"mp3Url"},arguments:[],directives:[]}]}}]}}],loc:{start:0,end:213}};n.loc.source={body:'query {\n  remix(\n    title: "Lovefool"\n    artist: "The Cardigans"\n    releaseTime: "1996-06-29T10:30:40.340Z"\n    mp3Url: "https://mus.ic/lovefool.mp3"\n  ) {\n    title\n    artist\n    releaseTime\n    mp3Url\n  }\n}\n',name:"GraphQL request",locationOffset:{line:1,column:1}};function t(e,n){if("FragmentSpread"===e.kind)n.add(e.name.value);else if("VariableDefinition"===e.kind){var i=e.type;"NamedType"===i.kind&&n.add(i.name.value)}e.selectionSet&&e.selectionSet.selections.forEach((function(e){t(e,n)})),e.variableDefinitions&&e.variableDefinitions.forEach((function(e){t(e,n)})),e.definitions&&e.definitions.forEach((function(e){t(e,n)}))}var i={};n.definitions.forEach((function(e){if(e.name){var n=new Set;t(e,n),i[e.name.value]=n}})),e.exports=n},58379:e=>{e.exports={content:'g.expose(\n  Policy.public(),\n  ctx=deno.func(\n    t.struct({}),\n    t.struct(\n      {\n        # the effect under which the function was run\n        "effect": t.enum(["create", "read", "update", "delete"]),\n        "meta": t.struct(\n          {\n            # url to host typegraph\n            # can be used to talk to host typegraph from within\n            # function\n            "url": t.string(),\n            # token for accessing host typegraph\n            "token": t.string(),\n          }\n        ),\n        # http headers\n        "headers": t.list(t.list(t.string())),\n        # typegraph secrets\n        "secrets": t.list(t.list(t.string())),\n        # FIXME: explanation\n        "parent": t.string(),\n        "context": t.string(),\n      }\n    ),\n    # modeling arbitrary associative arrays in\n    # graphql is difficult so we return a listified format.\n    # Follow the link for alternative solutions\n    # https://github.com/graphql/graphql-spec/issues/101#issuecomment-170170967\n    code="""(_, ctx) => ({\n    ...ctx,\n    parent: JSON.stringify(ctx.parent),\n    context: JSON.stringify(ctx.context),\n    headers: Object.entries(ctx.headers),\n    secrets: Object.entries(ctx.secrets),\n    })""",\n  ),\n)',path:"../examples/typegraphs/func-ctx.py"}},46165:e=>{e.exports={content:'g.expose(\n  {\n    ctx: deno.func(\n      t.struct({}),\n      t.struct({\n        // the effect under which the function was run\n        effect: t.enum_(["create", "read", "update", "delete"]),\n        meta: t.struct({\n          // url to host typegraph\n          // can be used to talk to host typegraph from within\n          // function\n          url: t.string(), // token for accessing host typegraph\n          token: t.string(),\n        }),\n\n        // http headers\n        headers: t.list(t.list(t.string())),\n        // typegraph secrets\n        secrets: t.list(t.list(t.string())),\n\n        // FIXME: explanation\n        parent: t.string(),\n        context: t.string(),\n      }),\n      {\n        // modeling arbitrary associative arrays in\n        // graphql is difficult so we return a listified format.\n        // Follow the link for alternative solutions\n        // https://github.com/graphql/graphql-spec/issues/101#issuecomment-170170967\n        code: (_: any, ctx: any) => ({\n          ...ctx,\n          parent: JSON.stringify(ctx.parent),\n          context: JSON.stringify(ctx.context),\n          headers: Object.entries(ctx.headers),\n          secrets: Object.entries(ctx.secrets),\n        }),\n      },\n    ),\n  },\n  Policy.public(),\n);',path:"../examples/typegraphs/func-ctx.ts"}},63014:e=>{e.exports={content:'deno = DenoRuntime()\ndb = PrismaRuntime("db", "POSTGRES")\nidea = t.struct(\n  {\n    "id": t.uuid(as_id=True, config={"auto": True}),\n    "name": t.string(),\n    "desc": t.string().optional(),\n    "authorEmail": t.email(),\n    "votes": t.list(g.ref("vote")),\n  },\n  name="idea",\n)\nvote = t.struct(\n  {\n    "id": t.uuid(as_id=True, config={"auto": True}),\n    "authorEmail": t.email(),\n    "idea": g.ref("idea"),\n  },\n  name="vote",\n)\n# Policy.internal means only custom functions\n# can access these root functions\ng.expose(\n  Policy.internal(),\n  i_get_idea=db.find_unique(idea),\n  i_create_vote=db.create(vote),\n)\ng.expose(\n  Policy.public(),\n  createIdea=db.create(idea),\n  createVote=deno.import_(\n    t.struct({"ideaId": t.uuid(), "authorEmail": t.email()}).rename(\n      "CreateVoteInput"\n    ),\n    t.struct(\n      {\n        "voteId": t.uuid(),\n        # using `reduce` we improve the API allowing\n        # create calls to get the newly created object\n        # without having to send this data from the\n        # custom funciton\n        "vote": db.find_unique(vote).reduce(\n          {\n            "where": {\n              "id": g.inherit().from_parent("voteId"),\n            },\n          }\n        ),\n      }\n    ).rename("CreateVoteOutput"),\n    module="scripts/createVote.ts",\n    name="handle",  # name the exported function to run\n    effect=fx.create(),\n  ),\n)',path:"../examples/typegraphs/func-gql.py"}},95856:e=>{e.exports={content:'const deno = new DenoRuntime();\nconst db = new PrismaRuntime("db", "POSTGRES");\n\nconst idea = t.struct(\n  {\n    id: t.uuid({ asId: true, config: { auto: true } }),\n    name: t.string(),\n    desc: t.string().optional(),\n    authorEmail: t.email(),\n    votes: t.list(g.ref("vote")),\n  },\n  { name: "idea" },\n);\nconst vote = t.struct(\n  {\n    id: t.uuid({ asId: true, config: { auto: true } }),\n    authorEmail: t.email(),\n    idea: g.ref("idea"),\n  },\n  { name: "vote" },\n);\n\n// Policy.internal means only custom functions\n// can access these root functions\ng.expose(\n  {\n    i_get_idea: db.findUnique(idea),\n    i_create_vote: db.create(vote),\n  },\n  Policy.internal(),\n);\n\ng.expose(\n  {\n    createIdea: db.create(idea),\n    createVote: deno.import(\n      t\n        .struct({ ideaId: t.uuid(), authorEmail: t.email() })\n        .rename("CreateVoteInput"),\n      t\n        .struct({\n          voteId: t.uuid(),\n          // using `reduce` we improve the API allowing\n          // create calls to get the newly created object\n          // without having to send this data from the\n          // custom funciton\n          vote: db.findUnique(vote).reduce({\n            where: {\n              id: g.inherit().fromParent("voteId"),\n            },\n          }),\n        })\n        .rename("CreateVoteOutput"),\n      {\n        module: "scripts/createVote.ts",\n        name: "handle", // name the exported function to run\n        effect: fx.create(),\n      },\n    ),\n  },\n  Policy.public(),\n);',path:"../examples/typegraphs/func-gql.ts"}},32535:e=>{e.exports={content:'from typegraph.runtimes.deno import DenoRuntime\n\n\n@typegraph(\n)\ndef math(g: Graph):\n  public = Policy.public()\n\n  # we need a runtime to run the functions on\n  deno = DenoRuntime()\n\n  # we can provide the function code inline\n  random_item_fn = "({ items }) => items[Math.floor(Math.random() * items.length)]"\n\n  # or we can point to a local file that\'s accessible to the meta-cli\n  fib_module = "scripts/fib.ts"\n\n  # the policy implementation is based on functions as well\n  restrict_referer = deno.policy(\n    "restrict_referer_policy",\n    \'(_, context) => context.headers.referer && ["localhost", "metatype.dev"].includes(new URL(context.headers.referer).hostname) ? "ALLOW" : "DENY"\',\n  )\n\n  g.expose(\n    public,\n    # all functions have inputs and outputs\n    fib=deno.import_(\n      t.struct({"size": t.integer()}),\n      t.list(t.float()),\n      module=fib_module,\n      name="default",  # name the exported function to run\n    ).with_policy(restrict_referer),\n    randomItem=deno.func(\n      t.struct({"items": t.list(t.string())}),\n      t.string(),\n      code=random_item_fn,\n    ),\n    random=deno.func(\n      t.struct(),\n      t.float(),\n      code="() => Math.random()",  # more inline code\n    ),\n  )',path:"../examples/typegraphs/math.py"}},41929:e=>{e.exports={content:'import { DenoRuntime } from "@typegraph/sdk/runtimes/deno";\n\nawait typegraph(\n  {\n    name: "math",\n  },\n  (g) => {\n    const pub = Policy.public();\n\n    // we need a runtime to run the functions on\n    const deno = new DenoRuntime();\n\n    // we can provide the function code inline\n    const random_item_fn =\n      "({ items }) => items[Math.floor(Math.random() * items.length)]";\n\n    // the policy implementation is based on functions itself\n    const restrict_referer = deno.policy(\n      "restrict_referer_policy",\n      \'(_, context) => context.headers.referer && ["localhost", "metatype.dev"].includes(new URL(context.headers.referer).hostname) ? "ALLOW" : "DENY"\',\n    );\n\n    // or we can point to a local file that\'s accessible to the meta-cli\n    const fib_module = "scripts/fib.ts";\n\n    g.expose(\n      {\n        // all functions have inputs and outputs\n        fib: deno\n          .import(t.struct({ size: t.integer() }), t.list(t.float()), {\n            module: fib_module,\n            name: "default", // name the exported function to run\n          })\n          .withPolicy(restrict_referer),\n        randomItem: deno.func(\n          t.struct({ items: t.list(t.string()) }),\n          t.string(),\n          { code: random_item_fn },\n        ),\n        random: deno.func(\n          t.struct({}),\n          t.float(),\n          { code: "() => Math.random()" }, // more inline code\n        ),\n      },\n      pub,\n    );\n  },\n);',path:"../examples/typegraphs/math.ts"}},14037:e=>{e.exports={content:'@typegraph(\n)\ndef metagen_deno(g: Graph):\n  idv3 = t.struct(\n    {\n      "title": t.string(),\n      "artist": t.string(),\n      "releaseTime": t.datetime(),\n      "mp3Url": t.uri(),\n      # explicit type names help when generating code\n    }\n  ).rename("idv3")\n  deno = DenoRuntime()\n\n  g.expose(\n    Policy.public(),\n    remix=deno.import_(\n      idv3,\n      idv3,\n      module="./metagen/ts/remix.ts",\n      deps=["./metagen/ts/fdk.ts"],\n      name="remix_track",\n    ).rename("remix_track"),  # explicit names help\n  )',path:"../examples/typegraphs/metagen-deno.py"}},86099:e=>{e.exports={content:'await typegraph(\n  {\n    name: "metagen-deno",\n  },\n  (g) => {\n    const idv3 = t\n      .struct({\n        title: t.string(),\n        artist: t.string(),\n        releaseTime: t.datetime(),\n        mp3Url: t.uri(),\n        // explicit type names help when generating code\n      })\n      .rename("idv3");\n\n    const deno = new DenoRuntime();\n\n    g.expose(\n      {\n        remix: deno\n          .import(idv3, idv3, {\n            module: "./metagen/ts/remix.ts",\n            deps: ["./metagen/ts/fdk.ts"],\n            name: "remix_track",\n          })\n          .rename("remix_track"), // explicit names help\n      },\n      Policy.public(),\n    );\n  },\n);',path:"../examples/typegraphs/metagen-deno.ts"}},96280:e=>{e.exports={content:'// This file was @generated by metagen and is intended\n// to be generated again on subsequent metagen runs.\n\nexport type Ctx = {\n  parent?: Record<string, unknown>;\n  /**\n   * Request context extracted by auth extractors.\n   */\n  context?: Record<string, unknown>;\n  secrets: Record<string, string>;\n  effect: "create" | "update" | "delete" | "read" | undefined | null;\n  meta: {\n    url: string;\n    token: string;\n  };\n  headers: Record<string, string>;\n};\n\n/**\n * Access features on your typegraph deployment.\n */\nexport type Deployment = {\n  gql: (query: readonly string[], ...args: unknown[]) => {\n    run: (\n      variables: Record<string, unknown>,\n    ) => Promise<Record<string, unknown>>;\n  };\n};\n\nexport type Handler<In, Out> = (\n  input: In,\n  ctx: Ctx,\n  tg: Deployment,\n) => Out | Promise<Out>;\n\nfunction _selectionToNodeSet(\n  selection: Selection,\n  metas: [string, () => NodeMeta][],\n  parentPath: string,\n): SelectNode<unknown>[] {\n  const out = [] as SelectNode[];\n  const selectAll = selection._ == "selectAll";\n  // set of the user specified nodes to do sanity\n  // check at the end\n  const foundNodes = new Set(Object.keys(selection));\n\n  for (const [nodeName, metaFn] of metas) {\n    foundNodes.delete(nodeName);\n\n    const nodeSelection = selection[nodeName];\n    if (!nodeSelection && !selectAll) {\n      // this node was not selected\n      continue;\n    }\n\n    const { argumentTypes, subNodes, variants, inputFiles } = metaFn();\n\n    const nodeInstances = nodeSelection instanceof Alias\n      ? nodeSelection.aliases()\n      : { [nodeName]: nodeSelection };\n\n    for (\n      const [instanceName, instanceSelection] of Object.entries(\n        nodeInstances,\n      )\n    ) {\n      if (!instanceSelection && !selectAll) {\n        continue;\n      }\n      if (instanceSelection instanceof Alias) {\n        throw new Error(\n          `nested Alias discovered at ${parentPath}.${instanceName}`,\n        );\n      }\n      const node: SelectNode = { instanceName, nodeName, files: inputFiles };\n\n      if (argumentTypes) {\n        // make sure the arg is of the expected form\n        let arg = instanceSelection;\n        if (Array.isArray(arg)) {\n          arg = arg[0];\n        }\n        // TODO: consider bringing in Zod (after hoisting impl into common lib)\n        if (typeof arg != "object" || arg === null) {\n          throw new Error(\n            `node at ${parentPath}.${instanceName} is a node ` +\n              `that requires arguments object but detected argument ` +\n              `is typeof ${typeof arg}`,\n          );\n        }\n\n        const expectedArguments = new Map(Object.entries(argumentTypes));\n        node.args = {};\n        for (const [key, value] of Object.entries(arg)) {\n          const typeName = expectedArguments.get(key);\n          // TODO: consider logging a warning if `_` is detected incase user passes\n          // Selection as arg\n          if (!typeName) {\n            throw new Error(\n              `unexpected argument ${key} at ${parentPath}.${instanceName}`,\n            );\n          }\n          expectedArguments.delete(key);\n          node.args[key] = { typeName, value };\n        }\n      }\n\n      if (subNodes || variants) {\n        // sanity check selection object\n        let subSelections = instanceSelection;\n        if (argumentTypes) {\n          if (!Array.isArray(subSelections)) {\n            throw new Error(\n              `node at ${parentPath}.${instanceName} ` +\n                `is a composite that takes an argument ` +\n                `but selection is typeof ${typeof subSelections}`,\n            );\n          }\n          subSelections = subSelections[1];\n        } else if (Array.isArray(subSelections)) {\n          throw new Error(\n            `node at ${parentPath}.${instanceName} ` +\n              `is a composite that takes no arguments ` +\n              `but selection is typeof ${typeof subSelections}`,\n          );\n        }\n        if (subSelections == undefined) {\n          subSelections = {\n            _: selection._,\n          };\n        }\n        if (typeof subSelections != "object") {\n          throw new Error(\n            `node at ${parentPath}.${nodeName} ` +\n              `is a no argument composite but first element of ` +\n              `selection is typeof ${typeof nodeSelection}`,\n          );\n        }\n\n        if (subNodes) {\n          if (variants) {\n            throw new Error(\n              "unreachable: union/either NodeMetas can\'t have subnodes",\n            );\n          }\n\n          // skip non explicit composite selection when using selectAll\n          if (subSelections?._ === "selectAll" && !instanceSelection) {\n            continue;\n          }\n\n          node.subNodes = _selectionToNodeSet(\n            // assume it\'s a Selection. If it\'s an argument\n            // object, mismatch between the node desc should hopefully\n            // catch it\n            subSelections as Selection,\n            subNodes,\n            `${parentPath}.${instanceName}`,\n          );\n        } else {\n          const unionSelections = {} as Record<string, SelectNode[]>;\n          const foundVariants = new Set([...Object.keys(subSelections)]);\n          for (const [variantTy, variant_meta_fn] of variants!) {\n            const variant_meta = variant_meta_fn();\n            // this union member is a scalar\n            if (!variant_meta.subNodes) {\n              continue;\n            }\n            foundVariants.delete(variantTy);\n            const variant_select = subSelections[variantTy];\n            const nodes = variant_select\n              ? _selectionToNodeSet(\n                variant_select as Selection,\n                variant_meta.subNodes,\n                `${parentPath}.${instanceName}.variant(${variantTy})`,\n              )\n              : [];\n            nodes.push({\n              nodeName: "__typename",\n              instanceName: "__typename",\n            });\n            unionSelections[variantTy] = nodes;\n          }\n          if (foundVariants.size > 0) {\n            throw new Error(\n              `node at ${parentPath}.${instanceName} ` +\n                "has none of the variants called " +\n                [...foundVariants.keys()],\n            );\n          }\n          node.subNodes = unionSelections;\n        }\n      }\n\n      out.push(node);\n    }\n  }\n  foundNodes.delete("_");\n  if (foundNodes.size > 0) {\n    throw new Error(\n      `unexpected nodes found in selection set at ${parentPath}: ${[\n        ...foundNodes,\n      ]}`,\n    );\n  }\n  return out;\n}\n\n/* Query node types section */\n\ntype SubNodes = undefined | SelectNode[] | Record<string, SelectNode[]>;\n\ntype SelectNode<_Out = unknown> = {\n  nodeName: string;\n  instanceName: string;\n  args?: NodeArgs;\n  subNodes?: SubNodes;\n  files?: TypePath[];\n};\n\nexport class QueryNode<Out> {\n  #inner: SelectNode<Out>;\n  constructor(inner: SelectNode<Out>) {\n    this.#inner = inner;\n  }\n\n  inner() {\n    return this.#inner;\n  }\n}\n\nexport class MutationNode<Out> {\n  #inner: SelectNode<Out>;\n  constructor(inner: SelectNode<Out>) {\n    this.#inner = inner;\n  }\n\n  inner() {\n    return this.#inner;\n  }\n}\n\ntype SelectNodeOut<T> = T extends QueryNode<infer O> | MutationNode<infer O> ? O\n  : never;\ntype QueryOut<T> = T extends\n  Record<string, QueryNode<unknown> | MutationNode<unknown>> ? {\n    [K in keyof T]: SelectNodeOut<T[K]>;\n  }\n  : T extends QueryNode<unknown> | MutationNode<unknown> ? SelectNodeOut<T>\n  : never;\n\ntype TypePath = ("?" | "[]" | `.${string}`)[];\ntype ValuePath = ("" | `[${number}]` | `.${string}`)[];\n\nclass FileExtractor {\n  #path: TypePath = [];\n  #currentPath: ValuePath = [];\n  #files: Map<string, File> = new Map();\n\n  static extractFrom(key: string, object: unknown, paths: TypePath[]) {\n    const extractor = new FileExtractor();\n    if (!object || typeof object !== "object") {\n      throw new Error("expected object");\n    }\n    for (const path of paths) {\n      if (path[0] && path[0].startsWith("." + key)) {\n        extractor.#currentPath = [];\n        extractor.#path = path;\n        extractor.#extractFromValue(object);\n      }\n    }\n    return extractor.#files;\n  }\n\n  #extractFromValue(value: unknown) {\n    const nextSegment = this.#path[this.#currentPath.length];\n    if (nextSegment === "?") {\n      if (value === null || value === undefined) {\n        return;\n      }\n      this.#currentPath.push("");\n      this.#extractFromValue(value);\n      this.#currentPath.pop();\n      return;\n    }\n\n    if (nextSegment === "[]") {\n      if (!Array.isArray(value)) {\n        throw new Error(`Expected array at ${this.#formatPath()}`);\n      }\n      for (let i = 0; i < value.length; i++) {\n        this.#currentPath.push(`[${i}]`);\n        this.#extractFromArray(value, i);\n        this.#currentPath.pop();\n      }\n      return;\n    }\n\n    if (nextSegment.startsWith(".")) {\n      if (typeof value !== "object" || value === null) {\n        throw new Error(`Expected non-null object at ${this.#formatPath()}`);\n      }\n      this.#currentPath.push(nextSegment);\n      this.#extractFromObject(\n        value as Record<string, unknown>,\n        nextSegment.slice(1),\n      );\n      this.#currentPath.pop();\n      return;\n    }\n  }\n\n  #extractFromObject(parent: Record<string, unknown>, key: string) {\n    const value = parent[key];\n    if (this.#currentPath.length == this.#path.length) {\n      if (value instanceof File) {\n        this.#files.set(this.#formatPath(), value);\n        parent[key] = null;\n        return;\n      }\n      throw new Error(`Expected File at ${this.#formatPath()}`);\n    }\n\n    this.#extractFromValue(value);\n  }\n\n  #extractFromArray(parent: unknown[], idx: number) {\n    const value = parent[idx];\n    if (this.#currentPath.length == this.#path.length) {\n      if (value instanceof File) {\n        this.#files.set(this.#formatPath(), value);\n        parent[idx] = null;\n        return;\n      }\n      throw new Error(`Expected File at ${this.#formatPath()}`);\n    }\n\n    this.#extractFromValue(value);\n  }\n\n  #formatPath() {\n    return this.#currentPath\n      .map((seg) => {\n        if (seg.startsWith("[")) {\n          return `.${seg.slice(1, -1)}`;\n        }\n        return seg;\n      })\n      .join("");\n  }\n}\n\ntype NodeMeta = {\n  subNodes?: [string, () => NodeMeta][];\n  variants?: [string, () => NodeMeta][];\n  argumentTypes?: { [name: string]: string };\n  inputFiles?: TypePath[];\n};\n\n/* Selection types section */\n\ntype SelectionFlags = "selectAll";\n\ntype Selection = {\n  _?: SelectionFlags;\n  [key: string]:\n    | SelectionFlags\n    | ScalarSelectNoArgs\n    | ScalarSelectArgs<Record<string, unknown>>\n    | CompositeSelectNoArgs<Selection | undefined>\n    | CompositeSelectArgs<Record<string, unknown>, Selection>\n    | Selection;\n};\n\ntype ScalarSelectNoArgs = boolean | Alias<true> | null | undefined;\n\ntype ScalarSelectArgs<ArgT extends Record<string, unknown>> =\n  | ArgT\n  | PlaceholderArgs<ArgT>\n  | Alias<ArgT | PlaceholderArgs<ArgT>>\n  | false\n  | null\n  | undefined;\n\ntype CompositeSelectNoArgs<SelectionT> =\n  | SelectionT\n  | Alias<SelectionT>\n  | false\n  | null\n  | undefined;\n\ntype CompositeSelectArgs<ArgT extends Record<string, unknown>, SelectionT> =\n  | [ArgT | PlaceholderArgs<ArgT>, SelectionT]\n  | Alias<[ArgT | PlaceholderArgs<ArgT>, SelectionT]>\n  | false\n  | undefined\n  | null;\n\n/**\n * Request multiple instances of a single node under different\n * aliases. Look at {@link alias} for a functional way of instantiating\n * this class.\n */\nexport class Alias<T> {\n  #aliases: Record<string, T>;\n  constructor(aliases: Record<string, T>) {\n    this.#aliases = aliases;\n  }\n  aliases() {\n    return this.#aliases;\n  }\n}\n\n/**\n * Request multiple instances of a single node under different\n * aliases.\n */\nexport function alias<T>(aliases: Record<string, T>): Alias<T> {\n  return new Alias(aliases);\n}\n\n/* Argument types section */\n\ntype NodeArgValue = {\n  typeName: string;\n  value: unknown;\n};\n\ntype NodeArgs = {\n  [name: string]: NodeArgValue;\n};\n\n/**\n * This object is passed to closures used for preparing requests\n * ahead of time for {@link PreparedRequest}s. It allows one to\n * get {@link PlaceholderValue}s that can be used in place of node\n * arguments. At request time, the {@link PreparedRequest} then\n * takes an object that adheres to `T` that can then be used\n * to replace the placeholders.\n */\nexport class PreparedArgs<T extends Record<string, unknown>> {\n  get(key: OnlyStringKeys<T>): PlaceholderValue<T[typeof key]> {\n    return new PlaceholderValue(key);\n  }\n}\n\n/**\n * Placeholder values for use by {@link PreparedRequest}\n */\nexport class PlaceholderValue<_T> {\n  #key: string;\n  constructor(key: string) {\n    this.#key = key;\n  }\n\n  key() {\n    return this.#key;\n  }\n}\n\nexport type PlaceholderArgs<T extends Record<string, unknown>> = {\n  [K in keyof T]: PlaceholderValue<T[K]>;\n};\n\n/* GraphQL section */\n\n/**\n * Options to be used for requests performed by {@link GraphQLTransport}.\n */\nexport type GraphQlTransportOptions = Omit<RequestInit, "body"> & {\n  /**\n   * {@link fetch} implementaiton to use. Defaults to the one found in the environment\n   */\n  fetch?: typeof fetch;\n};\n\nfunction convertQueryNodeGql(\n  typeToGqlTypeMap: Record<string, string>,\n  node: SelectNode,\n  variables: Map<string, NodeArgValue>,\n  files: Map<string, File>,\n) {\n  let out = node.nodeName == node.instanceName\n    ? node.nodeName\n    : `${node.instanceName}: ${node.nodeName}`;\n\n  const args = node.args;\n  if (args && Object.keys(args).length > 0) {\n    const argsRow = [];\n\n    for (const [key, val] of Object.entries(args)) {\n      const name = `in${variables.size}`;\n      const obj = { [key]: val.value };\n\n      if (node.files && node.files.length > 0) {\n        const extractedFiles = FileExtractor.extractFrom(key, obj, node.files);\n\n        for (const [path, file] of extractedFiles) {\n          const pathInVariables = path.replace(/^\\.[^\\.\\[]+/, `.${name}`);\n          files.set(pathInVariables, file);\n        }\n      }\n\n      val.value = obj[key];\n      variables.set(name, val);\n      argsRow.push(`${key}: $${name}`);\n    }\n\n    out = `${out} (${argsRow.join(", ")})`;\n  }\n\n  const subNodes = node.subNodes;\n  if (subNodes) {\n    if (Array.isArray(subNodes)) {\n      out = `${out} { ${\n        subNodes\n          .map((node) =>\n            convertQueryNodeGql(typeToGqlTypeMap, node, variables, files)\n          )\n          .join(" ")\n      } }`;\n    } else {\n      out = `${out} { ${\n        Object.entries(subNodes)\n          .map(([variantTy, subNodes]) => {\n            let gqlTy = typeToGqlTypeMap[variantTy];\n            if (!gqlTy) {\n              throw new Error(\n                `unreachable: no graphql type found for variant ${variantTy}`,\n              );\n            }\n            gqlTy = gqlTy.replace(/[!]+$/, "");\n\n            return `... on ${gqlTy} {${\n              subNodes\n                .map((node) =>\n                  convertQueryNodeGql(typeToGqlTypeMap, node, variables, files)\n                )\n                .join(" ")\n            }}`;\n          })\n          .join(" ")\n      } }`;\n    }\n  }\n  return out;\n}\n\nfunction buildGql(\n  typeToGqlTypeMap: Record<string, string>,\n  query: Record<string, SelectNode>,\n  ty: "query" | "mutation",\n  // deno-lint-ignore no-inferrable-types\n  name: string = "",\n) {\n  const variables = new Map<string, NodeArgValue>();\n  const files = new Map<string, File>();\n\n  const rootNodes = Object.entries(query)\n    .map(([key, node]) => {\n      const fixedNode = { ...node, instanceName: key };\n      return convertQueryNodeGql(typeToGqlTypeMap, fixedNode, variables, files);\n    })\n    .join("\\n  ");\n\n  let argsRow = [...variables.entries()]\n    .map(([key, val]) => `$${key}: ${typeToGqlTypeMap[val.typeName]} `)\n    .join(", ");\n  if (argsRow.length > 0) {\n    // graphql doesn\'t like empty parentheses so we only\n    // add them if there are args\n    argsRow = `(${argsRow})`;\n  }\n\n  const doc = `${ty} ${name}${argsRow} {\n  ${rootNodes}\n      } `;\n  return {\n    doc,\n    variables: Object.fromEntries(\n      [...variables.entries()].map(([key, val]) => [key, val.value]),\n    ),\n    files,\n  };\n}\n\nasync function fetchGql(\n  addr: URL,\n  doc: string,\n  variables: Record<string, unknown>,\n  options: GraphQlTransportOptions,\n  files?: Map<string, File>,\n) {\n  let body: FormData | string = JSON.stringify({\n    query: doc,\n    variables,\n  });\n\n  const additionalHeaders: HeadersInit = {};\n\n  if (files && files.size > 0) {\n    const data = new FormData();\n    const fileMap = new Map<File, string[]>();\n    const map: Record<string, string[]> = {};\n\n    for (const [path, file] of files) {\n      const array = fileMap.get(file);\n      const variable = "variables" + path;\n      if (array) {\n        array.push(variable);\n      } else {\n        fileMap.set(file, [variable]);\n      }\n    }\n\n    let index = 0;\n    for (const [file, variables] of fileMap) {\n      const key = index.toString();\n      map[key] = variables;\n      data.set(key, file);\n      index += 1;\n    }\n\n    data.set("operations", body);\n    data.set("map", JSON.stringify(map));\n\n    body = data;\n  } else {\n    additionalHeaders["content-type"] = "application/json";\n  }\n\n  const fetchImpl = options.fetch ?? fetch;\n  const res = await fetchImpl(addr, {\n    ...options,\n    method: "POST",\n    headers: {\n      accept: "application/json",\n      ...additionalHeaders,\n      ...(options.headers ?? {}),\n    },\n    body,\n  });\n\n  if (!res.ok) {\n    const body = await res.text().catch((err) => `error reading body: ${err} `);\n    throw new (Error as ErrorPolyfill)(\n      `graphql request to ${addr} failed with status ${res.status}: ${body} `,\n      {\n        cause: {\n          response: res,\n          body,\n        },\n      },\n    );\n  }\n  if (res.headers.get("content-type") != "application/json") {\n    throw new (Error as ErrorPolyfill)("unexpected content type in response", {\n      cause: {\n        response: res,\n        body: await res.text().catch((err) => `error reading body: ${err} `),\n      },\n    });\n  }\n  return (await res.json()) as { data: unknown; errors?: object[] };\n}\n\n/**\n * Access the typegraph over it\'s exposed GraphQL API.\n */\nexport class GraphQLTransport {\n  constructor(\n    public address: URL,\n    public options: GraphQlTransportOptions,\n    private typeToGqlTypeMap: Record<string, string>,\n  ) {}\n\n  protected async request(\n    doc: string,\n    variables: Record<string, unknown>,\n    options: GraphQlTransportOptions,\n    files?: Map<string, File>,\n  ) {\n    const res = await fetchGql(\n      this.address,\n      doc,\n      variables,\n      { ...this.options, ...options },\n      files,\n    );\n    if ("errors" in res) {\n      throw new (Error as ErrorPolyfill)("graphql errors on response", {\n        cause: res.errors,\n      });\n    }\n    return res.data;\n  }\n\n  /**\n   * Make a query request to the typegraph.\n   */\n  async query<\n    Q extends QueryNode<unknown> | Record<string, QueryNode<unknown>>,\n  >(\n    query: Q,\n    {\n      options,\n      name = "",\n    }: {\n      options?: GraphQlTransportOptions;\n      name?: string;\n    } = {},\n  ): Promise<QueryOut<Q>> {\n    const isNode = query instanceof QueryNode;\n    const { variables, doc } = buildGql(\n      this.typeToGqlTypeMap,\n      isNode ? { value: query.inner() } : Object.fromEntries(\n        Object.entries(query).map(([key, val]) => [\n          key,\n          (val as QueryNode<unknown>).inner(),\n        ]),\n      ),\n      "query",\n      name,\n    );\n    let result = await this.request(doc, variables, options ?? {});\n\n    if (isNode) {\n      result = (result as { value: SelectNodeOut<Q> }).value;\n    }\n\n    return result as QueryOut<Q>;\n  }\n\n  /**\n   * Make a mutation request to the typegraph.\n   */\n  async mutation<\n    Q extends MutationNode<unknown> | Record<string, MutationNode<unknown>>,\n  >(\n    query: Q,\n    {\n      options,\n      name = "",\n    }: {\n      options?: GraphQlTransportOptions;\n      name?: string;\n    } = {},\n  ): Promise<QueryOut<Q>> {\n    const isNode = query instanceof MutationNode;\n    const { variables, doc, files } = buildGql(\n      this.typeToGqlTypeMap,\n      isNode ? { value: query.inner() } : Object.fromEntries(\n        Object.entries(query).map(([key, val]) => [\n          key,\n          (val as MutationNode<unknown>).inner(),\n        ]),\n      ),\n      "mutation",\n      name,\n    );\n    let result = await this.request(doc, variables, options ?? {}, files);\n\n    if (isNode) {\n      result = (result as { value: SelectNodeOut<Q> }).value;\n    }\n\n    return result as QueryOut<Q>;\n  }\n\n  /**\n   * Prepare an ahead of time query {@link PreparedRequest}.\n   */\n  prepareQuery<\n    T extends JsonObject,\n    Q extends QueryNode<unknown> | Record<string, QueryNode<unknown>>,\n  >(\n    fun: (args: PreparedArgs<T>) => Q,\n    { name = "" }: { name?: string } = {},\n  ): PreparedRequest<T, Q> {\n    return new PreparedRequest(\n      (doc, vars, opts) => this.request(doc, vars, opts),\n      this.typeToGqlTypeMap,\n      fun,\n      "query",\n      name,\n    );\n  }\n\n  /**\n   * Prepare an ahead of time mutation {@link PreparedRequest}.\n   */\n  prepareMutation<\n    T extends JsonObject,\n    Q extends MutationNode<unknown> | Record<string, MutationNode<unknown>>,\n  >(\n    fun: (args: PreparedArgs<T>) => Q,\n    { name = "" }: { name?: string } = {},\n  ): PreparedRequest<T, Q> {\n    return new PreparedRequest(\n      (doc, vars, opts) => this.request(doc, vars, opts),\n      this.typeToGqlTypeMap,\n      fun,\n      "mutation",\n      name,\n    );\n  }\n}\n\nexport class HostcallTransport extends GraphQLTransport {\n  constructor(\n    private gqlFn: (\n      doc: string,\n      variables: Record<string, unknown>,\n    ) => Promise<Record<string, unknown>>,\n    options: GraphQlTransportOptions,\n    typeToGqlTypeMap: Record<string, string>,\n  ) {\n    super(\n      new URL("hostcall://this_url_will_never_be_used"),\n      options,\n      typeToGqlTypeMap,\n    );\n  }\n\n  protected async request(\n    doc: string,\n    variables: Record<string, unknown>,\n    _options: GraphQlTransportOptions,\n    files?: Map<string, File>,\n  ) {\n    if (files && files.size > 0) {\n      throw new Error("no support for file upload on HostcallTransport");\n    }\n    const res = await this.gqlFn(doc, variables);\n    if ("errors" in res) {\n      throw new (Error as ErrorPolyfill)("graphql errors on response", {\n        cause: res.errors,\n      });\n    }\n    return res.data;\n  }\n}\n\n/**\n * Prepares the GraphQL string ahead of time and allows re-use\n * avoid the compute and garbage overhead of re-building it for\n * repeat queries.\n */\nexport class PreparedRequest<\n  T extends JsonObject,\n  Q extends\n    | QueryNode<unknown>\n    | MutationNode<unknown>\n    | Record<string, QueryNode<unknown> | MutationNode<unknown>>,\n> {\n  public doc: string;\n  #mappings: Record<string, unknown>;\n  private singleNode: boolean;\n\n  constructor(\n    // private address: URL,\n    // private options: GraphQlTransportOptions,\n    private gqlFn: (\n      doc: string,\n      variables: Record<string, unknown>,\n      opts: GraphQlTransportOptions,\n    ) => Promise<unknown>,\n    typeToGqlTypeMap: Record<string, string>,\n    fun: (args: PreparedArgs<T>) => Q,\n    ty: "query" | "mutation",\n    name: string = "",\n  ) {\n    const args = new PreparedArgs<T>();\n    const dryRunNode = fun(args);\n    const isSingleNode = dryRunNode instanceof QueryNode ||\n      dryRunNode instanceof MutationNode;\n    // FIXME: file support for prepared requets\n    const { doc, variables } = buildGql(\n      typeToGqlTypeMap,\n      isSingleNode ? { value: dryRunNode.inner() } : Object.fromEntries(\n        Object.entries(dryRunNode).map(([key, val]) => [\n          key,\n          (val as MutationNode<unknown>).inner(),\n        ]),\n      ),\n      ty,\n      name,\n    );\n    this.doc = doc;\n    this.#mappings = variables;\n    this.singleNode = isSingleNode;\n  }\n\n  resolveVariables(args: T, mappings: Record<string, unknown>) {\n    const resolvedVariables = {} as Record<string, unknown>;\n    for (const [key, val] of Object.entries(mappings)) {\n      if (val instanceof PlaceholderValue) {\n        resolvedVariables[key] = args[val.key()];\n      } else if (typeof val == "object" && val != null) {\n        this.resolveVariables(args, val as JsonObject);\n      } else {\n        resolvedVariables[key] = val;\n      }\n    }\n    return resolvedVariables;\n  }\n\n  /**\n   * Execute the prepared request.\n   */\n  async perform(args: T, opts?: GraphQlTransportOptions): Promise<QueryOut<Q>> {\n    const resolvedVariables = this.resolveVariables(args, this.#mappings);\n    // console.log(this.doc, {\n    //   resolvedVariables,\n    //   mapping: this.#mappings,\n    // });\n    let result = await this.gqlFn(this.doc, resolvedVariables, {\n      ...opts,\n    });\n    if (this.singleNode) {\n      result = (result as { value: SelectNodeOut<Q> }).value;\n    }\n    return result as QueryOut<Q>;\n  }\n}\n\n/* Util types section */\n\ntype OnlyStringKeys<T extends Record<string, unknown>> = {\n  [K in keyof T]: K extends string ? K : never;\n}[keyof T];\n\ntype JsonLiteral = string | number | boolean | null;\ntype JsonObject = { [key: string]: Json };\ntype JsonArray = Json[];\ntype Json = JsonLiteral | JsonObject | JsonArray;\n\ntype ErrorPolyfill = new (msg: string, payload: unknown) => Error;\n\n/* QueryGraph section */\n\nexport class Transports {\n  /**\n   * Get the {@link GraphQLTransport} for the typegraph.\n   */\n  static graphql(\n    qg: _QueryGraphBase,\n    addr: URL | string,\n    options?: GraphQlTransportOptions,\n  ) {\n    return new GraphQLTransport(\n      new URL(addr),\n      options ?? {},\n      qg.typeNameMapGql,\n    );\n  }\n\n  static hostcall(\n    qg: _QueryGraphBase,\n    tg: Deployment,\n    options?: Pick<GraphQlTransportOptions, "headers">,\n  ) {\n    return new HostcallTransport(\n      (doc, vars) => tg.gql([doc]).run(vars),\n      options ?? {},\n      qg.typeNameMapGql,\n    );\n  }\n}\n\nclass _QueryGraphBase {\n  constructor(public typeNameMapGql: Record<string, string>) {}\n}\n\n// -------------------------------------------------- //\n\nconst nodeMetas = {\n  scalar() {\n    return {};\n  },\n  \n  Idv3(): NodeMeta {\n    return {\n      subNodes: [\n        ["title", nodeMetas.scalar],\n        ["artist", nodeMetas.scalar],\n        ["releaseTime", nodeMetas.scalar],\n        ["mp3Url", nodeMetas.scalar],\n      ],\n    };\n  },\n  RemixTrack(): NodeMeta {\n    return {\n      ...nodeMetas.Idv3(),\n      argumentTypes: {\n        title: "Idv3TitleString",\n        artist: "Idv3TitleString",\n        releaseTime: "Idv3ReleaseTimeStringDatetime",\n        mp3Url: "Idv3Mp3UrlStringUri",\n      },\n    };\n  },\n};\nexport type Idv3TitleString = string;\nexport type Idv3ReleaseTimeStringDatetime = string;\nexport type Idv3Mp3UrlStringUri = string;\nexport type Idv3 = {\n  title: Idv3TitleString;\n  artist: Idv3TitleString;\n  releaseTime: Idv3ReleaseTimeStringDatetime;\n  mp3Url: Idv3Mp3UrlStringUri;\n};\n\nexport type Idv3Selections = {\n  _?: SelectionFlags;\n  title?: ScalarSelectNoArgs;\n  artist?: ScalarSelectNoArgs;\n  releaseTime?: ScalarSelectNoArgs;\n  mp3Url?: ScalarSelectNoArgs;\n};\n\nexport class QueryGraph extends _QueryGraphBase {\n  constructor() {\n    super({\n      "Idv3TitleString": "String!",\n      "Idv3ReleaseTimeStringDatetime": "String!",\n      "Idv3Mp3UrlStringUri": "String!",\n    });\n  }\n    \n  remix(args: Idv3 | PlaceholderArgs<Idv3>, select: Idv3Selections): QueryNode<Idv3> {\n    const inner = _selectionToNodeSet(\n      { "remix": [args, select] },\n      [["remix", nodeMetas.RemixTrack]],\n      "$q",\n    )[0];\n    return new QueryNode(inner);\n  }\n}\n\nexport type RemixTrackHandler = Handler<Idv3, Idv3>;',path:"../examples/typegraphs/metagen/ts/fdk.ts"}},13246:e=>{e.exports={content:'import type { Ctx, Idv3, RemixTrackHandler } from "./fdk.ts";\n\n// the name of the export must match the one referred int he typegraph\nexport const remix_track: RemixTrackHandler = (inp, cx: Ctx) => {\n  const out: Idv3 = {\n    title: `${inp.title} (Remix)`,\n    artist: `${inp.artist} + DJ Cloud`,\n    releaseTime: new Date().toISOString(),\n    // S3Runtime could be used to really provide this service\n    mp3Url: `${cx.meta.url}/get_mp3`,\n  };\n  return out;\n};',path:"../examples/typegraphs/metagen/ts/remix.ts"}},97778:e=>{e.exports={content:"export async function handle(\n  inp: { ideaId: string; authorEmail: string },\n  _ctx: any,\n  // the third paramter contains the gql client object\n  { gql }: any,\n) {\n  // find the referenced idea from the typegraph\n  const { data: { idea } } = await gql`\n    query getIdeaAuthorEmail($ideaId: String!) {\n      idea: i_get_idea(where: { id: $ideaId }) {\n        authorEmail\n      }\n    }\n  `.run({ ideaId: inp.ideaId });\n\n  // we check if the idea exists\n  if (!idea) {\n    throw new Error(`no idea found under id ${inp.ideaId}`);\n  }\n\n  // and that the author and voter aren't the same\n  if (inp.authorEmail == idea.authorEmail) {\n    throw new Error(`author of idea can't vote for idea`);\n  }\n\n  // we persist the vote with another gql call\n  const { data: { vote } } = await gql`\n    mutation insertVote($ideaId: String!, $authorEmail: String!) {\n      vote: i_create_vote(data: { \n          authorEmail: $authorEmail, \n          idea: { connect: { id: $ideaId } } \n      }) {\n        id\n      }\n    }\n  `.run(inp);\n  return { voteId: vote.id };\n}",path:"../examples/typegraphs/scripts/createVote.ts"}},39409:e=>{e.exports={content:"const CACHE = [1, 1];\nconst MAX_CACHE_SIZE = 1000;\n\nexport default function fib({ size }: { size: number }) {\n  if (size > MAX_CACHE_SIZE) {\n    throw new Error(`unsupported size ${size} > ${MAX_CACHE_SIZE}`);\n  }\n  let i = CACHE.length;\n  while (i++ < size) {\n    CACHE.push(CACHE[i - 2] + CACHE[i - 3]);\n  }\n  return CACHE.slice(0, size);\n}",path:"../examples/typegraphs/scripts/fib.ts"}}}]);