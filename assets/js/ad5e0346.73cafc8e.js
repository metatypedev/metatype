(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[11],{49468:(e,n,t)=>{"use strict";t.d(n,{Ay:()=>o});var a=t(86070),i=t(25710);function r(e){const n={a:"a",admonition:"admonition",code:"code",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["Metatype is only supported on macOS and Linux. Windows users should use ",(0,a.jsx)(n.a,{href:"https://learn.microsoft.com/windows/wsl/install",children:"Linux on Windows with WSL"}),"."]})}),"\n",(0,a.jsxs)(n.p,{children:["You can download the binary from the\n",(0,a.jsx)(n.a,{href:"https://github.com/metatypedev/metatype/releases/",children:"releases page"}),", make it\nexecutable and add it to your ",(0,a.jsx)(n.code,{children:"PATH"})," or use the automated method below."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"An installer script is also provided for the CLI in our repository. Curl and install in it with the following one-liner. The installer may ask for your password."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"curl -fsSL https://raw.githubusercontent.com/metatypedev/metatype/main/installer.sh | bash\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["For later use, you can run the following command to upgrade ",(0,a.jsx)(n.code,{children:"Meta CLI"})," to a newer version. If your Meta CLI is up to date, you will get an ",(0,a.jsx)(n.code,{children:"Already up to date!"})," response."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"meta upgrade\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["That's it! You are done installing ",(0,a.jsx)(n.code,{children:"Meta CLI"}),"."]})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(r,{...e})}):r(e)}},58806:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>c,default:()=>m,frontMatter:()=>d,metadata:()=>l,toc:()=>p});var a=t(86070),i=t(25710),r=t(79752),o=t(54006),s=t(50695);t(49468),t(69564);const d={sidebar_position:3},c="Metatype Basics",l={id:"tutorials/metatype-basics/index",title:"Metatype Basics",description:"This page will walk you through a real world API with data storage and authorization.",source:"@site/docs/tutorials/metatype-basics/index.mdx",sourceDirName:"tutorials/metatype-basics",slug:"/tutorials/metatype-basics/",permalink:"/docs/tutorials/metatype-basics/",draft:!1,unlisted:!1,editUrl:"https://github.com/metatypedev/metatype/tree/main/website/docs/tutorials/metatype-basics/index.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docs",previous:{title:"Quick-start",permalink:"/docs/tutorials/quick-start/"},next:{title:"Custom functions",permalink:"/docs/guides/external-functions/"}},u={},p=[{value:"What are you building?",id:"what-are-you-building",level:2},{value:"Setup",id:"setup",level:2},{value:"Create a new project",id:"create-a-new-project",level:3},{value:"Launch typegate",id:"launch-typegate",level:3},{value:"Make sure it&#39;s all working",id:"make-sure-its-all-working",level:3},{value:"Building our Models",id:"building-our-models",level:2},{value:"Exposing our application",id:"exposing-our-application",level:2},{value:"The Prisma Runtime",id:"the-prisma-runtime",level:3},{value:"Policies",id:"policies",level:2},{value:"More Customization for our app",id:"more-customization-for-our-app",level:2},{value:"Preventing Unauthorized Creation of Related Objects",id:"preventing-unauthorized-creation-of-related-objects",level:3},{value:"Restrict Update Operation on Selected Fields",id:"restrict-update-operation-on-selected-fields",level:3},{value:"Creating REST endpoints",id:"creating-rest-endpoints",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"metatype-basics",children:"Metatype Basics"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"This page will walk you through a real world API with data storage and authorization."})}),"\n",(0,a.jsx)(n.admonition,{title:"You will learn",type:"note",children:(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"How to setup your development for metatype projects."}),"\n",(0,a.jsx)(n.li,{children:"How to run the typegate on the docker runtime."}),"\n",(0,a.jsx)(n.li,{children:"How to create/read/update/delete data."}),"\n",(0,a.jsx)(n.li,{children:"How to write custom business logic."}),"\n",(0,a.jsx)(n.li,{children:"How to authenticate requests."}),"\n",(0,a.jsx)(n.li,{children:"How to protect data with policies."}),"\n"]})}),"\n",(0,a.jsx)(n.h2,{id:"what-are-you-building",children:"What are you building?"}),"\n",(0,a.jsxs)(n.p,{children:["For this tutorial, we'll be implementing an API to power a simple feature roadmap/request hybrid as can be seen on ",(0,a.jsx)(n.a,{href:"https://productlane.com/roadmap",children:"Productlane"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Looking through the app we can see that the api should allow:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:'Unauthenticated users to submit new "ideas" or vote on any of those already listed.'}),"\n",(0,a.jsx)(n.li,{children:'Specify or vote on the importance of an "idea" from "medium" to "critical" or even submit text with more description.'}),"\n",(0,a.jsx)(n.li,{children:'Admins will be able to move ideas across buckets like "Backlog", "Planned", "In Progress".'}),"\n"]}),"\n","\n",(0,a.jsx)(n.h2,{id:"setup",children:"Setup"}),"\n",(0,a.jsxs)(n.p,{children:["To setup your Metatype development environment, please follow the installation guide ",(0,a.jsx)(n.a,{href:"/docs/tutorials/quick-start#1-meta-cli",children:"here"})]}),"\n",(0,a.jsx)(n.h3,{id:"create-a-new-project",children:"Create a new project"}),"\n",(0,a.jsx)(n.p,{children:"Metatype projects are composed of modular bundles of types, logic and policies called typegraphs. We author typegraphs using modern programming languages & environments. Python and Typescript are currently available for use. The meta-cli allows us to create a new project based on pre-existing templates."}),"\n",(0,a.jsxs)(r.Ay,{children:[(0,a.jsxs)(o.A,{value:"typescript",children:[(0,a.jsxs)(n.p,{children:["Run one the following commands to create a new project under a new directory titled ",(0,a.jsx)(n.code,{children:"tg_roadmap"}),"."]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# using Node/Bun runtimes\nmeta new --template node tg_roadmap\n#                        ^ project name\n#                   ^  Use `meta new --help` find out more available templates.\n"})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# using Deno\nmeta new --template deno tg_roadmap\n"})}),(0,a.jsxs)(n.p,{children:["When using Typescript, the ",(0,a.jsx)(n.code,{children:"@typegraph/sdk"})," package exposes all the necessary functions and types we'll need to describe our typegraph. The templates already specify it as as a dependency so all we need to do now is run the following command to download it:"]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# using Deno\ndeno cache api/example.ts # cache dependencies\n\n# using Bun\nbun install\n\n# using pnpm\npnpm install\n\n# using npm\nnpm install\n\n# using yarn\nyarn install\n"})})]}),(0,a.jsxs)(o.A,{value:"python",children:[(0,a.jsxs)(n.p,{children:["Run the following command to create a new project under a new directory titled ",(0,a.jsx)(n.code,{children:"tg_roadmap"}),"."]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"meta new --template python tg_roadmap\n#                          ^ project name\n#                   ^  Use `meta new --help` find out more available templates.\n"})}),(0,a.jsxs)(n.p,{children:["When using python, the ",(0,a.jsx)(n.code,{children:"typegraph"})," package exposes all the necessary functions and types we'll need to describe our typegraph. We'll need to run the following command to install it:"]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# virtual env\npython3 -m venv .venv\n# other activate scripts should be available for non bash shells\nsource .venv/bin/activate\n\n# using pip\npip3 install typegraph\n\n# using poetry\n# the template has included `typegraph` in the poetry manifest\npoetry install\n"})})]})]}),"\n",(0,a.jsx)(n.h3,{id:"launch-typegate",children:"Launch typegate"}),"\n",(0,a.jsxs)(n.p,{children:["The typegate is a program that runs and orchestrates our typegraphs. We can run it locally for development purposes. Typegate currently requires the Redis database to function and to make it easy to run both, we'll make use of a linux container runtime for this. The Docker runtime to be specific which has installation guides located ",(0,a.jsx)(n.a,{href:"https://docs.docker.com/get-docker/",children:"here"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["We'll also need the Docker Compose orchestrator which usually comes by default with the ",(0,a.jsx)(n.code,{children:"docker"})," command. Use the following command to check if it is available:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"docker compose version\n# Docker Compose version 2.23.0\n"})}),"\n",(0,a.jsxs)(n.p,{children:["...and if not, the official installation guide can be found ",(0,a.jsx)(n.a,{href:"https://docs.docker.com/compose/install/",children:"here"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["If you have your docker runtime installed and running correctly, you will be able to launch the ",(0,a.jsx)(n.code,{children:"compose.yml"})," file that's bundled in every template. The compose file by default includes the ",(0,a.jsx)(n.code,{children:"postgres"})," and ",(0,a.jsx)(n.code,{children:"mongo"})," databases. You can disable the latter by commenting it out or removing it as we'll not be needing it for this tutorial."]}),"\n",(0,a.jsx)(n.p,{children:"To launch the services, navigate your shell to the project directory and run the following command:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"docker compose up --detach\n#                 ^ detach means it'll run in the background.\n#                   Omit to get the all logs in the current terminal\n"})}),"\n",(0,a.jsx)(n.p,{children:"This should download and start typegate and its dependent services."}),"\n",(0,a.jsx)(n.p,{children:"We can observe their log of typegate or any of the other services with the following command. It has to be run from the same project directory."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"docker compose logs typegate --follow\n#                   ^ Omit service name to look at the combined logs of all services\n"})}),"\n",(0,a.jsx)(n.h3,{id:"make-sure-its-all-working",children:"Make sure it's all working"}),"\n",(0,a.jsx)(n.p,{children:"Run the following to make sure everything's up and running."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"meta doctor\n"})}),"\n",(0,a.jsxs)(n.p,{children:["After running the command, you should get a result similar to then one ",(0,a.jsx)(n.a,{href:"/docs/tutorials/quick-start#4-verify-your-installation",children:"here"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"building-our-models",children:"Building our Models"}),"\n",(0,a.jsxs)(n.p,{children:["We will be using the ",(0,a.jsx)(n.a,{href:"/docs/reference/types",children:"type system"}),' from the typegraph SDK to describe the shape of the data that flows through our application. In this case, we\'ll build our typegraph around types that represent "ideas", "votes" and "buckets".']}),"\n",(0,a.jsxs)(r.Ay,{children:[(0,a.jsxs)(o.A,{value:"typescript",children:[(0,a.jsxs)(n.p,{children:["Modify the file at ",(0,a.jsx)(n.code,{children:"api/example.ts"})," to look something like the following."]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'// we\'ll need the following imports\nimport { t, typegraph } from "@typegraph/sdk.js";\n\ntypegraph("roadmap", (g) => {\n  //       ^ each typegraph has a name\n\n  const bucket = t.struct({\n    // asId and other config items describe the logical properties\n    // of our types beyond just the shape\n    id: t.integer({}, { asId: true }),\n    name: t.string(),\n  });\n  const idea = t.struct({\n    // uuid is just a shorthand alias for `t.string({format: "uuid"})`\n    id: t.uuid({ asId: true }),\n    name: t.string(),\n    // another string shorthand\n    authorEmail: t.email(),\n  });\n  const vote = t.struct({\n    id: t.uuid(),\n    authorEmail: t.email(),\n    // `enum_` is also a shorthand over `t.string`\n    importance: t.enum_(["medium", "important", "critical"]).optional(),\n    // makes it optional\n    desc: t.string().optional(),\n  });\n});\n'})})]}),(0,a.jsxs)(o.A,{value:"python",children:[(0,a.jsxs)(n.p,{children:["Modify the file at ",(0,a.jsx)(n.code,{children:"api/example.py"})," to look something like the following."]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# we\'ll need the following imports\nfrom typegraph import typegraph, t, Graph\n\n# the typegraph will carry the name of the defining function by default\n@typegraph()\ndef roadmap(g: Graph):\n    bucket = t.struct({\n        # asId and other config items describe the logical properties\n        # of our types beyond just the shape\n        "id": t.integer(as_id=True),\n        "name": t.string(),\n    });\n    idea = t.struct({\n        # email is just a shorthand alias for `t.string({format: "uuid"})`\n        "id": t.uuid(as_id=True),\n        "name": t.string(),\n        # another string shorthand\n        "authorEmail": t.email(),\n    });\n    vote = t.struct({\n        "id": t.uuid(),\n        "authorEmail": t.email(),\n        # `enum` is also a shorthand over `t.string`\n        "importance": t.enum(["medium", "important", "critical"]).optional(),\n        # makes it optional\n        "desc": t.string().optional(),\n    });\n\n'})})]})]}),"\n",(0,a.jsx)(n.p,{children:"The types here are very simple and we haven't yet added any thing that models their relationships but they should do for our purposes."}),"\n",(0,a.jsx)(n.h2,{id:"exposing-our-application",children:"Exposing our application"}),"\n",(0,a.jsx)(n.p,{children:"Typegraphs expose an API to the external world using Function objects. Functions describe the operation that transform some input type into an output type and we define them in scope of different Runtimes, where the actual logic runs. At this early stage, we can make use of the Random runtime which allows us to generate random test data for our types to get a feel of our API."}),"\n",(0,a.jsxs)(r.Ay,{children:[(0,a.jsx)(o.A,{value:"typescript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'// add need the following imports\nimport { Policy } from "@typegraph/sdk/index.js";\nimport { RandomRuntime } from "@typegraph/sdk/runtimes/random.js";\n\ntypegraph("roadmap", (g) => {\n  // ...\n  // every exposed function requires access control policies\n  // for now, just use the public policy, anyone can access it\n  const pub = Policy.public();\n  const random = new RandomRuntime({});\n  g.expose({\n    // generates a random object in the shape of idea\n    get_idea: random.gen(idea).withPolicy(pub),\n  });\n});\n'})})}),(0,a.jsx)(o.A,{value:"python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# add need the following imports\nfrom typegraph.runtimes.random import RandomRuntime\nfrom typegraph import Policy\n\n@typegraph() def roadmap(g: Graph): # every exposed function requires access control policies # for now, just use the public policy, anyone can access it pub = Policy.public() random = RandomRuntime() g.expose( # generates a random object in the shape of idea get_idea=random.gen(idea).with_policy(pub) )\n\n"})})})]}),"\n",(0,a.jsx)(n.p,{children:"At this point, we can push our typegraph to the locally running typegate node and access it. Run the following command in your project root:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# features auto-reload on any changes to your source files\nmeta dev\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Typegate has first-class support for consuming the API through a GraphQl interface and it is enabled by default. It also bundles the GrahpiQl API explorer and you should be able to access it at ",(0,a.jsx)(n.a,{href:"http://localhost:7890/roadmap",children:"http://localhost:7890/roadmap"})," once meta-cli has successfully pushed your typegraph."]}),"\n",(0,a.jsxs)(n.p,{children:["You can go ahead and try out the following ",(0,a.jsx)(n.code,{children:"graphql"})," on the interface and get a feel for it."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"query {\n  get_idea {\n    id\n    name\n    authorEmail\n  }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Or, you can mess around on the playground below."}),"\n",(0,a.jsx)(s.A,{typegraph:"first-typegraph",python:t(73523),typescript:t(50029),query:t(15530)}),"\n",(0,a.jsx)(n.h3,{id:"the-prisma-runtime",children:"The Prisma Runtime"}),"\n",(0,a.jsxs)(n.p,{children:["Now that we have created a simple endpoint that generates random values for our ",(0,a.jsx)(n.code,{children:"idea"})," model/type, let's add a CRUD support to our app. A runtime most apps will be depend on is the ",(0,a.jsx)(n.a,{href:"/docs/reference/runtimes/prisma",children:"Prisma Runtime"})," which allows us to connect to different databases and peform database operations."]}),"\n",(0,a.jsxs)(n.p,{children:["For this tutorial, we'll be making use of the ",(0,a.jsx)(n.code,{children:"PostgreSQL"})," database. If you made use of the ",(0,a.jsx)(n.code,{children:"compose.yml"})," to run typegate as outlined in this tutorial, there should be an instance of Postgres already up. You can check if postgres container is currently running by using the ",(0,a.jsx)(n.code,{children:"meta doctor"})," command."]}),"\n",(0,a.jsxs)(n.p,{children:["If a typegraph needs to access a database, it first needs to be made aware of its address. This is done through secrets. In the root of your project directory, you'll find a file titled ",(0,a.jsx)(n.code,{children:"metatype.yaml"}),". It contains metatype specific configuration for our project such as the top level ",(0,a.jsx)(n.code,{children:"typegates"})," object which we use to specify the location and credentials of the different typegate nodes we'll be using. Each typegate entry also takes an ",(0,a.jsx)(n.a,{href:"/docs/reference/meta-cli/configuration-file#named-secrets",children:(0,a.jsx)(n.code,{children:"secrets"})})," object where we can specify secret to be passed to our typegraphs."]}),"\n",(0,a.jsxs)(n.p,{children:["The keys in the ",(0,a.jsx)(n.code,{children:"secrets"})," object are the names of the typegraphs and the values are objects mapping secret names to their values/sources."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"metatype.yaml"})," should already have a few sample environment variables. Add an entry like the following to give our typegraph access to the database's address:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'typegates:\n  dev:\n    # ..\n    secrets:\n      TG_ROADMAP_POSTGRES: "postgresql://postgres:password@postgres:5432/db"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Meta-cli will auto-reload when it detects changes to ",(0,a.jsx)(n.code,{children:"metatype.yaml"}),". This is because Meta-cli was run in ",(0,a.jsx)(n.code,{children:"dev"})," mode(through the ",(0,a.jsx)(n.code,{children:"meta dev"})," command)."]}),"\n",(0,a.jsx)(n.p,{children:"We can add the Prisma runtime to our typegraph now."}),"\n",(0,a.jsxs)(r.Ay,{children:[(0,a.jsx)(o.A,{value:"typescript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'// new imports\nimport { PrismaRuntime } from "@typegraph/sdk/providers/prisma.js";\n\ntypegraph("roadmap", (g) => {\n  // ...\n\n  // the constructor takes the name of the env var directly\n  const db = new PrismaRuntime("db", "POSTGRES");\n  // ...\n});\n'})})}),(0,a.jsx)(o.A,{value:"python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# new imports\nfrom typegraph.providers.prisma import PrismaRuntime\n\n@typegraph()\ndef roadmap(g: Graph):\n    # ..\n\n    # the constructor takes the name of the env var directly\n    db = PrismaRuntime("db", "POSTGRES")\n    # ..\n\n'})})})]}),"\n",(0,a.jsxs)(n.p,{children:["One of the features that the Prisma runtime allows us to implement is relationships. Here, we are creating a one to many relationship between bucket and ideas, also another one to many between ideas and vote. We will be specifiying relationships by using the ",(0,a.jsx)(n.code,{children:"t.list"})," List type and ",(0,a.jsx)(n.code,{children:"g.ref"}),"(method which accepts the name of the model/entity as a parameter) for creating the link. Check the example below for better understanding."]}),"\n",(0,a.jsxs)(r.Ay,{children:[(0,a.jsx)(o.A,{value:"typescript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import { PrismaRuntime } from "@typegraph/sdk/providers/prisma.js";\n\ntypegraph("roadmap", (g) => {\n  // ...\n\n  const db = new PrismaRuntime("db", "POSTGRES");\n\n  const bucket = t\n    .struct({\n      id: t.integer(\n        {},\n        {\n          asId: true,\n          //  auto generate ids during creation\n          config: { auto: true },\n        },\n      ),\n      name: t.string(),\n      // one-to many relationship\n      ideas: t.list(g.ref("idea")),\n    })\n    // explicitly naming our types makes reference later easier\n    .rename("bucket");\n\n  const idea = t\n    .struct({\n      id: t.uuid({ asId: true, config: { auto: true } }),\n      name: t.string(),\n      authorEmail: t.email(),\n      // we need to specify the relationships on both types\n      bucket: g.ref("bucket"),\n      votes: t.list(g.ref("vote")),\n    })\n    .rename("idea");\n\n  const vote = t\n    .struct({\n      id: t.uuid({ asId: true, config: { auto: true } }),\n      authorEmail: t.email(),\n      importance: t.enum_(["medium", "important", "critical"]).optional(),\n      desc: t.string().optional(),\n      idea: g.ref("idea"),\n    })\n    .rename("vote");\n\n  // ...\n});\n'})})}),(0,a.jsx)(o.A,{value:"python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from typegraph.providers.prisma import PrismaRuntime\n\n@typegraph()\ndef roadmap(g: Graph):\n    # ..\n    db = PrismaRuntime("db", "POSTGRES")\n\n    bucket = t.struct(\n        {\n            "id": t.integer(\n              as_id=True,\n              # auto generate ids during creation\n              config={"auto": True}\n            ),\n            "name": t.string(),\n            # one-to many relationship\n            "ideas": t.list(g.ref("idea")),\n        },\n        # explicitly naming our types makes reference later easier\n        name="bucket"\n    )\n    idea = t.struct(\n        {\n            "id": t.uuid(as_id=True, config={"auto": True}),\n            "name": t.string(),\n            "authorEmail": t.email(),\n            "votes": t.list(g.ref("vote")),\n            "bucket": g.ref("bucket"),\n        },\n        name="idea"\n    )\n    vote = t.struct(\n        {\n            "id": t.uuid(as_id=True, config={"auto": True}),\n            "authorEmail": t.email(),\n            "importance": t.enum(["medium", "important", "critical"]).optional(),\n            "desc": t.string().optional(),\n            "idea": g.ref("idea"),\n        },\n        name="vote"\n    )\n    # ..\n'})})})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"g.ref"})," declares logical relationships between our types which the Prisma runtime will be able to pick up. If you need more control on what the relationships will look like on the database, you can use the ",(0,a.jsx)(n.code,{children:"db.link"})," function. More information can be found on the Prisma runtime ",(0,a.jsx)(n.a,{href:"/docs/reference/runtimes/prisma",children:"reference"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["When we save our file at this point, the ",(0,a.jsx)(n.code,{children:"meta dev"})," watcher should automatically create and push the necessary migrations to our database to get it in its intended shape. You should see a new subdirectory in your project called ",(0,a.jsx)(n.code,{children:"prisma"}),". It's where the generated migrations are contained."]}),"\n",(0,a.jsx)(n.p,{children:"If you mess something up in the migrations and want a clean slate, you can reset everything by recreating the containers like so:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# remove all containers and their volumes\ndocker compose down -v\n# launch\ndocker compose up --detach\n# meta dev will auto apply any pending changes to databases\nmeta dev\n"})}),"\n",(0,a.jsx)(n.p,{children:"At this point, we're ready to add functions to expose database queries to create or read data. The Prisma runtime allows us to run raw queries directly on the database but it also provides handy functions we can use for basic CRUD operations. We'll make use of those."}),"\n",(0,a.jsxs)(r.Ay,{children:[(0,a.jsx)(o.A,{value:"typescript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import { PrismaRuntime } from "@typegraph/sdk/providers/prisma.js";\n\ntypegraph("roadmap", (g) => {\n  // ...\n  const pub = Policy.public();\n  const db = new PrismaRuntime("db", "POSTGRES");\n  // ...\n  g.expose(\n    {\n      get_buckets: db.findMany(bucket),\n      create_bucket: db.create(bucket),\n      get_idea: db.findFirst(idea),\n      create_ideas: db.create(idea),\n    },\n    pub, // make all functions public by default\n  );\n});\n'})})}),(0,a.jsx)(o.A,{value:"python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from typegraph.providers.prisma import PrismaRuntime\n\n@typegraph()\ndef roadmap(g: Graph):\n    # ..\n    pub = Policy.public()\n    db = PrismaRuntime("db", "POSTGRES")\n    # ..\n    g.expose(\n        pub, # make all functions public by default\n        get_buckets=db.find_many(bucket),\n        create_bucket=db.create(bucket),\n        get_idea=db.find_many(bucket),\n        create_idea=db.create(bucket),\n        get_vote=db.create(vote),\n    )\n\n'})})})]}),"\n",(0,a.jsx)(n.p,{children:"We should be able to add a few buckets and ideas now."}),"\n",(0,a.jsx)(s.A,{typegraph:"roadmap-prisma",python:t(63786),typescript:t(3004),query:t(59136)}),"\n",(0,a.jsx)(n.h2,{id:"policies",children:"Policies"}),"\n",(0,a.jsx)(n.p,{children:"We now have the tools enough to allow coarse CRUD of our data. The next thing we usually add at this point is authorization. A way to control who can read or write what. The primary mechanism typegraphs use for this purpose are policies."}),"\n",(0,a.jsx)(n.p,{children:"Policies are small functions that get the context of a request as input and return a boolean signaling weather access should be granted."}),"\n",(0,a.jsx)(n.p,{children:"Metatype currently supports policies based on javascript functions that are run on the Deno runtime."}),"\n",(0,a.jsxs)(n.p,{children:['For this tutorial, we\'ll be making use of the basic auth extractor. It expects a string in the format "Basic token" to be set in the ',(0,a.jsx)(n.code,{children:"Authorization"})," http header. The token is expected to be a base64 encoded string in the format ",(0,a.jsx)(n.code,{children:"username:secret"}),"."]}),"\n",(0,a.jsxs)(r.Ay,{children:[(0,a.jsx)(o.A,{value:"typescript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import { DenoRuntime } from "@typegraph/sdk/runtimes/deno.js";\nimport { Auth } from "@typegraph/sdk/params.js";\n\ntypegraph("roadmap", (g) => {\n  // ...\n\n  const deno = new DenoRuntime();\n\n  // The basic extractor only populates the context when\n  // it recognizes the username and the secret matches\n  g.auth(Auth.basic(["andim" /*more users*/]));\n\n  // the `username` value is only availaible if the basic\n  // extractor was successful\n  const admins = deno.policy(\n    "admins",\n    `\n  (_args, { context }) => !!context.username\n`,\n  );\n\n  g.expose(\n    {\n      // ..\n      // only admins are allowed to create new buckets\n      create_bucket: db.create(bucket).withPolicy(admins),\n      // ..\n    },\n    pub,\n  );\n\n  // ...\n});\n'})})}),(0,a.jsx)(o.A,{value:"python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from typegraph.providers.prisma import PrismaRuntime\nfrom typegraph.graph.params import Auth\n\n@typegraph()\ndef roadmap(g: Graph):\n    # ..\n    # The basic extractor only populates the context when\n    # it recognizes the username and the secret matches\n    g.auth(Auth.basic(["andim"]))\n\n    deno = DenoRuntime()\n\n    # the username value is only available if the basic\n    # extractor was successful\n    admins = deno.policy("admins", """\n  (_args, { context }) => !!context.username\n""")\n\n    g.expose(\n        pub,\n        # ..\n        # only admins are allowed to create new buckets\n        create_bucket=db.create(bucket).with_policy(admins),\n        # ..\n    )\n\n'})})})]}),"\n",(0,a.jsxs)(n.p,{children:["The basic extractors expects the secrets in environment variables named in a specific format. Add the following entries to the ",(0,a.jsx)(n.code,{children:"metatype.yaml"})," file:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"typegates:\n  dev:\n    # ..\n    secrets:\n      roadmap: # your typegraph name\n        # ..\n        # the basic extractor secret format\n        # BASIC_[username]\n        BASIC_ADMIN: hunter2\n"})}),"\n",(0,a.jsxs)(n.p,{children:["When you save the files, meta-cli will reload the new additions to your typegraph. ",(0,a.jsx)(n.code,{children:"create_bucket"})," is now only accessible to requests bearing the right tokens (For the provided example, ",(0,a.jsx)(n.code,{children:"Basic YW5kaW06aHVudGVyMg=="}),' should work). If you are using the GraphiQl interface from earlier, there should be a panel in the bottom left called "Headers" for setting http headers']}),"\n",(0,a.jsx)(s.A,{typegraph:"roadmap-policies",python:t(96179),typescript:t(49389),query:t(74802)}),"\n",(0,a.jsx)(n.h2,{id:"more-customization-for-our-app",children:"More Customization for our app"}),"\n",(0,a.jsx)(n.h3,{id:"preventing-unauthorized-creation-of-related-objects",children:"Preventing Unauthorized Creation of Related Objects"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Reference"}),": ",(0,a.jsx)(n.a,{href:"/docs/reference/types/parameter-transformations",children:"Parameter transformations"})]}),"\n",(0,a.jsxs)(n.p,{children:["By default, Prisma generates types that supports the whole suite of usecases one might have on a CRUD operation such as allowing creation of objects of related types in a single operation. We don't always want this and in our case, we want to prevent users from being able to create buckets, which are protected, through the ",(0,a.jsx)(n.code,{children:"create_idea"})," function which's public. We can use the ",(0,a.jsx)(n.code,{children:"reduce"})," method to modify the input types of functions."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:'mutation CIdea {\n  create_idea(\n    data: {\n      # we want to prevent bucket creation through `create_idea`\n      bucket: { create: { name: "Backlog" } }\n      authorEmail: "asdf@as.df"\n      name: "Add support for WASM GC"\n    }\n  ) {\n    id\n    name\n  }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Even though the ",(0,a.jsx)(n.code,{children:"reduce"})," method doesn't allow us to change the shape of the type, we can change the types of members and importantly here, hide the ones we don't need."]}),"\n",(0,a.jsxs)(r.Ay,{children:[(0,a.jsx)(o.A,{value:"typescript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'typegraph("roadmap", (g) => {\n  // ...\n  g.expose(\n    {\n      // ..\n      create_idea: db.create(idea).reduce({\n        data: {\n          // `g.inherit` specifies that we keep the member\n          // type of the original\n          name: g.inherit(),\n          authorEmail: g.inherit(),\n          votes: g.inherit(),\n          bucket: {\n            connect: g.inherit(),\n            // by omitting the `create` member, we hide it\n          },\n        },\n      }),\n      // ..\n    },\n    pub,\n  );\n});\n'})})}),(0,a.jsx)(o.A,{value:"python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'@typegraph()\ndef roadmap(g: Graph):\n    # ..\n    g.expose(\n        pub,\n        # ..\n        create_idea=db.create(idea).reduce({\n            "data": {\n                # `g.inherit` specifies that we keep the member\n                # type of the original\n                "name": g.inherit(),\n                "authorEmail": g.inherit(),\n                "votes": g.inherit(),\n                "bucket": {\n                    "connect": g.inherit(),\n                    # by omitting the `create` member, we hide it\n                }\n            }\n        }),\n        # ..\n    )\n\n'})})})]}),"\n",(0,a.jsxs)(n.p,{children:["Requests are now only able to ",(0,a.jsx)(n.code,{children:"connect"})," new ideas with pre-existing buckets and won't be able to create them. If you try to ",(0,a.jsx)(n.code,{children:"create"})," new bucket through ",(0,a.jsx)(n.code,{children:"create_idea"}),", the typgate will return this response."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "errors": [\n    {\n      "message": "Unexpected property \'create\' for argument \'data.bucket\' of type \'object\' (\'object_288\') at create_idea; valid properties are: connect",\n      "locations": [],\n      "path": [],\n      "extensions": {\n        "timestamp": "2024-04-21T09:46:33.177Z"\n      }\n    }\n  ]\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["As you will be linking existing buckets when creating ideas, you need to create at least one bucket in your database. To do that you need to execute the following graphql query with admin privileges. You should add ",(0,a.jsx)(n.code,{children:'Authorization: "Basic YW5kaW06cGFzc3dvcmQ="'})," in your headers when sending the request."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:'mutation CBucket {\n  create_bucket(data: { name: "Backlog" }) {\n    id\n    name\n  }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Now, If you try using this mutation, it will work as expected. You can only specify buckets that are already created."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:'mutation {\n  create_idea(\n    data: {\n      # we want to prevent bucket creation through `create_idea`\n      bucket: { connect: { id: 1 } }\n      authorEmail: "asdf@as.df"\n      name: "Add support for WASM GC"\n    }\n  ) {\n    id\n    name\n    bucket {\n      id\n      name\n    }\n  }\n}\n'})}),"\n",(0,a.jsx)(s.A,{typegraph:"roadmap-reduce",python:t(86628),typescript:t(38482),query:t(90102),headers:{Authorization:"Basic YW5kaW06cGFzc3dvcmQ="},tab:"headers"}),"\n",(0,a.jsx)(n.h3,{id:"restrict-update-operation-on-selected-fields",children:"Restrict Update Operation on Selected Fields"}),"\n",(0,a.jsxs)(n.p,{children:["You'll notice that we had set the ",(0,a.jsx)(n.code,{children:"importance"})," field on votes as optional. This is to allow users to just up-vote an idea from the main list without opening a form. If they want to add importance or a description to their vote at a later point, we want to update their already existing vote. It should be easy to expose a function for this using Prisma's ",(0,a.jsx)(n.code,{children:"db.update"})," helper and ",(0,a.jsx)(n.code,{children:"reduce"})," to restrict changes to only those field. But we'll take this opportunity to explore the feature of the Prisma runtime to execute raw queries."]}),"\n",(0,a.jsxs)(r.Ay,{children:[(0,a.jsx)(o.A,{value:"typescript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import * as effects from "@typegraph/sdk/effects.js";\n\ntypegraph("roadmap", (g) => {\n  // ...\n  g.expose(\n    {\n      // ..\n      set_vote_importance: db.execute(\n        // query parameters are matched by name from the input type\n        \'UPDATE "vote" SET importance = ${importance} WHERE id = ${vote_id}::uuid\',\n        // our input type\n        t.struct({\n          vote_id: t.uuid(),\n          importance: t.enum_(["medium", "important", "critical"]),\n        }),\n        // we use effects to signal what kind of operation we\'re doing\n        // updates and creates will be exposed as mutations in GraphQl\n        // the boolean signals that the query is idempotent\n        effects.update(true),\n      ),\n      // ..\n    },\n    pub,\n  );\n});\n'})})}),(0,a.jsx)(o.A,{value:"python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from typegraph.gen.exports.runtimes import EffectUpdate\n\n@typegraph()\ndef roadmap(g: Graph):\n    # ..\n    g.expose(\n        pub,\n        # ..\n        set_vote_importance=db.execute(\n            # query parameters are matched by name from the input typ\n            \'UPDATE "vote" SET importance = ${importance} WHERE id = ${vote_id}::uuid\',\n            # our input type\n            t.struct({\n                "vote_id": t.uuid(),\n                "importance": t.enum(["medium", "important", "critical"]),\n            }),\n            # we use effects to signal what kind of operation we\'re doing\n            # updates and creates will be exposed as mutations in GraphQl\n            # the boolean signals that the query is idempotent\n            EffectUpdate(True),\n        ),\n        # ..\n    )\n\n'})})})]}),"\n",(0,a.jsx)(n.p,{children:"Our query is exposed like any other function in the GraphQl api."}),"\n",(0,a.jsx)(s.A,{typegraph:"roadmap-execute",python:t(76931),typescript:t(62205),query:t(22847)}),"\n",(0,a.jsx)(n.h3,{id:"creating-rest-endpoints",children:"Creating REST endpoints"}),"\n",(0,a.jsxs)(n.p,{children:["We can easily expose an HTTP API for our typegraph using the ",(0,a.jsx)(n.code,{children:"g.rest"})," method. It takes a string describe a graphql query to be executed when the http path is requested."]}),"\n",(0,a.jsxs)(r.Ay,{children:[(0,a.jsx)(o.A,{value:"typescript",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'typegraph("roadmap", (g) => {\n  // ...\n\n  g.rest(\n    `\n        query get_buckets {\n            get_buckets {\n                id\n                name\n                ideas {\n                    id\n                    name\n                    authorEmail\n                }\n            }\n        }\n    `,\n  );\n  g.rest(\n    // query parameters present\n    // expects a request of the type `roadmap/rest/get_bucket?id=uuidstr`\n    `\n        query get_bucket($id: Integer) {\n            get_bucket(where:{\n                id: $id\n            }) {\n                id\n                name\n                ideas {\n                    id\n                    name\n                    authorEmail\n                }\n            }\n        }\n    `,\n  );\n});\n'})})}),(0,a.jsx)(o.A,{value:"python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'@typegraph()\ndef roadmap(g: Graph):\n    # ..\n    g.rest(\n        """\n        query get_buckets {\n            get_buckets {\n                id\n                name\n                ideas {\n                    id\n                    name\n                    authorEmail\n                }\n            }\n        }\n        """\n    )\n    g.rest(\n        # query parameters present\n        # expects a request of the type `roadmap/rest/get_bucket?id=uuidstr`\n        """\n        query get_bucket($id: Integer) {\n            get_bucket(where:{\n                id: $id\n            }) {\n                id\n                name\n                ideas {\n                    id\n                    name\n                    authorEmail\n                }\n            }\n        }\n        """\n    )\n\n'})})})]}),"\n",(0,a.jsxs)(n.p,{children:["The exposed query is served at the path ",(0,a.jsx)(n.code,{children:"{typegate_url}/{typegraph_name}/rest/{query_name}"}),". Any parameters that the query takes are processed from the search params of the request. You can check this ",(0,a.jsx)(n.a,{href:"http://localhost:7890/roadmap/rest/get_buckets",children:"link"})," on your local machine and check the results. "]}),"\n",(0,a.jsx)(n.p,{children:"This is it for this tutorial and thanks for following till the end! This was a long one but we hope it gave you an overview to the vast capabilties of Metatype. We ecourage you to keep exploring!"})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},79752:(e,n,t)=>{"use strict";t.d(n,{Ay:()=>o,gc:()=>s});t(30758);var a=t(93098),i=t(99035),r=t(86070);function o(e){let{children:n}=e;const[t,o]=(0,a.e)();return(0,r.jsx)(i.mS,{choices:{typescript:"Typescript SDK",python:"Python SDK"},choice:t,onChange:o,children:n})}function s(e){let{children:n}=e;const[t]=(0,a.e)();return(0,r.jsx)(i.q9,{choices:{typescript:"Typescript SDK",python:"Python SDK"},choice:t,children:n})}},22847:e=>{var n={kind:"Document",definitions:[{kind:"OperationDefinition",operation:"mutation",name:{kind:"Name",value:"UVote"},variableDefinitions:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"set_vote_importance"},arguments:[{kind:"Argument",name:{kind:"Name",value:"vote_id"},value:{kind:"StringValue",value:"2f3207e0-6cb6-4aaf-a759-037cdfe48f0c",block:!1}},{kind:"Argument",name:{kind:"Name",value:"importance"},value:{kind:"StringValue",value:"medium",block:!1}}],directives:[]}]}}],loc:{start:0,end:123}};n.loc.source={body:'mutation UVote {\n  set_vote_importance(\n    vote_id: "2f3207e0-6cb6-4aaf-a759-037cdfe48f0c"\n    importance: "medium"\n  )\n}\n',name:"GraphQL request",locationOffset:{line:1,column:1}};function t(e,n){if("FragmentSpread"===e.kind)n.add(e.name.value);else if("VariableDefinition"===e.kind){var a=e.type;"NamedType"===a.kind&&n.add(a.name.value)}e.selectionSet&&e.selectionSet.selections.forEach((function(e){t(e,n)})),e.variableDefinitions&&e.variableDefinitions.forEach((function(e){t(e,n)})),e.definitions&&e.definitions.forEach((function(e){t(e,n)}))}var a={};function i(e,n){for(var t=0;t<e.definitions.length;t++){var a=e.definitions[t];if(a.name&&a.name.value==n)return a}}n.definitions.forEach((function(e){if(e.name){var n=new Set;t(e,n),a[e.name.value]=n}})),e.exports=n,e.exports.UVote=function(e,n){var t={kind:e.kind,definitions:[i(e,n)]};e.hasOwnProperty("loc")&&(t.loc=e.loc);var r=a[n]||new Set,o=new Set,s=new Set;for(r.forEach((function(e){s.add(e)}));s.size>0;){var d=s;s=new Set,d.forEach((function(e){o.has(e)||(o.add(e),(a[e]||new Set).forEach((function(e){s.add(e)})))}))}return o.forEach((function(n){var a=i(e,n);a&&t.definitions.push(a)})),t}(n,"UVote")},74802:e=>{var n={kind:"Document",definitions:[{kind:"OperationDefinition",operation:"mutation",name:{kind:"Name",value:"CBucket"},variableDefinitions:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"create_bucket"},arguments:[{kind:"Argument",name:{kind:"Name",value:"data"},value:{kind:"ObjectValue",fields:[{kind:"ObjectField",name:{kind:"Name",value:"name"},value:{kind:"StringValue",value:"Backlog",block:!1}}]}}],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"id"},arguments:[],directives:[]},{kind:"Field",name:{kind:"Name",value:"name"},arguments:[],directives:[]}]}}]}}],loc:{start:0,end:86}};n.loc.source={body:'mutation CBucket {\n  create_bucket(data: { name: "Backlog" }) {\n    id\n    name\n  }\n}\n',name:"GraphQL request",locationOffset:{line:1,column:1}};function t(e,n){if("FragmentSpread"===e.kind)n.add(e.name.value);else if("VariableDefinition"===e.kind){var a=e.type;"NamedType"===a.kind&&n.add(a.name.value)}e.selectionSet&&e.selectionSet.selections.forEach((function(e){t(e,n)})),e.variableDefinitions&&e.variableDefinitions.forEach((function(e){t(e,n)})),e.definitions&&e.definitions.forEach((function(e){t(e,n)}))}var a={};function i(e,n){for(var t=0;t<e.definitions.length;t++){var a=e.definitions[t];if(a.name&&a.name.value==n)return a}}n.definitions.forEach((function(e){if(e.name){var n=new Set;t(e,n),a[e.name.value]=n}})),e.exports=n,e.exports.CBucket=function(e,n){var t={kind:e.kind,definitions:[i(e,n)]};e.hasOwnProperty("loc")&&(t.loc=e.loc);var r=a[n]||new Set,o=new Set,s=new Set;for(r.forEach((function(e){s.add(e)}));s.size>0;){var d=s;s=new Set,d.forEach((function(e){o.has(e)||(o.add(e),(a[e]||new Set).forEach((function(e){s.add(e)})))}))}return o.forEach((function(n){var a=i(e,n);a&&t.definitions.push(a)})),t}(n,"CBucket")},59136:e=>{var n={kind:"Document",definitions:[{kind:"OperationDefinition",operation:"mutation",name:{kind:"Name",value:"CBucket"},variableDefinitions:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"create_bucket"},arguments:[{kind:"Argument",name:{kind:"Name",value:"data"},value:{kind:"ObjectValue",fields:[{kind:"ObjectField",name:{kind:"Name",value:"name"},value:{kind:"StringValue",value:"Backlog",block:!1}}]}}],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"id"},arguments:[],directives:[]},{kind:"Field",name:{kind:"Name",value:"name"},arguments:[],directives:[]}]}}]}},{kind:"OperationDefinition",operation:"mutation",name:{kind:"Name",value:"CIdea"},variableDefinitions:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"create_idea"},arguments:[{kind:"Argument",name:{kind:"Name",value:"data"},value:{kind:"ObjectValue",fields:[{kind:"ObjectField",name:{kind:"Name",value:"bucket"},value:{kind:"ObjectValue",fields:[{kind:"ObjectField",name:{kind:"Name",value:"connect"},value:{kind:"ObjectValue",fields:[{kind:"ObjectField",name:{kind:"Name",value:"id"},value:{kind:"IntValue",value:"1"}}]}}]}},{kind:"ObjectField",name:{kind:"Name",value:"authorEmail"},value:{kind:"StringValue",value:"deng@xi.ng",block:!1}},{kind:"ObjectField",name:{kind:"Name",value:"name"},value:{kind:"StringValue",value:"Add support for WASM Gc",block:!1}}]}}],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"id"},arguments:[],directives:[]},{kind:"Field",name:{kind:"Name",value:"name"},arguments:[],directives:[]}]}}]}}],loc:{start:0,end:272}};n.loc.source={body:'mutation CBucket {\n  create_bucket(data: { name: "Backlog" }) {\n    id\n    name\n  }\n}\n\nmutation CIdea {\n  create_idea(\n    data: {\n      bucket: { connect: { id: 1 } }\n      authorEmail: "deng@xi.ng"\n      name: "Add support for WASM Gc"\n    }\n  ) {\n    id\n    name\n  }\n}\n',name:"GraphQL request",locationOffset:{line:1,column:1}};function t(e,n){if("FragmentSpread"===e.kind)n.add(e.name.value);else if("VariableDefinition"===e.kind){var a=e.type;"NamedType"===a.kind&&n.add(a.name.value)}e.selectionSet&&e.selectionSet.selections.forEach((function(e){t(e,n)})),e.variableDefinitions&&e.variableDefinitions.forEach((function(e){t(e,n)})),e.definitions&&e.definitions.forEach((function(e){t(e,n)}))}var a={};function i(e,n){for(var t=0;t<e.definitions.length;t++){var a=e.definitions[t];if(a.name&&a.name.value==n)return a}}function r(e,n){var t={kind:e.kind,definitions:[i(e,n)]};e.hasOwnProperty("loc")&&(t.loc=e.loc);var r=a[n]||new Set,o=new Set,s=new Set;for(r.forEach((function(e){s.add(e)}));s.size>0;){var d=s;s=new Set,d.forEach((function(e){o.has(e)||(o.add(e),(a[e]||new Set).forEach((function(e){s.add(e)})))}))}return o.forEach((function(n){var a=i(e,n);a&&t.definitions.push(a)})),t}n.definitions.forEach((function(e){if(e.name){var n=new Set;t(e,n),a[e.name.value]=n}})),e.exports=n,e.exports.CBucket=r(n,"CBucket"),e.exports.CIdea=r(n,"CIdea")},15530:e=>{var n={kind:"Document",definitions:[{kind:"OperationDefinition",operation:"query",variableDefinitions:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"get_message"},arguments:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"id"},arguments:[],directives:[]},{kind:"Field",name:{kind:"Name",value:"title"},arguments:[],directives:[]}]}},{kind:"Field",alias:{kind:"Name",value:"second_one"},name:{kind:"Name",value:"get_message"},arguments:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"user_id"},arguments:[],directives:[]}]}}]}}],loc:{start:0,end:106}};n.loc.source={body:"query {\n  get_message {\n    id\n    title\n    # user_id\n  }\n\n  second_one: get_message {\n    user_id\n  }\n}\n",name:"GraphQL request",locationOffset:{line:1,column:1}};function t(e,n){if("FragmentSpread"===e.kind)n.add(e.name.value);else if("VariableDefinition"===e.kind){var a=e.type;"NamedType"===a.kind&&n.add(a.name.value)}e.selectionSet&&e.selectionSet.selections.forEach((function(e){t(e,n)})),e.variableDefinitions&&e.variableDefinitions.forEach((function(e){t(e,n)})),e.definitions&&e.definitions.forEach((function(e){t(e,n)}))}var a={};n.definitions.forEach((function(e){if(e.name){var n=new Set;t(e,n),a[e.name.value]=n}})),e.exports=n},90102:e=>{var n={kind:"Document",definitions:[{kind:"OperationDefinition",operation:"mutation",name:{kind:"Name",value:"CBucket"},variableDefinitions:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"create_bucket"},arguments:[{kind:"Argument",name:{kind:"Name",value:"data"},value:{kind:"ObjectValue",fields:[{kind:"ObjectField",name:{kind:"Name",value:"name"},value:{kind:"StringValue",value:"Backlog",block:!1}}]}}],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"id"},arguments:[],directives:[]},{kind:"Field",name:{kind:"Name",value:"name"},arguments:[],directives:[]}]}}]}},{kind:"OperationDefinition",operation:"mutation",name:{kind:"Name",value:"CIdea"},variableDefinitions:[],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"create_idea"},arguments:[{kind:"Argument",name:{kind:"Name",value:"data"},value:{kind:"ObjectValue",fields:[{kind:"ObjectField",name:{kind:"Name",value:"bucket"},value:{kind:"ObjectValue",fields:[{kind:"ObjectField",name:{kind:"Name",value:"connect"},value:{kind:"ObjectValue",fields:[{kind:"ObjectField",name:{kind:"Name",value:"id"},value:{kind:"IntValue",value:"1"}}]}}]}},{kind:"ObjectField",name:{kind:"Name",value:"authorEmail"},value:{kind:"StringValue",value:"deng@xi.ng",block:!1}},{kind:"ObjectField",name:{kind:"Name",value:"name"},value:{kind:"StringValue",value:"Add support for WASM Gc",block:!1}}]}}],directives:[],selectionSet:{kind:"SelectionSet",selections:[{kind:"Field",name:{kind:"Name",value:"id"},arguments:[],directives:[]},{kind:"Field",name:{kind:"Name",value:"name"},arguments:[],directives:[]}]}}]}}],loc:{start:0,end:272}};n.loc.source={body:'mutation CBucket {\n  create_bucket(data: { name: "Backlog" }) {\n    id\n    name\n  }\n}\n\nmutation CIdea {\n  create_idea(\n    data: {\n      bucket: { connect: { id: 1 } }\n      authorEmail: "deng@xi.ng"\n      name: "Add support for WASM Gc"\n    }\n  ) {\n    id\n    name\n  }\n}\n',name:"GraphQL request",locationOffset:{line:1,column:1}};function t(e,n){if("FragmentSpread"===e.kind)n.add(e.name.value);else if("VariableDefinition"===e.kind){var a=e.type;"NamedType"===a.kind&&n.add(a.name.value)}e.selectionSet&&e.selectionSet.selections.forEach((function(e){t(e,n)})),e.variableDefinitions&&e.variableDefinitions.forEach((function(e){t(e,n)})),e.definitions&&e.definitions.forEach((function(e){t(e,n)}))}var a={};function i(e,n){for(var t=0;t<e.definitions.length;t++){var a=e.definitions[t];if(a.name&&a.name.value==n)return a}}function r(e,n){var t={kind:e.kind,definitions:[i(e,n)]};e.hasOwnProperty("loc")&&(t.loc=e.loc);var r=a[n]||new Set,o=new Set,s=new Set;for(r.forEach((function(e){s.add(e)}));s.size>0;){var d=s;s=new Set,d.forEach((function(e){o.has(e)||(o.add(e),(a[e]||new Set).forEach((function(e){s.add(e)})))}))}return o.forEach((function(n){var a=i(e,n);a&&t.definitions.push(a)})),t}n.definitions.forEach((function(e){if(e.name){var n=new Set;t(e,n),a[e.name.value]=n}})),e.exports=n,e.exports.CBucket=r(n,"CBucket"),e.exports.CIdea=r(n,"CIdea")},76931:e=>{e.exports={content:'from typegraph import typegraph, Policy, t, Graph\nfrom typegraph.runtimes.deno import DenoRuntime\nfrom typegraph.graph.params import Auth\nfrom typegraph.providers.prisma import PrismaRuntime\nfrom typegraph.gen.exports.runtimes import EffectUpdate\nfrom typegraph.graph.params import Cors\n\n\n@typegraph(\n)\ndef roadmap(g: Graph):\n  pub = Policy.public()\n  db = PrismaRuntime("db", "POSTGRES")\n  deno = DenoRuntime()\n\n  bucket = t.struct(\n    {\n      "id": t.integer(as_id=True, config={"auto": True}),\n      "name": t.string(),\n      "ideas": t.list(g.ref("idea")),\n    },\n    name="bucket",\n  )\n\n  idea = t.struct(\n    {\n      "id": t.uuid(as_id=True, config={"auto": True}),\n      "name": t.string(),\n      "authorEmail": t.email(),\n      "votes": t.list(g.ref("vote")),\n      "bucket": g.ref("bucket"),\n    },\n    name="idea",\n  )\n\n  vote = t.struct(\n    {\n      "id": t.uuid(as_id=True, config={"auto": True}),\n      "authorEmail": t.email(),\n      "importance": t.enum(\n        ["medium", "important", "critical"]\n      ).optional(),\n      "desc": t.string().optional(),\n      "idea": g.ref("idea"),\n    },\n    name="vote",\n  )\n\n  g.auth(Auth.basic(["andim"]))\n\n  admins = deno.policy(\n    "admins",\n    """\n  (_args, { context }) => !!context.username\n""",\n  )\n\n  g.expose(\n    pub,\n    create_bucket=db.create(bucket).with_policy(admins),\n    get_buckets=db.find_many(bucket),\n    get_bucket=db.find_first(bucket),\n    get_idea=db.find_many(idea),\n    create_idea=db.create(idea).reduce(\n      {\n        "data": {\n          "name": g.inherit(),\n          "authorEmail": g.inherit(),\n          "votes": g.inherit(),\n          "bucket": {"connect": g.inherit()},\n        }\n      }\n    ),\n    create_vote=db.create(vote),\n    set_vote_importance=db.execute(\n      \'UPDATE "vote" SET importance = ${importance} WHERE id = ${vote_id}::uuid\',\n      t.struct(\n        {\n          "vote_id": t.uuid(),\n          "importance": t.enum(\n            ["medium", "important", "critical"]\n          ),\n        }\n      ),\n      EffectUpdate(True),\n    ),\n    get_context=deno.identity(\n      t.struct({"username": t.string().optional()})\n    ).apply(\n      {\n        "username": g.from_context("username"),\n      }\n    ),\n  )',path:"examples/typegraphs/execute.py"}},62205:e=>{e.exports={content:'import { Policy, t, typegraph } from "@typegraph/sdk/index.ts";\nimport { DenoRuntime } from "@typegraph/sdk/runtimes/deno.ts";\nimport { PrismaRuntime } from "@typegraph/sdk/providers/prisma.ts";\nimport { Auth } from "@typegraph/sdk/params.ts";\nimport * as effects from "@typegraph/sdk/effects.ts";\n\nawait typegraph(\n  {\n  },\n  (g) => {\n    const pub = Policy.public();\n    const db = new PrismaRuntime("db", "POSTGRES");\n    const deno = new DenoRuntime();\n\n    const bucket = t.struct(\n      {\n        id: t.integer({}, { asId: true, config: { auto: true } }),\n        name: t.string(),\n        ideas: t.list(g.ref("idea")),\n      },\n      { name: "bucket" }\n    );\n\n    const idea = t.struct(\n      {\n        id: t.uuid({ asId: true, config: { auto: true } }),\n        name: t.string(),\n        authorEmail: t.email(),\n        votes: t.list(g.ref("vote")),\n        bucket: g.ref("bucket"),\n      },\n      { name: "idea" }\n    );\n\n    const vote = t.struct(\n      {\n        id: t.uuid({ asId: true, config: { auto: true } }),\n        authorEmail: t.email(),\n        importance: t.enum_(["medium", "important", "critical"]).optional(),\n        desc: t.string().optional(),\n        idea: g.ref("idea"),\n      },\n      { name: "vote" }\n    );\n\n    g.auth(Auth.basic(["andim"]));\n\n    const admins = deno.policy(\n      "admins",\n      `\n        (_args, { context }) => !!context.username\n    `\n    );\n\n    g.expose(\n      {\n        create_bucket: db.create(bucket).withPolicy(admins),\n        get_buckets: db.findMany(bucket),\n        get_bucket: db.findFirst(bucket),\n        get_idea: db.findMany(idea),\n        create_idea: db.create(idea).reduce({\n          data: {\n            name: g.inherit(),\n            authorEmail: g.inherit(),\n            votes: g.inherit(),\n            bucket: { connect: g.inherit() },\n          },\n        }),\n        create_vote: db.create(vote),\n        set_vote_importance: db.execute(\n          \'UPDATE "vote" SET importance = ${importance} WHERE id = ${vote_id}::uuid\',\n          t.struct({\n            vote_id: t.uuid(),\n            importance: t.enum_(["medium", "important", "critical"]),\n          }),\n          effects.update()\n        ),\n        get_context: deno\n          .identity(t.struct({ username: t.string().optional() }))\n          .apply({\n            username: g.fromContext("username"),\n          }),\n      },\n      pub\n    );\n  }\n);',path:"examples/typegraphs/execute.ts"}},73523:e=>{e.exports={content:'from typegraph import typegraph, Policy, t, Graph\nfrom typegraph.graph.params import Cors\nfrom typegraph.runtimes import RandomRuntime\n\n\n@typegraph(\n)\ndef first_typegraph(g: Graph):\n  # declare runtimes and policies\n  random = RandomRuntime(reset=None)\n  public = Policy.public()\n\n  # declare types\n  message = t.struct(\n    {\n      "id": t.integer(),\n      "title": t.string(),\n      "user_id": t.integer(),\n    }\n  )\n\n  # expose them with policies\n  g.expose(\n    public,\n    # input \u2192 output via runtime function\n    get_message=random.gen(message),\n  )',path:"examples/typegraphs/first-typegraph.py"}},50029:e=>{e.exports={content:'import { Policy, t, typegraph } from "@typegraph/sdk/index.ts";\nimport { RandomRuntime } from "@typegraph/sdk/runtimes/random.ts";\n\nawait typegraph(\n  {\n    name: "first-typegraph",\n  },\n  (g) => {\n    // declare runtimes and policies\n    const random = new RandomRuntime({});\n    const pub = Policy.public();\n\n    // declare types\n    const message = t.struct({\n      id: t.integer(),\n      title: t.string(),\n      user_id: t.integer(),\n    });\n\n    // expose them with policies\n    g.expose(\n      {\n        // input \u2192 output via runtime function\n        get_message: random.gen(message),\n      },\n      pub\n    );\n  }\n);',path:"examples/typegraphs/first-typegraph.ts"}},63786:e=>{e.exports={content:"",path:"examples/typegraphs/prisma.py"}},3004:e=>{e.exports={content:'import { Policy, t, typegraph } from "@typegraph/sdk/index.ts";\nimport { PrismaRuntime } from "@typegraph/sdk/providers/prisma.ts";\n\ntypegraph(\n  {\n    name: "roadmap-prisma",\n  },\n  (g) => {\n    const pub = Policy.public();\n    const db = new PrismaRuntime("db", "POSTGRES");\n\n    const bucket = t.struct(\n      {\n        id: t.integer({}, { asId: true, config: { auto: true } }),\n        name: t.string(),\n        ideas: t.list(g.ref("idea")),\n      },\n      { name: "bucket" }\n    );\n    const idea = t.struct(\n      {\n        id: t.uuid({ asId: true, config: { auto: true } }),\n        name: t.string(),\n        authorEmail: t.email(),\n        votes: t.list(g.ref("vote")),\n        bucket: g.ref("bucket"),\n      },\n      { name: "idea" }\n    );\n    const vote = t.struct(\n      {\n        id: t.uuid({ asId: true, config: { auto: true } }),\n        authorEmail: t.email(),\n        importance: t.enum_(["medium", "important", "critical"]).optional(),\n        desc: t.string().optional(),\n        idea: g.ref("idea"),\n      },\n      { name: "vote" }\n    );\n\n    g.expose(\n      {\n        get_buckets: db.findMany(bucket),\n        create_bucket: db.create(bucket),\n        get_idea: db.findMany(idea),\n        create_idea: db.create(idea),\n        get_vote: db.create(vote),\n      },\n      pub\n    );\n  }\n);',path:"examples/typegraphs/prisma.ts"}},86628:e=>{e.exports={content:'from typegraph import typegraph, Policy, t, Graph\nfrom typegraph.runtimes.deno import DenoRuntime\nfrom typegraph.graph.params import Auth\nfrom typegraph.providers.prisma import PrismaRuntime\nfrom typegraph.graph.params import Cors\n\n\n@typegraph(\n)\ndef roadmap(g: Graph):\n  pub = Policy.public()\n  db = PrismaRuntime("db", "POSTGRES")\n  deno = DenoRuntime()\n\n  bucket = t.struct(\n    {\n      "id": t.integer(as_id=True, config={"auto": True}),\n      "name": t.string(),\n      "ideas": t.list(g.ref("idea")),\n    },\n    name="bucket",\n  )\n\n  idea = t.struct(\n    {\n      "id": t.uuid(as_id=True, config={"auto": True}),\n      "name": t.string(),\n      "authorEmail": t.email(),\n      "votes": t.list(g.ref("vote")),\n      "bucket": g.ref("bucket"),\n    },\n    name="idea",\n  )\n\n  vote = t.struct(\n    {\n      "id": t.uuid(as_id=True, config={"auto": True}),\n      "authorEmail": t.email(),\n      "importance": t.enum(\n        ["medium", "important", "critical"]\n      ).optional(),\n      "desc": t.string().optional(),\n      "idea": g.ref("idea"),\n    },\n    name="vote",\n  )\n\n  g.auth(Auth.basic(["andim"]))\n\n  admins = deno.policy(\n    "admins",\n    "(_args, { context }) => !!context.username",\n  )\n\n  g.expose(\n    pub,\n    create_bucket=db.create(bucket).with_policy(admins),\n    get_buckets=db.find_many(bucket),\n    get_bucket=db.find_first(bucket),\n    get_idea=db.find_many(idea),\n    create_idea=db.create(idea).reduce(\n      {\n        "data": {\n          "name": g.inherit(),\n          "authorEmail": g.inherit(),\n          "votes": g.inherit(),\n          "bucket": {"connect": g.inherit()},\n        }\n      }\n    ),\n    create_vote=db.create(vote),\n  )',path:"examples/typegraphs/reduce.py"}},38482:e=>{e.exports={content:'import { Policy, t, typegraph } from "@typegraph/sdk/index.ts";\nimport { Auth } from "@typegraph/sdk/params.ts";\nimport { PrismaRuntime } from "@typegraph/sdk/providers/prisma.ts";\nimport { DenoRuntime } from "@typegraph/sdk/runtimes/deno.ts";\n\ntypegraph(\n  {\n    name: "roadmap-reduce",\n  },\n  (g) => {\n    const pub = Policy.public();\n    const db = new PrismaRuntime("db", "POSTGRES");\n    const deno = new DenoRuntime();\n\n    const bucket = t.struct(\n      {\n        id: t.integer({}, { asId: true, config: { auto: true } }),\n        name: t.string(),\n        ideas: t.list(g.ref("idea")),\n      },\n      { name: "bucket" }\n    );\n\n    const idea = t.struct(\n      {\n        id: t.uuid({ asId: true, config: { auto: true } }),\n        name: t.string(),\n        authorEmail: t.email(),\n        votes: t.list(g.ref("vote")),\n        bucket: g.ref("bucket"),\n      },\n      { name: "idea" }\n    );\n\n    const vote = t.struct(\n      {\n        id: t.uuid({ asId: true, config: { auto: true } }),\n        authorEmail: t.email(),\n        importance: t.enum_(["medium", "important", "critical"]).optional(),\n        desc: t.string().optional(),\n        idea: g.ref("idea"),\n      },\n      { name: "vote" }\n    );\n\n    g.auth(Auth.basic(["andim"]));\n\n    const admins = deno.policy(\n      "admins",\n      "(_args, { context }) => !!context.username"\n    );\n\n    g.expose(\n      {\n        create_bucket: db.create(bucket).withPolicy(admins),\n        get_buckets: db.findMany(bucket),\n        get_bucket: db.findFirst(bucket),\n        get_idea: db.findMany(idea),\n        create_idea: db.create(idea).reduce({\n          data: {\n            name: g.inherit(),\n            authorEmail: g.inherit(),\n            votes: g.inherit(),\n            bucket: { connect: g.inherit() },\n          },\n        }),\n        create_vote: db.create(vote),\n      },\n      pub\n    );\n  }\n);',path:"examples/typegraphs/reduce.ts"}},96179:e=>{e.exports={content:'from typegraph import typegraph, Policy, t, Graph\nfrom typegraph.runtimes.deno import DenoRuntime\nfrom typegraph.graph.params import Auth\nfrom typegraph.providers.prisma import PrismaRuntime\nfrom typegraph.graph.params import Cors\n\n\n@typegraph(\n)\ndef roadmap(g: Graph):\n  pub = Policy.public()\n  db = PrismaRuntime("db", "POSTGRES")\n  deno = DenoRuntime()\n\n\n  # highlight-next-line\n  g.auth(Auth.basic(["andim"]))\n\n  # highlight-start\n  admins = deno.policy(\n    "admins",\n    "(_args, { context }) => !!context.username",\n  )\n  # highlight-end\n\n  g.expose(\n    pub,\n    # highlight-next-line\n    create_bucket=db.create(bucket).with_policy(admins),\n    get_buckets=db.find_many(bucket),\n    get_idea=db.find_many(idea),\n    create_idea=db.create(idea),\n    create_vote=db.create(vote),\n  )',path:"examples/typegraphs/roadmap-policies.py"}},49389:e=>{e.exports={content:'import { Policy, t, typegraph } from "@typegraph/sdk/index.ts";\nimport { Auth } from "@typegraph/sdk/params.ts";\nimport { DenoRuntime } from "@typegraph/sdk/runtimes/deno.ts";\nimport { PrismaRuntime } from "@typegraph/sdk/providers/prisma.ts";\n\ntypegraph(\n  {\n    name: "roadmap-policies",\n  },\n  (g) => {\n    const pub = Policy.public();\n    const db = new PrismaRuntime("db", "POSTGRES");\n    const deno = new DenoRuntime();\n\n    const bucket = t.struct(\n      {\n        // auto generate ids during creation\n        id: t.integer({}, { asId: true, config: { auto: true } }),\n        name: t.string(),\n        ideas: t.list(g.ref("idea")),\n      },\n      { name: "bucket" }\n    );\n\n    const idea = t.struct(\n      {\n        id: t.uuid({ asId: true, config: { auto: true } }),\n        name: t.string(),\n        authorEmail: t.email(),\n        votes: t.list(g.ref("vote")),\n        bucket: g.ref("bucket"),\n      },\n      { name: "idea" }\n    );\n\n    const vote = t.struct(\n      {\n        id: t.uuid({ asId: true, config: { auto: true } }),\n        authorEmail: t.email(),\n        importance: t.enum_(["medium", "important", "critical"]).optional(),\n        desc: t.string().optional(),\n        idea: g.ref("idea"),\n      },\n      { name: "vote" }\n    );\n\n    g.auth(Auth.basic(["andim"]));\n\n    const admins = deno.policy(\n      "admins",\n      "(_args, { context }) => !!context.username"\n    );\n\n    g.expose(\n      {\n        create_bucket: db.create(bucket).withPolicy(admins),\n        get_buckets: db.findMany(bucket),\n        get_idea: db.findMany(idea),\n        create_idea: db.create(idea),\n        create_vote: db.create(vote),\n      },\n      pub\n    );\n  }\n);',path:"examples/typegraphs/roadmap-policies.ts"}}}]);