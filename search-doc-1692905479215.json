[{"title":"Introducing Metatype: programmable glue for developers","type":0,"sectionRef":"#","url":"/blog/2023/06/18/programmable-glue","content":"","keywords":"","version":null},{"title":"What is Metatype?​","type":1,"pageTitle":"Introducing Metatype: programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#what-is-metatype","content":"Metatype is an open source platform for developers to declaratively build APIs. It offers a unique approach to building backends, where the focus is all on data modelling and the platform takes care of the rest. The intent is to find a convenient computing model that tackles the following challenges: most developers still spend too much time on tasks with low-value (crud, data validation, compliance, etc.)when growing a product, it is hard to keep up with business needs and remain innovative with technologymanaging server and infrastructure shall never be a concern for developers nor slow them down In that respect, Metatype can be seen as an alternative to Hasura, Strapi, Firebase, or even web frameworks like Django or NestJS. You can see how Metatype differs reading the conceptual overview or the comparison summary. The platform consists of the following components: Typegraph: a package to describe typegraphs - virtual graphs of types - and compose themTypegate: a distributed REST/GraphQL query engine to execute queries over typegraphsMeta CLI: a command-line tool to provide great developer experience and serverless deployment A vast range of runtimes is implemented by the platform and provides out of the box support for storing data in databases/S3, connecting to third-party/internal APIs and running business logic in Deno/Python/WebAssembly. ","version":null,"tagName":"h2"},{"title":"What are virtual graphs?​","type":1,"pageTitle":"Introducing Metatype: programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#what-are-virtual-graphs","content":"Typegraphs are a declarative way to expose all APIs, storage and business logic of your stack as a single graph. They take inspiration from domain-driven design principles and in the idea that the relation between of the data is as important as data itself, even though they might be in different locations or shapes. Loading... These elements can then be combined and composed together similarly on how you would compose web components to create an interface in modern frontend practices. This allows developers to build modular and strongly typed APIs using typegraph as a programmable glue. ","version":null,"tagName":"h2"},{"title":"Where does this belong in the tech landscape?​","type":1,"pageTitle":"Introducing Metatype: programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#where-does-this-belong-in-the-tech-landscape","content":"Before Metatype, there was a gap in the technological landscape for a solution that specifically addressed the transactional, short-lived use cases. While there were existing tools for analytical or long-running use cases, such as Trino and Temporal, there was no generic engine for handling transactional, short-lived tasks. \t← individual level transactional\tlarge data → analytical instantaneous ↑ short-lived\tMetatype query engine for data entities in evolving systems\tTrino query engine for large data from multiples sources long-running asynchronous ↓\tTemporal workflow orchestration engine for data operations\tSpark batch/streaming engine for large data processing ","version":null,"tagName":"h2"},{"title":"Give it a try!​","type":1,"pageTitle":"Introducing Metatype: programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#give-it-a-try","content":"Let us know what you think! Metatype is open source and we welcome any feedback or contributions. The community primarily lives on GitHub. Next steps Build your first typegraph or read more about the concepts behind Metatype. ","version":null,"tagName":"h2"},{"title":"Comparing Metatype","type":0,"sectionRef":"#","url":"/docs/concepts/comparisons","content":"","keywords":"","version":"Next"},{"title":"App development platforms​","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#app-development-platforms","content":"FirebaseSupabase These are great platforms to quickly start a new project. However, they hardly scale in terms of architecture evolution, technology freedom, number of developers on the project, and you will eventually have to move out due to increasing costs or iterations slowness. When to choose Metatype You want to build modular APIs by composing pre-defined blocks and import the ones you need from existing systemsYou want to take advantage of developers tooling you are familiar with like version controls or multiple environmentsYou favor interoperability and extensibility over vendor lock-in and follow your future needs with ease ","version":"Next","tagName":"h2"},{"title":"Headless CMS​","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#headless-cms","content":"StrapiDirectus Headless Content Management Systems (CMS) are great tools to manage content and providing great editing experience. However, they are not designed to build complex APIs like a cart checkout or integrate with other systems. When to choose Metatype You want an all-in-one APIs development platforms and offer the same editing experience through a user-friendly interfaceYou care about end-user performance and want to use the best underlying technology for each use casesYou are more than one on the project and want to manage your data models using preferred programming language ","version":"Next","tagName":"h2"},{"title":"APIs over databases​","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#apis-over-databases","content":"HasuraPostGraphile These platforms offer great data accessibility, but they are focused on databases and forget about the importance of the business logic glues and the interoperability with other systems. When to choose Metatype You want to have more than CRUD operations and get authentication, rate-limiting, and business logic out of the boxYou want to decouple your database from your API and change where the data is stored as the project evolvesYou prefer focusing on what you want to achieve rather than how to achieve it (and get stuck Haskell or Postgres internals) ","version":"Next","tagName":"h2"},{"title":"GraphQL-based backends​","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#graphql-based-backends","content":"WunderGraphGrafbase These great tools leverage GraphQL to build internal APIs using pre-determined queries. They are less API consumer oriented and that disables powerful capabilities like querying between multiple instances owned by different users. When to choose Metatype You want to build internal and external APIs, and go beyond what can be described in a GraphQL schemaYou want to optimize your API queries on the fly and let the engine resolve your data in the most efficient wayYou expect a fine-grained permission model and control the data you expose at the level of each model field ","version":"Next","tagName":"h2"},{"title":"Web frameworks​","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#web-frameworks","content":"DjangoNestJS These frameworks are a great way to build web applications. However, they require a lot of boilerplate code to build APIs and are not designed to be deployed in a serverless environment. They also requires a lot of configuration to get a complete solution. When to choose Metatype When you want to build declarative APIs and let the engine handle the underlying implementationWhen you want to build APIs in multiple languages, with less code and have a consistent experience across themWhen you expect a lightweight and all-in-one solution with authentication, databases, caching, and more out of the box ","version":"Next","tagName":"h2"},{"title":"Workflow engines​","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#workflow-engines","content":"TemporalWindmill Great tools when it comes at scheduling long-running jobs. However, they are not designed to answer instantaneous API calls and are not optimized for data entities fetching. They are nonetheless the perfect companion to Metatype and some integrations already exists. When to choose Metatype When you want to implement modular APIs and backends with instantaneous responsesWhen you want to interact with workflow engines and control over the operations they perform, including pooling and retriesWhen you look for a serverless deployment solution and want to focus on your business logic ","version":"Next","tagName":"h2"},{"title":"Meta CLI","type":0,"sectionRef":"#","url":"/docs/concepts/meta-cli","content":"","keywords":"","version":"Next"},{"title":"Development​","type":1,"pageTitle":"Meta CLI","url":"/docs/concepts/meta-cli#development","content":"It watches for changes in your typegraphs and refresh your development typegate node on the fly. ","version":"Next","tagName":"h2"},{"title":"Deployment​","type":1,"pageTitle":"Meta CLI","url":"/docs/concepts/meta-cli#deployment","content":"It deploy your typegraph to the Metatype Cloud or your self-hosted typegate instances in a single command. ","version":"Next","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/docs/concepts/overview","content":"","keywords":"","version":"Next"},{"title":"Why does Metatype exist?​","type":1,"pageTitle":"Overview","url":"/docs/concepts/overview#why-does-metatype-exist","content":"As products evolve, building APIs becomes a challenging hot spot where initiatives collides and efficiency becomes a struggle. While deploying new features, all developers spend a non-negligible amount of time on low-value added tasks (CRUD generation, data validation, authorization, etc.) and deploying their solutions. This leaves little time under business constraints to design great interfaces and experiment with the best technical solution, eventually increasing the time to delivery and weakening the innovation capabilities. Metatype's vision is to enable everyone to build modular API with as little effort as possible. By helping developers to re-use existing systems and APIs, it enables teams to focus on what matters: their expert knowledge in business logic, modelling and technologies. Metatype manage the complex layers for them, making them productive and innovation-friendly for the next iterations. Drawing inspiration from modern frontend development practices, Metatype adopts the pattern of composing components together to solve backend development challenges. In that respect, Metatype is a key element in the composable enterprise trend by: making system interfaces accessible and easy to understand for everyone (discoverability)embracing iterative approaches and cut time to deployment in half (autonomy)building strong foundations for APIs with type safety and bounded context (modularity)empowering teams to innovate with new technologies and interoperability (orchestration) ","version":"Next","tagName":"h2"},{"title":"How does Metatype work?​","type":1,"pageTitle":"Overview","url":"/docs/concepts/overview#how-does-metatype-work","content":"When developing a feature, the classical approach is to define what data will be at play, how to transform them, where the execution shall take place and who should be authorized. Instead, Metatype define an abstraction for each of those steps and put the emphasis on composing pre-defined APIs or defining re-usable ones when there is no existing solution. \tClassical approach\tMetatype's computing modelWhat (data)\tfixed response defined by the logic\tAPI clients selects what they need from types How (transformations)\tad-hoc code logic\tcomposed data with interchangeable materializers Where (execution)\t1 code base + 1 database\torchestrate the request across multiple runtimes Who (authentication)\thard-coded rules or system\trequest context based and controlled by policies When (event)\trequest arrival\tbased on triggers This computing model brings numerous advantages: it offers multiple runtimes with pre-defined operations and can replace the needs for an ad-hoc backendwhen the project grows, you easily introduce new APIs or break existing ones in smaller partsyou write complex business logic directly in Typescript, Python or WebAssembly and run them on-demandthird-parties APIs can be easily integrated, providing you visibility and control over themit is interoperable with existing (legacy) systems, and can be introduced step by stepit can be easily self-hosted in your own infrastructure or customized according to your needs ","version":"Next","tagName":"h2"},{"title":"What's exactly Metatype?​","type":1,"pageTitle":"Overview","url":"/docs/concepts/overview#whats-exactly-metatype","content":"Metatype is an open source platform for developers to declaratively build APIs. It offers a unique approach to building backends, where the focus is all on data modelling and the platform takes care of the rest. The intent is to find a convenient computing model that tackles the following challenges: most developers still spend too much time on tasks with low-value (crud, data validation, compliance, etc.)when growing a product, it is hard to keep up with business needs and remain innovative with technologymanaging server and infrastructure shall never be a concern for developers nor slow them down In that respect, Metatype can be seen as an alternative to Hasura, Strapi, Firebase, or even web frameworks like Django or NestJS. You can see how Metatype differs reading the conceptual overview or the comparison summary. The platform consists of the following components: Typegraph: a package to describe typegraphs - virtual graphs of types - and compose themTypegate: a distributed REST/GraphQL query engine to execute queries over typegraphsMeta CLI: a command-line tool to provide great developer experience and serverless deployment A vast range of runtimes is implemented by the platform and provides out of the box support for storing data in databases/S3, connecting to third-party/internal APIs and running business logic in Deno/Python/WebAssembly. ","version":"Next","tagName":"h2"},{"title":"Architectural overview​","type":1,"pageTitle":"Overview","url":"/docs/concepts/overview#architectural-overview","content":"Metatype is designed for cloud environments and comes with minimal components. The only requirement to scale horizontally is to share some memory between replicas via Redis. You can use Metatype helm chart to directly deploy typegates on your Kubernetes cluster.  ","version":"Next","tagName":"h3"},{"title":"Typegate","type":0,"sectionRef":"#","url":"/docs/concepts/typegate","content":"","keywords":"","version":"Next"},{"title":"Request lifecycle​","type":1,"pageTitle":"Typegate","url":"/docs/concepts/typegate#request-lifecycle","content":"When a new request fires a trigger, the typegate orchestrates the following stages: extract the secure request context from custom authentication or JSON Web Token (JWT)retrieve cached execution plan or compute a new one traverse the typegraph to create a DAG of the required typesoptimize the DAG to reduce the number of calls to the runtimespre-compute all structural elements and data resolutions execute the plan type check the argumentsverify lazily policies on the needrun the DAG executionenforce the rate-limitingtype check the response manage metadata of the request ","version":"Next","tagName":"h2"},{"title":"HTTP/GraphQL interface​","type":1,"pageTitle":"Typegate","url":"/docs/concepts/typegate#httpgraphql-interface","content":"For now, the typegate nodes are only accessible through HTTP/1.1 and HTTP/2. More protocols could be supported in the future. Typegates expose a GraphQL interface which is the result of a typegraph projected onto corresponding GraphQL types. While this reduces the type safety of the data flowing, it makes more interoperable thanks to the many high-quality and well-known GraphQL tooling already available. The underlying types are also exposed in order for API clients to verify the underlying types. GraphQL, being a query language, offers a great asset for Metatype's philosophy: Efficient querying: the client can specify exactly what data it needs, reducing the amount of over- or under-fetchingFlexibility: allows for retrieving multiple resources in a single request, unlike REST, which often requires multiple onesTyping: GraphQL has a built-in type system that allows for better documentation and stronger validation of the requestsImproved tooling: tools and libraries around GraphQL are rapidly growing and great a development experience ","version":"Next","tagName":"h2"},{"title":"Authenticate your requests","type":0,"sectionRef":"#","url":"/docs/guides/authentication","content":"","keywords":"","version":"Next"},{"title":"Basic authentication​","type":1,"pageTitle":"Authenticate your requests","url":"/docs/guides/authentication#basic-authentication","content":"Basic authentication is the simplest way to authenticate requests. It is done by sending a base64 encoded string of your username and password in the authorization header. Recall that base64 encoding is not encryption and can be easily reversed, thus the traffic must be encrypted with SSL/TLS when using basic authentication as your password will otherwise be visible. Components\tValuesSecrets\tTG_[typegraph]_BASIC_[username]=password Header\tAuthorization: Basic base64(username:password) Context\t{ username } Loading... ","version":"Next","tagName":"h2"},{"title":"JWT authentication​","type":1,"pageTitle":"Authenticate your requests","url":"/docs/guides/authentication#jwt-authentication","content":"A more secure way to authenticate requests is to use JSON Web Tokens. The context of a user is signed with a secret key and the typegate will verify the signature to ensure the context has not been tampered with. The JWT is then sent in the authorization header. The JWT is usually generated by an external identity provider (IdP) such as Keycloak or Auth0 and limited in time. The typegate will check that the exp (expiration time) and nbf (not before) are valid if they exist in the context. The logic of refreshing expired tokens is left to the user or the IdP client library being used. The typegate supports the most frequently used algorithms for signing the JWT and can be imported as using &quot;jwk&quot;, &quot;raw&quot;, &quot;pkcs8&quot; or &quot;spki&quot; formats (see SubtleCrypto documentation). For instance, an asymmetric key pair can be generated with the following command: const keys = await crypto.subtle.generateKey( { name: &quot;ECDSA&quot;, namedCurve: &quot;P-384&quot; }, true, [&quot;sign&quot;, &quot;verify&quot;] ); const publicKey = await crypto.subtle.exportKey(&quot;jwk&quot;, keys.publicKey); // save keys.privateKey for later use console.log(JSON.stringify(publicKey)); // in typegraph: Auth.jwt(&quot;keycloak&quot;, &quot;jwk&quot;, {&quot;name&quot;: &quot;ECDSA&quot;, &quot;namedCurve&quot;: &quot;P-384&quot;})  Even though, asymmetric encryption is recommended, HMAC-SHA256 is so commonly used that an alias is provided for it. Components\tValuesSecrets\tTG_[typegraph]_[authentication]_JWT=secret Header\tAuthorization: Bearer token Context\t{ your_own_content } Loading... Note that for the sake of the demo, the token has no expiration time. Tokens should always be shorted lived and refreshed frequently to reduce the risk of unexpected access. ","version":"Next","tagName":"h2"},{"title":"OAuth2 authorization​","type":1,"pageTitle":"Authenticate your requests","url":"/docs/guides/authentication#oauth2-authorization","content":"OAuth2 allows a user to grant limited access to their resources on one site, to another site, without having to expose their credentials. It is commonly used when the typegate needed to access restricted information in third-parties such as Google or GitHub. Most of the time, the OAuth2 is managed by your identity provider and relies on the JWT authentication as explained above. However the typegate provides a simple way to handle the OAuth2 flow without IdP or when the system should be lightweight. Components\tValuesSecrets\tTG_[typegraph]_[authentication]_CLIENT_ID=client_id, TG_[typegraph]_[authentication]_CLIENT_SECRET=client_secret Header\tAuthorization: Bearer token Context\t{ content_from_your_idp } ","version":"Next","tagName":"h2"},{"title":"Take flow​","type":1,"pageTitle":"Authenticate your requests","url":"/docs/guides/authentication#take-flow","content":"Redirect the user to https://[typegate].metatype.cloud/[typegraph]/auth/[authentication]?redirect_uri=https://your-website.com/login and the OAuth2 starts for the user When the user has completed the flow, the typegate will redirect the user to https://your-website.com/login and you can &quot;take&quot; the token from the typegate as follows. This can be only done once and is limited in time: const take = await fetch( &quot;https://[typegate].metatype.cloud/[typegraph]/auth/take&quot;, { credentials: &quot;include&quot;, } ); const { token } = await take.json();  The token can then be used as JWT in the Authorization header of your requests, and the response of the typegate will contain a header Next-Authorization. When this header is present, the value should be used in follow-up calls (value will be empty if the authentication has expired). Loading... ","version":"Next","tagName":"h3"},{"title":"OpenID Connect​","type":1,"pageTitle":"Authenticate your requests","url":"/docs/guides/authentication#openid-connect","content":"OpenID Connect is an authentication layer on top of OAuth2. It is used to verify the identity of the user and retrieve basic information about them. You can add openid to the OAuth2 scope and you will receive an id_token in the response. The id_token is a JWT that contains the user's information and is signed by the IdP. ","version":"Next","tagName":"h3"},{"title":"Embedded providers​","type":1,"pageTitle":"Authenticate your requests","url":"/docs/guides/authentication#embedded-providers","content":"Frequent OAuth2 providers are embedded and can be directly used in the typegraph. from typegraph.graph.auth import oauth2 oauth2.github(&quot;openid profile email&quot;)  The whole list is available here. ","version":"Next","tagName":"h3"},{"title":"Typegraph","type":0,"sectionRef":"#","url":"/docs/concepts/typegraph","content":"","keywords":"","version":"Next"},{"title":"Types​","type":1,"pageTitle":"Typegraph","url":"/docs/concepts/typegraph#types","content":"Types are the building block of typegraphs. They define a type system describing all data objects processed in Metatype. They can be easily extended to support new data types according to the needs of the application. t.struct( { &quot;id&quot;: t.uuid(), &quot;age&quot;: t.integer(), &quot;cars&quot;: t.array( t.struct( { &quot;model&quot;: t.string(), &quot;name&quot;: t.string().optional(), } ) ), } )  Analogy in SQL: types are similar to the Data Definition Language (DDL) with the extended capacity of describing any type of data. ","version":"Next","tagName":"h2"},{"title":"Materializers​","type":1,"pageTitle":"Typegraph","url":"/docs/concepts/typegraph#materializers","content":"Types can also describe functions and materializers define how the input type gets transformed into the output type. The input and output types are similar to a function signature and a materializer to its implementation, except that it might not always know what the function body is. In such case, the materializer knows at least where and how to access it. t.func( t.struct({&quot;input&quot;: t.string()}), t.string(), PureFunMat(&quot;({ input }) =&gt; `hello ${input}`&quot;), # with logic ) t.func( t.struct({}), t.enum([&quot;head&quot;, &quot;tail&quot;]), RESTMat( http, &quot;GET&quot;, &quot;/flip_coin&quot;, effect=effects.none ), # where the logic is )  Analogy in SQL: a materializer is similar to a join, a function, or an alias. ","version":"Next","tagName":"h2"},{"title":"Runtimes​","type":1,"pageTitle":"Typegraph","url":"/docs/concepts/typegraph#runtimes","content":"Every type and materializer have a runtime associated to it. This runtime describes where the types or materializers are physically located. It can be another API, a database, or any other services the typegate can connect to. The typegates uses that information to optimize the execution of the queries and minimize the amount of data moved. In practice, materializers are often not explicitly used and the usage of runtime sugar syntax is preferred. http = HTTPRuntime(&quot;https://random.org/api&quot;) # same func as above http.get( &quot;/flip_coin&quot;, t.struct({}), t.enum([&quot;head&quot;, &quot;tail&quot;]) ) # implicitly attaches runtime to all types  Analogy in SQL: a runtime is similar to a database instance running some requests. ","version":"Next","tagName":"h2"},{"title":"Policies​","type":1,"pageTitle":"Typegraph","url":"/docs/concepts/typegraph#policies","content":"Policies are a special type of function t.func(t.struct({...}), t.boolean().optional()) attachable to any other type. They are evaluated once per request and determine whether one of the polices authorizes the access or not. They receive the request context (see typegate) as argument allowing you to implement authorization, access control, or any other business logic. The policy decision can be: true: the access is authorizedfalse: the access is deniednull: the access in inherited from the parent types public = Policy(PureFunMat(&quot;() =&gt; true&quot;)) team_only = Policy( PureFunMat(&quot;(ctx) =&gt; ctx.user.role === 'admin'&quot;) )  Analogy in SQL: policies are similar to Row Security Policies (RSP) or Row Level Security (RLS) concepts. ","version":"Next","tagName":"h2"},{"title":"Triggers​","type":1,"pageTitle":"Typegraph","url":"/docs/concepts/typegraph#triggers","content":"Triggers are events launching the execution of one or multiple functions. They fire when a GraphQL request is received for the specific typegraph. with TypeGraph(&quot;triggers&quot;) as g: # ... g.expose( flip=http.get( &quot;/flip_coin&quot;, t.struct({}), t.enum([&quot;head&quot;, &quot;tail&quot;]) ), default_policy=[public], )  Analogy in SQL: a trigger is similar to receiving a new query. ","version":"Next","tagName":"h2"},{"title":"Contributing","type":0,"sectionRef":"#","url":"/docs/guides/contributing","content":"","keywords":"","version":"Next"},{"title":"Prerequisites​","type":1,"pageTitle":"Contributing","url":"/docs/guides/contributing#prerequisites","content":"Install: RustPythonpipxPNPMDenoNode ","version":"Next","tagName":"h2"},{"title":"Essential packages for Linux / WSL​","type":1,"pageTitle":"Contributing","url":"/docs/guides/contributing#essential-packages-for-linux--wsl","content":"sudo apt install build-essential unzip pkg-config libssl-dev protobuf-compiler  ","version":"Next","tagName":"h3"},{"title":"Getting started​","type":1,"pageTitle":"Contributing","url":"/docs/guides/contributing#getting-started","content":"","version":"Next","tagName":"h2"},{"title":"Toolkit​","type":1,"pageTitle":"Contributing","url":"/docs/guides/contributing#toolkit","content":"# manage rust dependencies cargo install cargo-edit # task runner cargo install whiz # enforce style and good practice pipx install pre-commit # maange python dependencies pipx install poetry # clang sudo apt-get install libclang-dev # wasm runtime curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash  ","version":"Next","tagName":"h3"},{"title":"Initiate workspace​","type":1,"pageTitle":"Contributing","url":"/docs/guides/contributing#initiate-workspace","content":"# install git hooks pre-commit install # prepare python virtual environment python3 -m venv .venv source .venv/bin/activate # depends on your shell # run the task runner and it will install the remaining dependencies whiz  ","version":"Next","tagName":"h3"},{"title":"Testing​","type":1,"pageTitle":"Contributing","url":"/docs/guides/contributing#testing","content":"deno run -A dev/env.ts all # or only the env required (e.g. base prisma s3) cargo test deno run -A dev/test.ts cd typegraph/python &amp;&amp; pytest -s deno run -A dev/env.ts # shutdown all env  ","version":"Next","tagName":"h2"},{"title":"Using external functions","type":0,"sectionRef":"#","url":"/docs/guides/external-functions","content":"","keywords":"","version":"Next"},{"title":"Typegraph​","type":1,"pageTitle":"Using external functions","url":"/docs/guides/external-functions#typegraph","content":"  ","version":"Next","tagName":"h2"},{"title":"External function definition​","type":1,"pageTitle":"Using external functions","url":"/docs/guides/external-functions#external-function-definition","content":"// fib.ts const CACHE = [1, 1]; const MAX_CACHE_SIZE = 1000; export default function fib({ size }: { size: number }) { if (size &gt; MAX_CACHE_SIZE) { throw new Error(`unsupported size ${size} &gt; ${MAX_CACHE_SIZE}`); } let i = CACHE.length; while (i++ &lt; size) { CACHE.push(CACHE[i - 2] + CACHE[i - 3]); } return CACHE.slice(0, size); }  ","version":"Next","tagName":"h2"},{"title":"Generate crud with prisma","type":0,"sectionRef":"#","url":"/docs/guides/crud-with-prisma","content":"","keywords":"","version":"Next"},{"title":"Typegraph​","type":1,"pageTitle":"Generate crud with prisma","url":"/docs/guides/crud-with-prisma#typegraph","content":"from typegraph import TypeGraph, policies, t from typegraph.providers.prisma.runtimes.prisma import PrismaRuntime # import debugpy # debugpy.listen(5678) # debugpy.wait_for_client() with TypeGraph(name=&quot;blog&quot;) as g: db = PrismaRuntime(&quot;blog&quot;, &quot;POSTGRES&quot;) users = t.struct( { &quot;id&quot;: t.integer().as_id, &quot;name&quot;: t.string(), &quot;posts&quot;: t.array(g(&quot;Post&quot;)), &quot;profile&quot;: g(&quot;Profile&quot;).optional(), } ).named(&quot;User&quot;) profiles = t.struct( { &quot;id&quot;: t.integer().as_id, &quot;profilePic&quot;: t.string(), &quot;user&quot;: g(&quot;User&quot;), } ).named(&quot;Profile&quot;) posts = t.struct( { &quot;id&quot;: t.integer().as_id, &quot;content&quot;: t.string(), &quot;author&quot;: g(&quot;User&quot;), } ).named(&quot;Post&quot;) public = policies.public() g.expose( createUser=db.create(users).add_policy(public), findUniqueUser=db.find_unique(users).add_policy(public), findManyUsers=db.find_many(users).add_policy(public), updateUser=db.update(users).add_policy(public), deleteUser=db.delete(users).add_policy(public), createPost=db.create(posts).add_policy(public), findUniquePost=db.find_unique(posts).add_policy(public), findManyPosts=db.find_many(posts).add_policy(public), )  ","version":"Next","tagName":"h2"},{"title":"Importing graphql definitions","type":0,"sectionRef":"#","url":"/docs/guides/importing-graphql-definitions","content":"","keywords":"","version":"Next"},{"title":"Typegraph​","type":1,"pageTitle":"Importing graphql definitions","url":"/docs/guides/importing-graphql-definitions#typegraph","content":"  ","version":"Next","tagName":"h2"},{"title":"Importing openapi definitions","type":0,"sectionRef":"#","url":"/docs/guides/importing-openapi-definitions","content":"","keywords":"","version":"Next"},{"title":"Typegraph​","type":1,"pageTitle":"Importing openapi definitions","url":"/docs/guides/importing-openapi-definitions#typegraph","content":"  ","version":"Next","tagName":"h2"},{"title":"Uploading files to S3","type":0,"sectionRef":"#","url":"/docs/guides/files-upload","content":"","keywords":"","version":"Next"},{"title":"Typegraph​","type":1,"pageTitle":"Uploading files to S3","url":"/docs/guides/files-upload#typegraph","content":"TG_RETREND_S3_HOST=http://localhost:9000 TG_RETREND_S3_REGION=local TG_RETREND_S3_ACCESS_KEY=minio TG_RETREND_S3_SECRET_KEY=password TG_RETREND_S3_PATH_STYLE=true    ","version":"Next","tagName":"h2"},{"title":"Uploading file using presigned url​","type":1,"pageTitle":"Uploading files to S3","url":"/docs/guides/files-upload#uploading-file-using-presigned-url","content":"const image = await Deno.readFile(&quot;website/static/images/logo.png&quot;); // Get a presigned url const { data: { signUploadUrl: presigned }, } = await fetch(&quot;http://localhost:7891/retrend&quot;, { method: &quot;POST&quot;, body: JSON.stringify({ query: ` query SignUploadUrl($length: Int) { signUploadUrl(length: $length, path: &quot;my-super-image.png&quot;) } `, variables: { length: image.length, }, }), }).then((r) =&gt; r.json()); // Upload the file const upload = await fetch(presigned, { method: &quot;PUT&quot;, body: image, headers: { &quot;content-type&quot;: &quot;image/png&quot;, &quot;content-length&quot;: image.length, }, }); console.log(upload.status);  ","version":"Next","tagName":"h2"},{"title":"Uploading file using GraphQL multipart request​","type":1,"pageTitle":"Uploading files to S3","url":"/docs/guides/files-upload#uploading-file-using-graphql-multipart-request","content":"Metatype supportsGraphQL multipart requestfor uploading files. You may use one of the clients in thislistthat support GraphQL multipart request. const image = await Deno.readFile(&quot;website/static/images/logo.png&quot;); const formData = new FormData(); formData.append( &quot;operations&quot;, JSON.stringify({ query: ` mutation UploadImage($file: Upload!) { upload(file: $file) { id path size contentType } } `, variables: { file: null, }, }) ); formData.append(&quot;map&quot;, JSON.stringify({ 0: [&quot;variables.file&quot;] })); formData.append(&quot;0&quot;, image, &quot;logo.png&quot;); const upload = await fetch(&quot;http://localhost:7891/retrend&quot;, { method: &quot;POST&quot;, body: formData, }); console.log(await upload.json());  ","version":"Next","tagName":"h2"},{"title":"Self-hosting","type":0,"sectionRef":"#","url":"/docs/guides/self-hosting","content":"","keywords":"","version":"Next"},{"title":"Helm​","type":1,"pageTitle":"Self-hosting","url":"/docs/guides/self-hosting#helm","content":"Helm must be installed to use the charts. Please refer to Helm's documentation to get started. The chart can be accessed on the dedicatedrepository. Once Helm has been set up correctly, add the repo as follows: helm repo add metatype https://charts.metatype.dev helm show values metatype/typegate &gt; values.yml # customize values.yaml helm install my-gate --values values.yml metatype/typegate  ","version":"Next","tagName":"h2"},{"title":"Reference","type":0,"sectionRef":"#","url":"/docs/reference","content":"Reference","keywords":"","version":"Next"},{"title":"Ecosystem","type":0,"sectionRef":"#","url":"/docs/reference/ecosystem","content":"","keywords":"","version":"Next"},{"title":"Metatype​","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#metatype","content":"Metatype is the principal repository of the Metatype ecosystem. It contains the Meta CLI, the typegate and the typegraph components. ","version":"Next","tagName":"h2"},{"title":"Whiz​","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#whiz","content":"Whiz is a modern DAG/tasks runner for multi-platform monorepos. It enables to develop the core components of the ecosystem together and reloading only the necessary tasks on file change.  ","version":"Next","tagName":"h2"},{"title":"Lade​","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#lade","content":"Lade automatically load secrets from your preferred vault as environment variables, and clear them once your shell command is over. The Meta CLI bundles Lade and use it to load secret seamlessly into your typegates.  ","version":"Next","tagName":"h2"},{"title":"Python WASI reactor​","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#python-wasi-reactor","content":"Python WASI reactor is one of the runtimes bundled into the typegate. It allows to run Python scripts as WASI modules on the fly. ","version":"Next","tagName":"h2"},{"title":"Meta CLI","type":0,"sectionRef":"#","url":"/docs/reference/meta-cli","content":"Meta CLI You can download the binary executable fromreleases page on GitHub, make it executable and add it to your $PATH or use the method below to automate those steps. curl -fsSL https://raw.githubusercontent.com/metatypedev/metatype/main/installer.sh | bash meta upgrade # to upgrade to the latest version ","keywords":"","version":"Next"},{"title":"Configuration file","type":0,"sectionRef":"#","url":"/docs/reference/meta-cli/configuration-file","content":"","keywords":"","version":"Next"},{"title":"metatype.yml Example file​","type":1,"pageTitle":"Configuration file","url":"/docs/reference/meta-cli/configuration-file#metatypeyml-example-file","content":"typegates: dev: url: http://localhost:7890 username: admin password: password typegraphs: python: include: &quot;**/*.py&quot; materializers: prisma: migrations_path: &quot;migrations&quot;  ","version":"Next","tagName":"h2"},{"title":"Automatic secret loading support​","type":1,"pageTitle":"Configuration file","url":"/docs/reference/meta-cli/configuration-file#automatic-secret-loading-support","content":"Lade is a secret loading tool that transparently inject environment variables from a variety of sources. It works with Fish, Bash or Zsh and currently supports Doppler, Infisical and 1Password as vault source. To use Lade with Metatype, you can use the op://, infisical:// or doppler:// prefixes in your configuration file. It will then use the CLI of the vault to securely load the required secrets. For example: typegates: dev: url: http://localhost:7890 username: op://VAULT_NAME/SECRET_NAME/FIELD_NAME password: infisical://app.infisical.com/PROJECT_NAME/ENV_NAME/SECRET_NAME  ","version":"Next","tagName":"h2"},{"title":"Changelog","type":0,"sectionRef":"#","url":"/docs/reference/changelog","content":"","keywords":"","version":"Next"},{"title":"v0.1.12 (8/3/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v0112-832023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed","content":"New features 🎉​ chore: prepare release 0.1.12-0+dev by @github-actions in #383feat: more stable run by fixing little bugs + typegraph upgrade by @zifeo in #384 Full Changelog: v0.1.11...v0.1.12 ","version":"Next","tagName":"h3"},{"title":"v0.1.11 (8/2/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v0111-822023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-1","content":"New features 🎉​ docs: Documentation for types by @Natoandro in #348feat(Deno): support deno function defined in multiple files by @afmika in #345feat: improve SDKs and rest support by @zifeo in #350fix: Ensure hooks logging by @Natoandro in #357feat: wit component 3 by @zifeo in #366feat(gate): generate openapi over rest endpoints by @afmika in #365fix: enable introspection on system typegraphs by @afmika in #373docs: move some examples typegraph into how to guides reference or tests by @afmika in #374feat: Customize the generated prisma schema with the target database by @Natoandro in #359feat(wasi): add support for python def and python module by @afmika in #360feat: improve installer script + release 0.1.11 by @zifeo in #381 Full Changelog: v0.1.10...v0.1.11 ","version":"Next","tagName":"h3"},{"title":"v0.1.10 (6/29/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v0110-6292023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-2","content":"New features 🎉​ chore: prepare release 0.1.10-dev.0 by @github-actions in #326feat: remove cookie auth, fix typegraph detection, fix injection, add auth doc, add regression test for doc by @zifeo in #327feat: Configure S3 in secrets by @Natoandro in #336fix: Fix injection for GraphQL runtime by @Natoandro in #333feat: add oauth profiler, blog, comparison and small fixes by @zifeo in #338feat: New typegraph SDK by @Natoandro in #337fix: Fix migrations for target with prefix by @Natoandro in #344chore: release 0.1.10 by @zifeo in #347 Full Changelog: v0.1.9...v0.1.10 ","version":"Next","tagName":"h3"},{"title":"v0.1.10-dev.0 (5/31/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v0110-dev0-5312023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-3","content":"New features 🎉​ chore: prepare release 0.1.10-dev.0 by @github-actions in #326feat: remove cookie auth, fix typegraph detection, fix injection, add auth doc, add regression test for doc by @zifeo in #327 Full Changelog: v0.1.9...v0.1.10-dev.0 ","version":"Next","tagName":"h3"},{"title":"v0.1.9 (5/26/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v019-5262023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-4","content":"New features 🎉​ chore: prepare release 0.1.9-dev.0 by @github-actions in #310feat: change target default for meta dev/deploy by @zifeo in #314feat: fixed tmp dir creation and logging, make tests parallel by @zifeo in #313feat: ignore files without tg (MET-175) + temporal fixes by @zifeo in #315docs: introduce typegraph_std by @afmika in #316fix: all importers by @afmika in #311fix: Python typing error happening in example.py file by @Kazy in #319feat: File upload by @Natoandro in #312fix: GitHub(Importer) and validate names by @afmika in #322fix: add explicit error message by @afmika in #318doc(tuto): typo and missing highlight line by @Kazy in #320fix: typegraph name error (root) by @afmika in #324chore: prepare release v0.1.9 by @zifeo in #323 ","version":"Next","tagName":"h3"},{"title":"New Contributors​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#new-contributors","content":"@Kazy made their first contribution in #319 Full Changelog: v0.1.8...v0.1.9 ","version":"Next","tagName":"h3"},{"title":"v0.1.8 (5/16/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v018-5162023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-5","content":"New features 🎉​ MET-148: Optimized typecheck by @Natoandro in #300Struct autocomplete by @afmika in #289Update class syntax by @afmika in #301Add type hint for importers by @afmika in #302feat: rework landing page and small improvements by @zifeo in #303feat: update doc, improve design, some renaming and fix cors issue by @zifeo in #306Bug fixes by @Natoandro in #307Query result validator by @Natoandro in #304chore: prepare release 0.1.8 by @zifeo in #308 Full Changelog: v0.1.7...v0.1.8 ","version":"Next","tagName":"h3"},{"title":"v0.1.7 (5/2/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v017-522023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-6","content":"New features 🎉​ feat: rust typegraph sdk poc by @zifeo in #281feat: add prefix to deploy target by @zifeo in #298 Full Changelog: v0.1.6...v0.1.7 ","version":"Next","tagName":"h3"},{"title":"v0.1.6 (4/27/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v016-4272023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-7","content":"New features 🎉​ chore: prepare release 0.1.6-dev.0 by @github-actions in #275Improved CLI DX (bis2) by @Natoandro in #277fix: typo fix and pipeline change by @zifeo in #278MET-154: (gate) prisma runtime find does not support empty string by @afmika in #276feat: add better intro by @zifeo in #279MET-34: enable array of optional's by @afmika in #271feat: jwt regex + new build target + upgrade banner by @zifeo in #280feat: Injection switch by @Natoandro in #282MET-163: (prisma) type mismatch on contains for nested relation by @afmika in #284Change version from 0.1.6-dev.0 to 0.1.6 by @Natoandro in #285Disable build on aarch64-apple-darwin by @Natoandro in #287 Full Changelog: v0.1.5...v0.1.6 ","version":"Next","tagName":"h3"},{"title":"v0.1.5 (4/18/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v015-4182023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-8","content":"New features 🎉​ chore: prepare release 0.1.5-dev.0 by @github-actions in #265Fix either schema by @afmika in #262Fix: Unvalidated dynamic method call by @afmika in #269feat: deno coverage and small fixes by @zifeo in #272Improve CLI DX by @Natoandro in #268MET-112: gate better error message for invalid operation type by @afmika in #267feat: new command and for use cases on the website by @zifeo in #273 Full Changelog: v0.1.4...v0.1.5 ","version":"Next","tagName":"h3"},{"title":"v0.1.4 (4/11/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v014-4112023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-9","content":"New features 🎉​ Improved CLI DX by @Natoandro in #247chore: prepare release 0.1.4-dev.0 by @github-actions in #261feat: doctor, upgrade with version, static materializer and website updates by @zifeo in #263 Full Changelog: v0.1.3...v0.1.4 ","version":"Next","tagName":"h3"},{"title":"v0.1.3 (4/5/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v013-452023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-10","content":"New features 🎉​ chore: upgrade build dependencies by @zifeo in #255feat: secrets sync by @zifeo in #257Met-101: (copy) fix google service discovery in the tutorial by @afmika in #226feat: add oauth2 providers and upgrade lade for windows by @zifeo in #259MET-128: either should be supported in the introspection by @afmika in #243MET-143: support multi-runtime in all runtimes by @afmika in #258 Full Changelog: v0.1.1...v0.1.3 ","version":"Next","tagName":"h3"},{"title":"v0.1.1 (3/29/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v011-3292023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-11","content":"New features 🎉​ feat: improve jwt auth, support auth without provider, fix redis bug, fix typos by @zifeo in #244 Full Changelog: v0.1.0...v0.1.1 ","version":"Next","tagName":"h3"},{"title":"v0.1.0 (3/28/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v010-3282023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-12","content":"New features 🎉​ MET-129: prisma runtime object should only consider same runtime field by @afmika in #228feat: Optional relationships by @Natoandro in #238feat: messenger patterns, refactor and upgrades by @zifeo in #230 Full Changelog: https://github.com/metatypedev/metatype/commits/v0.1.0 ","version":"Next","tagName":"h3"},{"title":"v0.0.3-dev.6 (3/8/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v003-dev6-382023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-13","content":"New features 🎉​ chore: prepare release 0.0.3-dev.6 by @github-actions in #158fix: disable sentry on worker by @zifeo in #159chore(deps): bump schemars from 0.8.11 to 0.8.12 by @dependabot in #163chore(deps): bump syn from 1.0.108 to 1.0.109 by @dependabot in #162chore(deps): bump tempfile from 3.3.0 to 3.4.0 by @dependabot in #161chore(deps): bump actions/checkout from 2 to 3 by @dependabot in #160chore(deps): bump sentry from 0.29.3 to 0.30.0 by @dependabot in #164MET-118: handle optional and list values in t.union by @afmika in #165chore(deps): bump clap from 4.1.6 to 4.1.8 by @dependabot in #168chore(deps): bump tokio from 1.25.0 to 1.26.0 by @dependabot in #170chore(deps): bump crossbeam-channel from 0.5.6 to 0.5.7 by @dependabot in #167chore(deps-dev): bump ruff from 0.0.245 to 0.0.253 in /typegraph by @dependabot in #169chore(deps): bump temporal-client from 09a2e4f to 6d55691 by @dependabot in #172chore(deps): bump temporal-sdk-core-protos from 09a2e4f to 6d55691 by @dependabot in #171MET-8: http runtime name clash by @afmika in #148MET-67 graph implement full prisma mapping by @afmika in #111MET-73: Make policies configurable per effect by @Natoandro in #147Revert &quot;MET-67 graph implement full prisma mapping (#111)&quot; by @zifeo in #175chore(deps): bump indoc from 2.0.0 to 2.0.1 by @dependabot in #183chore(deps): bump temporal-sdk-core-protos from 6d55691 to 34a2d55 by @dependabot in #182chore(deps): bump thiserror from 1.0.38 to 1.0.39 by @dependabot in #181chore(deps): bump string_cache from 0.8.4 to 0.8.6 by @dependabot in #180chore(deps-dev): bump pytest from 7.2.1 to 7.2.2 in /typegraph by @dependabot in #178chore(deps-dev): bump ruff from 0.0.253 to 0.0.254 in /typegraph by @dependabot in #177chore(deps): bump serde_json from 1.0.93 to 1.0.94 by @dependabot in #179feat: add WasmEdge experiment runtime by @zifeo in #176feat: add lade support by @zifeo in #173feat: internal policy and remove external url by @zifeo in #174chore(deps): bump serde_yaml from 0.9.17 to 0.9.19 by @dependabot in #188chore(deps): bump lade-sdk from 0.2.2 to 0.3.1 by @dependabot in #184chore(deps): bump temporal-client from 34a2d55 to 606c417 by @dependabot in #186chore(deps): bump temporal-sdk-core-protos from 34a2d55 to 606c417 by @dependabot in #187chore(deps): bump async-trait from 0.1.65 to 0.1.66 by @dependabot in #185 Full Changelog: v0.0.3-dev.5...v0.0.3-dev.6 ","version":"Next","tagName":"h3"},{"title":"v0.0.3-dev.5 (2/24/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v003-dev5-2242023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-14","content":"New features 🎉​ chore(deps): bump temporal-sdk-core-protos from af26dee to 0d7908c by @dependabot in #142feat: add type node either by @msga-mmm in #110chore: prepare release 0.0.3-dev.5 by @github-actions in #146chore(deps): bump temporal-client from 0d7908c to 09a2e4f by @dependabot in #156chore(deps): bump syn from 1.0.107 to 1.0.108 by @dependabot in #155chore(deps): bump swc_ecma_codegen from 0.129.8 to 0.129.10 by @dependabot in #153chore(deps): bump swc_ecma_transforms_typescript from 0.164.10 to 0.164.11 by @dependabot in #154chore(deps): bump python-box from 7.0.0 to 7.0.1 in /typegraph by @dependabot in #151feat: better logging and fix deployment by @zifeo in #150 Full Changelog: v0.0.3-dev.4...v0.0.3-dev.5 ","version":"Next","tagName":"h3"},{"title":"v0.0.3-dev.4 (2/22/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v003-dev4-2222023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-15","content":"New features 🎉​ chore(meta-cli/codegen): make config file optional by @msga-mmm in #125chore(deps): bump temporal-sdk-core-protos from 17ceab7 to 454cbea by @dependabot in #127chore(deps): bump clap from 4.1.4 to 4.1.6 by @dependabot in #128chore(deps): bump temporal-sdk-core-protos from 454cbea to 00fc0ff by @dependabot in #132chore(deps): bump temporal-client from 454cbea to 00fc0ff by @dependabot in #131chore: prepare release 0.0.3-dev.4 by @github-actions in #130chore: upgrade dependency and unify dependency management by @zifeo in #140chore(deps): bump frozendict from 2.3.4 to 2.3.5 in /typegraph by @dependabot in #137 ","version":"Next","tagName":"h3"},{"title":"New Contributors​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#new-contributors-1","content":"@github-actions made their first contribution in #130 Full Changelog: v0.0.3-dev.3...v0.0.3-dev.4 ","version":"Next","tagName":"h3"},{"title":"v0.0.3-dev.3 (2/16/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v003-dev3-2162023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-16","content":"New features 🎉​ chore(deps): bump openssl-src from 111.24.0+1.1.1s to 111.25.0+1.1.1t by @dependabot in #106chore(deps): bump serde_json from 1.0.92 to 1.0.93 by @dependabot in #107chore(deps): bump sentry from 0.29.2 to 0.29.3 by @dependabot in #108chore(deps): bump dprint-plugin-typescript from 0.82.0 to 0.83.0 by @dependabot in #109Docs by @zifeo in #101feat(typegraph): support type union by @msga-mmm in #78chore(deps): bump thehanimo/pr-title-checker from 1.3.6 to 1.3.7 by @dependabot in #112chore(deps): bump self_update from 0.34.0 to 0.35.0 by @dependabot in #113Met 18: New way to use prisma runtime by @Natoandro in #105chore(deps): bump proc-macro2 from 1.0.50 to 1.0.51 by @dependabot in #119chore(deps): bump temporal-sdk-core-protos from 106b09f to 454cbea by @dependabot in #118chore: small fixes by @zifeo in #116Met 75 check all todos fixme in the project by @afmika in #90chore(deps): bump typing-extensions from 4.4.0 to 4.5.0 in /typegraph by @dependabot in #121chore: update Cargo.lock by @msga-mmm in #123 Full Changelog: v0.0.3-dev.2...v0.0.3-dev.3 ","version":"Next","tagName":"h3"},{"title":"v0.0.3-dev.2 (2/7/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v003-dev2-272023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-17","content":"New features 🎉​ add: system typegraph documentation and change build steps to avoid permission issues by @zifeo in #69refactor : rename allow_all into public by @afmika in #70chore: one more attempt at solving caching issue by @zifeo in #75chore(deps): bump peter-evans/create-pull-request from 3 to 4 by @dependabot in #71chore: one more attempt at solving caching issue by @zifeo in #79chore(deps-dev): bump flake8-docstrings from 1.6.0 to 1.7.0 in /typegraph by @dependabot in #76chore(deps): bump sentry from 0.29.1 to 0.29.2 by @dependabot in #77chore(deps): bump clap from 4.1.2 to 4.1.4 by @dependabot in #72chore(deps): bump temporal-client from feb6258 to a5a1a75 by @dependabot in #81chore(deps): bump temporal-sdk-core-protos from feb6258 to a5a1a75 by @dependabot in #80MET-9 : (http runtime) implement multipart form data by @afmika in #74chore(deps): bump thehanimo/pr-title-checker from 1.3.5 to 1.3.6 by @dependabot in #82chore(deps): bump docker/build-push-action from 3 to 4 by @dependabot in #87MET-72: Replace serial with effect by @Natoandro in #67Feat MET-39: Rewrite importers by @Natoandro in #62Upgrade Deno, refactor cache and add docs typegraph deployment by @zifeo in #89MET-54: branding graphiql by @zoharyAnd in #73chore(deps): bump temporal-sdk-core-protos from a5a1a75 to 106b09f by @dependabot in #91chore(deps): bump notify from 5.0.0 to 5.1.0 by @dependabot in #83chore(deps): bump tokio from 1.24.2 to 1.25.0 by @dependabot in #85fix: deploy by @zifeo in #92chore(deps): bump indoc from 1.0.8 to 2.0.0 by @dependabot in #86chore(deps): bump dprint-plugin-typescript from 0.80.2 to 0.81.1 by @dependabot in #84chore(deps): bump black from 22.12.0 to 23.1.0 in /typegraph by @dependabot in #93chore(deps): bump uuid from 1.2.2 to 1.3.0 by @dependabot in #94chore(deps): bump anyhow from 1.0.68 to 1.0.69 by @dependabot in #99chore(deps): bump serde_json from 1.0.91 to 1.0.92 by @dependabot in #98chore(deps): bump dprint-plugin-typescript from 0.81.1 to 0.82.0 by @dependabot in #97chore(deps): bump proc-macro2 from 1.0.50 to 1.0.51 by @dependabot in #96chore(deps): bump python-box from 6.1.0 to 7.0.0 in /typegraph by @dependabot in #95chore(deps): bump temporal-sdk-core-protos from 106b09f to 17ceab7 by @dependabot in #100Fix introspection by @Natoandro in #102Prepare release: 0.0.3-dev.2 by @Natoandro in #103 ","version":"Next","tagName":"h3"},{"title":"New Contributors​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#new-contributors-2","content":"@zoharyAnd made their first contribution in #73 Full Changelog: v0.0.3-dev.1...v0.0.3-dev.2 ","version":"Next","tagName":"h3"},{"title":"v0.0.3-dev.1 (1/24/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v003-dev1-1242023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-18","content":"New features 🎉​ Docs follow-up + refactoring by @zifeo in #54Refactor MET-51 handle better ffi crash by @afmika in #52Fix: TypeScript codegen by @Natoandro in #60(CLI) MET-57: Rewrite terminal documentation by @afmika in #61feat(meta-cli): link openssl statically by @msga-mmm in #65MET-86: Fix introspection by @Natoandro in #64feat MET-71: (GRAPH)Add policy.jwt by @afmika in #63Refactor, multiple fixes and add temporal runtime by @zifeo in #66 ","version":"Next","tagName":"h3"},{"title":"New Contributors​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#new-contributors-3","content":"@msga-mmm made their first contribution in #65 Full Changelog: v0.0.3-dev.0...v0.0.3-dev.1 ","version":"Next","tagName":"h3"},{"title":"v0.0.3-dev.0 (1/14/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v003-dev0-1142023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-19","content":"New features 🎉​ build: add dependabot by @zifeo in #9chore(deps-dev): bump flake8 from 5.0.4 to 6.0.0 in /website by @dependabot in #20chore(deps): bump docker/login-action from 1 to 2 by @dependabot in #13chore(deps): bump actions/checkout from 2 to 3 by @dependabot in #11chore: release improvement by @zifeo in #8chore(deps): bump pnpm/action-setup from 2.2.2 to 2.2.4 by @dependabot in #10chore(deps-dev): bump pytest-asyncio from 0.19.0 to 0.20.3 in /typegraph by @dependabot in #30chore(deps-dev): bump mypy from 0.982 to 0.991 in /typegraph by @dependabot in #26chore(deps): bump httpx from 0.22.0 to 0.23.3 in /typegraph by @dependabot in #25chore(deps): bump base64 from 0.13.1 to 0.20.0 by @dependabot in #29chore: upgrade rust deps by @zifeo in #31chore(deps): bump orjson from 3.8.4 to 3.8.5 in /typegraph by @dependabot in #33Add missing commands by @afmika in #47add changes to the doc by @afmika in #46feat(MET-38): Expose function inputs to the policy by @Natoandro in #4feat MET-12: Generate TypeScript type definitions from jsonschema by @Natoandro in #45Fix workflow for release by @Natoandro in #53 ","version":"Next","tagName":"h3"},{"title":"New Contributors​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#new-contributors-4","content":"@afmika made their first contribution in #47@Natoandro made their first contribution in #4 Full Changelog: v0.0.2-alpha.14...v0.0.3-dev.0 ","version":"Next","tagName":"h3"},{"title":"v0.0.2-alpha.14 (1/7/2023)​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#v002-alpha14-172023","content":"","version":"Next","tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#whats-changed-20","content":"New features 🎉​ build: improve pipeline and refactor cache by @zifeo in #5chore(deps): bump tokio from 1.23.0 to 1.23.1 by @dependabot in #6chore: release a14 by @zifeo in #7 ","version":"Next","tagName":"h3"},{"title":"New Contributors​","type":1,"pageTitle":"Changelog","url":"/docs/reference/changelog#new-contributors-5","content":"@zifeo made their first contribution in #5 Full Changelog: v0.0.2-alpha.13...v0.0.2-alpha.14 ","version":"Next","tagName":"h3"},{"title":"Runtimes","type":0,"sectionRef":"#","url":"/docs/reference/runtimes","content":"Runtimes The status represents the maturity of the runtime implementation: not documented: experiment at your own riskalpha: incomplete or non-stabilized API, most features should work you should expect breaking changes likelybeta: complete and almost-stable API, but still collecting feedbacks and improving usabilitystable: complete and stable API, no breaking changes expected Missing your favorite runtime? Submit your request and vote for your preferred ones here. Runtime\tDescription\tRuntime version\tStatus\tTypegate versionPrisma\tQuery SQL and no-SQL databases with Prisma\t4.17.0\tbeta\t&gt;0.1.0 Deno\tExecute Typescript functions with NPM or deno dependencies\t1.35.0\tbeta\t&gt;0.1.0 HTTP\tMake HTTP requests to (REST) HTTP APIs beta\t&gt;0.1.0 GraphQL\tMake GraphQL requests beta\t&gt;0.1.0 Random\tGenerate random data based on your schema alpha\t&gt;0.1.0 S3\tManipulate S3-compatible storage alpha\t&gt;0.1.0 Temporal\tQuery and trigger workflow orchestrated by Temporal alpha\t&gt;0.1.0 WasmEdge\tExecute WebAssembly functions alpha\t&gt;0.1.0 Python\tExecute Python functions alpha\t&gt;0.1.0","keywords":"","version":"Next"},{"title":"GraphQL runtime","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/graphql","content":"GraphQL runtime","keywords":"","version":"Next"},{"title":"Deno runtime","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/deno","content":"Deno runtime Example: # my_typegraph.py from typegraph import TypeGraph, policies, t from typegraph.runtimes.deno import ModuleMat, PureFunMat with TypeGraph(&quot;deno&quot;) as g: public = policies.public() g.expose( add=t.func( t.struct({&quot;a&quot;: t.number(), &quot;b&quot;: t.number()}), t.number(), ModuleMat(&quot;main.ts&quot;).imp(&quot;doAddition&quot;), ), simple=t.func( t.struct({&quot;a&quot;: t.number(), &quot;b&quot;: t.number()}), t.number(), PureFunMat(&quot;({ a, b }) =&gt; a + b&quot;), ), default_policy=[public], ) // main.ts interface AddInput { a: number; b: number; } export function doAddition({ a, b }: AddInput) { return a + b; } ","keywords":"","version":"Next"},{"title":"HTTP runtime","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/http","content":"HTTP runtime Example: from typegraph.runtime.http import HTTPRuntime remote = HTTPRuntime('https://dev.to/api') remote.get( '/test', t.struct({}), t.array(t.struct({'a': t.integer()})), ) ","keywords":"","version":"Next"},{"title":"Python runtime","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/python","content":"Python runtime Example: # my_typegraph.py from typegraph import TypeGraph, policies, t from typegraph.runtimes.python import Python, PyModuleMat with TypeGraph(&quot;example_python&quot;) as g: public = policies.public() python = Python() g.expose( add=t.func( t.struct({&quot;a&quot;: t.integer(), &quot;b&quot;: t.integer()}), t.integer(), python.from_lambda(lambda x: x[&quot;a&quot;] + x[&quot;b&quot;]), ), sayHello=t.func( t.struct({&quot;name&quot;: t.string()}), t.string(), PyModuleMat(&quot;hello.py&quot;).imp(&quot;say_hello&quot;), ), default_policy=[public], ) # hello.py def say_hello(x: any): return f&quot;Hello {x[&quot;name&quot;]}&quot; ","keywords":"","version":"Next"},{"title":"Prisma runtime","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/prisma","content":"","keywords":"","version":"Next"},{"title":"Usage​","type":1,"pageTitle":"Prisma runtime","url":"/docs/reference/runtimes/prisma#usage","content":"with TypeGraph(&quot;prisma-runtime-example&quot;) as g: db = PrismaRuntime(&quot;main_db&quot;, &quot;DB_CONNECTION&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email(), } ) g.expose( createUser=db.create(user).add_policy(public) )  ","version":"Next","tagName":"h2"},{"title":"Raw query​","type":1,"pageTitle":"Prisma runtime","url":"/docs/reference/runtimes/prisma#raw-query","content":"Generate a raw SQL query operation on the runtime db = PrismaRuntime(&quot;my-app&quot;, &quot;POSTGRES&quot;) g.expose( countUsers=db.raw_query(&quot;SELECT COUNT(*) FROM User&quot;, t.integer()) )  Generate a raw SQL query operation without return db = PrismaRuntime(&quot;my-app&quot;, &quot;POSTGRES&quot;) g.expose( setActive=db.raw_execute(&quot;UPDATE User SET active = TRUE WHERE id=$1&quot;, effect=effects.update()), )  ","version":"Next","tagName":"h3"},{"title":"Models​","type":1,"pageTitle":"Prisma runtime","url":"/docs/reference/runtimes/prisma#models","content":"Any t.struct that is passed to a generator of a PrismaRuntimedefines a model. Models must have an ID field specified by the &quot;id&quot; config. Here is the list of all the available configs for model fields: Config\tEffectid\tdefines the field ID for the model (a.k.a. primary key) auto\tthe value of this field can be auto generated; supported for t.integer() (auto-increment) and t.uuid() unique\tmake this field unique among all instances of the model ","version":"Next","tagName":"h2"},{"title":"Relationships​","type":1,"pageTitle":"Prisma runtime","url":"/docs/reference/runtimes/prisma#relationships","content":"Relationship fields must be defined on both sides of the relationship. A relationship is always defined for t.struct types and t.optional ort.array of t.struct. Relationships can also be defined implicitly using the link instance method of PrismaRuntime. runtime = PrismaRuntime(&quot;example&quot;, &quot;POSTGRES&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email().config(&quot;unique&quot;), &quot;posts&quot;: t.array(g(&quot;Post&quot;)), } ).named(&quot;User&quot;) post = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;title&quot;: t.string(), &quot;author&quot;: g(&quot;User&quot;), } ).named(&quot;Post&quot;)  The PrismaRuntime supports two kinds of relationship between models. ","version":"Next","tagName":"h2"},{"title":"One-to-one relationships​","type":1,"pageTitle":"Prisma runtime","url":"/docs/reference/runtimes/prisma#one-to-one-relationships","content":"A one-to-one relationship must be in one of these two variants. Cardinality\tField type in Model1\tField type in Model21..1 ↔ 0..1\tg(&quot;Model2&quot;)\tg(&quot;Model1&quot;).optional() 0..1 ↔ 0..1\tg(&quot;Model2&quot;).optional()\tg(&quot;Model1&quot;).optional() For the optional (0..1 ↔ 0..1) one-to-one relationship, you need to indicate on which field/model the foreign key will be by: wrapping the type in a runtime.link(.) with fkey=True:runtime.link(g(&quot;Model2&quot;).optional(), fkey=True); or adding .config(&quot;unique&quot;): g(&quot;Model2&quot;).optional().config(&quot;unique&quot;). ","version":"Next","tagName":"h3"},{"title":"One-to-many relationships​","type":1,"pageTitle":"Prisma runtime","url":"/docs/reference/runtimes/prisma#one-to-many-relationships","content":"A one-to-many relationship must be in one of these two variants. Cardinality\tField type in Model1\tField type in Model21..1 ↔ 0..n\tg(&quot;Model2&quot;)\tt.array(g(&quot;Model1&quot;)) 0..1 ↔ 0..n\tg(&quot;Model2&quot;).optional()\tt.array(g(&quot;Model1&quot;)) ","version":"Next","tagName":"h3"},{"title":"Many-to-many relationships​","type":1,"pageTitle":"Prisma runtime","url":"/docs/reference/runtimes/prisma#many-to-many-relationships","content":"Many-to-many relationships must be modelled explicitly using a join model. ","version":"Next","tagName":"h3"},{"title":"Link​","type":1,"pageTitle":"Prisma runtime","url":"/docs/reference/runtimes/prisma#link","content":"Explicitly declare a relationship between models. The return value of this function shall be the type of a property of a t.struct that defines a model. If the other end of the relationship is also defined using link, both links must have the same name. runtime = PrismaRuntime(&quot;example&quot;, &quot;POSTGRES&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email().config(&quot;unique&quot;), &quot;posts&quot;: runtime.link(t.array(g(&quot;Post&quot;)), &quot;postAuthor&quot;), } ).named(&quot;User&quot;) post = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;title&quot;: t.string(), &quot;author&quot;: runtime.link(g(&quot;User&quot;), &quot;postAuthor&quot;), } ).named(&quot;Post&quot;)  ","version":"Next","tagName":"h3"},{"title":"Generators​","type":1,"pageTitle":"Prisma runtime","url":"/docs/reference/runtimes/prisma#generators","content":"Generators are instance methods of PrismaRuntime that can be used to generate a t.func that represents a specific operation on a specific model of the runtime. They match to the model queries defined for theprisma client API. for the type of the input t.struct and the return type. Example: with TypeGraph(&quot;prisma-runtime-example&quot;) as g: db = PrismaRuntime(&quot;main_db&quot;, &quot;DB_CONNECTION&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email(), } ) g.expose( createUser=db.create(user).add_policy(public), findUser=db.find(user).add_policy(public), findManyUsers=db.find_many(user).add_policy(public), )  Here is a list of all available generators: find_uniquefind_firstfind_manycreateupdateupsertdeletedelete_many ","version":"Next","tagName":"h2"},{"title":"Random runtime","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/random","content":"Random runtime","keywords":"","version":"Next"},{"title":"Temporal runtime","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/temporal","content":"Temporal runtime Interacts with Temporal server.","keywords":"","version":"Next"},{"title":"S3 runtime","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/s3","content":"S3 runtime","keywords":"","version":"Next"},{"title":"WasmEdge runtime","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/wasmedge","content":"WasmEdge runtime Runs Wasm functions on the WasmEdge runtime.","keywords":"","version":"Next"},{"title":"Specifications","type":0,"sectionRef":"#","url":"/docs/reference/specifications","content":"","keywords":"","version":"Next"},{"title":"JSON Schema​","type":1,"pageTitle":"Specifications","url":"/docs/reference/specifications#json-schema","content":"v0.0.1 ","version":"Next","tagName":"h2"},{"title":"Typegate","type":0,"sectionRef":"#","url":"/docs/reference/typegate","content":"Typegate meta new your-folder cd your-folder docker compose up --detach docker compose logs typegate -f # to see the logs ","keywords":"","version":"Next"},{"title":"Mutations","type":0,"sectionRef":"#","url":"/docs/reference/typegate/internal-api/prisma-migration/mutations","content":"","keywords":"","version":"Next"},{"title":"apply​","type":1,"pageTitle":"Mutations","url":"/docs/reference/typegate/internal-api/prisma-migration/mutations#apply","content":"Type: object_23! apply field Policies: admin_only Arguments Name\tDescriptionresetDatabase Boolean! resetDatabase input field migrations String migrations input field runtime String runtime input field typegraph String! typegraph input field ","version":"Next","tagName":"h2"},{"title":"create​","type":1,"pageTitle":"Mutations","url":"/docs/reference/typegate/internal-api/prisma-migration/mutations#create","content":"Type: object_33! create field Policies: admin_only Arguments Name\tDescriptionapply Boolean! apply input field name String! name input field migrations String migrations input field runtime String runtime input field typegraph String! typegraph input field ","version":"Next","tagName":"h2"},{"title":"deploy​","type":1,"pageTitle":"Mutations","url":"/docs/reference/typegate/internal-api/prisma-migration/mutations#deploy","content":"Type: object_40! deploy field Policies: admin_only Arguments Name\tDescriptionmigrations String! migrations input field runtime String runtime input field typegraph String! typegraph input field ","version":"Next","tagName":"h2"},{"title":"reset​","type":1,"pageTitle":"Mutations","url":"/docs/reference/typegate/internal-api/prisma-migration/mutations#reset","content":"Type: Boolean! reset field Policies: admin_only Arguments Name\tDescriptionmigrations String migrations input field runtime String runtime input field typegraph String! typegraph input field ","version":"Next","tagName":"h2"},{"title":"Objects","type":0,"sectionRef":"#","url":"/docs/reference/typegate/internal-api/prisma-migration/objects","content":"","keywords":"","version":"Next"},{"title":"object_16​","type":1,"pageTitle":"Objects","url":"/docs/reference/typegate/internal-api/prisma-migration/objects#object_16","content":"object_16 type Fields Name\tDescriptionruntimeName String! runtimeName field Policies: inherit diff String diff field Policies: inherit ","version":"Next","tagName":"h2"},{"title":"object_23​","type":1,"pageTitle":"Objects","url":"/docs/reference/typegate/internal-api/prisma-migration/objects#object_23","content":"object_23 type Fields Name\tDescriptionappliedMigrations [String!]! appliedMigrations field Policies: inherit databaseReset Boolean! databaseReset field Policies: inherit ","version":"Next","tagName":"h2"},{"title":"object_33​","type":1,"pageTitle":"Objects","url":"/docs/reference/typegate/internal-api/prisma-migration/objects#object_33","content":"object_33 type Fields Name\tDescriptionruntimeName String! runtimeName field Policies: inherit migrations String! migrations field Policies: inherit applyError String applyError field Policies: inherit createdMigrationName String! createdMigrationName field Policies: inherit ","version":"Next","tagName":"h2"},{"title":"object_40​","type":1,"pageTitle":"Objects","url":"/docs/reference/typegate/internal-api/prisma-migration/objects#object_40","content":"object_40 type Fields Name\tDescriptionappliedMigrations [String!]! appliedMigrations field Policies: inherit migrationCount Int! migrationCount field Policies: inherit ","version":"Next","tagName":"h2"},{"title":"Queries","type":0,"sectionRef":"#","url":"/docs/reference/typegate/internal-api/prisma-migration/queries","content":"","keywords":"","version":"Next"},{"title":"diff​","type":1,"pageTitle":"Queries","url":"/docs/reference/typegate/internal-api/prisma-migration/queries#diff","content":"Type: object_16! diff field Policies: admin_only Arguments Name\tDescriptionscript Boolean! script input field runtime String runtime input field typegraph String! typegraph input field ","version":"Next","tagName":"h2"},{"title":"Type System","type":0,"sectionRef":"#","url":"/docs/reference/type-system","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Type System","url":"/docs/reference/type-system#overview","content":"Types are used to describe the data to be processed. They constrains the range of value that can be accepted as input data or expected as result on each computation running in a runtime. ","version":"Next","tagName":"h2"},{"title":"Scalar types​","type":1,"pageTitle":"Type System","url":"/docs/reference/type-system#scalar-types","content":"Type\tGraphQL type\tDescriptiont.integer()\tInt\tRepresents signed 32-bit integers. t.number()\tFloat\tRepresents signed double-precision values as specified by IEEE 754. t.float()\tFloat\tAlias to t.number(). t.boolean()\tBoolean\tRepresents true or false. t.string()\tString\tRepresents textual data as UTF-8 character sequences. t.file()\t—\tRepresents a file for upload. The following scalar types are aliases to a t.string() type with a specific format. t.uuid()t.json()t.email()t.uri()t.hostname()t.ean()t.phone()t.date()t.datetime() ","version":"Next","tagName":"h3"},{"title":"Non-scalar types​","type":1,"pageTitle":"Type System","url":"/docs/reference/type-system#non-scalar-types","content":"Type\tGraphQL type\tDescriptiont.optional()\tnullable\tRepresents a value that may be null. t.array()\tlist\tRepresents a list of values. t.struct()\tinterface\tRepresents a structured data value, consisting of fields which map to typed values. t.union()\tunion\tRepresents a value which can be one of a set of specified types. t.either()\tunion\tRepresents a value which can match one and only one of a set of specified types. t.func\t—\tRepresents an operation that has to be performed on the typegate. ","version":"Next","tagName":"h3"},{"title":"Type constraints​","type":1,"pageTitle":"Type System","url":"/docs/reference/type-system#type-constraints","content":"Type constraints define an additional narrowing of the range of values that can be accepted for the type. Example:The min constraint on the type t.integer() from typegraph import t # represents integers greater than or equal to `12` t.integer().min(12)  ","version":"Next","tagName":"h3"},{"title":"Names and type references​","type":1,"pageTitle":"Type System","url":"/docs/reference/type-system#names-and-type-references","content":"","version":"Next","tagName":"h3"},{"title":"Injection​","type":1,"pageTitle":"Type System","url":"/docs/reference/type-system#injection","content":"","version":"Next","tagName":"h3"},{"title":"Types​","type":1,"pageTitle":"Type System","url":"/docs/reference/type-system#types","content":"","version":"Next","tagName":"h2"},{"title":"t.boolean()​","type":1,"pageTitle":"Type System","url":"/docs/reference/type-system#tboolean","content":"from typegraph import t t.boolean()  The t.boolean() type represents boolean values, true or false. ","version":"Next","tagName":"h3"},{"title":"t.integer()​","type":1,"pageTitle":"Type System","url":"/docs/reference/type-system#tinteger","content":"The t.integer() type represents 32-bit integers. from typegraph import t t.integer()  Constraints​ Constraint\tDescriptionmin\tThe minimum value of the integer. max\tThe maximum value of the integer. x_min\tThe minimum value of the integer, exclusive. x_max\tThe maximum value of the integer, exclusive. multiple_of\tThe integer must be a multiple of this value. Examples​ from typegraph import t # non-negative integer t.integer().min(0) # an integer in the rage [18, 120) adult_age = t.integer().min(18).x_max(120) # an even integer t.integer().multiple_of(2)  ","version":"Next","tagName":"h3"},{"title":"t.number()​","type":1,"pageTitle":"Type System","url":"/docs/reference/type-system#tnumber","content":"from typegraph import t t.number()  The t.number() type represents numbers, stored in double precision floating-point format (IEEE 754). Constraints​ The t.number() type has the same constraints as t.integer(). See integer constraints. Aliases​ The following types are aliases to the t.number() type: t.float() ","version":"Next","tagName":"h3"},{"title":"t.string()​","type":1,"pageTitle":"Type System","url":"/docs/reference/type-system#tstring","content":"from typegraph import t t.string()  The t.string() type represents textual data represented as UTF-8 character sequences. Constraints​ Constraint\tType\tDescriptionmin\tInteger\tMinimum length of the string. max\tInteger\tMaximum length of the string. pattern\tString\tRegular expression pattern that the string must match. format\tString\tJSON schema format that the string must match. See below for the list of supported formats. Supported formats​ Here is the list of supported formats: uuidjsonemailurihostnameeanphonedatedate-time Examples​ from typegraph import t # a non-empty string of maximum 64 characters t.string().min(1).max(64) # a email address t.string().format(&quot;email&quot;) # a json data t.string().format(&quot;json&quot;)  Aliases​ Alias\tEquivalent declarationt.uuid()\tt.string().format(&quot;uuid&quot;) t.email()\tt.string().format(&quot;email&quot;) t.uri()\tt.string().format(&quot;uri&quot;) t.json\tt.string().format(&quot;json&quot;) t.ean()\tt.string().format(&quot;ean&quot;) t.phone()\tt.string().format(&quot;phone&quot;) t.date()\tt.string().format(&quot;date&quot;) t.datetime()\tt.string().format(&quot;date-time&quot;) ","version":"Next","tagName":"h3"},{"title":"t.file()​","type":1,"pageTitle":"Type System","url":"/docs/reference/type-system#tfile","content":"from typegraph import t t.file()  The t.file() represents files for upload. Type Constraints​ Constraint\tType\tDescriptionmin\tInteger\tMinimum size of the file in bytes. max\tInteger\tMaximum size of the file in bytes. allow\tArray of strings\tList of allowed content-types Examples​ from typegraph import t # A file of a minimum size of 1KB t.file().min(1024) # A JPEG or PNG file less than 2KB t.file().max(2048).allow([&quot;image/jpeg&quot;, &quot;image/png&quot;])  ","version":"Next","tagName":"h3"},{"title":"t.optional()​","type":1,"pageTitle":"Type System","url":"/docs/reference/type-system#toptional","content":"from typegraph import t t.optional(t.string()) t.string().optional() # equivalent syntactic sugar  Default value​ If the type is used as an input type, the default value can be specified using the .default() method. from typegraph import t t.string().optional().default(&quot;default value&quot;)  ","version":"Next","tagName":"h3"},{"title":"t.array()​","type":1,"pageTitle":"Type System","url":"/docs/reference/type-system#tarray","content":"from typegraph import t t.array(t.string())  The t.array() type represents a sequence of values of the same type. Constraints​ Constraint\tType\tDescriptionmin\tInteger\tMinimum number of items. max\tInteger\tMaximum number of items. unique_items\tBoolean\tWhether the items must be unique. Examples​ from typegraph import t # A list of strings t.array(t.string()) # A list of unique strings t.array(t.string()).unique_items() # A list of strings with at least 3 items # and at most 10 items t.array(t.string()).min(3).max(10)  ","version":"Next","tagName":"h3"},{"title":"t.struct()​","type":1,"pageTitle":"Type System","url":"/docs/reference/type-system#tstruct","content":"from typegraph import t user = t.struct({ &quot;id&quot;: t.uuid().as_id, &quot;email&quot;: t.email(), &quot;username&quot;: t.string().min(3).max(64), })  The t.struct() type represents structured data, consisting of fields which map to typed values. All the fields are required unless the corresponding type is wrapped int.optional(). In that case, the field is allowed to be missing from the data or be null. Constraints​ Constraint\tType\tDescriptionmin\tInteger\tMinimum number of fields. max\tInteger\tMaximum number of fields. Examples​ from typegraph import t # A user profile user = t.struct({ &quot;id&quot;: t.uuid().as_id, &quot;email&quot;: t.email(), &quot;username&quot;: t.string().min(3).max(64), }) # A user profile with an optional `name` field user = t.struct({ &quot;id&quot;: t.uuid().as_id, &quot;email&quot;: t.email(), &quot;username&quot;: t.string().min(3).max(64), &quot;name&quot;: t.optional(t.string().min(3).max(64)), })  ","version":"Next","tagName":"h3"},{"title":"t.union() and t.either()​","type":1,"pageTitle":"Type System","url":"/docs/reference/type-system#tunion-and-teither","content":"from typegraph import t t.union([t.string(), t.integer()]) t.either([t.string(), t.integer()])  The t.union type represents a value that can be of any of the specified types. The t.either type represents a value that must be of one and only one of the specified types. ","version":"Next","tagName":"h3"},{"title":"t.func()​","type":1,"pageTitle":"Type System","url":"/docs/reference/type-system#tfunc","content":"The t.func() type represents an operation to be performed on the typegate with the specified materializer. Usually, the functions are not defined explicitly, but rather created with the runtime instance. Parameters​ Parameter\tType\tDescriptioninput type\tt.struct()\tThe type of the input data. output type\tany type\tThe type of the output data. materializer\tMaterializer\tThe materializer to use to perform the operation/computation. Examples​ from typegraph import t from typegraph.runtimes.deno import FunMat from typegraph.providers.prisma.runtimes import PrismaRuntime with TypeGraph(&quot;math&quot;) as g: add = t.func( t.struct({ &quot;a&quot;: t.integer(), &quot;b&quot;: t.integer(), }), t.integer(), FunMat(&quot;(({a, b}) =&gt; a + b&quot;) ) g.expose(add=add) db = PrismaRuntime(&quot;main-db&quot;, &quot;POSTGRES&quot;) user = t.struct({ &quot;id&quot;: t.uuid().as_id, &quot;email&quot;: t.email(), &quot;username&quot;: t.string().min(3).max(64), }) g.expose(createUser=db.create(user))  ","version":"Next","tagName":"h3"},{"title":"Scalars","type":0,"sectionRef":"#","url":"/docs/reference/typegate/internal-api/prisma-migration/scalars","content":"","keywords":"","version":"Next"},{"title":"Boolean​","type":1,"pageTitle":"Scalars","url":"/docs/reference/typegate/internal-api/prisma-migration/scalars#boolean","content":"The Boolean scalar type represents true or false. ","version":"Next","tagName":"h2"},{"title":"Int​","type":1,"pageTitle":"Scalars","url":"/docs/reference/typegate/internal-api/prisma-migration/scalars#int","content":"The Int scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. ","version":"Next","tagName":"h2"},{"title":"String​","type":1,"pageTitle":"Scalars","url":"/docs/reference/typegate/internal-api/prisma-migration/scalars#string","content":"The String scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. ","version":"Next","tagName":"h2"},{"title":"Mutations","type":0,"sectionRef":"#","url":"/docs/reference/typegate/internal-api/typegate/mutations","content":"","keywords":"","version":"Next"},{"title":"addTypegraph​","type":1,"pageTitle":"Mutations","url":"/docs/reference/typegate/internal-api/typegate/mutations#addtypegraph","content":"Type: object_31! addTypegraph field Policies: admin_only Arguments Name\tDescriptioncliVersion String! cliVersion input field secrets String! secrets input field fromString String! fromString input field ","version":"Next","tagName":"h2"},{"title":"removeTypegraph​","type":1,"pageTitle":"Mutations","url":"/docs/reference/typegate/internal-api/typegate/mutations#removetypegraph","content":"Type: Int! removeTypegraph field Policies: admin_only Arguments Name\tDescriptionname String! name input field ","version":"Next","tagName":"h2"},{"title":"Queries","type":0,"sectionRef":"#","url":"/docs/reference/typegate/internal-api/typegate/queries","content":"","keywords":"","version":"Next"},{"title":"typegraph​","type":1,"pageTitle":"Queries","url":"/docs/reference/typegate/internal-api/typegate/queries#typegraph","content":"Type: object_13 typegraph field Policies: admin_only Arguments Name\tDescriptionname String! name input field ","version":"Next","tagName":"h2"},{"title":"typegraphs​","type":1,"pageTitle":"Queries","url":"/docs/reference/typegate/internal-api/typegate/queries#typegraphs","content":"Type: [typegraph!]! typegraphs field Policies: admin_only ","version":"Next","tagName":"h2"},{"title":"Objects","type":0,"sectionRef":"#","url":"/docs/reference/typegate/internal-api/typegate/objects","content":"","keywords":"","version":"Next"},{"title":"object_13​","type":1,"pageTitle":"Objects","url":"/docs/reference/typegate/internal-api/typegate/objects#object_13","content":"object_13 type Fields Name\tDescriptionserialized String! serialized field Policies: inherit url String! url field Policies: inherit name String! name field Policies: inherit ","version":"Next","tagName":"h2"},{"title":"object_23​","type":1,"pageTitle":"Objects","url":"/docs/reference/typegate/internal-api/typegate/objects#object_23","content":"object_23 type Fields Name\tDescriptiontext String! text field Policies: inherit type String! type field Policies: inherit ","version":"Next","tagName":"h2"},{"title":"object_27​","type":1,"pageTitle":"Objects","url":"/docs/reference/typegate/internal-api/typegate/objects#object_27","content":"object_27 type Fields Name\tDescriptionmigrations String! migrations field Policies: inherit runtime String! runtime field Policies: inherit ","version":"Next","tagName":"h2"},{"title":"object_31​","type":1,"pageTitle":"Objects","url":"/docs/reference/typegate/internal-api/typegate/objects#object_31","content":"object_31 type Fields Name\tDescriptionresetRequired [String!]! resetRequired field Policies: inherit migrations [object_27!]! migrations field Policies: inherit messages [object_23!]! messages field Policies: inherit name String! name field Policies: inherit ","version":"Next","tagName":"h2"},{"title":"typegraph​","type":1,"pageTitle":"Objects","url":"/docs/reference/typegate/internal-api/typegate/objects#typegraph","content":"typegraph type Fields Name\tDescriptionurl String! url field Policies: inherit name String! name field Policies: inherit ","version":"Next","tagName":"h2"},{"title":"Scalars","type":0,"sectionRef":"#","url":"/docs/reference/typegate/internal-api/typegate/scalars","content":"","keywords":"","version":"Next"},{"title":"Boolean​","type":1,"pageTitle":"Scalars","url":"/docs/reference/typegate/internal-api/typegate/scalars#boolean","content":"The Boolean scalar type represents true or false. ","version":"Next","tagName":"h2"},{"title":"Int​","type":1,"pageTitle":"Scalars","url":"/docs/reference/typegate/internal-api/typegate/scalars#int","content":"The Int scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. ","version":"Next","tagName":"h2"},{"title":"String​","type":1,"pageTitle":"Scalars","url":"/docs/reference/typegate/internal-api/typegate/scalars#string","content":"The String scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. ","version":"Next","tagName":"h2"},{"title":"Typegraph","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python","content":"Typegraph Create (and activate) the virtual environment (a local folder where you install the dependency of a project) for your project. Then install the typegraph package from PyPi using pip. python3 -m venv .venv source .venv/bin/activate pip3 install typegraph --upgrade meta doctor # to check version ","keywords":"","version":"Next"},{"title":"typegraph.graph.typegraph","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/graph/typegraph","content":"","keywords":"","version":"Next"},{"title":"TypeGraph Objects​","type":1,"pageTitle":"typegraph.graph.typegraph","url":"/docs/reference/typegraph/python/typegraph/graph/typegraph#typegraph-objects","content":"class TypeGraph()  type_by_names​ for explicit names get_absolute_path​ def get_absolute_path(relative: str, stack_depth: int = 1) -&gt; Path  Concat stack_depth-th immediate caller path with relative. By default, stack_depth is set to 1, this ensure that the file holding the definition of this function is not considered. ","version":"Next","tagName":"h2"},{"title":"typegraph.graph.models","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/graph/models","content":"","keywords":"","version":"Next"},{"title":"Auth Objects​","type":1,"pageTitle":"typegraph.graph.models","url":"/docs/reference/typegraph/python/typegraph/graph/models#auth-objects","content":"@define class Auth()  oauth2​ @classmethod def oauth2(cls, name: str, authorize_url: str, access_url: str, scopes: str, profile_url: Optional[str] = None, profiler: Optional[str] = None) -&gt; &quot;Auth&quot;  Documentation jwt​ @classmethod def jwt(cls, name: str, format: str, algorithm: None) -&gt; &quot;Auth&quot;  Documentation ","version":"Next","tagName":"h2"},{"title":"typegraph.importers.base.importer","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/importers/base/importer","content":"","keywords":"","version":"Next"},{"title":"Importer Objects​","type":1,"pageTitle":"typegraph.importers.base.importer","url":"/docs/reference/typegraph/python/typegraph/importers/base/importer#importer-objects","content":"class Importer()  Base importer class headers​ codegen header lines __init__​ def __init__(name: str, *, renames: Dict[str, str] = {}, keep_names: List[str] = [])  Arguments: name - name of the importerrenames - a dictionary mapping original (imported) names to exposed nameskeep_names - a list of names to keep as the original (imported) ","version":"Next","tagName":"h2"},{"title":"Import Objects​","type":1,"pageTitle":"typegraph.importers.base.importer","url":"/docs/reference/typegraph/python/typegraph/importers/base/importer#import-objects","content":"@frozen class Import()  types​ Dict[str, t.typedef] functions​ Dict[str, t.func] ","version":"Next","tagName":"h2"},{"title":"typegraph.injection","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/injection","content":"","keywords":"","version":"Next"},{"title":"StaticInjection Objects​","type":1,"pageTitle":"typegraph.injection","url":"/docs/reference/typegraph/python/typegraph/injection#staticinjection-objects","content":"@frozen class StaticInjection(Injection)  value​ json serialized data ","version":"Next","tagName":"h2"},{"title":"DynamicValueInjection Objects​","type":1,"pageTitle":"typegraph.injection","url":"/docs/reference/typegraph/python/typegraph/injection#dynamicvalueinjection-objects","content":"@frozen class DynamicValueInjection(Injection)  value​ generator name ","version":"Next","tagName":"h2"},{"title":"ContextInjection Objects​","type":1,"pageTitle":"typegraph.injection","url":"/docs/reference/typegraph/python/typegraph/injection#contextinjection-objects","content":"@frozen class ContextInjection(Injection)  value​ context name ","version":"Next","tagName":"h2"},{"title":"ParentInjection Objects​","type":1,"pageTitle":"typegraph.injection","url":"/docs/reference/typegraph/python/typegraph/injection#parentinjection-objects","content":"@frozen class ParentInjection(Injection)  value​ parent type ","version":"Next","tagName":"h2"},{"title":"SecretInjection Objects​","type":1,"pageTitle":"typegraph.injection","url":"/docs/reference/typegraph/python/typegraph/injection#secretinjection-objects","content":"@frozen class SecretInjection(Injection)  value​ secret name ","version":"Next","tagName":"h2"},{"title":"typegraph.importers.openapi","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/importers/openapi","content":"","keywords":"","version":"Next"},{"title":"OpenApiImporter Objects​","type":1,"pageTitle":"typegraph.importers.openapi","url":"/docs/reference/typegraph/python/typegraph/importers/openapi#openapiimporter-objects","content":"class OpenApiImporter(Importer)  __init__​ def __init__(name: str, *, url: Optional[str] = None, file: Optional[str] = None, base_url: Optional[str] = None, renames: Dict[str, str] = {}, keep_names: List[str] = [])  Requires either only url or file and base_url ","version":"Next","tagName":"h2"},{"title":"Path Objects​","type":1,"pageTitle":"typegraph.importers.openapi","url":"/docs/reference/typegraph/python/typegraph/importers/openapi#path-objects","content":"class Path()  gen_input_type​ def gen_input_type(op_spec: Box) -&gt; Tuple[t.typedef, Box]  Returns a tuple of t.typedef and a box of kwargs ","version":"Next","tagName":"h2"},{"title":"typegraph.providers.prisma.relations","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/providers/prisma/relations","content":"","keywords":"","version":"Next"},{"title":"RelationshipModel Objects​","type":1,"pageTitle":"typegraph.providers.prisma.relations","url":"/docs/reference/typegraph/python/typegraph/providers/prisma/relations#relationshipmodel-objects","content":"@frozen class RelationshipModel()  field​ field of this model pointing to the other side cardinality​ cardinality of the field pointing to the other model ","version":"Next","tagName":"h2"},{"title":"typegraph.providers.aws.runtimes.s3","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/providers/aws/runtimes/s3","content":"","keywords":"","version":"Next"},{"title":"S3Runtime Objects​","type":1,"pageTitle":"typegraph.providers.aws.runtimes.s3","url":"/docs/reference/typegraph/python/typegraph/providers/aws/runtimes/s3#s3runtime-objects","content":"@frozen class S3Runtime(Runtime)  Documentation ","version":"Next","tagName":"h2"},{"title":"typegraph.providers.prisma.schema","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/providers/prisma/schema","content":"","keywords":"","version":"Next"},{"title":"SchemaField Objects​","type":1,"pageTitle":"typegraph.providers.prisma.schema","url":"/docs/reference/typegraph/python/typegraph/providers/prisma/schema#schemafield-objects","content":"@frozen class SchemaField()  fkeys​ foreign keys ","version":"Next","tagName":"h2"},{"title":"typegraph.providers.prisma.runtimes.prisma","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/providers/prisma/runtimes/prisma","content":"","keywords":"","version":"Next"},{"title":"PrismaRuntime Objects​","type":1,"pageTitle":"typegraph.providers.prisma.runtimes.prisma","url":"/docs/reference/typegraph/python/typegraph/providers/prisma/runtimes/prisma#prismaruntime-objects","content":"@frozen class PrismaRuntime(Runtime)  Documentation Attributes: name - Name of prisma runtimeconnection_string_secret - Name of the secret that contains the connection string that will be used to connect to the database link​ def link(typ: Union[t.TypeNode, str], name: Optional[str] = None, *, field: Optional[str] = None, fkey: Optional[bool] = None) -&gt; t.TypeNode  Arguments: name - name of the relationshipfield - name of the target field on the target model ","version":"Next","tagName":"h2"},{"title":"typegraph.providers.temporal.runtimes.temporal","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/providers/temporal/runtimes/temporal","content":"","keywords":"","version":"Next"},{"title":"TemporalRuntime Objects​","type":1,"pageTitle":"typegraph.providers.temporal.runtimes.temporal","url":"/docs/reference/typegraph/python/typegraph/providers/temporal/runtimes/temporal#temporalruntime-objects","content":"@frozen class TemporalRuntime(Runtime)  Documentation ","version":"Next","tagName":"h2"},{"title":"typegraph.runtimes.graphql","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/runtimes/graphql","content":"","keywords":"","version":"Next"},{"title":"GraphQLRuntime Objects​","type":1,"pageTitle":"typegraph.runtimes.graphql","url":"/docs/reference/typegraph/python/typegraph/runtimes/graphql#graphqlruntime-objects","content":"@frozen class GraphQLRuntime(Runtime)  Documentation ","version":"Next","tagName":"h2"},{"title":"typegraph.runtimes.deno","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/runtimes/deno","content":"","keywords":"","version":"Next"},{"title":"DenoRuntime Objects​","type":1,"pageTitle":"typegraph.runtimes.deno","url":"/docs/reference/typegraph/python/typegraph/runtimes/deno#denoruntime-objects","content":"@frozen class DenoRuntime(Runtime)  Documentation ","version":"Next","tagName":"h2"},{"title":"ImportFunMat Objects​","type":1,"pageTitle":"typegraph.runtimes.deno","url":"/docs/reference/typegraph/python/typegraph/runtimes/deno#importfunmat-objects","content":"@frozen class ImportFunMat(Materializer)  runtime​ should be the same runtime as mod's ","version":"Next","tagName":"h2"},{"title":"ModuleMat Objects​","type":1,"pageTitle":"typegraph.runtimes.deno","url":"/docs/reference/typegraph/python/typegraph/runtimes/deno#modulemat-objects","content":"@frozen class ModuleMat(Materializer)  runtime​ DenoRuntime ","version":"Next","tagName":"h2"},{"title":"typegraph.runtimes.python","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/runtimes/python","content":"","keywords":"","version":"Next"},{"title":"Python Objects​","type":1,"pageTitle":"typegraph.runtimes.python","url":"/docs/reference/typegraph/python/typegraph/runtimes/python#python-objects","content":"@frozen class Python(Runtime)  Documentation ","version":"Next","tagName":"h2"},{"title":"ImportFunMat Objects​","type":1,"pageTitle":"typegraph.runtimes.python","url":"/docs/reference/typegraph/python/typegraph/runtimes/python#importfunmat-objects","content":"@frozen class ImportFunMat(Materializer)  runtime​ should be the same runtime as mod's ","version":"Next","tagName":"h2"},{"title":"typegraph.runtimes.http","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/runtimes/http","content":"","keywords":"","version":"Next"},{"title":"HTTPRuntime Objects​","type":1,"pageTitle":"typegraph.runtimes.http","url":"/docs/reference/typegraph/python/typegraph/runtimes/http#httpruntime-objects","content":"@frozen class HTTPRuntime(Runtime)  Documentation ","version":"Next","tagName":"h2"},{"title":"typegraph.runtimes.python_wasi","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/runtimes/python_wasi","content":"","keywords":"","version":"Next"},{"title":"Python Objects​","type":1,"pageTitle":"typegraph.runtimes.python_wasi","url":"/docs/reference/typegraph/python/typegraph/runtimes/python_wasi#python-objects","content":"@frozen class Python(Runtime)  https://metatype.dev/docs/reference/runtimes/python ","version":"Next","tagName":"h2"},{"title":"typegraph.runtimes.random","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/runtimes/random","content":"","keywords":"","version":"Next"},{"title":"RandomRuntime Objects​","type":1,"pageTitle":"typegraph.runtimes.random","url":"/docs/reference/typegraph/python/typegraph/runtimes/random#randomruntime-objects","content":"@frozen class RandomRuntime(Runtime)  Documentation ","version":"Next","tagName":"h2"},{"title":"typegraph.types","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/types","content":"","keywords":"","version":"Next"},{"title":"number_base Objects​","type":1,"pageTitle":"typegraph.types","url":"/docs/reference/typegraph/python/typegraph/types#number_base-objects","content":"@with_constraints @frozen class number_base(typedef)  See t.number() ","version":"Next","tagName":"h2"},{"title":"integer Objects​","type":1,"pageTitle":"typegraph.types","url":"/docs/reference/typegraph/python/typegraph/types#integer-objects","content":"@frozen class integer(number_base)  See t.integer() ","version":"Next","tagName":"h2"},{"title":"union Objects​","type":1,"pageTitle":"typegraph.types","url":"/docs/reference/typegraph/python/typegraph/types#union-objects","content":"@frozen class union(typedef)  A union type represents a general union with the variants provided. The union type is equivalent to the anyOf field in JSON Schema where the given data must be valid against one or more of the given subschemas. ","version":"Next","tagName":"h2"},{"title":"either Objects​","type":1,"pageTitle":"typegraph.types","url":"/docs/reference/typegraph/python/typegraph/types#either-objects","content":"@frozen class either(typedef)  An either type represents a disjoint union with the variants provided. The either type is equivalent to the oneOf field in JSON Schema where the given data must be valid against exactly one of the given subschemas. ","version":"Next","tagName":"h2"},{"title":"typegraph.runtimes.wasmedge","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/runtimes/wasmedge","content":"","keywords":"","version":"Next"},{"title":"WasmEdgeRuntime Objects​","type":1,"pageTitle":"typegraph.runtimes.wasmedge","url":"/docs/reference/typegraph/python/typegraph/runtimes/wasmedge#wasmedgeruntime-objects","content":"@frozen class WasmEdgeRuntime(Runtime)  Documentation ","version":"Next","tagName":"h2"},{"title":"Adding more runtimes","type":0,"sectionRef":"#","url":"/docs/tutorials/adding-more-runtimes","content":"","keywords":"","version":"Next"},{"title":"Prisma runtime​","type":1,"pageTitle":"Adding more runtimes","url":"/docs/tutorials/adding-more-runtimes#prisma-runtime","content":"Prisma is a &quot;Next-generation Node.js and Typescript ORM&quot; supporting PostgreSQL, MySQL/MariaDB, SQLite, MongoDB, CockroachDB and Microsoft SQL Server. It is one of the main runtimes provided by Metatype and doesn't require any additional installation. Go ahead and update typegraph.py with the highlighted lines below: Loading... A few things to note on the changes: You can import runtimes from typegraph.runtime.Y or typegraph.providers.X.runtimes.Y for non-core providers.The config method allows specifying runtime specific attributes. In this case, id shall be automatically set and incremented by the database.Types get generated names unless you manually specify them. You can find the exact names in the playground documentation. Here you want to have a human friendly name as it will also be the name of the table in your database.Runtimes often come with some sugar syntax to generate types and avoid manipulating materializers directly. A corresponding declaration would have looked like this: t.func( t.struct( { &quot;data&quot;: t.struct( { # notice to absence of `id` as automatically generated &quot;title&quot;: t.string(), &quot;body&quot;: t.string(), } ) } ), t.array(message), PrismaOperationMat( db, &quot;Message&quot;, &quot;createOne&quot;, effect=effects.create(), ), )  In order to use the Prisma runtime, you need to add a new environment variable. Runtimes don't take raw secrets, but instead a secret key used to look up environment variables named under the format TG_[typegraph name]_[key]. You can either add it in your metatype.yml (recommended) or in your compose.yml. $ cat metatype.yml typegates: dev: # .. env: TG_DATABASE_POSTGRES_CONN: postgres://postgres:password@postgres:5432/db $ meta dev  And now, you can iteratively continue to improve your interface, running migrations and having data stored inside your database. ","version":"Next","tagName":"h2"},{"title":"GraphQL runtime​","type":1,"pageTitle":"Adding more runtimes","url":"/docs/tutorials/adding-more-runtimes#graphql-runtime","content":"You currently have a single model to describe messages sent in the chat-based app. A reasonable next step is to add a user model and make a link between the two. While you can store users in the same database, it's wiser to avoid data duplication and re-use your service for user management available at GraphQLZero endpoint. Let's introduce the GraphQL runtime that allows remote GraphQL queries. Update typegraph.py with the highlighted lines below: Loading... Again, a few interesting happened here: No migration has been run. The field user comes from another runtime and doesn't exist in the database. The typegate will orchestrate the query execution in all runtimes and minimize the work done.The from_parent rule automatically fills the input type with the parent field named uid. The g(·) rule allows making named reference to another type and avoid circular reference. Other type enforcement rules also exists: from_secret(key) to fill the input type with the secret in the TG_[typegraph name]_[key] formatfrom_context(·) to fill the input type with content from the request context, such as JSON Web Token (JWT), etc.set(x) to fill the input type with content x You should now start to see the power provided by Metatype and might wonder how to integrate it step by step with your existing systems. Writing all those types by hand is tedious and error-prone. The next section will show you how to generate types from existing sources. ","version":"Next","tagName":"h2"},{"title":"typegraph.utils.sanitizers","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/python/typegraph/utils/sanitizers","content":"typegraph.utils.sanitizers inject_params​ def inject_params(s: str, params: Union[None, Dict[str, str]]) Example: s = &quot;{protocol}://{hostname}&quot;, params= {'protocol': 'http', 'hostname': 'example.com'} returns &quot;http://example.com&quot; as_attr​ def as_attr(name: str) Convert a string into valid attribute Example: root:some complicated/Name =&gt; root_some_complicated_Name","keywords":"","version":"Next"},{"title":"Authentication and security","type":0,"sectionRef":"#","url":"/docs/tutorials/authentication-and-security","content":"","keywords":"","version":"Next"},{"title":"CORS​","type":1,"pageTitle":"Authentication and security","url":"/docs/tutorials/authentication-and-security#cors","content":"Cross-Origin Resource Sharing (CORS) on the one hand is a mechanism that allows or denies cross-origin requests in the browser. It avoids that other websites use your API without explicitly allowing it. Note that it doesn't protect other servers or a mobile app from using your typegraphs, only browsers implements the CORS mechanism. See this documentation for the details. Loading... If your browser support well CORS, you should see an error and even more if you try to run the interactive demo. By the way, there is a hidden core header in all interactive demos you have met so far: TypeGraph.Cors(allow_origin=[&quot;https://metatype.dev&quot;, &quot;http://localhost:3000&quot;])  ","version":"Next","tagName":"h2"},{"title":"Authentication​","type":1,"pageTitle":"Authentication and security","url":"/docs/tutorials/authentication-and-security#authentication","content":"Metatype supports multiple authentication schemes: Basic authentication, JSON Web Tokens (JWT) and OAuth2. This enables every request to have a context and store some information about the user. You can then use the context to set specific fields with from_context or as you will see next step, to restrict accesses via the policies. For your app, you will use basic authentication in order to restrict some actions for admin users. In order to do so, adding the following secret to your metatype.yml file: TG_AUTHENTICATION_BASIC_ADMIN=password. Loading... ","version":"Next","tagName":"h2"},{"title":"Rate limiting​","type":1,"pageTitle":"Authentication and security","url":"/docs/tutorials/authentication-and-security#rate-limiting","content":"The rate limiting algorithm works as follows: each function type can either count the # of calls it gets or the # of results returned rate_calls=Falseeach function type can have a weight rate_weight=1each request is identified by its IP or by one value of its context if set context_identifiera single query can score a maximum of query_limitmultiple queries can sum up to window_limit in a window_sec windowwhen there is multiple typegates (N), you can improve performance by avoiding score synchronizing while the typegate has not reached local_excess: the real maximum score is thus window_limit + min(local_excess, query_limit) * N Loading... Playing with the above should allow you to quickly hit the limits. ","version":"Next","tagName":"h2"},{"title":"Getting started","type":0,"sectionRef":"#","url":"/docs/tutorials/getting-started","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Getting started","url":"/docs/tutorials/getting-started#introduction","content":"In this tutorial, you will write your first typegraph and deploy it on a typegate node using the Meta CLI. You will design some APIs for a chat-based app where users can exchange messages. Running the ecosystem requires Python &gt;=3.8 which should be available on most of the recent OS. Python &gt;=3.8 not yet installed? Follow these steps. Debian-based LinuxMacOSWindows sudo apt-get update sudo apt-get install python3 python3-pip python3-venv Then verify that you have a version higher than 3.8: python --version # or python3 --version # Python 3.8.16  No previous Python knowledge required. While the definition of typegraphs is currently done in Python, it doesn't require previous experience writing Python. The tutorial covers all the basics and doesn't use advanced features of the language. ","version":"Next","tagName":"h2"},{"title":"Quickstart with Metatype Cloud​","type":1,"pageTitle":"Getting started","url":"/docs/tutorials/getting-started#quickstart-with-metatype-cloud","content":"This is the easiest way to get started, yet it's not publicly accessible. You can sign-up for the private beta below.  ","version":"Next","tagName":"h2"},{"title":"Quickstart with Docker​","type":1,"pageTitle":"Getting started","url":"/docs/tutorials/getting-started#quickstart-with-docker","content":"Docker not yet installed? Follow these steps. Debian-based LinuxMacOSWindows curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh  ","version":"Next","tagName":"h2"},{"title":"1. Meta CLI​","type":1,"pageTitle":"Getting started","url":"/docs/tutorials/getting-started#1-meta-cli","content":"You can download the binary executable fromreleases page on GitHub, make it executable and add it to your $PATH or use the method below to automate those steps. curl -fsSL https://raw.githubusercontent.com/metatypedev/metatype/main/installer.sh | bash meta upgrade # to upgrade to the latest version  ","version":"Next","tagName":"h3"},{"title":"2. Typegraph package​","type":1,"pageTitle":"Getting started","url":"/docs/tutorials/getting-started#2-typegraph-package","content":"Create (and activate) the virtual environment (a local folder where you install the dependency of a project) for your project. Then install the typegraph package from PyPi using pip. python3 -m venv .venv source .venv/bin/activate pip3 install typegraph --upgrade meta doctor # to check version  ","version":"Next","tagName":"h3"},{"title":"3. Typegate node​","type":1,"pageTitle":"Getting started","url":"/docs/tutorials/getting-started#3-typegate-node","content":"Finally, download and launch the docker-compose manifest running a typegate node, a Redis instance (this is the sole dependency of the typegate) and a Postgres instance to store the app's messages. meta new your-folder cd your-folder docker compose up --detach docker compose logs typegate -f # to see the logs  And go the next section. Alternative installation from source Alternatively, you can install directly the typegraph package and the CLI from the GitHub repository (useful to check out unreleased features). pip3 install --upgrade git+https://github.com/metatypedev/metatype#subdirectory=typegraph cargo install --force meta-cli --git https://github.com/metatypedev/metatype --locked  ","version":"Next","tagName":"h3"},{"title":"Policies and materializers","type":0,"sectionRef":"#","url":"/docs/tutorials/policies-and-materializers","content":"","keywords":"","version":"Next"},{"title":"Deno runtime​","type":1,"pageTitle":"Policies and materializers","url":"/docs/tutorials/policies-and-materializers#deno-runtime","content":"While the tutorial covered already interesting runtimes, allowing you to connect to already a lot of systems and different protocols, there is still one powerful that wasn't covered yet: the typescript or Deno runtime. This enables to run lightweight and short-lived typescript function in a sandboxed environment. Permissions can be customized per typegraph and by default only include some HTTPs domains. It's a great way to implement custom logic and materializers. All typegraphs can lazily spawn a web worker and get an incredible cold-start and continuous performance thanks to the V8 engine powering Deno. Loading... ","version":"Next","tagName":"h2"},{"title":"Policy based access control (PBAC)​","type":1,"pageTitle":"Policies and materializers","url":"/docs/tutorials/policies-and-materializers#policy-based-access-control-pbac","content":"The Deno runtime enable to understand the last abstraction. Policies are a way to verify for each type whether the user is authorized or not to access it. It's a very powerful concept that can be for instance used to guarantee a given type is never accidentally exposed to the outside world. Metatype comes with some built-in policies, but you can use the Deno runtime to define your own: policies.public() is an alias for Policy(PureFunMat(&quot;() =&gt; true&quot;)) providing everyone open access.policies.ctx(&quot;role_value&quot;, &quot;role_field&quot;) is a companion policy for the authentication strategy you learned in the previous section. It will verify the context and give adequate access to the user. Policies are hierarchical in the sense that the request starts with a denial, and the root materializers must explicitly provide an access or not. Once access granted, any further types can either inherit or override the access. Policies evaluate in order in case multiple ones are defined. Loading... Enough studied, let's go back to your app and finalize it. ","version":"Next","tagName":"h2"},{"title":"Your chat app","type":0,"sectionRef":"#","url":"/docs/tutorials/your-chat-app","content":"","keywords":"","version":"Next"},{"title":"External typescript function​","type":1,"pageTitle":"Your chat app","url":"/docs/tutorials/your-chat-app#external-typescript-function","content":"The Deno runtime can register external files for longer functions. You can use the meta CLI to generate the types once the ModuleMat has been defined in your typegraph: meta codegen deno -f typegraph.py. The external function offers three arguments: the first one is the arguments received as inputthe second one contains additional information about the request, including the context of the userthe last one offers helpers functions to make authenticated calls to the same typegraph // Copyright Metatype OÜ, licensed under the Elastic License 2.0. // SPDX-License-Identifier: Elastic-2.0 import * as emoji from &quot;https://deno.land/x/emoji@0.2.1/mod.ts&quot;; interface ISend { title: string; } export default async function ( { title }: ISend, { context }, { gql }, ): Promise&lt;boolean&gt; { const text = `New message: ${title} from ${context.user.name} ${ emoji(&quot;coffee&quot;) }`; const messageQuery = gql` mutation db($title: String!, $user_id: Int!) { create_message(data: {title: $title, user_id: $user_id}) { id } } `; const message = await messageQuery( { title: text, user_id: context.user.id }, ); console.log(`created message ${message.data.db.create_message.id}`); const notifQuery = gql` mutation fcm { send_notification } `; const notif = await notifQuery(); console.log(`created notif ${notif.data.fcm.send_notification}`); return true; }  ","version":"Next","tagName":"h2"},{"title":"Connecting the pieces together​","type":1,"pageTitle":"Your chat app","url":"/docs/tutorials/your-chat-app#connecting-the-pieces-together","content":"Take the learning of the last sections and use at your advantage the internal policies allowing to made calls within the Deno runtime and keeping the same context. Loading... That's it, you just developed chat-based API for your app - simple for sure, but covering most of the feature of Metatype. ","version":"Next","tagName":"h2"},{"title":"Your first typegraph","type":0,"sectionRef":"#","url":"/docs/tutorials/your-first-typegraph","content":"","keywords":"","version":"Next"},{"title":"Zooming on the types​","type":1,"pageTitle":"Your first typegraph","url":"/docs/tutorials/your-first-typegraph#zooming-on-the-types","content":"There is no &quot;object&quot; or &quot;primitive&quot; type, only 4 main categories of types: value types: t.integer(), t.string(), t.uuid(), etc.quantifier types: t.optional(·), t.array(·), etc.consolidator types: t.struct(·, ·), t.union(·, ·), etc.function types: t.func(· → ·), t.policy(· → ·), etc. You can combine them with each other to describe almost any data type you may need. The typegate enforces the data validation when data flows through it. Some syntactic sugar is available to make the type definition shorter: t.struct( { &quot;name&quot;: t.string().max(200), &quot;age&quot;: t.optional( t.integer() ), # or t.integer().optional() &quot;messages&quot;: t.array( t.struct({&quot;text&quot;: t.string(), &quot;sentAt&quot;: t.datetime()}) ), } ) # the typegate will accept data as follow { &quot;name&quot;: &quot;Alan&quot;, &quot;age&quot;: 28, &quot;messages&quot;: [ {&quot;text&quot;: &quot;Hello!&quot;, &quot;sentAt&quot;: &quot;2022-12-28T01:11:10Z&quot;} ], } # and reject invalid data {&quot;name&quot;: &quot;Turing&quot;, &quot;messages&quot;: [{&quot;sentAt&quot;: 1}]}  ","version":"Next","tagName":"h2"},{"title":"The typegraph package​","type":1,"pageTitle":"Your first typegraph","url":"/docs/tutorials/your-first-typegraph#the-typegraph-package","content":"The typegraph package is a Python package that allows to describe a full typegraph. It's a thin wrapper around the type system, and provides a few helpers to make the typegraph definition easier. It builds on the type system to provide some more building blocks: what data types exists → value, quantifier, consolidator typeshow these data get transformed → function types and materializers that specify the transformationwhere these data and transformations run → runtimes that describe materializers operatewho can access them → a special case of function types named policies that control accesses This tutorial will cover these abstractions concept by concept and show how to use them by example. Code sample are interactive You can interact with most of the typegraph in the documentation. Press command/ctrl + enter to submit the selected query or use the &quot;play&quot; button. Some parts might be voluntarily hidden and full source can be found by clicking on the link. A complete typegraph definition may look like the following: Loading... To start with the chat app design, copy the typegraph into the file named example.py next to your compose.yml file. ","version":"Next","tagName":"h2"},{"title":"The meta CLI​","type":1,"pageTitle":"Your first typegraph","url":"/docs/tutorials/your-first-typegraph#the-meta-cli","content":"The meta CLI use a YAML configuration file to source some information and avoid typing the same arguments over and over again. Copy the following into named metatype.yml also next to previous files: typegates: dev: url: &quot;http://localhost:7890&quot; # default values username: admin password: password typegraphs: python: include: &quot;**/*.py&quot;  At this point, you should have everything ready for your first typegraph. Run the following command in your terminal: $ ls -1a ./ ../ .venv/ api/ compose.yml metatype.yml pyproject.toml $ ls -1a api ./ ../ example.py $ meta dev Loaded 1 typegraph from ./api/example.py: → Pushing typegraph first-typegraph... ✓ Success!  You can now open http://localhost:7890/first-typegraph in your browser. The CLI will automatically watch for changes in the typegraph and reload the typegraph. You should see a GraphQL playground with a query editor and some auto-generated documentation clicking the top-left menu item. Congrats, you can now to play with your first typegraph!  ","version":"Next","tagName":"h2"},{"title":"Import your existing APIs","type":0,"sectionRef":"#","url":"/docs/tutorials/import-your-existing-apis","content":"","keywords":"","version":"Next"},{"title":"Google importers​","type":1,"pageTitle":"Import your existing APIs","url":"/docs/tutorials/import-your-existing-apis#google-importers","content":"The typegraph module comes with some handy importers to avoid having to rewrite manually all types and materializers. Currently, it supports importers for OpenAPI, GraphQL API and Google APIs. Beta/unstable feature Importers are quite recent and likely to evolve as feedback is received. Your voice and use cases matter a lot, let Metatype community know what suits you the best in this discussion. Importers are function call with a boolean re-writing the source code file where they live. As they can generate quite long type definition, the best practice is to separate them into a dedicated file that can be imported into your main typegraph. Let's create google.py and run python google.py to generate the types. from typegraph.importers.google_discovery import ( GoogleDiscoveryImporter, ) GoogleDiscoveryImporter( &quot;googleapi&quot;, url=&quot;https://fcm.googleapis.com/$discovery/rest?version=v1&quot;, ).imp(False)  This should generate code similar to this: def import_googleapi(): # ... types[&quot;MessageOut&quot;] = t.struct( { &quot;token&quot;: t.string().optional(), &quot;name&quot;: t.string().optional(), &quot;condition&quot;: t.string().optional(), &quot;data&quot;: t.struct({&quot;_&quot;: t.string().optional()}).optional(), &quot;fcmOptions&quot;: t.proxy( renames[&quot;FcmOptionsOut&quot;] ).optional(), &quot;notification&quot;: t.proxy( renames[&quot;NotificationOut&quot;] ).optional(), &quot;android&quot;: t.proxy( renames[&quot;AndroidConfigOut&quot;] ).optional(), &quot;topic&quot;: t.string().optional(), &quot;apns&quot;: t.proxy(renames[&quot;ApnsConfigOut&quot;]).optional(), &quot;webpush&quot;: t.proxy( renames[&quot;WebpushConfigOut&quot;] ).optional(), &quot;error&quot;: t.proxy(renames[&quot;ErrorResponse&quot;]).optional(), } ).named(renames[&quot;MessageOut&quot;]) # ... return Import( importer=&quot;googleapi&quot;, renames=renames, types=Box(types), functions=Box(functions), )  And can be imported/customized in your main typegraph file: Loading... ","version":"Next","tagName":"h2"},{"title":"Effects​","type":1,"pageTitle":"Import your existing APIs","url":"/docs/tutorials/import-your-existing-apis#effects","content":"Effects are a property of materializers and help categorization what happens to data when it gets transformed. Although they are similar to REST verbs and SQL statements, there is no direct one-to-one mapping. Effects\tREST verbs\tSQL statementsnone\tGET\tSELECT create\tPOST\tINSERT update\tPUT/PATCH\tUPDATE upsert\tPUT\tINSERT ON CONFLICT delete\tDELETE\tDELETE They provide hints to the typegates for the query orchestration by splitting the queries and mutations. For example, the create effect is exposed as a mutation. They also allow setting different policies based on them, that's for the next page. ","version":"Next","tagName":"h2"},{"title":"Introduction to typegraph_std​","type":1,"pageTitle":"Import your existing APIs","url":"/docs/tutorials/import-your-existing-apis#introduction-to-typegraph_std","content":"Alternatively, you can use the typegraph_std for the most common APIs. It comes as a separate package so instead of maintening your own importers, you can use typegraph_std. The package currently includes: Google APIs (fcm, firebase, youtube, etc.)StripeGithub from typegraph import TypeGraph, policies from typegraph_std.github import import_github from typegraph_std.google import import_gmail with TypeGraph( &quot;emails&quot;, allow_origin=[&quot;https://metatype.dev&quot;, &quot;http://localhost:3000&quot;] ), ) as g: public = policies.public() # {protocol}://{hostname}/api/v3 github = import_github( {&quot;protocol&quot;: &quot;https&quot;, &quot;hostname&quot;: &quot;custom_host&quot;} ) gmail = import_gmail() g.expose( list_emails=github.functions.users_list_emails_for_authenticated_user, **gmail.functions, default_policy=[public] )  As you can see, it works pretty much the same way as importers. ","version":"Next","tagName":"h2"},{"title":"Backend for frontend","type":0,"sectionRef":"#","url":"/use-cases/backend-for-frontend","content":"","keywords":"","version":"Next"},{"title":"Case study​","type":1,"pageTitle":"Backend for frontend","url":"/use-cases/backend-for-frontend#case-study","content":" Imagine you have a web frontend and a mobile app that both consume data from a microservices-based backend. The web frontend requires certain data fields in a given format, and the mobile app requires the same additional fields in another format. In a traditional architecture, both the web and mobile frontends would have to make separate API calls to the microservices, and then format the data into the appropriate structure themselves. This can lead to duplicated code, increased latency due heavier calls with non-necessary data, and decreased developer efficiency. With a BFF in place, it handles the formatting of the data based on the specific needs of each client. All frontends can thus make a single API call to the BFF, which then communicates with the microservices, retrieves the data, and formats it into the required structure before returning it to the frontend. ","version":"Next","tagName":"h2"},{"title":"Metatype's solution​","type":1,"pageTitle":"Backend for frontend","url":"/use-cases/backend-for-frontend#metatypes-solution","content":"Metatype can act as a generic BFF component, serving multiple dedicated APIs and handling security, authentication and authorization for you. By encapsulating the logic for communicating with the microservices, Metatype helps to ensure that the frontends are as decoupled as possible from the other services, making it easier to make changes to either the frontend or the backend without affecting the other side. Loading... ","version":"Next","tagName":"h2"},{"title":"Automatic CRUD + validation","type":0,"sectionRef":"#","url":"/use-cases/automatic-crud-validation","content":"","keywords":"","version":"Next"},{"title":"Case study​","type":1,"pageTitle":"Automatic CRUD + validation","url":"/use-cases/automatic-crud-validation#case-study","content":" Let's say you are developing a web application for a retail store that allows customers to place orders online. In this scenario, you would need to use CRUD operations to create, read, update, and delete data related to orders, customers, products, and inventory. You would have to model each of these entities as a data type, define the operations that can be performed on them and write the code to ensure the correctness of the data processed in the operations. For example, you would need to define a Customer type with the following fields: id, name, email, and address. You would also need to define the operations that can be performed on the Customer type, such as createCustomer, updateCustomer, and deleteCustomer. You would also need to write the code to validate the data in the createCustomer operation to ensure that the customer's email address is valid and that the customer's address is not empty. Same for the other fields. ","version":"Next","tagName":"h2"},{"title":"Metatype's solution​","type":1,"pageTitle":"Automatic CRUD + validation","url":"/use-cases/automatic-crud-validation#metatypes-solution","content":"Metatype simplifies the development of CRUD APIs by providing the Prisma runtime that automates the creation of the API for CRUD operations and corresponding data validation in PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB. It can even validate some advanced types like email which may not be supported by downstream system (databases often store email address into plain string instead of a specialized field). This makes it faster for developers to create scalable CRUD APIs and enable them to focus their expertise where it matters most like checkout or the search capabilities. Loading... ","version":"Next","tagName":"h2"},{"title":"Function-as-a-service runner","type":0,"sectionRef":"#","url":"/use-cases/faas-runner","content":"","keywords":"","version":"Next"},{"title":"Case study​","type":1,"pageTitle":"Function-as-a-service runner","url":"/use-cases/faas-runner#case-study","content":" For example, imagine you have an e-commerce application that uses FaaS to process orders. When a customer places an order, multiple functions may need to be executed, such as validating the order, processing the payment, and updating the inventory. Each function may be executed independently by the FaaS platform and may take varying amounts of time to complete. Those functions may also be executed for historical reason on different platforms like AWS Lambda, Google Cloud Functions, or Azure Functions. To collect the results of all the functions in a timely manner, you need to ensure that each function is executed in the correct order and that you are not waiting for a slow function to complete before moving on to the next function. ","version":"Next","tagName":"h2"},{"title":"Metatype's solution​","type":1,"pageTitle":"Function-as-a-service runner","url":"/use-cases/faas-runner#metatypes-solution","content":"To solve the use case of executing multiple functions and collecting their results, Metatype provides two key features. Function composition/chaining: functions can be chained together to form a pipeline. The output of one function can be used as the input of the next function in the pipeline. This allows us to execute multiple functions in a specific order. Embedded runner: you can easily write a function that glues together multiple functions and executes them in a specific order. This allows you to execute multiple functions in a specific order. Currently, both Python and Typescript are supported. Loading... ","version":"Next","tagName":"h2"},{"title":"IAM provider","type":0,"sectionRef":"#","url":"/use-cases/iam-provider","content":"","keywords":"","version":"Next"},{"title":"Case study​","type":1,"pageTitle":"IAM provider","url":"/use-cases/iam-provider#case-study","content":" Suppose a developer is building a social media platform that allows users to post updates and view other users' profiles. The developer wants to ensure that only authenticated users can access the platform's resources, and that each user can only access their own data. To achieve this, the developer can use OAuth2 for user authentication and access control. OAuth2 allows users to log in using their Google or GitHub credentials, which are verified by Google or GitHub's IAM system. Once the user is authenticated, the social media platform can use OAuth2 to obtain an access token, which is used to authorize the user's access to the platform's resources. The social media platform can also use IAM to control access to resources based on user roles and permissions. For example, only authenticated users can access the platform's resources, and each user can only access their own data. ","version":"Next","tagName":"h2"},{"title":"Metatype's solution​","type":1,"pageTitle":"IAM provider","url":"/use-cases/iam-provider#metatypes-solution","content":"Metatype comes with a built-in IAM provider that can be used to manage user identities and their authorized privileges within a system. It supports any OpenID/OAuth2 provider and includes a list of pre-configured ones like Google, GitHub, Facebook, Twitter or LinkedIn. You can also use your own identity provider and rely on JSON Web Tokens (JWT) for authentication. Once the user is authenticated, you can use policy access based control (PBAC) to control access to resources based on user identifies and permissions. For example, only authenticated users can access the platform's resources, and each user can only access their own data. Policies can be defined by any function, and run on or off Metatype. Loading... ","version":"Next","tagName":"h2"},{"title":"All-in-one GraphQL server","type":0,"sectionRef":"#","url":"/use-cases/graphql-server","content":"","keywords":"","version":"Next"},{"title":"Case study​","type":1,"pageTitle":"All-in-one GraphQL server","url":"/use-cases/graphql-server#case-study","content":" Suppose you are building a subscription platform with a GraphQL API. You need to design a schema that accurately represents the available products, their attributes, and the operations that clients can perform, such as searching, filtering, and sorting. You also need to optimize the performance of complex queries that involve joining multiple data sources, such as products, categories, and user preferences. Additionally, you need to implement caching and pagination to improve the performance and scalability of your API. Finally, you need to ensure that your API is secure and implements appropriate authentication and authorization mechanisms to protect sensitive data and operations. Some challenges like the N+1 problem (when a single query results in multiple nested queries, each of which requires a separate database or API call) can also make the development of GraphQL resolver slow and complex to manage. ","version":"Next","tagName":"h2"},{"title":"Metatype's solution​","type":1,"pageTitle":"All-in-one GraphQL server","url":"/use-cases/graphql-server#metatypes-solution","content":"Metatype's approach is to focus on schema design solely, and leave the GraphQL resolver implementation to the engine. By providing where the data is stored and how to access it, the queries are optimized by the engine to minimize the number of external API/database calls and to cache the results. This can be seen as a declarative GraphQL servers, where the server is orchestrated everything for you. Metatype also comes with pre-built functionalities like authentication, authorization, and rate limiting. Loading... ","version":"Next","tagName":"h2"},{"title":"Microservices orchestration","type":0,"sectionRef":"#","url":"/use-cases/microservice-orchestration","content":"","keywords":"","version":"Next"},{"title":"Case study​","type":1,"pageTitle":"Microservices orchestration","url":"/use-cases/microservice-orchestration#case-study","content":" Let's say your company develop a healthcare platform and that one of the microservices is responsible for handling patient records (owned by team A), and another microservice is responsible for handling appointment scheduling (owned by team B). When a patient schedules an appointment, the appointment scheduling microservice needs access to the patient's records to ensure that the appointment is scheduled with the right provider and that the provider has the necessary information to provide effective care. However, since patient records contain sensitive information, it is important to ensure that only authorized users have access to them. To achieve this, the healthcare platform must use authentication and authorization on each API, which allows sharing only required information. ","version":"Next","tagName":"h2"},{"title":"Metatype's solution​","type":1,"pageTitle":"Microservices orchestration","url":"/use-cases/microservice-orchestration#metatypes-solution","content":"Metatype can act as a central entry point for all incoming requests and responses between the microservices themselves and external clients. It is responsible for routing requests to the appropriate microservices and handling responses from those microservices, while verifying the authentication and authorization for each request. Additionally, Metatype gateway can provide other important features such as rate limiting, caching, and request/response transformations. It can even provide an API from another typegraph and delegate the query processing to it. Loading... ","version":"Next","tagName":"h2"},{"title":"Programmable API gateway","type":0,"sectionRef":"#","url":"/use-cases/programmable-api-gateway","content":"","keywords":"","version":"Next"},{"title":"Case study​","type":1,"pageTitle":"Programmable API gateway","url":"/use-cases/programmable-api-gateway#case-study","content":" Suppose that your company needs to implement various policies and logic to manage and secure its APIs, such as rate limiting, caching, and request/response transformations. To achieve this, the company can adopt a programmable API gateway that allows developers to create and deploy custom function to implement additional logic and policies for incoming requests and outgoing responses. It also provides a platform for the company to manage its API infrastructure more efficiently and flexibly. Developers can leverage existing libraries and frameworks to quickly build and deploy custom logic, reducing the time and effort required to develop and maintain the API gateway. ","version":"Next","tagName":"h2"},{"title":"Metatype's solution​","type":1,"pageTitle":"Programmable API gateway","url":"/use-cases/programmable-api-gateway#metatypes-solution","content":"Metatype provide a Python SDK for developers to create and deploy custom logic and policies, which can later be deployed to the gateway in a single command line. Importers can also be used to import existing API or logic definitions from other sources, such as OpenAPI, GraphQL, and gRPC. This enables developer to quickly build and deploy any update the API or the business logic without having to worry about the underlying infrastructure. Loading... ","version":"Next","tagName":"h2"},{"title":"ORM for the edge","type":0,"sectionRef":"#","url":"/use-cases/orm-for-the-edge","content":"","keywords":"","version":"Next"},{"title":"Case study​","type":1,"pageTitle":"ORM for the edge","url":"/use-cases/orm-for-the-edge#case-study","content":" Suppose you are building a mobile app that allows users to order food from local restaurants. To provide a low-latency user experience, you want to run your server-side logic as close as possible to your users. You can deploy your functions across multiple locations on distributed edge servers. For database interactions, you may need a lightweight relay API to remains compatible with the platform and offer an efficient interface like an ORM provide. When a user makes a request to view the menu or place an order, the corresponding function running on the edge will make a request to the lightweight relay API to retrieve or modify the relevant data in the database. ","version":"Next","tagName":"h2"},{"title":"Metatype's solution​","type":1,"pageTitle":"ORM for the edge","url":"/use-cases/orm-for-the-edge#metatypes-solution","content":"Metatype can act out of the box as a lightweight relay API, simplifying database interactions via HTTP/GraphQL requests, and allowing you to query your database through the Prisma runtime. Prisma is a well-known ORM library that provides a convenient interface to interact with PostgreSQL, MySQL, SQLite, SQL Server, MongoDB, CockroachDB databases. Loading... ","version":"Next","tagName":"h2"}]