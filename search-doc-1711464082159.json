{"searchDocs":[{"title":"Programmable glue for developers","type":0,"sectionRef":"#","url":"/blog/2023/06/18/programmable-glue","content":"","keywords":"","version":null},{"title":"What is Metatype?‚Äã","type":1,"pageTitle":"Programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#what-is-metatype","content":" Metatype is an open platform for developers to declaratively build APIs. It offers a new approach to creating backends, where the developers focus on data modelling and delegate the implementation to the platform.  The intent is to address the following challenges:  developers are often a bottleneck, and may spend less than 50% of their time on tasks that mattermost of the developments needs are similar, yet most of the systems are not interoperableinfrastructure management takes time and slows down the deployment velocity  The platform is composed of the following components:  Typegraph: a multi-language SDK to manage typegraphs - virtual graphs of types - and compose themTypegate: a serverless REST/GraphQL gateway to execute queries over typegraphsMeta CLI: a command-line tool to offer a great developer experience and fast deployment  ","version":null,"tagName":"h2"},{"title":"What are virtual graphs?‚Äã","type":1,"pageTitle":"Programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#what-are-virtual-graphs","content":" Typegraphs are a declarative way to expose all APIs, storage and business logic of your stack as a single graph. They take inspiration from domain-driven design principles and in the idea that the relation between of the data is as important as data itself, even though they might be in different locations or shapes.  Loading...  These elements can then be combined and composed together similarly on how you would compose web components to create an interface in modern frontend practices. This allows developers to build modular and strongly typed APIs using typegraph as a programmable glue.  ","version":null,"tagName":"h2"},{"title":"Where does this belong in the tech landscape?‚Äã","type":1,"pageTitle":"Programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#where-does-this-belong-in-the-tech-landscape","content":" Before Metatype, there was a gap in the technological landscape for a solution that specifically addressed the transactional, short-lived use cases. While there were existing tools for analytical or long-running use cases, such as Trino and Temporal, there was no generic engine for handling transactional, short-lived tasks.  \t‚Üê individual level transactional\tlarge data ‚Üí analytical instantaneous ‚Üë short-lived\tMetatype query engine for data entities in evolving systems\tTrino query engine for large data from multiples sources long-running asynchronous ‚Üì\tTemporal workflow orchestration engine for data operations\tSpark batch/streaming engine for large data processing  ","version":null,"tagName":"h2"},{"title":"Give it a try!‚Äã","type":1,"pageTitle":"Programmable glue for developers","url":"/blog/2023/06/18/programmable-glue#give-it-a-try","content":" Let us know what you think! Metatype is open source and we welcome any feedback or contributions. The community primarily lives on GitHub.  Next steps Build your first typegraph or read more about the concepts behind Metatype. ","version":null,"tagName":"h2"},{"title":"Adding a typegraph SDK for Node","type":0,"sectionRef":"#","url":"/blog/2023/10/23/index","content":"","keywords":"","version":null},{"title":"Welcome to the Metatype documentation!","type":0,"sectionRef":"#","url":"/docs","content":"","keywords":"","version":"Next"},{"title":"Get to know Metatype‚Äã","type":1,"pageTitle":"Welcome to the Metatype documentation!","url":"/docs#get-to-know-metatype","content":" Follow the quick-start to install the components and get a taste of Metatype. Or, jump right into practice with a tutorial below.  üìÑÔ∏è Metatype basics Learn the basics of Metatpe by building a real world API..  ","version":"Next","tagName":"h2"},{"title":"Explore and learn more functionalities‚Äã","type":1,"pageTitle":"Welcome to the Metatype documentation!","url":"/docs#explore-and-learn-more-functionalities","content":" The platform provides out of the box support for many use cases:  create/read/update/delete data in your database storing files in your cloud storage authenticate users with different providers or using JWTs connecting to third-party/internal APIs running custom business logic in your preferred language providing fine-grained access control to your data and more... üìÑÔ∏è All about types üìÑÔ∏è List of support runtimes üìÑÔ∏è Deploy on different environments üìÑÔ∏è Security mechanisms  ","version":"Next","tagName":"h2"},{"title":"Understand Metatype in depth‚Äã","type":1,"pageTitle":"Welcome to the Metatype documentation!","url":"/docs#understand-metatype-in-depth","content":" Once you are familiar with the basics, you can learn more about the motivation behind Metatype and the underlying implementation.  üìÑÔ∏è Mental model üìÑÔ∏è Comparing Metatype üìÑÔ∏è Query engine üìÑÔ∏è Access control ","version":"Next","tagName":"h2"},{"title":"Architecture","type":0,"sectionRef":"#","url":"/docs/concepts/architecture","content":"Architecture","keywords":"","version":"Next"},{"title":"Access control","type":0,"sectionRef":"#","url":"/docs/concepts/access-control","content":"Access control Typegraphs allow you to specify granular access control when exposing your materializers. This can be done at the materializer or the type field level.Policy-based-access-control is the primary paradigm implemented in Metatype today.","keywords":"","version":"Next"},{"title":"Metatype explained to X","type":0,"sectionRef":"#","url":"/docs/concepts/explanations","content":"Metatype explained to X","keywords":"","version":"Next"},{"title":"Comparing Metatype","type":0,"sectionRef":"#","url":"/docs/concepts/comparisons","content":"","keywords":"","version":"Next"},{"title":"App development platforms‚Äã","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#app-development-platforms","content":" FirebaseSupabase  These are great platforms to quickly start a new project. However, they hardly scale in terms of architecture evolution, technology freedom, number of developers on the project, and you will eventually have to move out due to increasing costs or iterations slowness.  When to choose Metatype  You want to build modular APIs by composing pre-defined blocks and import the ones you need from existing systemsYou want to take advantage of developers tooling you are familiar with like version controls or multiple environmentsYou favor interoperability and extensibility over vendor lock-in and follow your future needs with ease  ","version":"Next","tagName":"h2"},{"title":"Headless CMS‚Äã","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#headless-cms","content":" StrapiDirectus  Headless Content Management Systems (CMS) are great tools to manage content and providing great editing experience. However, they are not designed to build complex APIs like a cart checkout or integrate with other systems.  When to choose Metatype  You want an all-in-one APIs development platforms and offer the same editing experience through a user-friendly interfaceYou care about end-user performance and want to use the best underlying technology for each use casesYou are more than one on the project and want to manage your data models using preferred programming language  ","version":"Next","tagName":"h2"},{"title":"APIs over databases‚Äã","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#apis-over-databases","content":" HasuraPostGraphile  These platforms offer great data accessibility, but they are focused on databases and forget about the importance of the business logic glues and the interoperability with other systems.  When to choose Metatype  You want to have more than CRUD operations and get authentication, rate-limiting, and business logic out of the boxYou want to decouple your database from your API and change where the data is stored as the project evolvesYou prefer focusing on what you want to achieve rather than how to achieve it (and get stuck Haskell or Postgres internals)  ","version":"Next","tagName":"h2"},{"title":"GraphQL-based backends‚Äã","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#graphql-based-backends","content":" WunderGraphGrafbase  These great tools leverage GraphQL to build internal APIs using pre-determined queries. They are less API consumer oriented and that disables powerful capabilities like querying between multiple instances owned by different users.  When to choose Metatype  You want to build internal and external APIs, and go beyond what can be described in a GraphQL schemaYou want to optimize your API queries on the fly and let the engine resolve your data in the most efficient wayYou expect a fine-grained permission model and control the data you expose at the level of each model field  ","version":"Next","tagName":"h2"},{"title":"Web frameworks‚Äã","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#web-frameworks","content":" DjangoNestJS  These frameworks are a great way to build web applications. However, they require a lot of boilerplate code to build APIs and are not designed to be deployed in a serverless environment. They also requires a lot of configuration to get a complete solution.  When to choose Metatype  When you want to build declarative APIs and let the engine handle the underlying implementationWhen you want to build APIs in multiple languages, with less code and have a consistent experience across themWhen you expect a lightweight and all-in-one solution with authentication, databases, caching, and more out of the box  ","version":"Next","tagName":"h2"},{"title":"Workflow engines‚Äã","type":1,"pageTitle":"Comparing Metatype","url":"/docs/concepts/comparisons#workflow-engines","content":" TemporalWindmill  Great tools when it comes at scheduling long-running jobs. However, they are not designed to answer instantaneous API calls and are not optimized for data entities fetching. They are nonetheless the perfect companion to Metatype and some integrations already exists.  When to choose Metatype  When you want to implement modular APIs and backends with instantaneous responsesWhen you want to interact with workflow engines and control over the operations they perform, including pooling and retriesWhen you look for a serverless deployment solution and want to focus on your business logic ","version":"Next","tagName":"h2"},{"title":"Query engine","type":0,"sectionRef":"#","url":"/docs/concepts/query-engine","content":"Query engine","keywords":"","version":"Next"},{"title":"Features overview","type":0,"sectionRef":"#","url":"/docs/concepts/features-overview","content":"","keywords":"","version":"Next"},{"title":"GraphQL and REST queries‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#graphql-and-rest-queries","content":" Easily expose business logic endpoints through using generated GraphQl APIs. Including helpers to auto-generate and expose CRUD operations from your types on myriad of databases. These are only helpers though. They're built upon the typegraphs primitive that compose well with every other feature and allow granular control when required. There are helpers to expose sections of your GraphQl through REST queries as well.  ","version":"Next","tagName":"h2"},{"title":"Authentication‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#authentication","content":" First class support for authentication primitives through the Policies object. Oauth2 helpers for popular services included as well. Read more here.  ","version":"Next","tagName":"h2"},{"title":"Type checking‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#type-checking","content":" Everything in Metatype starts with types. The typegraph sdks allow you to model exactly what's needed for your app with simple syntax and a modern type system. Type authoring isn't done with through static, declarative snippets but through the typegraphs in a functional, &quot;first class&quot; manner allowing you build your own abstractions when needed.  ","version":"Next","tagName":"h2"},{"title":"Live reload during development‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#live-reload-during-development","content":" Metatype development is primarily done through the meta-cil that's designed to get you up and productive in no time. Live auto-reload, database migration management, type-checking and linting, it's all there.  ","version":"Next","tagName":"h2"},{"title":"Built-in CORS and rate-limiting‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#built-in-cors-and-rate-limiting","content":" ","version":"Next","tagName":"h2"},{"title":"Bring your own storage‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#bring-your-own-storage","content":" Working with object files in Metatype is easy using the S3Runtime including support for GraphQl file uploads and presigned URLs.  ","version":"Next","tagName":"h2"},{"title":"Function runner‚Äã","type":1,"pageTitle":"Features overview","url":"/docs/concepts/features-overview#function-runner","content":" When the expressive powers of the typegate primitives are not up for the task, different runtimes are available for running the exact, turing complete, code you need. Metatype supports Typescript, Python and Wasm functions today. ","version":"Next","tagName":"h2"},{"title":"","type":0,"sectionRef":"#","url":"/docs/guides/contributing","content":"","keywords":"","version":"Next"},{"title":"Table of Contents‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#table-of-contents","content":" Code of ConductI Have a QuestionI Want To ContributeReporting BugsSuggesting EnhancementsYour First Code Contribution  ","version":"Next","tagName":"h2"},{"title":"Code of Conduct‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#code-of-conduct","content":" This project and everyone participating in it is governed by ourCode of Conduct. By participating, you are expected to uphold this code.  ","version":"Next","tagName":"h2"},{"title":"I Have a Question‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#i-have-a-question","content":" If you want to ask a question, we assume that you have read the availabledocumentation.  Before you ask a question, it is best to search for existingIssues that might help you. In case you have found a suitable issue and still need clarification, you can write your question in this issue. It is also advisable to search the internet for answers first.  If you then still feel the need to ask a question and need clarification, we recommend the following:  Open an Issue.Provide as much context as you can about what you're running into.Provide project and platform versions depending on what seems relevant.  ","version":"Next","tagName":"h2"},{"title":"I Want To Contribute‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#i-want-to-contribute","content":" Legal Notice‚Äã When contributing to this project, you must agree that you have authored 100% of the content, that you have the necessary rights to the content and that the content you contribute may be provided under the project license.  ","version":"Next","tagName":"h2"},{"title":"Reporting Bugs‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#reporting-bugs","content":" Before Submitting a Bug Report‚Äã  A good bug report shouldn't leave others needing to chase you up for more information. Therefore, we ask you to investigate carefully, collect information and describe the issue in detail in your report. Please complete the following steps in advance to help us fix any potential bug as fast as possible.  Make sure that you are using the latest version.Determine if your bug is really a bug and not an error on your side e.g. using incompatible environment components/versions (Make sure that you have read thedocumentation. If you are looking for support, you might want to check this section).To see if other users have experienced (and potentially already solved) the same issue you are having, check if there is not already a bug report existing for your bug or error in thebug tracker.Also make sure to search the internet (including Stack Overflow) to see if users outside the GitHub community have discussed the issue.Collect information about the bug:Stack traceOS, Platform and Version (Windows, Linux, macOS, x86, ARM)Version of the interpreter, compiler, SDK, runtime environment, package manager, depending on what seems relevant.Possibly your input and the outputCan you reliably reproduce the issue? And can you also reproduce it with older versions?  How Do I Submit a Good Bug Report?‚Äã  You must never report security related issues, vulnerabilities or bugs including sensitive information to the issue tracker, or elsewhere in public. Instead sensitive bugs must be reported according to theSecurity Policy.  We use GitHub issues to track bugs and errors. If you run into an issue with the project:  Open an Issue. (Since we can't be sure at this point whether it is a bug or not, we ask you not to talk about a bug yet and not to label the issue.)Explain the behavior you would expect and the actual behavior.Please provide as much context as possible and describe the reproduction steps that someone else can follow to recreate the issue on their own. This usually includes your code. For good bug reports you should isolate the problem and create a reduced test case.Provide the information you collected in the previous section.  ","version":"Next","tagName":"h3"},{"title":"Suggesting Enhancements‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#suggesting-enhancements","content":" This section guides you through submitting an enhancement suggestion for Metatype, including completely new features and minor improvements to existing functionality. Following these guidelines will help us and the community to understand your suggestion and find related suggestions.  Before Submitting an Enhancement‚Äã  Make sure that you are using the latest version.Read the documentation carefully and find out if the functionality is already covered, maybe by an individual configuration.Perform a search to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one.Find out whether your idea fits with the scope and aims of the project. It's up to you to make a strong case to convince the project's developers of the merits of this feature. Keep in mind that we want features that will be useful to the majority of our users and not just a small subset. If you're just targeting a minority of users, consider writing an add-on/plugin library.  How Do I Submit a Good Enhancement Suggestion?‚Äã  Enhancement suggestions are tracked asGitHub issues.  Use a clear and descriptive title for the issue to identify the suggestion.Provide a step-by-step description of the suggested enhancement in as many details as possible.Describe the current behavior and explain which behavior you expected to see instead and why. At this point you can also tell which alternatives do not work for you.Explain why this enhancement would be useful to most Metatype users. You may also want to point out the other projects that solved it better and which could serve as inspiration.  ","version":"Next","tagName":"h3"},{"title":"Your First Code Contribution‚Äã","type":1,"pageTitle":"","url":"/docs/guides/contributing#your-first-code-contribution","content":" Metatype is using a mono-repository approach. This means that all code is centralized and requires many different tools to work with. The following sections will guide you through the setup process.  Dependencies‚Äã  Install the following global dependencies:  RustPythonPipxPNPMDenoNode  And then more specific ones for the workspace:  # manage rust dependencies cargo install cargo-edit # task runner cargo install whiz # enforce style and good practice pipx install pre-commit # manange python dependencies pipx install poetry # wasmedge prerequisits brew install llvm sudo apt-get install libclang-dev # grpc prerequisits brew install protobuf sudo apt-get install protobuf-compiler libprotobuf-dev # wasmedge runtime curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash   Running The Project‚Äã  # install git commit hooks pre-commit install # prepare python virtual environment python3 -m venv .venv source .venv/bin/activate # depends on your shell # run the task runner and it will install the remaining dependencies (see whiz.yaml and install step) whiz   Environments And Tests‚Äã  deno run -A dev/env.ts all # or only the envs required (e.g. base prisma s3) cargo test --tests # there is a bug with wasm and doc testings deno run -A dev/test.ts # all tests deno run -A dev/test.ts runtimes/prisma/full_prisma_mapping_test.ts # isolated test deno run -A dev/env.ts # shutdown all envs   There are many more developer scripts in the dev folder, however most of them should only be needed for advanced tasks.  Commit Messages‚Äã  Pre-commit hooks enforce some basic checks, namely that all commit messages follow the conventional commitformat. This is a simple set of rules that makes review easier and help us to generate a changelog.  Faster linking‚Äã  We recommend using mold for Linux targets and macOS new parallel linker for faster linking. You can use them as aliases or configure them in your ~/.cargo/config.toml file.  [target.aarch64-apple-darwin] rustflags = [ &quot;-C&quot;, &quot;link-arg=-fuse-ld=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld&quot;, &quot;-C&quot;, &quot;link-arg=-ld_new&quot; # makes sure the new parallel linker is used ] [target.x86_64-unknown-linux-gnu] rustflags = [ &quot;-C&quot;, &quot;link-arg=-fuse-ld=mold&quot; ]   Local typegraph with Nodejs‚Äã  Currently, the typegraph/sdk/node/dist project is generated dynamically. Depending on your package manager, the protocol used may differ.  # uses the `file:..` protocol npm install path/to/typegraph/sdk/node/dist # uses the `link:..` protocol (equivalent to `file:..` but for directories only) pnpm install path/to/typegraph/sdk/node/dist  ","version":"Next","tagName":"h3"},{"title":"Run serverless functions","type":0,"sectionRef":"#","url":"/docs/guides/external-functions","content":"Run serverless functions Typegraphs allow us to define and execute at different places to accomplish myriad of tasks: Loading... Here's what fib.ts looks like: // Copyright Metatype O√ú, licensed under the Elastic License 2.0. // SPDX-License-Identifier: Elastic-2.0 const CACHE = [1, 1]; const MAX_CACHE_SIZE = 1000; export default function fib({ size }: { size: number }) { if (size &gt; MAX_CACHE_SIZE) { throw new Error(`unsupported size ${size} &gt; ${MAX_CACHE_SIZE}`); } let i = CACHE.length; while (i++ &lt; size) { CACHE.push(CACHE[i - 2] + CACHE[i - 3]); } return CACHE.slice(0, size); } ","keywords":"","version":"Next"},{"title":"Write REST endpoints","type":0,"sectionRef":"#","url":"/docs/guides/rest","content":"Write REST endpoints The materializers we expose from our typegraphs are currently provided with a GraphQl API by default. If we have need for a REST API, we can easily achieve that by the rest function which takes GraphQl queries and provides RESTly endpoints for them. from typegraph import Graph, Policy, t, typegraph from typegraph.runtimes.deno import DenoRuntime @typegraph(dynamic=False) def example_rest(g: Graph): deno = DenoRuntime() pub = Policy.public() user = t.struct({&quot;id&quot;: t.integer()}, name=&quot;User&quot;) post = t.struct( { &quot;id&quot;: t.integer(), &quot;author&quot;: user, }, name=&quot;Post&quot;, ) # API docs {typegate_url}/example-rest/rest # In this example, the query below maps to {typegate_url}/example-rest/rest/get_post?id=.. g.rest( &quot;&quot;&quot; query get_post($id: Integer) { postFromUser(id: $id) { id author { id } } } &quot;&quot;&quot; ) g.expose( postFromUser=deno.func( user, post, code=&quot;(_) =&gt; ({ id: 12, author: {id: 1} })&quot;, ).with_policy(pub), ) ","keywords":"","version":"Next"},{"title":"Secure your requests","type":0,"sectionRef":"#","url":"/docs/guides/securing-requests","content":"","keywords":"","version":"Next"},{"title":"Authentication‚Äã","type":1,"pageTitle":"Secure your requests","url":"/docs/guides/securing-requests#authentication","content":" Metatype supports multiple authentication schemes: Basic authentication, JSON Web Tokens (JWT) and OAuth2. This enables every request to have a context and store some information about the user. You can then use the context to set specific fields with from_context or as you will see next step, to restrict accesses via the policies.  For your app, you will use basic authentication in order to restrict some actions for admin users. In order to do so, adding the following secret to your metatype.yml file: TG_AUTHENTICATION_BASIC_ADMIN=password.  Loading...  More details here.    ","version":"Next","tagName":"h2"},{"title":"CORS‚Äã","type":1,"pageTitle":"Secure your requests","url":"/docs/guides/securing-requests#cors","content":" Cross-Origin Resource Sharing (CORS) on the one hand is a mechanism that allows or denies cross-origin requests in the browser. It avoids that other websites use your API without explicitly allowing it. Note that it doesn't protect other servers or a mobile app from using your typegraphs, only browsers implements the CORS mechanism. See this documentation for the details.  Loading...  If your browser support well CORS, you should see an error and even more if you try to run the interactive demo. By the way, there is a hidden core header in all interactive demos you have met so far:  TypeGraph.Cors(allow_origin=[&quot;https://metatype.dev&quot;, &quot;http://localhost:3000&quot;])   TypeGraph.Cors(allow_origin=[&quot;https://metatype.dev&quot;, &quot;http://localhost:3000&quot;])  ","version":"Next","tagName":"h2"},{"title":"Self-host the Typegate","type":0,"sectionRef":"#","url":"/docs/guides/self-hosting","content":"","keywords":"","version":"Next"},{"title":"Helm‚Äã","type":1,"pageTitle":"Self-host the Typegate","url":"/docs/guides/self-hosting#helm","content":" Helm must be installed to use the charts. Please refer to Helm's documentation to get started. The chart can be accessed on the dedicatedrepository.  Once Helm has been set up correctly, add the repo as follows:  helm repo add metatype https://charts.metatype.dev helm show values metatype/typegate &gt; values.yml # customize values.yaml helm install my-gate --values values.yml metatype/typegate  ","version":"Next","tagName":"h2"},{"title":"Ecosystem","type":0,"sectionRef":"#","url":"/docs/reference/ecosystem","content":"","keywords":"","version":"Next"},{"title":"Metatype‚Äã","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#metatype","content":" Metatype is the principal repository of the Metatype ecosystem. It contains the Meta CLI, the typegate and the typegraph components.  ","version":"Next","tagName":"h2"},{"title":"Whiz‚Äã","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#whiz","content":" Whiz is a modern DAG/tasks runner for multi-platform monorepos. It enables to develop the core components of the ecosystem together and reloading only the necessary tasks on file change.    ","version":"Next","tagName":"h2"},{"title":"Lade‚Äã","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#lade","content":" Lade automatically load secrets from your preferred vault as environment variables, and clear them once your shell command is over. The Meta CLI bundles Lade and use it to load secret seamlessly into your typegates.    ","version":"Next","tagName":"h2"},{"title":"Mental model","type":0,"sectionRef":"#","url":"/docs/concepts/mental-model","content":"","keywords":"","version":"Next"},{"title":"Why does Metatype exist?‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#why-does-metatype-exist","content":" As products evolve, building APIs becomes a challenging hot spot where initiatives collides and efficiency becomes a struggle. While deploying new features, all developers spend a non-negligible amount of time on low-value added tasks (CRUD generation, data validation, authorization, etc.) and deploying their solutions. This leaves little time under business constraints to design great interfaces and experiment with the best technical solution, eventually increasing the time to delivery and weakening the innovation capabilities.  Metatype's vision is to enable everyone to build modular API with as little effort as possible. By helping developers to re-use existing systems and APIs, it enables teams to focus on what matters: their expert knowledge in business logic, modelling and technologies. Metatype manage the complex layers for them, making them productive and innovation-friendly for the next iterations.  Drawing inspiration from modern frontend development practices, Metatype adopts the pattern of composing components together to solve backend development challenges. In that respect, Metatype is a key element in the composable enterprise trend by:  making system interfaces accessible and easy to understand for everyone (discoverability)embracing iterative approaches and cut time to deployment in half (autonomy)building strong foundations for APIs with type safety and bounded context (modularity)empowering teams to innovate with new technologies and interoperability (orchestration)  ","version":"Next","tagName":"h2"},{"title":"How does Metatype work?‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#how-does-metatype-work","content":" When developing a feature, the classical approach is to define what data will be at play, how to transform them, where the execution shall take place and who should be authorized. Instead, Metatype define an abstraction for each of those steps and put the emphasis on composing pre-defined APIs or defining re-usable ones when there is no existing solution.  \tClassical approach\tMetatype's computing modelWhat (data)\tfixed response defined by the logic\tAPI clients selects what they need from types How (transformations)\tad-hoc code logic\tcomposed data with interchangeable materializers Where (execution)\t1 code base + 1 database\torchestrate the request across multiple runtimes Who (authentication)\thard-coded rules or system\trequest context based and controlled by policies When (event)\trequest arrival\tbased on triggers  This computing model brings numerous advantages:  it offers multiple runtimes with pre-defined operations and can replace the needs for an ad-hoc backendwhen the project grows, you easily introduce new APIs or break existing ones in smaller partsyou write complex business logic directly in Typescript, Python or WebAssembly and run them on-demandthird-parties APIs can be easily integrated, providing you visibility and control over themit is interoperable with existing (legacy) systems, and can be introduced step by stepit can be easily self-hosted in your own infrastructure or customized according to your needs  ","version":"Next","tagName":"h2"},{"title":"What's exactly Metatype?‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#whats-exactly-metatype","content":" Metatype is an open platform for developers to declaratively build APIs. It offers a new approach to creating backends, where the developers focus on data modelling and delegate the implementation to the platform.  The intent is to address the following challenges:  developers are often a bottleneck, and may spend less than 50% of their time on tasks that mattermost of the developments needs are similar, yet most of the systems are not interoperableinfrastructure management takes time and slows down the deployment velocity  The platform is composed of the following components:  Typegraph: a multi-language SDK to manage typegraphs - virtual graphs of types - and compose themTypegate: a serverless REST/GraphQL gateway to execute queries over typegraphsMeta CLI: a command-line tool to offer a great developer experience and fast deployment  ","version":"Next","tagName":"h2"},{"title":"Architectural overview‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#architectural-overview","content":" Metatype is designed for cloud environments and comes with minimal components. The only requirement to scale horizontally is to share some memory between replicas via Redis. You can use Metatype helm chart to directly deploy typegates on your Kubernetes cluster.        Typegraph  Typegraph is a Python package for building virtual graphs of types and managing their metadata. The name also refers to the typegraph specification which is a file format, currently in JSON, describing all elements of a typegraph.  Why Python? Python was historically chosen during Metatype's prototyping phase and remained since then the default way to describe typegraphs. Its great readability and dynamic typing make it a very accessible language for everyone to pick up quickly. In theory, all frameworks and languages can produce typegraphs respecting the specification to become executable by typegates. This opens the door to a wide range of use cases, including generating typegraphs automatically from existing code base and tools.  ","version":"Next","tagName":"h3"},{"title":"Types‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#types","content":" Types are the building block of typegraphs. They define a type system describing all data objects processed in Metatype. They can be easily extended to support new data types according to the needs of the application.  t.struct( { &quot;id&quot;: t.uuid(), &quot;age&quot;: t.integer(), &quot;cars&quot;: t.list( t.struct( { &quot;model&quot;: t.string(), &quot;name&quot;: t.string().optional(), } ) ), } )   Analogy in SQL: types are similar to the Data Definition Language (DDL) with the extended capacity of describing any type of data.  ","version":"Next","tagName":"h2"},{"title":"Materializers‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#materializers","content":" Types can also describe functions and materializers define how the input type gets transformed into the output type. The input and output types are similar to a function signature and a materializer to its implementation, except that it might not always know what the function body is. In such case, the materializer knows at least where and how to access it.  deno = DenoRuntime() deno.func( t.struct({&quot;input&quot;: t.string()}), t.string(), code=&quot;({ input }) =&gt; `hello ${input}`&quot;, # with logic ) http = HttpRuntime(&quot;https://random.org/api&quot;) http.get( &quot;/flip_coin&quot;, t.struct({}), t.enum([&quot;head&quot;, &quot;tail&quot;]), )   Analogy in SQL: a materializer is similar to a join, a function, or an alias.  ","version":"Next","tagName":"h2"},{"title":"Runtimes‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#runtimes","content":" Every type and materializer have a runtime associated to it. This runtime describes where the types or materializers are physically located. It can be another API, a database, or any other services the typegate can connect to. The typegates uses that information to optimize the execution of the queries and minimize the amount of data moved.  In practice, materializers are often not explicitly used and the usage of runtime sugar syntax is preferred.     Analogy in SQL: a runtime is similar to a database instance running some requests.  ","version":"Next","tagName":"h2"},{"title":"Policies‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#policies","content":" Policies are a special type of function t.func(t.struct({...}), t.boolean().optional()) attachable to any other type. They are evaluated once per request and determine whether one of the polices authorizes the access or not. They receive the request context (see typegate) as argument allowing you to implement authorization, access control, or any other business logic.  The policy decision can be:  true: the access is authorizedfalse: the access is deniednull: the access in inherited from the parent types     Analogy in SQL: policies are similar to Row Security Policies (RSP) or Row Level Security (RLS) concepts.  ","version":"Next","tagName":"h2"},{"title":"Triggers‚Äã","type":1,"pageTitle":"Mental model","url":"/docs/concepts/mental-model#triggers","content":" Triggers are events launching the execution of one or multiple functions. They fire when a GraphQL request is received for the specific typegraph.     Analogy in SQL: a trigger is similar to receiving a new query. ","version":"Next","tagName":"h2"},{"title":"Upload files to cloud storage","type":0,"sectionRef":"#","url":"/docs/guides/files-upload","content":"","keywords":"","version":"Next"},{"title":"Uploading file using presigned url‚Äã","type":1,"pageTitle":"Upload files to cloud storage","url":"/docs/guides/files-upload#uploading-file-using-presigned-url","content":" const image = await Deno.readFile(&quot;website/static/images/logo.png&quot;); // Get a presigned url const { data: { signUploadUrl: presigned }, } = await fetch(&quot;http://localhost:7891/retrend&quot;, { method: &quot;POST&quot;, body: JSON.stringify({ query: ` query SignUploadUrl($length: Int) { signUploadUrl(length: $length, path: &quot;my-super-image.png&quot;) } `, variables: { length: image.length, }, }), }).then((r) =&gt; r.json()); // Upload the file const upload = await fetch(presigned, { method: &quot;PUT&quot;, body: image, headers: { &quot;content-type&quot;: &quot;image/png&quot;, &quot;content-length&quot;: image.length, }, }); console.log(upload.status);   ","version":"Next","tagName":"h3"},{"title":"Uploading file using GraphQL multipart request‚Äã","type":1,"pageTitle":"Upload files to cloud storage","url":"/docs/guides/files-upload#uploading-file-using-graphql-multipart-request","content":" Metatype supportsGraphQL multipart requestfor uploading files. You may use one of the clients in thislistthat support GraphQL multipart request.  const image = await Deno.readFile(&quot;website/static/images/logo.png&quot;); const formData = new FormData(); formData.append( &quot;operations&quot;, JSON.stringify({ query: ` mutation UploadImage($file: Upload!) { upload(file: $file) { id path size contentType } } `, variables: { file: null, }, }) ); formData.append(&quot;map&quot;, JSON.stringify({ 0: [&quot;variables.file&quot;] })); formData.append(&quot;0&quot;, image, &quot;logo.png&quot;); const upload = await fetch(&quot;http://localhost:7891/retrend&quot;, { method: &quot;POST&quot;, body: formData, }); console.log(await upload.json());  ","version":"Next","tagName":"h3"},{"title":"Python WASI reactor‚Äã","type":1,"pageTitle":"Ecosystem","url":"/docs/reference/ecosystem#python-wasi-reactor","content":" Python WASI reactor is one of the runtimes bundled into the typegate. It allows to run Python scripts as WASI modules on the fly. ","version":"Next","tagName":"h2"},{"title":"Meta CLI","type":0,"sectionRef":"#","url":"/docs/reference/meta-cli","content":"","keywords":"","version":"Next"},{"title":"Development‚Äã","type":1,"pageTitle":"Meta CLI","url":"/docs/reference/meta-cli#development","content":" It watches for changes in your typegraphs and refresh your development typegate node on the fly.  ","version":"Next","tagName":"h2"},{"title":"Deployment‚Äã","type":1,"pageTitle":"Meta CLI","url":"/docs/reference/meta-cli#deployment","content":" It deploy your typegraph to the Metatype Cloud or your self-hosted typegate instances in a single command. ","version":"Next","tagName":"h2"},{"title":"Configuration file","type":0,"sectionRef":"#","url":"/docs/reference/meta-cli/configuration-file","content":"","keywords":"","version":"Next"},{"title":"metatype.yml Example file‚Äã","type":1,"pageTitle":"Configuration file","url":"/docs/reference/meta-cli/configuration-file#metatypeyml-example-file","content":" typegates: dev: url: http://localhost:7890 username: admin password: password typegraphs: python: include: &quot;**/*.py&quot; materializers: prisma: migrations_path: &quot;migrations&quot;   ","version":"Next","tagName":"h2"},{"title":"Automatic secret loading support‚Äã","type":1,"pageTitle":"Configuration file","url":"/docs/reference/meta-cli/configuration-file#automatic-secret-loading-support","content":" Lade is a secret loading tool that transparently inject environment variables from a variety of sources. It works with Fish, Bash or Zsh and currently supports Doppler, Infisical and 1Password as vault source.  To use Lade with Metatype, you can use the op://, infisical:// or doppler:// prefixes in your configuration file. It will then use the CLI of the vault to securely load the required secrets. For example:  typegates: dev: url: http://localhost:7890 username: op://VAULT_NAME/SECRET_NAME/FIELD_NAME password: infisical://app.infisical.com/PROJECT_NAME/ENV_NAME/SECRET_NAME   More of Lade documentation ","version":"Next","tagName":"h2"},{"title":"Policies","type":0,"sectionRef":"#","url":"/docs/reference/policies","content":"","keywords":"","version":"Next"},{"title":"Policy based access control (PBAC)‚Äã","type":1,"pageTitle":"Policies","url":"/docs/reference/policies#policy-based-access-control-pbac","content":" The Deno runtime enable to understand the last abstraction. Policies are a way to verify for each type whether the user is authorized or not to access it. It's a very powerful concept that can be for instance used to guarantee a given type is never accidentally exposed to the outside world.  Metatype comes with some built-in policies, but you can use the Deno runtime to define your own:  policies.public() is an alias for Policy(PureFunMat(&quot;() =&gt; true&quot;)) providing everyone open access.policies.ctx(&quot;role_value&quot;, &quot;role_field&quot;) is a companion policy for the authentication strategy you learned in the previous section. It will verify the context and give adequate access to the user.  Policies are hierarchical in the sense that the request starts with a denial, and the root materializers must explicitly provide an access or not. Once access granted, any further types can either inherit or override the access. Policies evaluate in order in case multiple ones are defined.  Loading... ","version":"Next","tagName":"h2"},{"title":"Runtimes","type":0,"sectionRef":"#","url":"/docs/reference/runtimes","content":"Runtimes The status represents the maturity of the runtime implementation: not documented: experiment at your own riskalpha: incomplete or non-stabilized API, most features should work you should expect breaking changes likelybeta: complete and almost-stable API, but still collecting feedbacks and improving usabilitystable: complete and stable API, no breaking changes expected Missing your favorite runtime? Submit your request and vote for your preferred ones here. Runtime\tDescription\tRuntime version\tStatus\tTypegate versionPrisma\tQuery SQL and no-SQL databases with Prisma\t4.17.0\tbeta\t&gt;0.1.0 Deno\tExecute Typescript functions with NPM or deno dependencies\t1.35.0\tbeta\t&gt;0.1.0 HTTP\tMake HTTP requests to (REST) HTTP APIs beta\t&gt;0.1.0 GraphQL\tMake GraphQL requests beta\t&gt;0.1.0 Random\tGenerate random data based on your schema alpha\t&gt;0.1.0 S3\tManipulate S3-compatible storage alpha\t&gt;0.1.0 Temporal\tQuery and trigger workflow orchestrated by Temporal alpha\t&gt;0.1.0 WasmEdge\tExecute WebAssembly functions alpha\t&gt;0.1.0 Python\tExecute Python functions alpha\t&gt;0.1.0","keywords":"","version":"Next"},{"title":"HTTP/REST","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/http","content":"HTTP/REST The HTTPRuntime allows our typegraphs to access external REST APIs. Example: from typegraph.runtime.http import HTTPRuntime # .. remote = HTTPRuntime('https://dev.to/api') remote.get( '/test', t.struct({}), t.list(t.struct({'a': t.integer()})), ) ","keywords":"","version":"Next"},{"title":"GraphQL","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/graphql","content":"","keywords":"","version":"Next"},{"title":"GraphQL runtime‚Äã","type":1,"pageTitle":"GraphQL","url":"/docs/reference/runtimes/graphql#graphql-runtime","content":" You currently have a single model to describe messages sent in the chat-based app. A reasonable next step is to add a user model and make a link between the two. While you can store users in the same database, it's wiser to avoid data duplication and re-use your service for user management available at GraphQLZero endpoint. Let's introduce the GraphQL runtime that allows remote GraphQL queries.  Update typegraph.py with the highlighted lines below:  Loading...  Again, a few interesting happened here:  No migration has been run. The field user comes from another runtime and doesn't exist in the database. The typegate will orchestrate the query execution in all runtimes and minimize the work done.The from_parent rule automatically fills the input type with the parent field named uid. The g(¬∑) rule allows making named reference to another type and avoid circular reference.  Other type enforcement rules also exists:  from_secret(key) to fill the input type with the secret in the TG_[typegraph name]_[key] formatfrom_context(¬∑) to fill the input type with content from the request context, such as JSON Web Token (JWT), etc.set(x) to fill the input type with content x  You should now start to see the power provided by Metatype and might wonder how to integrate it step by step with your existing systems. Writing all those types by hand is tedious and error-prone. The next section will show you how to generate types from existing sources. ","version":"Next","tagName":"h2"},{"title":"Python","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/python","content":"Python The PythonRuntime allows you to run short-lived code on a Python virtual machine. # my_typegraph.py from typegraph import typegraph, Policy, t, Graph from typegraph.runtimes.deno import PythonRuntime @typegraph() def example_python(g: Graph): public = Policy.public() python = PythonRuntime() g.expose( public, add=t.func( t.struct({&quot;a&quot;: t.integer(), &quot;b&quot;: t.integer()}), t.integer(), # we can provide the code inline using lambdas python.from_lambda(lambda x: x[&quot;a&quot;] + x[&quot;b&quot;]), ), sayHello=python.import_( t.struct({&quot;name&quot;: t.string()}), t.string(), # point to pythoin a file on disc module=&quot;hello.py&quot;, name=&quot;say_hello&quot; ), ) # hello.py def say_hello(x: any): return f&quot;Hello {x[&quot;name&quot;]}&quot; ","keywords":"","version":"Next"},{"title":"Random","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/random","content":"Random","keywords":"","version":"Next"},{"title":"Deno/typescript","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/deno","content":"","keywords":"","version":"Next"},{"title":"Deno runtime‚Äã","type":1,"pageTitle":"Deno/typescript","url":"/docs/reference/runtimes/deno#deno-runtime","content":" The DenoRuntime allows you to run lightweight and short-lived typescript function in a sandboxed environment. Permissions can be customized per typegraph and by default only include some HTTPs domains. It's a great way to implement custom logic and materializers. All typegraphs can lazily spawn a web worker and get an incredible cold-start and continuous performance thanks to the V8 engine powering Deno.  Loading...  Instead of providing the typescript code inline, we can also point to a file on disk:  # my_typegraph.py from typegraph import typegraph, Policy, t, Graph from typegraph.runtimes.deno import DenoRuntime @typegraph() def deno(g: Graph): public = Policy.public() deno = DenoRuntime() g.expose( public, add=deno.import_( t.struct({&quot;a&quot;: t.number(), &quot;b&quot;: t.number()}), t.number(), module=&quot;main.ts&quot;, # path to ts file name=&quot;doAddition&quot;, # function export from ts file to use ), )   Where main.ts looks like:  // main.ts interface AddInput { a: number; b: number; } export function doAddition({ a, b }: AddInput) { return a + b; }  ","version":"Next","tagName":"h2"},{"title":"S3","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/s3","content":"S3 We can make use of the S3Runtime to interact with object storage APIs that implement the S3 api. We'll need to add the following vars to our metatype.yml first. typegates: dev: # .. env: # replace RETREND by the name of your typegraph TG_RETREND_S3_HOST: http://localhost:9000 TG_RETREND_S3_REGION: local TG_RETREND_S3_ACCESS_KEY: minio TG_RETREND_S3_SECRET_KEY: password TG_RETREND_S3_PATH_STYLE: true Our typegraph will then look something like: Loading...","keywords":"","version":"Next"},{"title":"Temporal","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/temporal","content":"Temporal Interacts with Temporal server.","keywords":"","version":"Next"},{"title":"WebAssembly","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/wasmedge","content":"WebAssembly Runs Wasm functions on the WasmEdge runtime.","keywords":"","version":"Next"},{"title":"Prisma","type":0,"sectionRef":"#","url":"/docs/reference/runtimes/prisma","content":"","keywords":"","version":"Next"},{"title":"Prisma runtime‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#prisma-runtime","content":" Prisma is a &quot;Next-generation Node.js and Typescript ORM&quot; supporting PostgreSQL, MySQL/MariaDB, SQLite, MongoDB, CockroachDB and Microsoft SQL Server. It is one of the main runtimes provided by Metatype and doesn't require any additional installation.  Go ahead and update typegraph.py with the highlighted lines below:  Loading...  A few things to note on the changes:  You can import runtimes from typegraph.runtime.Y or typegraph.providers.X.runtimes.Y for non-core providers.The config method allows specifying runtime specific attributes. In this case, id shall be automatically set and incremented by the database.Types get generated names unless you manually specify them. You can find the exact names in the playground documentation. Here you want to have a human friendly name as it will also be the name of the table in your database.Runtimes often come with some sugar syntax to generate types and avoid manipulating materializers directly. A corresponding declaration would have looked like this:    In order to use the Prisma runtime, you need to add a new environment variable. Runtimes don't take raw secrets, but instead a secret key used to look up environment variables named under the format TG_[typegraph name]_[key]. You can either add it in your metatype.yml (recommended) or in your compose.yml.  $ cat metatype.yml typegates: dev: # .. env: TG_DATABASE_POSTGRES_CONN: postgresql://postgres:password@postgres:5432/db $ meta dev   And now, you can iteratively continue to improve your interface, running migrations and having data stored inside your database.  ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#usage","content":" with TypeGraph(&quot;prisma-runtime-example&quot;) as g: db = PrismaRuntime(&quot;main_db&quot;, &quot;DB_CONNECTION&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email(), } ) g.expose( createUser=db.create(user).add_policy(public) )   ","version":"Next","tagName":"h2"},{"title":"Raw query‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#raw-query","content":" Generate a raw SQL query operation on the runtime  db = PrismaRuntime(&quot;my-app&quot;, &quot;POSTGRES&quot;) g.expose( countUsers=db.raw_query( &quot;SELECT COUNT(*) as total FROM User&quot;, t.struct({}), t.list(t.struct({&quot;total&quot;: t.integer()})) ) )   Generate a raw SQL query operation without return  db = PrismaRuntime(&quot;my-app&quot;, &quot;POSTGRES&quot;) g.expose( setActive=db.raw_execute( &quot;UPDATE User SET active = TRUE WHERE id=${id}&quot;, t.struct({&quot;id&quot;: t.uuid()}), effect=effects.update() ), )   ","version":"Next","tagName":"h3"},{"title":"Models‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#models","content":" Any t.struct that is passed to a generator of a PrismaRuntimedefines a model. Models must have an ID field specified by the &quot;id&quot; config.  Here is the list of all the available configs for model fields:  Config\tEffectid\tdefines the field ID for the model (a.k.a. primary key) auto\tthe value of this field can be auto generated; supported for t.integer() (auto-increment) and t.uuid() unique\tmake this field unique among all instances of the model  ","version":"Next","tagName":"h2"},{"title":"Relationships‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#relationships","content":" Relationship fields must be defined on both sides of the relationship. A relationship is always defined for t.struct types and t.optional ort.list of t.struct.  Relationships can also be defined implicitly using the link instance method of PrismaRuntime.  runtime = PrismaRuntime(&quot;example&quot;, &quot;POSTGRES&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email().config(&quot;unique&quot;), &quot;posts&quot;: t.list(g(&quot;Post&quot;)), } ).named(&quot;User&quot;) post = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;title&quot;: t.string(), &quot;author&quot;: g(&quot;User&quot;), } ).named(&quot;Post&quot;)   The PrismaRuntime supports two kinds of relationship between models.  ","version":"Next","tagName":"h2"},{"title":"One-to-one relationships‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#one-to-one-relationships","content":" A one-to-one relationship must be in one of these two variants.  Cardinality\tField type in Model1\tField type in Model21..1 ‚Üî 0..1\tg(&quot;Model2&quot;)\tg(&quot;Model1&quot;).optional() 0..1 ‚Üî 0..1\tg(&quot;Model2&quot;).optional()\tg(&quot;Model1&quot;).optional()  For the optional (0..1 ‚Üî 0..1) one-to-one relationship, you need to indicate on which field/model the foreign key will be by:  wrapping the type in a runtime.link(.) with fkey=True:runtime.link(g(&quot;Model2&quot;).optional(), fkey=True); or adding .config(&quot;unique&quot;): g(&quot;Model2&quot;).optional().config(&quot;unique&quot;).  ","version":"Next","tagName":"h3"},{"title":"One-to-many relationships‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#one-to-many-relationships","content":" A one-to-many relationship must be in one of these two variants.  Cardinality\tField type in Model1\tField type in Model21..1 ‚Üî 0..n\tg(&quot;Model2&quot;)\tt.list(g(&quot;Model1&quot;)) 0..1 ‚Üî 0..n\tg(&quot;Model2&quot;).optional()\tt.list(g(&quot;Model1&quot;))  ","version":"Next","tagName":"h3"},{"title":"Many-to-many relationships‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#many-to-many-relationships","content":" Many-to-many relationships must be modelled explicitly using a join model.  ","version":"Next","tagName":"h3"},{"title":"Link‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#link","content":" Explicitly declare a relationship between models. The return value of this function shall be the type of a property of a t.struct that defines a model. If the other end of the relationship is also defined using link, both links must have the same name.  runtime = PrismaRuntime(&quot;example&quot;, &quot;POSTGRES&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email().config(&quot;unique&quot;), &quot;posts&quot;: runtime.link(t.list(g(&quot;Post&quot;)), &quot;postAuthor&quot;), } ).named(&quot;User&quot;) post = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;title&quot;: t.string(), &quot;author&quot;: runtime.link(g(&quot;User&quot;), &quot;postAuthor&quot;), } ).named(&quot;Post&quot;)   ","version":"Next","tagName":"h3"},{"title":"Generators‚Äã","type":1,"pageTitle":"Prisma","url":"/docs/reference/runtimes/prisma#generators","content":" Generators are instance methods of PrismaRuntime that can be used to generate a t.func that represents a specific operation on a specific model of the runtime. They match to the model queries defined for theprisma client API. for the type of the input t.struct and the return type.  Example:  with TypeGraph(&quot;prisma-runtime-example&quot;) as g: db = PrismaRuntime(&quot;main_db&quot;, &quot;DB_CONNECTION&quot;) user = t.struct( { &quot;id&quot;: t.uuid().config(&quot;id&quot;, &quot;auto&quot;), &quot;email&quot;: t.email(), } ) g.expose( createUser=db.create(user).add_policy(public), findUser=db.find(user).add_policy(public), findManyUsers=db.find_many(user).add_policy(public), )   Here is a list of all available generators:  find_uniquefind_firstfind_manycreateupdateupsertdeletedelete_many ","version":"Next","tagName":"h2"},{"title":"Authentication","type":0,"sectionRef":"#","url":"/docs/reference/typegate/authentication","content":"","keywords":"","version":"Next"},{"title":"Basic authentication‚Äã","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#basic-authentication","content":" Basic authentication is the simplest way to authenticate requests. It is done by sending a base64 encoded string of your username and password in the authorization header. Recall that base64 encoding is not encryption and can be easily reversed, thus the traffic must be encrypted with SSL/TLS when using basic authentication as your password will otherwise be visible.  Components\tValuesSecrets\tTG_[typegraph]_BASIC_[username]=password Header\tAuthorization: Basic base64(username:password) Context\t{ username }  Loading...  ","version":"Next","tagName":"h2"},{"title":"JWT authentication‚Äã","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#jwt-authentication","content":" A more secure way to authenticate requests is to use JSON Web Tokens. The context of a user is signed with a secret key and the typegate will verify the signature to ensure the context has not been tampered with. The JWT is then sent in the authorization header.  The JWT is usually generated by an external identity provider (IdP) such as Keycloak or Auth0 and limited in time. The typegate will check that the exp (expiration time) and nbf (not before) are valid if they exist in the context. The logic of refreshing expired tokens is left to the user or the IdP client library being used.  The typegate supports the most frequently used algorithms for signing the JWT and can be imported as using &quot;jwk&quot;, &quot;raw&quot;, &quot;pkcs8&quot; or &quot;spki&quot; formats (see SubtleCrypto documentation). For instance, an asymmetric key pair can be generated with the following command:  const keys = await crypto.subtle.generateKey( { name: &quot;ECDSA&quot;, namedCurve: &quot;P-384&quot; }, true, [&quot;sign&quot;, &quot;verify&quot;] ); const publicKey = await crypto.subtle.exportKey(&quot;jwk&quot;, keys.publicKey); // save keys.privateKey for later use console.log(JSON.stringify(publicKey)); // in typegraph: Auth.jwt(&quot;keycloak&quot;, &quot;jwk&quot;, {&quot;name&quot;: &quot;ECDSA&quot;, &quot;namedCurve&quot;: &quot;P-384&quot;})   Even though, asymmetric encryption is recommended, HMAC-SHA256 is so commonly used that an alias is provided for it.  Components\tValuesSecrets\tTG_[typegraph]_[authentication]_JWT=secret Header\tAuthorization: Bearer token Context\t{ your_own_content }  Loading...  Note that for the sake of the demo, the token has no expiration time. Tokens should always be shorted lived and refreshed frequently to reduce the risk of unexpected access.  ","version":"Next","tagName":"h2"},{"title":"OAuth2 authorization‚Äã","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#oauth2-authorization","content":" OAuth2 allows a user to grant limited access to their resources on one site, to another site, without having to expose their credentials. It is commonly used when the typegate needed to access restricted information in third-parties such as Google or GitHub.  Most of the time, the OAuth2 is managed by your identity provider and relies on the JWT authentication as explained above. However the typegate provides a simple way to handle the OAuth2 flow without IdP or when the system should be lightweight.  Components\tValuesSecrets\tTG_[typegraph]_[authentication]_CLIENT_ID=client_id, TG_[typegraph]_[authentication]_CLIENT_SECRET=client_secret Header\tAuthorization: Bearer token Context\t{ content_from_your_idp }  ","version":"Next","tagName":"h2"},{"title":"Take flow‚Äã","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#take-flow","content":" Redirect the user to https://[typegate].metatype.cloud/[typegraph]/auth/[authentication]?redirect_uri=https://your-website.com/login and the OAuth2 starts for the user When the user has completed the flow, the typegate will redirect the user to https://your-website.com/login and you can &quot;take&quot; the token from the typegate as follows. This can be only done once and is limited in time:  const take = await fetch( &quot;https://[typegate].metatype.cloud/[typegraph]/auth/take&quot;, { credentials: &quot;include&quot;, } ); const { token } = await take.json();   The token can then be used as JWT in the Authorization header of your requests, and the response of the typegate will contain a header Next-Authorization. When this header is present, the value should be used in follow-up calls (value will be empty if the authentication has expired).    Loading...  ","version":"Next","tagName":"h3"},{"title":"OpenID Connect‚Äã","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#openid-connect","content":" OpenID Connect is an authentication layer on top of OAuth2. It is used to verify the identity of the user and retrieve basic information about them. You can add openid to the OAuth2 scope and you will receive an id_token in the response. The id_token is a JWT that contains the user's information and is signed by the IdP.  ","version":"Next","tagName":"h3"},{"title":"Embedded providers‚Äã","type":1,"pageTitle":"Authentication","url":"/docs/reference/typegate/authentication#embedded-providers","content":" Frequent OAuth2 providers are embedded and can be directly used in the typegraph.  from typegraph.graph.auth import oauth2 oauth2.github(&quot;openid profile email&quot;)   The whole list is available here. ","version":"Next","tagName":"h3"},{"title":"CORS","type":0,"sectionRef":"#","url":"/docs/reference/typegate/cors","content":"CORS Cross-Origin Resource Sharing (CORS) on the one hand is a mechanism that allows or denies cross-origin requests in the browser. It avoids that other websites use your API without explicitly allowing it. Note that it doesn't protect other servers or a mobile app from using your typegraphs, only browsers implements the CORS mechanism. See this documentation for the details. Loading... If your browser support well CORS, you should see an error and even more if you try to run the interactive demo. By the way, there is a hidden core header in all interactive demos you have met so far: TypeGraph.Cors(allow_origin=[&quot;https://metatype.dev&quot;, &quot;http://localhost:3000&quot;]) ","keywords":"","version":"Next"},{"title":"Typegate","type":0,"sectionRef":"#","url":"/docs/reference/typegate","content":"","keywords":"","version":"Next"},{"title":"With Metatype Cloud‚Äã","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#with-metatype-cloud","content":" This is the easiest way to get started, yet it's not publicly accessible. You can sign up for the private beta below.    ","version":"Next","tagName":"h3"},{"title":"With Docker‚Äã","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#with-docker","content":" Install Docker and use the following compose.yml to launch a typegate node. Redis is the single required dependency, however in practice you will want to add database or other systems that the typegate can connect to.  services: typegate: image: ghcr.io/metatypedev/typegate:latest ports: - &quot;7890:7890&quot; extra_hosts: - &quot;host.docker.internal:host-gateway&quot; environment: # only for dev, generate secure values for production TG_SECRET: &quot;a4lNi0PbEItlFZbus1oeH/+wyIxi9uH6TpL8AIqIaMBNvp7SESmuUBbfUwC0prxhGhZqHw8vMDYZAGMhSZ4fLw==&quot; TG_ADMIN_PASSWORD: password REDIS_URL: redis://:password@redis:6379/0 DEBUG: &quot;true&quot; depends_on: - redis redis: image: redis:7 restart: always command: --requirepass password   # launch the containers docker compose up --detach # watch the typegate logs docker compose logs typegate --follow   ","version":"Next","tagName":"h3"},{"title":"Internal APIs‚Äã","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#internal-apis","content":" Most of the internal APIs are still unstable, and may change without notice. If you still want to experiment with them, you can use the GraphQL introspection to discover them.  /typegate/prisma-migration  The typegate nodes - or typegates - are the central components of the ecosystems. They build and type check typegraphs, and expose them through a HTTP/GraphQL interface. They enforce the type safety of the data flows, connect to all the runtimes and orchestrate the execution of incoming requests.  ","version":"Next","tagName":"h2"},{"title":"Request lifecycle‚Äã","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#request-lifecycle","content":" When a new request fires a trigger, the typegate orchestrates the following stages:  extract the secure request context from custom authentication or JSON Web Token (JWT)retrieve cached execution plan or compute a new one traverse the typegraph to create a DAG of the required typesoptimize the DAG to reduce the number of calls to the runtimespre-compute all structural elements and data resolutions execute the plan type check the argumentsverify lazily policies on the needrun the DAG executionenforce the rate-limitingtype check the response manage metadata of the request  ","version":"Next","tagName":"h2"},{"title":"HTTP/GraphQL interface‚Äã","type":1,"pageTitle":"Typegate","url":"/docs/reference/typegate#httpgraphql-interface","content":" For now, the typegate nodes are only accessible through HTTP/1.1 and HTTP/2. More protocols could be supported in the future. Typegates expose a GraphQL interface which is the result of a typegraph projected onto corresponding GraphQL types. While this reduces the type safety of the data flowing, it makes more interoperable thanks to the many high-quality and well-known GraphQL tooling already available. The underlying types are also exposed in order for API clients to verify the underlying types.  GraphQL, being a query language, offers a great asset for Metatype's philosophy:  Efficient querying: the client can specify exactly what data it needs, reducing the amount of over- or under-fetchingFlexibility: allows for retrieving multiple resources in a single request, unlike REST, which often requires multiple onesTyping: GraphQL has a built-in type system that allows for better documentation and stronger validation of the requestsImproved tooling: tools and libraries around GraphQL are rapidly growing and great a development experience ","version":"Next","tagName":"h2"},{"title":"Rate limiting","type":0,"sectionRef":"#","url":"/docs/reference/typegate/rate-limiting","content":"Rate limiting The rate limiting algorithm works as follows: each function type can either count the # of calls it gets or the # of results returned rate_calls=Falseeach function type can have a weight rate_weight=1each request is identified by its IP or by one value of its context if set context_identifiera single query can score a maximum of query_limitmultiple queries can sum up to window_limit in a window_sec windowwhen there is multiple typegates (N), you can improve performance by avoiding score synchronizing while the typegate has not reached local_excess: the real maximum score is thus window_limit + min(local_excess, query_limit) * N Loading... Playing with the above should allow you to quickly hit the limits.","keywords":"","version":"Next"},{"title":"Synchronization","type":0,"sectionRef":"#","url":"/docs/reference/typegate/synchronization","content":"","keywords":"","version":"Next"},{"title":"System setup‚Äã","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#system-setup","content":" To enable multiple typegate instance support, the system need the following services:  Service\tRoleLoad balancer\tShare the loads accross the different typegate instances Redis database\tUsed for synchronization between typegate instances S3 storage\tStore all the shared files/artifacts for the typegate instances Typegate instances\tObvious    ","version":"Next","tagName":"h2"},{"title":"Load balancer‚Äã","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#load-balancer","content":" The setup does not require a specific load balancer software/hardware. Any load balancer can do the job.  ","version":"Next","tagName":"h3"},{"title":"Redis database‚Äã","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#redis-database","content":" A single redis instance can be shared by multiple systems, configured with different database numbers.  ","version":"Next","tagName":"h3"},{"title":"S3 storage‚Äã","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#s3-storage","content":" Any S3-compatible object store is supported for the file/artifact storage.  One S3 storage might be shared by multiple systems. However, each system must be configured to use its own dedicated bucket.  ","version":"Next","tagName":"h3"},{"title":"Typegate instances‚Äã","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#typegate-instances","content":" The typegate instances are configured with environment variables. All the instances of the system must share the same value for the synchronization variables.  See configuration for details.  ","version":"Next","tagName":"h3"},{"title":"Typegate configuration‚Äã","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#typegate-configuration","content":" The typegate instances that at the core of the system must share the configuration variables.  Synchronization variable names start with SYNC_.  warning If no SYNC_* variable is present, the typegate will run in the default single instance mode.The typegate will fail to start if any of the SYNC_* variables is present and some required SYNC_* variable is missing.  Variable\tDescriptionSYNC_REDIS_URL (Required)\tURL to the Redis database. Must include the database number. SYNC_REDIS_PASSWORD (Optional)\tRedis database password, can be included in SYNC_REDIS_URL; SYNC_S3_HOST (Required)\tHostname of the S3 store; SYNC_S3_REGION (Required)\tS3 region; SYNC_S3_ACCESS_KEY (Required)\tAccess key for the S3 store credentials; SYNC_S3_SECRET_KEY (Required)\tAccess key secret for the S3 store credentials; SYNC_S3_PATH_STYLE (Optional)\ttrue or false, force path style if true. SYNC_S3_BUCKET (Required)\tThe bucket to be used for the system (dedicated).  ","version":"Next","tagName":"h2"},{"title":"Synchronized mode features‚Äã","type":1,"pageTitle":"Synchronization","url":"/docs/reference/typegate/synchronization#synchronized-mode-features","content":" Sharing typegraphs accross multiple typegate instancesHistory (WIP) ","version":"Next","tagName":"h2"},{"title":"Typegraph","type":0,"sectionRef":"#","url":"/docs/reference/typegraph","content":"","keywords":"","version":"Next"},{"title":"SDK‚Äã","type":1,"pageTitle":"Typegraph","url":"/docs/reference/typegraph#sdk","content":" The typegates only know of and accept typegraphs in their serialized format. But for authoring typegraphs, we make use of SDK libraries available in different languages.  Typescript SDKPython SDK Install the @typegraph/sdk package from npm using your preferred package manager and runtime. The SDK requires Node 16+ with Typescript 4.7+, Deno 1.28+ or Bun 1+. # using pnpm pnpm add @typegraph/sdk # using npm npm install @typegraph/sdk # using yarn yarn add @typegraph/sdk # using Deno import { ... } from &quot;npm:@typegraph/sdk/mod.ts&quot;; # using Bun bun add @typegraph/sdk When using Node, make sure to add this to your Typescript configuration: &quot;moduleResolution&quot;: &quot;node16&quot;, // Or &quot;nodenext&quot;  ","version":"Next","tagName":"h2"},{"title":"Functions","type":0,"sectionRef":"#","url":"/docs/reference/types/functions","content":"","keywords":"","version":"Next"},{"title":"Effects‚Äã","type":1,"pageTitle":"Functions","url":"/docs/reference/types/functions#effects","content":" Effects are a property of materializers and help categorization what happens to data when it gets transformed. Although they are similar to REST verbs and SQL statements, there is no direct one-to-one mapping.  Effects\tREST verbs\tSQL statementsnone\tGET\tSELECT create\tPOST\tINSERT update\tPUT/PATCH\tUPDATE upsert\tPUT\tINSERT ON CONFLICT delete\tDELETE\tDELETE  They provide hints to the typegates for the query orchestration by splitting the queries and mutations. For example, the create effect is exposed as a mutation. They also allow setting different policies based on them, that's for the next page. ","version":"Next","tagName":"h2"},{"title":"Importers","type":0,"sectionRef":"#","url":"/docs/reference/types/importers","content":"","keywords":"","version":"Next"},{"title":"Google importers‚Äã","type":1,"pageTitle":"Importers","url":"/docs/reference/types/importers#google-importers","content":" The typegraph module comes with some handy importers to avoid having to rewrite manually all types and materializers. Currently, it supports importers for OpenAPI, GraphQL API and Google APIs.  Importers are function call with a boolean re-writing the source code file where they live. As they can generate quite long type definition, the best practice is to separate them into a dedicated file that can be imported into your main typegraph. Let's create google.py and run python google.py to generate the types.  This should generate code similar to this:  And can be imported/customized in your main typegraph file: ","version":"Next","tagName":"h2"},{"title":"Specifications","type":0,"sectionRef":"#","url":"/docs/reference/typegraph/specifications","content":"","keywords":"","version":"Next"},{"title":"Notations‚Äã","type":1,"pageTitle":"Specifications","url":"/docs/reference/typegraph/specifications#notations","content":" t.int() ‚Üí int t.int(as_id=true) ‚Üí int(as_id=true) t.int(...) ‚Üí int(¬∑) t.list(t.int()) ‚Üí [int] t.optional(t.int()) ‚Üí ?int t.either([t.int(), t.float()]) ‚Üí int ‚äï float ‚Üí either int float t.union([t.int(), t.float()]) ‚Üí int | float ‚Üí union int float t.int().compose(t.float()) ‚Üí int &amp; float ‚Üí compose int float t.struct({&quot;a&quot;: t.int(), &quot;b&quot;: t.float()}) ‚Üí struct a: int b: float  ","version":"Next","tagName":"h2"},{"title":"Injections","type":0,"sectionRef":"#","url":"/docs/reference/types/injections","content":"","keywords":"","version":"Next"},{"title":"Raw‚Äã","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#raw","content":" ","version":"Next","tagName":"h2"},{"title":"Parent‚Äã","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#parent","content":" caution Only supported for scalars type inside a struct.  ","version":"Next","tagName":"h2"},{"title":"Context‚Äã","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#context","content":" ","version":"Next","tagName":"h2"},{"title":"Secret‚Äã","type":1,"pageTitle":"Injections","url":"/docs/reference/types/injections#secret","content":"","version":"Next","tagName":"h2"},{"title":"Reducers","type":0,"sectionRef":"#","url":"/docs/reference/types/reducers","content":"Reducers","keywords":"","version":"Next"},{"title":"","type":0,"sectionRef":"#","url":"/docs/reference/changelog","content":"","keywords":"","version":"Next"},{"title":"v0.3.6 - 2024-03-14‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v036---2024-03-14","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes","content":" (gate) RandomRuntime does not consider enum, either, union variants (#619) add either, enum, struct and union type support in Random Runtime. Motivation and context‚Äã generating random values for enums, either and union types was failing. Migration notes‚Äã _No Migrations Needed Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (python-wasi) Fix for vm not initialized after consecutive deploy (#617) Bug fix for typegate throwing vm not initialized after reload Motivation and context‚Äã Bug fix Migration notes‚Äã No Migrations Needed Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Apply from context (#616) Fix type validators for apply from context. Motivation and context‚Äã Bug. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Optimize typegraph size (#618) Hash all type data to compare them on the conversion phase in typegraph/core: remove duplicate types from type final typegraph (duplicate: same value for all the fields except for the &quot;random&quot; name/title).Skip unreferenced types in .apply Motivation and context‚Äã Typegraph is too big sometimes. Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks","content":" Prepare release v0.3.6 (#626) Prepare release v0.3.6 Motivation and context‚Äã N/A Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"v0.3.5 - 2024-03-05‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v035---2024-03-05","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-1","content":" (cli) Fix for meta-cli deploy exit with code 0 on failure (#600) fix the issue where meta-cli deploy command exits with code 0 on failure. Motivation and context‚Äã bug fix Migration notes‚Äã No changes needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (typegate,typegraph) Minor bugs (#596) Just a few very minor bugs I'd encountered this week. Tests pending. Motivation and context‚Äã Bugs. Migration notes‚Äã No changes required Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Show error message for unregistered type name (#594) Check and throw the error for the expose function when called from the Python SDK. Motivation and context‚Äã We got a finalization failure when there are some unregistered type referenced with g.ref. Migration notes‚Äã No changes needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Remove injections from prisma output types (#597) Remove injections from generated output types for prisma operations. Motivation and context‚Äã Generated types fail validations (injection not allowed in output types). Migration notes‚Äã No changes needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Esm customizer for typegate deno ext (#606) Enables v8 snapshots integration for meta typegate subcommand and the standalone typegate. Also bumps deno to 1.41.0. Motivation and context‚Äã  Re-enable macos-latest cli-compat test job (#608) Fixes and enables the broken job. Motivation and context‚Äã Job was disabled earlier to mysterious breakages. Migration notes‚Äã No changes required Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features","content":" (deno/sdk) Native function embedding in typescript (#598) Add support for function or lambda definition typescript sdk for deno.funcsimilarly to how python.from_def in python sdk works. Motivation and context‚Äã Providing a string is a bit impractical and counter-intuitive espcially when the sdk language matches with runtime's language. Migration notes‚Äã No changes needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (sdk) Testing framework integration 2 (#579) Motivation and context‚Äã Continuation of #566 , focused on prisma runtime. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (sdk) From_random injection (#593) This change includes changes in StringFormats(added some string formats), logic to provide random values for type nodes and tests to validate the changes. The changes are mostly in the typegraph sdk. Motivation and context‚Äã This feature enables the user to inject random values for a field(Type Node) when defining a Typegraph. Migration notes‚Äã No changes needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Remove obsolete restrictions on prisma (#592) Motivation and context‚Äã Since v5, where on unique queries exposes all the fields, not just unique fields.  Parameter transformation (#587) Enable parameter transformation with the .apply() method. It has more or less the same logic as .reduce() with the ability to flatten the input type. Motivation and context‚Äã This feature enables simpler APIs (input types) on top of runtimes (e.g.: prisma). Migration notes‚Äã No changes needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Nested context query (#595) BREAKING: Nested context query (#595) Revert context flatteningEnable jsonpath-like key to access nested object fields or array items on the context. Migration notes‚Äã If you access the context directly in your application (through the token), access to nested fields shall be updated. E.g. the expressioncontext[&quot;profile.id&quot;] have to turned to context.profile.id. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-1","content":" (release) Bump 0.3.5 (#613) Ready for release of v0.3.5 Motivation and context‚Äã Required by console. Migration notes‚Äã No changes required_. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Refactor‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#refactor","content":" (sdk) Move post-processing functions to the typegate (#586) Motivation and context‚Äã Depends on #579 Compiled wasm bin size is too large, goal is to reduce it to ~3MB. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Make fat meta-cli the default (#607) BREAKING: make fat meta-cli the default (#607) Switch the default meta-cli release to the fat version (the one that includes the typegate subcommand). Motivation and context‚Äã  ","version":"Next","tagName":"h3"},{"title":"v0.3.4 - 2024-02-10‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v034---2024-02-10","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-2","content":" (ci) upload-artifact@v4 migration, cross compilation for meta + typegate (#571) The recent update to upload-artifact@v4 has some breaking changes as describedhere. This PR addresses them. It also fixes the cross-compilation issues with themeta-cli job in the release workflow. Motivation and context‚Äã Issuein release workflow. Migration notes‚Äã No changes required. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (ci) Minor typo in release.yml/docker (#576) Small typo blocking the job that pushes the images to ghcr.io. Motivation and context‚Äã Broken run. Migration notes‚Äã No changes required. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (ci) Missing ts modules from typegate image (#577) Adds a check step to the typegate's Dockerfile and converts the.dockerignore to be a whitelist. Motivation and context‚Äã The image for 0.3.3 has some files missing. Migration notes‚Äã No changes required Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (typegate) Fix tmp dir issue, bump to 0.3.4 (#583) Fixes an issue with the prisma migration code being unable to properlymktmpd when running in the typegate images.Removes cross usage for all but the aarch64-unknown-linux-gnu target in the meta-cli release jobs. Deno doesn't like being cross compiled, doesn't like being built by the cross toolchain in general (even for the native target). The consequence of all this is that the aarch64-unknown-linux-gnutarget will temporarily lack the full version builds.This also bumps the version of the 0.3.4 to get the fix out. Motivation and context‚Äã The main TMP_DIR was not created properly in the typegate Dockerfile. Migration notes‚Äã No changes required Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Remove unallowed fields (#569) Skip fields with policies in findListQueries. Motivation and context‚Äã Console. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Hotfix typo in release.yml (#580) Yes, another one lol. This removes the target param from the release builder which will default to the last stage of the Dockerfile, the epoint stage. I elected to remove the parameter rather than replacing the value in order to remove one more place future changes will have to consider. (convention better than configuration the saying goes (i think)). Motivation and context‚Äã The typegate images currently have the wrong target and thus the wrongentrypoint command. Migration notes‚Äã No changes required Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Documentation‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#documentation","content":" (website) Cleanup (#521) Describe your change‚Äã This mainly shuffles around the existing docs for better structure. Still a lot to be done. The following pages are also empty as I lack the info regarding their topics: ArchitectureQuery engine Super open to feedback. Bring up any points that you think should be mentioned on each page and I'll add them.  Getting started guide for the vscode extension (#578) Motivation and context‚Äã Documentation is missing. Migration notes‚Äã No changes needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-1","content":" (sdk) Testing framework integration (#566) Motivation and context‚Äã Enable deploying directly from the typegraph instead of always relying on meta-cli. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"v0.3.3 - 2024-01-31‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v033---2024-01-31","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-3","content":" (ci) Bug in typegraph release job (#545) Motivation and context‚Äã jco output path is wrong. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (ci) Typo in release.yml (#548) Fix small typo. Surprised act didn't catch this, it must evaluate expressions lazily.  (ci) Force/skip push to registries on manual release (#549) What it says on the tin can. Also fixes a typo in the vscode-extension job. Motivation and context‚Äã Manual re-release breaks otherwise as seenhere.  (ci) Typos in release.yml (#550) Oof, I can't believe I missed these. The publish steps are hard to test locally with act so ig they require extra scrutiny. Motivation and context‚Äã Bug on manual dispatch of releasae wflow.  (ci) Mismatch in location of $AZURE_DEVOPS_TOKEN (#551) Another minor issue with the release workflow. Motivation and context‚Äã Failure in release runhere.  (ci,release) Hack for broken arm64 builds, bump deno to 1.40.1, bump to 0.3.3 (#565) This provides a temporary fix for the broken build on arm64. The issue's related to wasm-opt builds not being availaible for install by ghjk/cargo-binstall. This PR uses cargo install directly instead when in the dockerfile. It also: bumps metatype version to 0.3.3 to ready the next releasebumps the deno version to 1.40.1 (which comes with some changes) Motivation and context‚Äã Failure in CI run.. Migration notes‚Äã No changes required Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (cli) Bad conditionals in loader detection (#559) BREAKING: bad conditionals in loader detection (#559) Fix bug in js typegraph loader detection.FIx bug where the cwd for loader was overridden in loader_cmd despite being set in get_loader_cmd.Update to latest ghjkRefresh setup task in whiz.yaml Motivation and context‚Äã The old conditionals were faulty. Migration notes‚Äã node and bun loaders are now run with the cwd set to the directory of the typegraph as opposed to the metatype.yml file. This should resolve settings to the nearest package.json despite location. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (cli, typegate) Explicitly import DenoRuntime.import modules from path (#564) When using the dynamic import function, if you provide it a raw path like/foo/bar/baz and deno detects the current module's loaded from a remote host, it'll convert it to a http url. Reasonable behavior but it turned out to be the cause of #560. This pr fixes this issue along with: Puts contents of main.ts in a try/catch block for better error logging.Fixes minor permission bugs with the bundled runtime. Motivation and context‚Äã #560 Migration notes‚Äã No changes required Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (oauth2-profiler) Fix OAuth2 profiler params (#562) Pass the appropriate request URL and headers to the profiler resolver. Motivation and context‚Äã It used the provider url instead of the (typegate) request URL, causing internal queries to fail. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (template/node) Update sdk version to 0.3.2 + add deno.static (#558) Motivation and context‚Äã Sync template examples with latest 0.3.2. Added missing deno.static andfunc.rate(...) on node. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (vscode-extension) Fix publisher name and version (#553) Change the publisher name to metatypedev to match the account name on Azure Devops.Add dev-tools projects to dev/lock.yml for automatic versioning. Motivation and context‚Äã Failureto publish the extension. Non-matching version. Migration notes‚Äã Blank Checklist‚Äã The change come with new or modified tests (N/A) Hard-to-understand functions have explanatory comments (N/A) End-user documentation is updated to reflect the change (N/A)  ","version":"Next","tagName":"h3"},{"title":"Documentation‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#documentation-1","content":" (website) Move typegraphs in separate folder + add ts version (#552) Motivation and context‚Äã Better organization + typescript examples. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-2","content":" (node) Node fontend missing features (#557) Motivation and context‚Äã Easier translation from python to typescript typegraph. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (prisma) Add support multi-field ids and id on struct (#556) Adds support for more advanced id fields and unique constraints: Multi-field idId on struct (foreign key)Multi-field unique constraintsUnique constraint on struct (foreign key) Motivation and context‚Äã Support these kind of construct: user = t.struct( { &quot;authProvider&quot;: t.string().from_context(&quot;provider&quot;), &quot;profileId&quot;: t.string().from_context(&quot;profile.id&quot;), # ... }, config={&quot;id&quot;: [&quot;authProvider&quot;, &quot;profileId&quot;]}, ).rename(&quot;User&quot;) project = t.struct( { &quot;id&quot;: t.uuid(as_id=True, config=[&quot;auto&quot;]), &quot;owner&quot;: g.ref(&quot;Account&quot;), &quot;name&quot;: t.string(min=3, pattern=&quot;^[A-Za-z_-]$&quot;), }, config={&quot;unique&quot;: [[&quot;owner&quot;, &quot;name&quot;]]} ).rename(&quot;Project&quot;) Migration notes‚Äã No migration needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (typegate) Oauth2 token validation endpoint (#567) Create an oauth2 token validation endpoint: /:tgName/auth/validate. Motivation and context‚Äã Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (typegate-rt) Extend typegate runtime (#561) Extend the typegate runtime with the following queries: findListQueries: find all the queries that returns a list of t.struct. Motivation and context‚Äã Console. Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (vscode-ext) Logo, README, display name, description (#554) Added a better display name and descriptionAdded logo and README  Flattened context (#555) Flatten profile fields in the context. So instead of { provider: 'github', accessToken: 'xxxxxxxxxxxxxxxxxxxxxxxxxx', refreshToken: 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx', refreshAt: 1704717676, profile: { id: '43663718' }, exp: 1707280877, iat: 1704688876 } we would have: { provider: 'github', accessToken: 'xxxxxxxxxxxxxxxxxxxxxxxxxx', refreshToken: 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx', refreshAt: 1704717676, 'profile.id': '43663718', exp: 1707280877, iat: 1704688876 } Motivation and context‚Äã It was impossible to get the nested id into a from_context injection. Now we can inject .from_context(&quot;profile.id&quot;). Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Refactor‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#refactor-1","content":" (ci) workflow_dispatch for release wflow (#546) Manual trigger for release wflowAdds missing ghjk step for vscode-extension release job Motivation and context‚Äã Provides recovery path for when things break. Migration notes‚Äã Doesn't affect end users. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"v0.3.2 - 2024-01-12‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v032---2024-01-12","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-4","content":" (ci) Release changelog generation (#542) Describe your change‚Äã Configures the checkout action step in the workflow that generates the workflow to clone the full git history. Motivation and context‚Äã The updates to the release workflow that introducegit cliff based changelogs (back in #487) don't appear to be in effect. Migration notes‚Äã No end user changes required. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (website) Fix docusaurus warnings (#526) Describe your change‚Äã Fix docusaurus warnings on the website Motivation and context‚Äã SolvesMET-307 Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Fix stage iteration (#540) Describe your change‚Äã Fix the iterChildStages function. It does not yield accurate values in some edge cases.Update the testing framework to enable planning without executing on theGraphQLQuery object. Motivation and context‚Äã Sibling stages can be falsely registered as children, for example with the following stages: getUser.id getUser.identity getUser.ideas Migration notes‚Äã No migration needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments (N/A) End-user documentation is updated to reflect the change (N/A)  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-3","content":" (cli) Interactive deployment for prisma (#527) Describe your change‚Äã Make the CLI interactive for migration options to development and production databases. Motivation and context‚Äã MET-257 Migration notes‚Äã This creates some breaking changes if you use the CLI in a non-interactive way. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (gate) Redis-less mode (#528) Describe your change‚Äã Fallback to MemoryRegister and NoLimiter if typegate is unable to connect to Redis. Motivation and context‚Äã Enable Redis-Less mode. Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (lsp) Simple diagnostics (#496) Describe your change‚Äã Adds a simple LSP implementation for diagnostics. Motivation and context‚Äã Better DX, catch potential errors while editing the typegraph module. Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (prisma) Connect/create many relation (#522) Describe your change‚Äã Add missing create: [ ... ] and connect: [ ... ] Motivation and context‚Äã SolvesMET-304 Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (python_wasi) Vm docking (#520) Describe your change‚Äã Bump all WasmEdge dependencies to latest versionReplace wasmedge_sdk_bindgen with VmDock Motivation and context‚Äã wasmedge_sdk_bindgen is deprecated, VmDock replaces it entirely. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (sdk/node) Move js deno to node (#539) Describe your change‚Äã Change deno frontend to pure node Motivation and context‚Äã Easier integration. Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Customizable oauth2 profiler (#538) Describe your change‚Äã Enable custom profiler for the std (predefined) Oauth2 providers: Default profilerNo profilerExtended default profilerCustom profiler Motivation and context‚Äã We may want for example to add the Github login in the profile in addition to the id. Migration notes‚Äã No migration needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Limited parallel loads (#537) Describe your change‚Äã Limit the number of parallel loads. The default max is the number of CPU cores, but it can be set with the option --max-parallel-loads=N. Motivation and context‚Äã When we have a high number of typegraphs, the loader processes exhaust the CPU load. Migration notes‚Äã No migration needed. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-2","content":" (release) Bump 0.3.2 (#543) Bump the version of all metatype libs to 0.3.2. Motivation and context‚Äã About to tag the next version. Migration notes‚Äã Change their manifests to point at the new version. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Refactor‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#refactor-2","content":" (ci) Use ghjk for deps (#495) Describe your change‚Äã This PR merges most of the CI test runs into one and make use of the ghjk tool to install most of the dependencies. Motivation and context‚Äã Improve tool dependency management. Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Use shadow_rs for versions (#523) Describe your change‚Äã Replaces the common::get_version util function with the PKG_VERSIONvariables extracted from shadow_rs. If you know of any other opportunities where we can replace things fromshadow_rs, we can add them in this PR as wel.. Motivation and context‚Äã shadow_rs makes the old function redundant Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"Testing‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#testing","content":" (gate) Add tests with file upload and apollo client (#529) Describe your change‚Äã Add file upload test using raw fetch and apollo client. Motivation and context‚Äã Ensure common uses of upload feature to work. Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  ","version":"Next","tagName":"h3"},{"title":"v0.3.1 - 2023-12-08‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v031---2023-12-08","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-5","content":" (ci) Release workflow bugs (#518) Describe your change‚Äã Fix the release workflow according to the CI updates from #487. Motivation and context‚Äã Bug. Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Git cliff  ","version":"Next","tagName":"h3"},{"title":"v0.3.0 - 2023-12-08‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v030---2023-12-08","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-6","content":" (gate) Pushing a typegraph must not timeout (#511) Describe your change‚Äã Retry policy eval one more time if too long Motivation and context‚Äã MET-296  (tests) Use temporary directories for test git repositories (#485)  (xtask) Add support for end of flags and typechecking (#493) Describe your change‚Äã Adds support for end of flags arguments to the cargo x deno test/benchcommands. Motivation and context‚Äã Fix an issue that preventing a updating snapshots as implemented in thedev/test.ts script.  Small fixes (#486)  Remove meta prisma subcommand (#490) Solve MET-292  Typed result and similar (#509) Describe your change‚Äã Fixes datetime return type by returning the value field instead of the whole object. Motivation and context‚Äã Prisma has a $type tag for formatted string such as DateTime, this PR aims to add support for that. Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Fix default argument computation for objects (#510) Describe your change‚Äã Fix the default argument computation. Make non-optional objects optional if all of its fields are optional. Motivation and context‚Äã MET-295 Migration notes‚Äã N/A Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change: N/A  Revert deno to 1.38.1 (#516) Describe your change‚Äã Revert the embedded deno to 1.38.1. Motivation and context‚Äã Deno 1.38.2 does not work well with the FFI bindings.  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-4","content":" (cli) Actor model (#471)  (cli) Nodejs loader (#515) Describe your change‚Äã Add support for using nodejs runtime to execute and serialize typescript based typegraphs. This also adds support for MCLI_LOADER_CMD that can be used to override the command to exec the typegraphs. Motivation and context‚Äã Previously, meta-cli either used the and python &amp; deno runtimes to serialize the typegraphs. Now that @typegraph/sdk also supports Node.js, users might be developing in environments wher deno runtime is not availaible butnode is. This PR provides a way fwd in those cases. Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  (cli) Meta undeploy subcommand (#508) Describe your change‚Äã Add undeploy subcommand to the meta CLI. Motivation and context‚Äã Allow user to undeploy a typegraph.We always had resource leak error when deploying a typegraph from a test step. This subcommand would allow us to undeploy the typegraph at the end of the test step. Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change: N/A  (prisma/migrations) Default value on new column (#465) Display a more concise error message for new column that failed the NON NULL constraint during the migration. Enable user to set default value on new NON NULL column.  (sdk,gate) Node information by path (#498) Describe your change‚Äã Fixes renamed function in sdkAdds argInfoByPath utility function in typegate.py Motivation and context‚Äã Make the task of fetching type information from the graphql function args easier Migration notes‚Äã Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  mt_deno (#466) Todo in this PR: Expose bench and test sub commands from deno This approach gives us a binary size of 101 MiB stripped and 143 MiB prior.  Docs update + project structure (#487)  ","version":"Next","tagName":"h3"},{"title":"Refactor‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#refactor-3","content":" (typegraph/core) Remove wrapper types (#489) Solve MET-260. Wrapper types will be implemented like .rename(...). Remove WithInjection type Remove WithPolicy type Remove WrapperType&lt;T&gt;  Sdk dx (#470) rename apply to reduce move t.ref to g.ref and remove t.proxy rename t.array to t.list standard policies should defined in core remove python* section in metatype.yml  Replace deno_bindgen ffi with v8 Extension ffi (#481) What's pending: Replace usage and make sure tests run successfully Remove old binding code  Three binaries (#483) TL;DR meta typegate that uses the ecma sources hosted on GitHub This is configurable using flags cargo x typegate that uses the local sources from ./typegate/srctypegate_prod that also uses sources from ./typegate/src as might be found in it's container This behavior is configurable using environment variables  ","version":"Next","tagName":"h3"},{"title":"Testing‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#testing-1","content":" Move cli e2e test to typegate/tests/e2e (#492) Describe your change‚Äã Move CLI e2e tests to typegate/tests/e2e Motivation and context‚Äã MET-208 Checklist‚Äã The change come with new or modified tests Hard-to-understand functions have explanatory comments End-user documentation is updated to reflect the change  Fix tests (#507) Describe your change‚Äã Attempt to fix all the failing tests in the main branch. Test parallelization requires tests to use different: temporary git repositories (previously solved);different port for virtual typegate instances;different database namespace (postgres schema). This applies toe2e/cli/deploy_test.ts and e2e/typegraph/templates_test.ts. A regression was introduced by a previous by a previous PR on the typegraph serialization, that disabled injection for union/either types.Most of the snapshots were outdated.  ","version":"Next","tagName":"h3"},{"title":"v0.2.4 - 2023-10-25‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v024---2023-10-25","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-7","content":" (sdk) Reduce union/either variant if required in apply syntax (#463)  Fix lock.yml (#459) Fix lock.yml to set WASM_OPT_VERSION in whiz.yaml  Fix doc typegraphs deployment (#462)  Set metatype version to v0.2.4 (#467)  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-5","content":" Pre-registered public policy (#461) The PolicyId for the public policy was cached in a class variable in Policy. The cache was not valid in a second typegraph defined in the same module.  ","version":"Next","tagName":"h3"},{"title":"v0.2.3 - 2023-10-19‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v023---2023-10-19","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-8","content":" (gate) Explicit null on query arg (#453) Solves MET-268 + fixes an edgecase for &quot;weak validation&quot;  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-6","content":" (gate,sdk) Update auth interface, better oauth2 (#447)  Remove injected fields from generated types for prisma operations (#448) Injected fields are skipped when generating types for prisma. Additional changes: Enable recursive relationships in where filters.Add disconnect, update, upsert, delete, updateMany, deleteMany on nested reletionships for create/update operations.Fix optional union arg validation.  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-3","content":" Upgrade wasm-opt (#456)  ","version":"Next","tagName":"h3"},{"title":"v0.2.2 - 2023-10-11‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v022---2023-10-11","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-9","content":" (gate) Script reload while gate is running (#441)  ","version":"Next","tagName":"h3"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-7","content":" (sdk) Change rest queries interface (#444)  Stability fixes (#442)  Wasm + change effect none to read (#443)  ","version":"Next","tagName":"h3"},{"title":"v0.2.1 - 2023-10-05‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v021---2023-10-05","content":" ","version":"Next","tagName":"h2"},{"title":"Bug Fixes‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#bug-fixes-10","content":" Update rename logic (#439) Duplicate the store entry instead of referencing.  ","version":"Next","tagName":"h3"},{"title":"Refactor‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#refactor-4","content":" (typegraph_core) Simplify private rust SDK (#432)  ","version":"Next","tagName":"h3"},{"title":"v0.2.0 - 2023-10-04‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#v020---2023-10-04","content":" ","version":"Next","tagName":"h2"},{"title":"Features‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#features-8","content":" Release 0.2.0 (#434)  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Tasks‚Äã","type":1,"pageTitle":"","url":"/docs/reference/changelog#miscellaneous-tasks-4","content":" Check that all interfaces are implemented in both sdk (#435)  Hotfix release flow  Hotfix release ","version":"Next","tagName":"h3"},{"title":"Types","type":0,"sectionRef":"#","url":"/docs/reference/types","content":"","keywords":"","version":"Next"},{"title":"Overview‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#overview","content":" Types are used to describe the data to be processed. They constrains the range of value that can be accepted as input data or expected as result on each computation running in a runtime.  ","version":"Next","tagName":"h2"},{"title":"Scalar types‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#scalar-types","content":" Type\tGraphQL type\tDescriptiont.integer()\tInt\tRepresents signed 32-bit integers. t.number()\tFloat\tRepresents signed double-precision values as specified by IEEE 754. t.float()\tFloat\tAlias to t.number(). t.boolean()\tBoolean\tRepresents true or false. t.string()\tString\tRepresents textual data as UTF-8 character sequences. t.file()\t‚Äî\tRepresents a file for upload.  The following scalar types are aliases to a t.string() type with a specific format.  t.uuid()t.json()t.email()t.uri()t.hostname()t.ean()t.phone()t.date()t.datetime()  ","version":"Next","tagName":"h3"},{"title":"Non-scalar types‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#non-scalar-types","content":" Type\tGraphQL type\tDescriptiont.optional()\tnullable\tRepresents a value that may be null. t.list()\tlist\tRepresents a list of values. t.struct()\tinterface\tRepresents a structured data value, consisting of fields which map to typed values. t.union()\tunion\tRepresents a value which can be one of a set of specified types. t.either()\tunion\tRepresents a value which can match one and only one of a set of specified types. t.func\t‚Äî\tRepresents an operation that has to be performed on the typegate.  ","version":"Next","tagName":"h3"},{"title":"Type constraints‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#type-constraints","content":" Type constraints define an additional narrowing of the range of values that can be accepted for the type.  Example:The min constraint on the type t.integer()  from typegraph import t # represents integers greater than or equal to `12` t.integer().min(12)   ","version":"Next","tagName":"h3"},{"title":"Names and type references‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#names-and-type-references","content":" ","version":"Next","tagName":"h3"},{"title":"Injection‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#injection","content":" ","version":"Next","tagName":"h3"},{"title":"Types‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#types-1","content":" ","version":"Next","tagName":"h2"},{"title":"t.boolean()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tboolean","content":" from typegraph import t t.boolean()   The t.boolean() type represents boolean values, true or false.  ","version":"Next","tagName":"h3"},{"title":"t.integer()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tinteger","content":" The t.integer() type represents 32-bit integers.  from typegraph import t t.integer()   Constraints‚Äã  Constraint\tDescriptionmin\tThe minimum value of the integer. max\tThe maximum value of the integer. x_min\tThe minimum value of the integer, exclusive. x_max\tThe maximum value of the integer, exclusive. multiple_of\tThe integer must be a multiple of this value.  Examples‚Äã  from typegraph import t # non-negative integer t.integer().min(0) # an integer in the rage [18, 120) adult_age = t.integer().min(18).x_max(120) # an even integer t.integer().multiple_of(2)   ","version":"Next","tagName":"h3"},{"title":"t.number()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tnumber","content":" from typegraph import t t.number()   The t.number() type represents numbers, stored in double precision floating-point format (IEEE 754).  Constraints‚Äã  The t.number() type has the same constraints as t.integer(). See integer constraints.  Aliases‚Äã  The following types are aliases to the t.number() type:  t.float()  ","version":"Next","tagName":"h3"},{"title":"t.string()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tstring","content":" from typegraph import t t.string()   The t.string() type represents textual data represented as UTF-8 character sequences.  Constraints‚Äã  Constraint\tType\tDescriptionmin\tInteger\tMinimum length of the string. max\tInteger\tMaximum length of the string. pattern\tString\tRegular expression pattern that the string must match. format\tString\tJSON schema format that the string must match. See below for the list of supported formats.  Supported formats‚Äã  Here is the list of supported formats:  uuidjsonemailurihostnameeanphonedatedate-time  Examples‚Äã  from typegraph import t # a non-empty string of maximum 64 characters t.string().min(1).max(64) # a email address t.string().format(&quot;email&quot;) # a json data t.string().format(&quot;json&quot;)   Aliases‚Äã  Alias\tEquivalent declarationt.uuid()\tt.string().format(&quot;uuid&quot;) t.email()\tt.string().format(&quot;email&quot;) t.uri()\tt.string().format(&quot;uri&quot;) t.json\tt.string().format(&quot;json&quot;) t.ean()\tt.string().format(&quot;ean&quot;) t.phone()\tt.string().format(&quot;phone&quot;) t.date()\tt.string().format(&quot;date&quot;) t.datetime()\tt.string().format(&quot;date-time&quot;)  ","version":"Next","tagName":"h3"},{"title":"t.file()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tfile","content":" from typegraph import t t.file()   The t.file() represents files for upload.  Type Constraints‚Äã  Constraint\tType\tDescriptionmin\tInteger\tMinimum size of the file in bytes. max\tInteger\tMaximum size of the file in bytes. allow\tArray of strings\tList of allowed content-types  Examples‚Äã  from typegraph import t # A file of a minimum size of 1KB t.file().min(1024) # A JPEG or PNG file less than 2KB t.file().max(2048).allow([&quot;image/jpeg&quot;, &quot;image/png&quot;])   ","version":"Next","tagName":"h3"},{"title":"t.optional()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#toptional","content":" from typegraph import t t.optional(t.string()) t.string().optional() # equivalent syntactic sugar   Default value‚Äã  If the type is used as an input type, the default value can be specified using the .default() method.  from typegraph import t t.string().optional().default(&quot;default value&quot;)   ","version":"Next","tagName":"h3"},{"title":"t.list()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tlist","content":" from typegraph import t t.list(t.string())   The t.list() type represents a sequence of values of the same type.  Constraints‚Äã  Constraint\tType\tDescriptionmin\tInteger\tMinimum number of items. max\tInteger\tMaximum number of items. unique_items\tBoolean\tWhether the items must be unique.  Examples‚Äã  from typegraph import t # A list of strings t.list(t.string()) # A list of unique strings t.list(t.string()).unique_items() # A list of strings with at least 3 items # and at most 10 items t.list(t.string()).min(3).max(10)   ","version":"Next","tagName":"h3"},{"title":"t.struct()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tstruct","content":" from typegraph import t user = t.struct({ &quot;id&quot;: t.uuid().as_id, &quot;email&quot;: t.email(), &quot;username&quot;: t.string().min(3).max(64), })   The t.struct() type represents structured data, consisting of fields which map to typed values.  All the fields are required unless the corresponding type is wrapped int.optional(). In that case, the field is allowed to be missing from the data or be null.  Constraints‚Äã  Constraint\tType\tDescriptionmin\tInteger\tMinimum number of fields. max\tInteger\tMaximum number of fields.  Examples‚Äã  from typegraph import t # A user profile user = t.struct({ &quot;id&quot;: t.uuid().as_id, &quot;email&quot;: t.email(), &quot;username&quot;: t.string().min(3).max(64), }) # A user profile with an optional `name` field user = t.struct({ &quot;id&quot;: t.uuid().as_id, &quot;email&quot;: t.email(), &quot;username&quot;: t.string().min(3).max(64), &quot;name&quot;: t.optional(t.string().min(3).max(64)), })   ","version":"Next","tagName":"h3"},{"title":"t.union() and t.either()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tunion-and-teither","content":" from typegraph import t t.union([t.string(), t.integer()]) t.either([t.string(), t.integer()])   The t.union type represents a value that can be of any of the specified types. The t.either type represents a value that must be of one and only one of the specified types.  ","version":"Next","tagName":"h3"},{"title":"t.func()‚Äã","type":1,"pageTitle":"Types","url":"/docs/reference/types#tfunc","content":" The t.func() type represents an operation to be performed on the typegate with the specified materializer.  Usually, the functions are not defined explicitly, but rather created with the runtime instance.  Parameters‚Äã  Parameter\tType\tDescriptioninput type\tt.struct()\tThe type of the input data. output type\tany type\tThe type of the output data. materializer\tMaterializer\tThe materializer to use to perform the operation/computation.  Methods‚Äã  Method\tPurpose\tReference pagerate\tRate limiting\tRate limiting reduce\tParameter transformation\treduce apply\tParameter transformation\tapply  Examples‚Äã  from typegraph import t from typegraph.runtimes.deno import FunMat from typegraph.providers.prisma.runtimes import PrismaRuntime with TypeGraph(&quot;math&quot;) as g: add = t.func( t.struct({ &quot;a&quot;: t.integer(), &quot;b&quot;: t.integer(), }), t.integer(), FunMat(&quot;(({a, b}) =&gt; a + b&quot;) ) g.expose(add=add) db = PrismaRuntime(&quot;main-db&quot;, &quot;POSTGRES&quot;) user = t.struct({ &quot;id&quot;: t.uuid().as_id, &quot;email&quot;: t.email(), &quot;username&quot;: t.string().min(3).max(64), }) g.expose(createUser=db.create(user))  ","version":"Next","tagName":"h3"},{"title":"Parameter Transformations","type":0,"sectionRef":"#","url":"/docs/reference/types/parameter-transformations","content":"","keywords":"","version":"Next"},{"title":"func::reduce(tree)‚Äã","type":1,"pageTitle":"Parameter Transformations","url":"/docs/reference/types/parameter-transformations#funcreducetree","content":" The reduce method allows you to only enable some paths in the graph of the input type of the function.  The only required parameter to func::reduce is the reduce tree.  ","version":"Next","tagName":"h2"},{"title":"Reduce tree‚Äã","type":1,"pageTitle":"Parameter Transformations","url":"/docs/reference/types/parameter-transformations#reduce-tree","content":" A reduce tree (reduce sub-tree) is plain object whose property values are either a reduce sub-tree or a g.inherit() expression.  Each plain object represents a t.struct() in the input type subgraph.  All the nodes that are missing from the reduce tree will set the argument to its default value. Therefore they must be optional.  Consider the following typegraph:  Typescript SDKPython SDK const post = t.struct({ id: t.uuid(), title: t.string(), content: t.string(), }); const user = t.struct({ id: t.uuid(), email: t.email(), posts: t.list(post), }); const filter = t.struct({ id: t.uuid().optional(), email: t.email().optional(), posts: t.struct({ count: t.struct({ gt: t.integer({ min: 1 }).optional(), lt: t.integer({ min: 1 }).optional(), }), tag: t.list(t.string()), }), }); const deno = DenoRuntime(); const findUsers = deno.func(filter, t.list(user), { code: &quot;...&quot; }); g.expose({ findUserById: findUsers.reduce({ id: g.inherit(), }), findUsersByPostCount: findUsers.reduce({ posts: { count: g.inherit(), } }), currentUser: findUsers.reduce({ id: g.inherit().fromContext(&quot;profile.userId&quot;), }), });   The following queries are valid:  query FindUsersById($id: String!) { findUserById(id: $id) { id email } } query FindUsersByPostCount($min: Int!) { findUsersByPostCount(posts: { count: { gt: $min } }) { id email } }   However the following query is invalid:  query Q { findUserById(email: &quot;user@example.com&quot;) { id email } }   The currentUser function will not accept any parameter.  Notes:  The only fully supported non-leaf node is t.struct().Support for t.either() and t.union() is experimental.t.list() is not supported.Each non-leaf node may be optional or not.  ","version":"Next","tagName":"h3"},{"title":"func::apply(tree)‚Äã","type":1,"pageTitle":"Parameter Transformations","url":"/docs/reference/types/parameter-transformations#funcapplytree","content":" The apply method allows you to rewrite the input type of the function, enabling flat input type whatever is the level of nesting in the original input type.  The only required parameter to func::apply is the apply tree.  ","version":"Next","tagName":"h2"},{"title":"Apply tree‚Äã","type":1,"pageTitle":"Parameter Transformations","url":"/docs/reference/types/parameter-transformations#apply-tree","content":" Lexicon\tDefinitionApply node\tObject node, list node or leaf-node Apply tree\tObject node Object node\tA plain object whose property values are nodes. It represents a t.struct(). List node\tAn array or list whose items are nodes. It represents a t.list(). Leaf node\tAn apply expression. See below.  From the code blocks in previouse section, let's make the following changes.  Typescript SDKPython SDK g.expose( findUsersByPostCount: findUsers.apply({ posts: { count: { lt: g.as_arg(), gt: g.as_arg(), } } }), findTechWriters: findUsers.apply({ posts: { tags: [g.set(&quot;tech&quot;)] } }), )   In this case, the matching queries are the following:  query FindUsersByPostCount($lt: Int, $gt: Int) { findUsersByPostCount(lt: $lt, gt: $gt) { id email } } query FindTechWriters { findTechWriters { id email } }   Those queries will be translated to the following:  query FindUsersByPostCount($lt: Int, $gt: Int) { findUsers({ posts: { count: { lt: $lt, gt: $gt } } }) { id email } } query FindTechWriters { findUsers({ posts: { tags: [&quot;tech&quot;] } }) { id email } }   ","version":"Next","tagName":"h3"},{"title":"Apply expressions‚Äã","type":1,"pageTitle":"Parameter Transformations","url":"/docs/reference/types/parameter-transformations#apply-expressions","content":" An apply expression indicates the source of the value for a specific leaf node in the apply tree.  Apply expression\tSourceg.as_arg([name])\tThe value will be provided as a parameter, under the name name. It is optional for object properties where the default is the property key. g.from_parent(type_name)\tThe node will have the same value as the field of the parent t.struct (of the t.func) that has the type name type_name. g.from_context(path)\tThe node will have the value of the context field accessible by the path path. g.from_secret(key)\tThe node will have the value of the secret named key on the current typegraph. g.set(literal_value)\tThe passed literal_value will be used. ","version":"Next","tagName":"h3"},{"title":"Quick start","type":0,"sectionRef":"#","url":"/docs/tutorials/quick-start","content":"","keywords":"","version":"Next"},{"title":"1. Meta CLI‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#1-meta-cli","content":" info Metatype is only supported on macOS and Linux. Windows users should use Linux on Windows with WSL.  You can download the binary from thereleases page, make it executable and add it to your PATH or use the automated method below.  # the installer may ask for your password curl -fsSL https://raw.githubusercontent.com/metatypedev/metatype/main/installer.sh | bash # (optional, read below) install libwasmedge and... curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v $WASMEDGE_VERSION # (linux) ...add it to dynamic libraries path export LD_LIBRARY_PATH=~/.wasmedge/lib # (macos) ...add it to dynamic libraries path export DYLD_LIBRARY_PATH=~/.wasmedge/lib # consider permanently adding this to your shell rc # (for later) upgrade to a newer version meta upgrade   A thin version of the cli that doesn't rely on libwasmedge is also provided. This version of the cli doesn't offer the typegate command that lets you spin up a typegate for development purposes. To install it, you can pass META_THIN=1 environment variable to the installer script or download it from the github relases.  ","version":"Next","tagName":"h2"},{"title":"2. Typegraph SDK‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#2-typegraph-sdk","content":" Typescript SDKPython SDK Install the @typegraph/sdk package from npm using your preferred package manager and runtime. The SDK requires Node 16+ with Typescript 4.7+, Deno 1.28+ or Bun 1+. # using pnpm pnpm add @typegraph/sdk # using npm npm install @typegraph/sdk # using yarn yarn add @typegraph/sdk # using Deno import { ... } from &quot;npm:@typegraph/sdk/mod.ts&quot;; # using Bun bun add @typegraph/sdk When using Node, make sure to add this to your Typescript configuration: &quot;moduleResolution&quot;: &quot;node16&quot;, // Or &quot;nodenext&quot;   ","version":"Next","tagName":"h2"},{"title":"3. Typegate node‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#3-typegate-node","content":" ","version":"Next","tagName":"h2"},{"title":"With Metatype Cloud‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#with-metatype-cloud","content":" This is the easiest way to get started, yet it's not publicly accessible. You can sign up for the private beta below.    ","version":"Next","tagName":"h3"},{"title":"With Docker‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#with-docker","content":" Install Docker and use the following compose.yml to launch a typegate node. Redis is the single required dependency, however in practice you will want to add database or other systems that the typegate can connect to.  services: typegate: image: ghcr.io/metatypedev/typegate:latest ports: - &quot;7890:7890&quot; extra_hosts: - &quot;host.docker.internal:host-gateway&quot; environment: # only for dev, generate secure values for production TG_SECRET: &quot;a4lNi0PbEItlFZbus1oeH/+wyIxi9uH6TpL8AIqIaMBNvp7SESmuUBbfUwC0prxhGhZqHw8vMDYZAGMhSZ4fLw==&quot; TG_ADMIN_PASSWORD: password REDIS_URL: redis://:password@redis:6379/0 DEBUG: &quot;true&quot; depends_on: - redis redis: image: redis:7 restart: always command: --requirepass password   # launch the containers docker compose up --detach # watch the typegate logs docker compose logs typegate --follow   ","version":"Next","tagName":"h3"},{"title":"4. Verify your installation‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#4-verify-your-installation","content":" The doctor subcommand will attempt to detect all the components and report any potential issue. Please make sure to run it before opening an issue and include the output in your report.  meta doctor   ","version":"Next","tagName":"h2"},{"title":"5. Install the development tools (Optional)‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#5-install-the-development-tools-optional","content":" warning üöß This is a work in progress and still experimental.  The development tools provide some additional real-time diagnostics on the typegraph definition and autocompletion (WIP).  Currently, it only works for TypeScript/JavaScript typegraph definitions and the VS Code editor.  ","version":"Next","tagName":"h2"},{"title":"VS Code‚Äã","type":1,"pageTitle":"Quick start","url":"/docs/tutorials/quick-start#vs-code","content":" VS Code users can use the VSCode extension for Metatype.  To install it, launch VS Code Quick Open (Ctrl+P), paste the following command, and press enter.  ext install metatypedev.vscode-metatype   Alternatively, you can download the .vsix file from thereleases pageand manually install the extension. ","version":"Next","tagName":"h3"},{"title":"Instant APIs on your database","type":0,"sectionRef":"#","url":"/use-cases/automatic-crud-validation","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"Instant APIs on your database","url":"/use-cases/automatic-crud-validation#case-study","content":"   Let's say you are developing a web application for a retail store that allows customers to place orders online. In this scenario, you would need to use CRUD operations to create, read, update, and delete data related to orders, customers, products, and inventory.  You would have to model each of these entities as a data type, define the operations that can be performed on them and write the code to ensure the correctness of the data processed in the operations.  For example, you would need to define a Customer type with the following fields: id, name, email, and address. You would also need to define the operations that can be performed on the Customer type, such as createCustomer, updateCustomer, and deleteCustomer. You would also need to write the code to validate the data in the createCustomer operation to ensure that the customer's email address is valid and that the customer's address is not empty. Same for the other fields.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"Instant APIs on your database","url":"/use-cases/automatic-crud-validation#metatypes-solution","content":" Metatype simplifies the development of CRUD APIs by providing the Prisma runtime that automates the creation of the API for CRUD operations and corresponding data validation in PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB. It can even validate some advanced types like email which may not be supported by downstream system (databases often store email address into plain string instead of a specialized field). This makes it faster for developers to create scalable CRUD APIs and enable them to focus their expertise where it matters most like checkout or the search capabilities.  Loading... ","version":"Next","tagName":"h2"},{"title":"Backend for frontend","type":0,"sectionRef":"#","url":"/use-cases/backend-for-frontend","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"Backend for frontend","url":"/use-cases/backend-for-frontend#case-study","content":"   Imagine you have a web frontend and a mobile app that both consume data from a microservices-based backend. The web frontend requires certain data fields in a given format, and the mobile app requires the same additional fields in another format.  In a traditional architecture, both the web and mobile frontends would have to make separate API calls to the microservices, and then format the data into the appropriate structure themselves. This can lead to duplicated code, increased latency due heavier calls with non-necessary data, and decreased developer efficiency.  With a BFF in place, it handles the formatting of the data based on the specific needs of each client. All frontends can thus make a single API call to the BFF, which then communicates with the microservices, retrieves the data, and formats it into the required structure before returning it to the frontend.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"Backend for frontend","url":"/use-cases/backend-for-frontend#metatypes-solution","content":" Metatype can act as a generic BFF component, serving multiple dedicated APIs and handling security, authentication and authorization for you. By encapsulating the logic for communicating with the microservices, Metatype helps to ensure that the frontends are as decoupled as possible from the other services, making it easier to make changes to either the frontend or the backend without affecting the other side.  Loading... ","version":"Next","tagName":"h2"},{"title":"Cloud function runner","type":0,"sectionRef":"#","url":"/use-cases/faas-runner","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"Cloud function runner","url":"/use-cases/faas-runner#case-study","content":"   For example, imagine you have an e-commerce application that uses FaaS to process orders. When a customer places an order, multiple functions may need to be executed, such as validating the order, processing the payment, and updating the inventory.  Each function may be executed independently by the FaaS platform and may take varying amounts of time to complete. Those functions may also be executed for historical reason on different platforms like AWS Lambda, Google Cloud Functions, or Azure Functions.  To collect the results of all the functions in a timely manner, you need to ensure that each function is executed in the correct order and that you are not waiting for a slow function to complete before moving on to the next function.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"Cloud function runner","url":"/use-cases/faas-runner#metatypes-solution","content":" To solve the use case of executing multiple functions and collecting their results, Metatype provides two key features.  Function composition/chaining: functions can be chained together to form a pipeline. The output of one function can be used as the input of the next function in the pipeline. This allows us to execute multiple functions in a specific order. Embedded runner: you can easily write a function that glues together multiple functions and executes them in a specific order. This allows you to execute multiple functions in a specific order. Currently, both Python and Typescript are supported.  Loading... ","version":"Next","tagName":"h2"},{"title":"Composable GraphQL server","type":0,"sectionRef":"#","url":"/use-cases/graphql-server","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"Composable GraphQL server","url":"/use-cases/graphql-server#case-study","content":"   Suppose you are building a subscription platform with a GraphQL API. You need to design a schema that accurately represents the available products, their attributes, and the operations that clients can perform, such as searching, filtering, and sorting.  You also need to optimize the performance of complex queries that involve joining multiple data sources, such as products, categories, and user preferences. Additionally, you need to implement caching and pagination to improve the performance and scalability of your API.  Finally, you need to ensure that your API is secure and implements appropriate authentication and authorization mechanisms to protect sensitive data and operations. Some challenges like the N+1 problem (when a single query results in multiple nested queries, each of which requires a separate database or API call) can also make the development of GraphQL resolver slow and complex to manage.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"Composable GraphQL server","url":"/use-cases/graphql-server#metatypes-solution","content":" Metatype's approach is to focus on schema design solely, and leave the GraphQL resolver implementation to the engine. By providing where the data is stored and how to access it, the queries are optimized by the engine to minimize the number of external API/database calls and to cache the results.  This can be seen as a declarative GraphQL servers, where the server is orchestrated everything for you. Metatype also comes with pre-built functionalities like authentication, authorization, and rate limiting.  Loading... ","version":"Next","tagName":"h2"},{"title":"IAM gateway","type":0,"sectionRef":"#","url":"/use-cases/iam-provider","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"IAM gateway","url":"/use-cases/iam-provider#case-study","content":"   Suppose a developer is building a social media platform that allows users to post updates and view other users' profiles. The developer wants to ensure that only authenticated users can access the platform's resources, and that each user can only access their own data.  To achieve this, the developer can use OAuth2 for user authentication and access control. OAuth2 allows users to log in using their Google or GitHub credentials, which are verified by Google or GitHub's IAM system. Once the user is authenticated, the social media platform can use OAuth2 to obtain an access token, which is used to authorize the user's access to the platform's resources.  The social media platform can also use IAM to control access to resources based on user roles and permissions. For example, only authenticated users can access the platform's resources, and each user can only access their own data.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"IAM gateway","url":"/use-cases/iam-provider#metatypes-solution","content":" Metatype comes with a built-in IAM gateway that can be used to manage user identities and their authorized privileges within a system. It supports any OpenID/OAuth2 providers and includes a list of pre-configured ones like Google, GitHub, Facebook, Twitter or LinkedIn. You can also use your own identity provider and rely on JSON Web Tokens (JWT) for authentication.  Once the user is authenticated, you can use policy access based control (PBAC) to control access to resources based on user identifies and permissions. For example, only authenticated users can access the platform's resources, and each user can only access their own data. Policies can be defined by any function, and run on or off Metatype.  Loading... ","version":"Next","tagName":"h2"},{"title":"Microservices orchestration","type":0,"sectionRef":"#","url":"/use-cases/microservice-orchestration","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"Microservices orchestration","url":"/use-cases/microservice-orchestration#case-study","content":"   Let's say your company develop a healthcare platform and that one of the microservices is responsible for handling patient records (owned by team A), and another microservice is responsible for handling appointment scheduling (owned by team B).  When a patient schedules an appointment, the appointment scheduling microservice needs access to the patient's records to ensure that the appointment is scheduled with the right provider and that the provider has the necessary information to provide effective care. However, since patient records contain sensitive information, it is important to ensure that only authorized users have access to them.  To achieve this, the healthcare platform must use authentication and authorization on each API, which allows sharing only required information.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"Microservices orchestration","url":"/use-cases/microservice-orchestration#metatypes-solution","content":" Metatype can act as a central entry point for all incoming requests and responses between the microservices themselves and external clients. It is responsible for routing requests to the appropriate microservices and handling responses from those microservices, while verifying the authentication and authorization for each request.  Additionally, Metatype gateway can provide other important features such as rate limiting, caching, and request/response transformations. It can even provide an API from another typegraph and delegate the query processing to it.  Loading... ","version":"Next","tagName":"h2"},{"title":"ORM for the edge","type":0,"sectionRef":"#","url":"/use-cases/orm-for-the-edge","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"ORM for the edge","url":"/use-cases/orm-for-the-edge#case-study","content":"   Suppose you are building a mobile app that allows users to order food from local restaurants. To provide a low-latency user experience, you want to run your server-side logic as close as possible to your users.  You can deploy your functions across multiple locations on distributed edge servers. For database interactions, you may need a lightweight relay API to remains compatible with the platform and offer an efficient interface like an ORM provide.  When a user makes a request to view the menu or place an order, the corresponding function running on the edge will make a request to the lightweight relay API to retrieve or modify the relevant data in the database.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"ORM for the edge","url":"/use-cases/orm-for-the-edge#metatypes-solution","content":" Metatype can act out of the box as a lightweight relay API, simplifying database interactions via HTTP/GraphQL requests, and allowing you to query your database through the Prisma runtime. Prisma is a well-known ORM library that provides a convenient interface to interact with PostgreSQL, MySQL, SQLite, SQL Server, MongoDB, CockroachDB databases.  Loading... ","version":"Next","tagName":"h2"},{"title":"Programmable API gateway","type":0,"sectionRef":"#","url":"/use-cases/programmable-api-gateway","content":"","keywords":"","version":"Next"},{"title":"Case study‚Äã","type":1,"pageTitle":"Programmable API gateway","url":"/use-cases/programmable-api-gateway#case-study","content":"   Suppose that your company needs to implement various policies and logic to manage and secure its APIs, such as rate limiting, caching, and request/response transformations.  To achieve this, the company can adopt a programmable API gateway that allows developers to create and deploy custom function to implement additional logic and policies for incoming requests and outgoing responses.  It also provides a platform for the company to manage its API infrastructure more efficiently and flexibly. Developers can leverage existing libraries and frameworks to quickly build and deploy custom logic, reducing the time and effort required to develop and maintain the API gateway.  ","version":"Next","tagName":"h2"},{"title":"Metatype's solution‚Äã","type":1,"pageTitle":"Programmable API gateway","url":"/use-cases/programmable-api-gateway#metatypes-solution","content":" Metatype provide a Python SDK for developers to create and deploy custom logic and policies, which can later be deployed to the gateway in a single command line. Importers can also be used to import existing API or logic definitions from other sources, such as OpenAPI, GraphQL, and gRPC.  This enables developer to quickly build and deploy any update the API or the business logic without having to worry about the underlying infrastructure.  Loading... ","version":"Next","tagName":"h2"},{"title":"Metatype Basics","type":0,"sectionRef":"#","url":"/docs/tutorials/metatype-basics","content":"","keywords":"","version":"Next"},{"title":"What are you building?‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#what-are-you-building","content":" For this tutorial, we'll be implementing an API to power a simple feature roadmap/request hybrid as can be seen on Productlane.  Looking through the app we can see that the api should allow:  Unauthenticated users to submit new &quot;ideas&quot; or vote on any of those already listed. Specify or vote on the importance of an &quot;idea&quot; from &quot;medium&quot; to &quot;critical&quot; or even submit text with more description. Admins will be able to move ideas across buckets like &quot;Backlog&quot;, &quot;Planned&quot;, &quot;In Progress&quot;.  ","version":"Next","tagName":"h2"},{"title":"Setup‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#setup","content":" Before anything, we'll first need to install the tooling required for development and create a new project.  ","version":"Next","tagName":"h2"},{"title":"Install Meta CLI‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#install-meta-cli","content":" t.struct( { &quot;name&quot;: t.string(max=200), &quot;age&quot;: t.optional( t.integer() ), # or t.integer().optional() &quot;messages&quot;: t.list( t.struct({&quot;text&quot;: t.string(), &quot;sentAt&quot;: t.datetime()}) ), } ) # the typegate will accept data as follow { &quot;name&quot;: &quot;Alan&quot;, &quot;age&quot;: 28, &quot;messages&quot;: [ {&quot;text&quot;: &quot;Hello!&quot;, &quot;sentAt&quot;: &quot;2022-12-28T01:11:10Z&quot;} ], } # and reject invalid data {&quot;name&quot;: &quot;Turing&quot;, &quot;messages&quot;: [{&quot;sentAt&quot;: 1}]}   The meta-cli tool manages and helps you develop your metatype based projects. This include allowing you to run them locally for development, push them to production in the cloud, managing your database migrations and more.  info Metatype is only supported on macOS and Linux. Windows users should use Linux on Windows with WSL.  You can download the binary from thereleases page, make it executable and add it to your PATH or use the automated method below.  # the installer may ask for your password curl -fsSL https://raw.githubusercontent.com/metatypedev/metatype/main/installer.sh | bash # (optional, read below) install libwasmedge and... curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v $WASMEDGE_VERSION # (linux) ...add it to dynamic libraries path export LD_LIBRARY_PATH=~/.wasmedge/lib # (macos) ...add it to dynamic libraries path export DYLD_LIBRARY_PATH=~/.wasmedge/lib # consider permanently adding this to your shell rc # (for later) upgrade to a newer version meta upgrade   A thin version of the cli that doesn't rely on libwasmedge is also provided. This version of the cli doesn't offer the typegate command that lets you spin up a typegate for development purposes. To install it, you can pass META_THIN=1 environment variable to the installer script or download it from the github relases.  ","version":"Next","tagName":"h3"},{"title":"Create a new project‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#create-a-new-project","content":" Metatype projects are composed of modular bundles of types, logic and policies called typegraphs. We author typegraphs using modern programming languages &amp; environments. Python and ECMAScript/Typescript are currently available for use. The meta-cli allows us to create a new project based on pre-existing templates.  Typescript SDKPython SDK Run one the following commands to create a new project under a new directory titled tg_roadmap. # using Node/Bun runtimes meta new --template node tg_roadmap # ^ project name # ^ Use `meta new --help` find out more available templates. # using Deno meta new --template deno tg_roadmap When using ECMAScript/Typescript, the @typegraph/sdk package exposes all the necessary functions and types we'll need to describe our typegraph. The templates already specify it as as a dependency so all we need to do now is run the following command to download it: # using Deno deno cache api/example.ts # cache dependencies # using Bun bun install # using pnpm pnpm install # using npm npm install # using yarn yarn install   ","version":"Next","tagName":"h3"},{"title":"Launch typegate‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#launch-typegate","content":" The typegate is a program that runs and orchestrates our typegraphs. We can run it locally for development purposes. Typegate currently requires the Redis database to function and to make it eay to run both, we'll make use of a linux container runtime for this. The Docker runtime to be specific which has installation guides located here.  We'll also need the Docker Compose orchestrator which usually comes by default with the docker command. Use the following command to check if it's available:  docker compose version # Docker Compose version 2.23.0   ...and if not, the official installation guide can be found here.  If you have your docker runtime installed and running correctly, you will be able to launch the compose.yml file that's bundled in every template. The compose file by default includes the postgres and mongo databases. You can disable the latter by commenting it out or removing it as we'll not be needing it for this tutorial.  To launch the services, navigate you shell the the project directory and run the following command:  docker compose up --detach # ^ detach means it'll run in the background. # Omit to get the all logs in the current terminal   This should download and start typegate and it's dependent services.  We can observe their log of typegate or any of the other services with the following command. It has to be run from the same project directory.  docker compose logs typegate --follow # ^ Omit service name to look at the combined logs of all services   ","version":"Next","tagName":"h3"},{"title":"Make sure it's all working‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#make-sure-its-all-working","content":" The meta-cli includes the doctor command that checks everything is in working order. You can run the following to make sure everything's up and running.  meta doctor # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Global ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî # curr. directory /home/asdf/tg_roadmap # global config /home/asdf/.config/meta/config.json # meta-cli version 0.2.4 # docker version Docker version 24.0.7, build afdd53b4e3 # containers ghcr.io/metatypedev/typegate:v0.2.4 (Up 7 minutes), redis:7 (Up 7 minutes), postgres:15 (Up 7 minutes) # # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Project ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî # metatype file metatype.yaml # targets [2] deploy (remote, 3 secrets), dev (local, 3 secrets) # typegraphs [1] api/example.ts # # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Python SDK ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî # python version Python 3.11.5 # python bin .venv/bin/python # venv folder .venv # pyproject file pyproject.toml # pipfile file not found # requirements file not found # typegraph version # # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Typescript SDK ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî # deno version deno 1.38.0 # node version v20.9.0 # # ‚îå‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚îê # | Check that all versions match. | # | In case of issue or question, please raise a ticket on: | # | https://github.com/metatypedev/metatype/issues | # | Or browse the documentation: | # | https://metatype.dev/docs/reference | # ‚îî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚îò   ","version":"Next","tagName":"h3"},{"title":"Types‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#types","content":" The types of our typegraph describe the shape of the data that flows through it. In this case, we'll build our typegraph around types that represent &quot;ideas&quot;, &quot;votes&quot; and &quot;buckets&quot;.  Typescript SDKPython SDK Modify the file at api/example.ts to look something like the following. // we'll need the following imports import { t, typegraph } from &quot;@typegraph/sdk&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ^ each typegraph has a name const bucket = t.struct({ // asId and other config items describe the logical properties // of our types beyond just the shape &quot;id&quot;: t.integer({}, { asId: true }), &quot;name&quot;: t.string(), }); const idea = t.struct({ // uuid is just a shorthand alias for `t.string({format: &quot;uuid&quot;})` &quot;id&quot;: t.uuid({ asId: true }), &quot;name&quot;: t.string(), // another string shorthand &quot;authorEmail&quot;: t.email(), }); const vote = t.struct({ &quot;id&quot;: t.uuid(), &quot;authorEmail&quot;: t.email(), // `enum_` is also a shorthand over `t.string` &quot;importance&quot;: t.enum_([&quot;medium&quot;, &quot;important&quot;, &quot;critical&quot;]).optional(), // makes it optional &quot;desc&quot;: t.string().optional(), }); });   The types here are very simple and we haven't yet added any thing that models their relationships but they should do for our purposes.  ","version":"Next","tagName":"h2"},{"title":"Materializers‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#materializers","content":" Typegraphs expose an API to the external world using Materializer objects. Materializers describe functions that transform some input type into an output type and we define them in scope of different Runtimes, where the actual logic runs. At this early stage, we can make use of the Random runtime which allows us to generate random test data for our types to get a feel of our API.  Typescript SDKPython SDK // add need the following imports import { Policy } from &quot;@typegraph/sdk&quot;; import { RandomRuntime } from &quot;@typegraph/sdk/runtimes/random&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... // every exposed materializer requires access control policies // for now, just use the public policy, anyone can access it const pub = Policy.public(); const random = new RandomRuntime({}); g.expose( { // generates a random object in the shape of idea &quot;get_idea&quot;: random.gen(idea).withPolicy(pub), }, ); });   At this point, we can push our typegraph to the locally running typegate node and access it. Run the following command in your project root:  # features auto-reload on any changes to your source files meta dev   Typegate has first-class support for consuming the API through a GraphQl interface and it's enabled by default. It also bundles the GrahpiQl API explorer and you should be able to access it at http://localhost:7890/roadmap once meta-cli has successfully pushed your typegraph.  Loading...  ","version":"Next","tagName":"h2"},{"title":"The Prisma Runtime‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#the-prisma-runtime","content":" A runtime most apps will be depend on is the Prisma Runtime. It allows you to persist data and run queries on different kinds of databases and has support for popular SQL and NoSQL databases. We'll use it to add the CRUD (create, read, update, delete) operations our app needs.  For this tutorial, we'll be making use of the PostgreSQL database. If you made use of the compose.yml to run typegate as outlined in this tutorial, there should be an instance of Postgres already up. You can check if postgres container is currently running by using the meta doctor command.  If a typegraph needs to access a database, it first needs to be made aware of its address. This is done through environment variables. In the root of your project directory, you'll find a file titled metatype.yaml. It contains metatype specific configuration for our project such as the top level typegates object which we use to specify the location and credentials of the different typegate nodes we'll be using. Each typegate entry also takes an env object where we can specify environment variables to be passed to our typegraphs. This requires special syntax. If we want for a typegraph called, say FOO, to be able read a variable named BAR, we specify the variable as TG_FOO_BAR: value in our config.  The metatype.yaml should already have a few sample environment variables. Add an entry like the following to give our typegraph access to the database's address:  typegates: dev: # .. env: # values here assume default config TG_ROADMAP_POSTGRES: &quot;postgresql://postgres:password@postgres:5432/db&quot;   Meta-cli will auto-reload when it detects changes to metatype.yaml.  We can add the Prisma runtime to our typegraph now.  Typescript SDKPython SDK // new imports import { PrismaRuntime } from &quot;@typegraph/sdk/providers/prisma&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... // the constructor takes the name of the env var directly const db = new PrismaRuntime(&quot;db&quot;, &quot;POSTGRES&quot;); // ... });   One of the features that the Prisma runtime allows us to implement is relationships.  Typescript SDKPython SDK import { PrismaRuntime } from &quot;@typegraph/sdk/providers/prisma&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... const db = new PrismaRuntime(&quot;db&quot;, &quot;POSTGRES&quot;); const bucket = t.struct({ &quot;id&quot;: t.integer({}, { asId: true, // auto generate ids during creation config: { auto: true } }), &quot;name&quot;: t.string(), // one-to many relationship &quot;ideas&quot;: t.list(g.ref(&quot;idea&quot;)), }) // explicitly naming our types makes reference later easier .rename(&quot;bucket&quot;); const idea = t.struct({ &quot;id&quot;: t.uuid({ asId: true, config: { auto: true } }), &quot;name&quot;: t.string(), &quot;authorEmail&quot;: t.email(), // we need to specify the relationships on both types &quot;bucket&quot;: g.ref(&quot;bucket&quot;), &quot;votes&quot;: t.list(g.ref(&quot;vote&quot;)), }) .rename(&quot;idea&quot;); const vote = t.struct({ &quot;id&quot;: t.uuid({ asId: true, config: { auto: true } }), &quot;authorEmail&quot;: t.email(), &quot;importance&quot;: t.enum_([&quot;medium&quot;, &quot;important&quot;, &quot;critical&quot;]).optional(), &quot;desc&quot;: t.string().optional(), &quot;idea&quot;: g.ref(&quot;idea&quot;) }) .rename(&quot;vote&quot;); // ... });   g.ref declares logical relationships between our types which the Prisma runtime will be able to pick up. If you need more control on what the relationships will look like on the database, you can use the db.link function. More information can be found on the Prisma runtime reference.  When we save our file at this point, the meta dev watcher should automatically create and push the necessary migrations to our database to get it in its intended shape. You should see a new subdirectory in your project called prisma. It's where the generated migrations are contained.  If you mess something up in the migrations and want a clean slate, you can reset everything by recreating the containers like so:  # remove all containers and their volumes docker compose down -v # launch docker compose up --detach # meta dev will auto apply any pending changes to databases meta dev   At this point, we're ready to add materializers to expose database queries to create or read data. The Prisma runtime allows us to run raw queries directly on the database but it also provides handy functions we can use for basic CRUD operations. We'll make use of those.  Typescript SDKPython SDK import { PrismaRuntime } from &quot;@typegraph/sdk/providers/prisma&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... const pub = Policy.public(); const db = new PrismaRuntime(&quot;db&quot;, &quot;POSTGRES&quot;); // ... g.expose( { &quot;get_buckets&quot;: db.findMany(bucket), &quot;create_bucket&quot;: db.create(bucket), &quot;get_idea&quot;: db.findFirst(idea), &quot;create_ideas&quot;: db.create(idea), }, pub // make all materializers public by default ); });   We should be able to add a few buckets and ideas now.  Loading...  ","version":"Next","tagName":"h3"},{"title":"Policies‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#policies","content":" We now have the tools enough to allow coarse CRUD of our data. The next thing we usually add at this point is authorization. A way to control who can read or write what. The primary mechanism typegraphs use for this purpose are policies.  Policies are small functions that get the context of a request as input and return a boolean signaling weather access should be granted. There are different kinds of extractors available that primarily work on HTTP request headers including jwt, hmac, basic and oauth2 with support for different providers. We register any extractors we're interested in for the entire typegraph. Any policies running within it can then access their extracted values in the context. Metatype currently supports policies based on javascript functions that are run on the Deno runtime.  For this tutorial, we'll be making use of the basic auth extractor. It expects a string in the format &quot;Basic token&quot; to be set in the Authorization http header. The token is expected to be a base64 encoded string in the format username:secret.  Typescript SDKPython SDK import { DenoRuntime } from &quot;@typegraph/sdk/runtimes/deno&quot;; import { Auth } from &quot;@typegraph/sdk/params&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... const deno = new DenoRuntime(); // The basic extractor only populates the context when // it recognizes the username and the secret matches g.auth(Auth.basic([&quot;andim&quot;, /*more users*/])) // the `username` value is only availaible if the basic // extractor was successful const admins = deno.policy(&quot;admins&quot;, ` (_args, { context }) =&gt; !!context.username `); g.expose( { // .. // only admins are allowed to create new buckets &quot;create_bucket&quot;: db.create(bucket).withPolicy(admins), // .. }, pub ); // ... });   The basic extractors expects the secrets in environment variables named in a specific format. Add the following entries to the metatype.yaml file:  typegates: dev: # .. env: # .. # the basic extractor secret format # TG_[typegraph]_BASIC_[username] TG_ROADMAP_BASIC_ANDIM: hunter2   When you save the files, meta-cli will reload the new additions to your typegraph.create_bucket is now only accessible to requests bearing the right tokens (For the provided example, Basic YW5kaW06aHVudGVyMg== should work). If you're using the GraphiQl interface from earlier, there should be a panel in the bottom left called &quot;Headers&quot; for setting http headers  Loading...  ","version":"Next","tagName":"h2"},{"title":"More‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#more","content":" ","version":"Next","tagName":"h2"},{"title":"reduce‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#reduce","content":" Reference: Parameter transformations  We can use the reduce method to modify the input types of functions. This comes especially handy when dealing with generated functions like those from the CRUD helpers from the Prisma runtime. By default, Prisma generates types that supports the whole suite of usecases one might have on a CRUD operation such as allowing creation of objects of related types in a single operation. We don't always want this and in our case, we want to prevent users from being able to create buckets, which are protected, through the create_idea materializer which's public.  mutation CIdea { create_idea( data: { # we want to prevent bucket creation through `create_idea` bucket: { create: {name: &quot;Backlog&quot;} }, authorEmail: &quot;asdf@as.df&quot;, name: &quot;Add support for WASM GC&quot; } ) { id name } }   Even though the reduce method doesn't allow us to change the shape of the type, we can change the types of members and importantly here, hide the ones we don't need.  Typescript SDKPython SDK typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... g.expose( { // .. &quot;create_idea&quot;: db.create(idea).reduce({ &quot;data&quot;: { // `g.inherit` specifies that we keep the member // type of the original &quot;name&quot;: g.inherit(), &quot;authorEmail&quot;: g.inherit(), &quot;votes&quot;: g.inherit(), &quot;bucket&quot;: { &quot;connect&quot;: g.inherit(), // by omitting the `create` member, we hide it } } }), // .. }, pub ); });   Requests are now only able to connect new ideas with pre-existing buckets and won't be able to create them.  Loading...  ","version":"Next","tagName":"h3"},{"title":"execute‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#execute","content":" You'll notice that we had set the importance field on votes as optional. This is to allow users to just up-vote an idea from the main list without opening a form. If they want to add importance or a description to their vote at a later point, we want to update their already existing vote. It should be easy to expose a materializer for this using Prisma's db.update helper and reduce to restrict changes to only those field. But we'll take this opportunity to explore the feature of the Prisma runtime to execute raw queries.  Typescript SDKPython SDK import * as effects from &quot;@typegraph/sdk/effects&quot;; typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... g.expose( { // .. &quot;set_vote_importance&quot;: db.execute( // query parameters are matched by name from the input type 'UPDATE &quot;vote&quot; SET importance = ${importance} WHERE id = ${vote_id}::uuid', // our input type t.struct({ &quot;vote_id&quot;: t.uuid(), &quot;importance&quot;: t.enum_([&quot;medium&quot;, &quot;important&quot;, &quot;critical&quot;]), }), // we use effects to signal what kind of operation we're doing // updates and creates will be exposed as mutations in GraphQl // the boolean signals that the query is idempotent effects.update(true), ) // .. }, pub ); });   Our query is exposed like any other materializer in the GraphQl api.  Loading...  ","version":"Next","tagName":"h3"},{"title":"rest‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#rest","content":" We can easily expose an HTTP API for our typegraph using the g.rest method. It takes a string describe a graphql query to be executed when the http path is requested.  Typescript SDKPython SDK typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... g.rest( ` query get_buckets { get_buckets { id name ideas { id name authorEmail } } } ` ) g.rest( // query parameters present // expects a request of the type `roadmap/rest/get_bucket?id=uuidstr` ` query get_bucket($id: Integer) { get_bucket(where:{ id: $id }) { id name ideas { id name authorEmail } } } ` ) });   The exposed query is served at the path {typegate_url}/{typegraph_name}/rest/{query_name}. Any parameters that the query takes are processed from the search params of the request.    ","version":"Next","tagName":"h3"},{"title":"import‚Äã","type":1,"pageTitle":"Metatype Basics","url":"/docs/tutorials/metatype-basics#import","content":" So far, the materializers we've looked at have been generated by helpers like the CRUD helpers from the Prisma runtime or the the Random runtime's generate helper. The deno.policy function we used for authoring policies was also based on function objects. All these helpers are shorthands for creating function objects and now we'll look at how to roll a custom function ourselves. We'll be using the Deno runtime to run our code.  Instead of including the code inline through a string, the Deno runtime allows us to import modules from disk. Our modules are allowed to use ESM imports to access libraries on different registries like npm and deno.land. We'll use these features to write a simple materializer that converts markdown to html.  import * as marked from &quot;https://deno.land/x/marked/mod.ts&quot;; export function parse({ raw }: { raw: string }): string { return marked.parse(raw); }   We'll expose our module using the deno runtime.  Typescript SDKPython SDK typegraph(&quot;roadmap&quot;, (g) =&gt; { // ... g.expose( { // .. &quot;parse_markdown&quot;: deno.import( t.struct({&quot;raw&quot;: t.string()}), t.string(), { name: &quot;parse&quot;, // the path is parsed relative to the typegraph file module: &quot;md2html.ts&quot;, } ), // .. }, pub ); });   We can now access our func through the GraphQl api.  Loading... ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}